

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/my_world/img/favicon.png">
  <link rel="icon" href="/my_world/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#336699">
  <meta name="description" content="">
  <meta name="author" content="Vsoapmac">
  <meta name="keywords" content="">
  
  <title>软件设计的行为型模式（一） | My note</title>

  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/my_world/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/my_world/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/my_world/css/scrollbar.css">
<link rel="stylesheet" href="/my_world/css/customfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"my_world.github.io","root":"/my_world/","version":"1.8.11","typing":{"enable":true,"typeSpeed":60,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"./xml/local-search.xml"};
  </script>
  <script  src="/my_world/js/utils.js" ></script>
  <script  src="/my_world/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" style="box-shadow:none;" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/my_world/">&nbsp;<strong>Infinite</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/my_world/img/post.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="软件设计的行为型模式（一）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-18 09:19" pubdate>
        2021年3月18日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      115
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">软件设计的行为型模式（一）</h1>
            
            <div class="markdown-body">
              <p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<blockquote>
<p>图片原链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 | 菜鸟教程 (runoob.com)</a></p>
<p>文字原链接：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1317.html">软件设计模式概述 (biancheng.net)</a></p>
</blockquote>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li><strong>命令（Command）模式</strong>：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li><strong>观察者（Observer）模式</strong>：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<p>该模式的主要优点如下。</p>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ol>
<p>该模式的主要缺点如下。</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。现在来介绍它们的基本结构。</p>
<p><strong>模式的结构</strong></p>
<p>模板方法模式包含以下主要角色。</p>
<p>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p>
<p>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。<br>抽象方法：在抽象类中申明，由具体子类实现。<br>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。<br>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>
<p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg" srcset="/my_world/img/loading.gif" lazyload alt="模板模式实现"></p>
<p><strong>模式的实现</strong></p>
<p>模板方法模式的代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> templateMethod;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateMethodPattern</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        AbstractClass tm=<span class="hljs-keyword">new</span> ConcreteClass();
        tm.TemplateMethod();
    &#125;
&#125;
<span class="hljs-comment">//抽象类</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span><span class="hljs-params">()</span> <span class="hljs-comment">//模板方法</span></span>
<span class="hljs-function">    </span>&#123;
        SpecificMethod();
        abstractMethod1();          
         abstractMethod2();
    &#125;  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpecificMethod</span><span class="hljs-params">()</span> <span class="hljs-comment">//具体方法</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;抽象类中的具体方法被调用...&quot;</span>);
    &#125;   
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法1</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法2</span>
&#125;
<span class="hljs-comment">//具体子类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;抽象方法1的实现被调用...&quot;</span>);
    &#125;   
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;抽象方法2的实现被调用...&quot;</span>);
    &#125;
&#125;</code></pre></div>
<h2 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用模板方法模式实现出国留学手续设计程序。</p>
<p>分析：出国留学手续一般经过以下流程：索取学校资料，提出入学申请，办理因私出国护照、出境卡和公证，申请签证，体检、订机票、准备行装，抵达目标学校等，其中有些业务对各个学校是一样的，但有些业务因学校不同而不同，所以比较适合用模板方法模式来实现。</p>
<p>在本实例中，我们先定义一个出国留学的抽象类 StudyAbroad，里面包含了一个模板方法 TemplateMethod()，该方法中包含了办理出国留学手续流程中的各个基本方法，其中有些方法的处理由于各国都一样，所以在抽象类中就可以实现，但有些方法的处理各国是不同的，必须在其具体子类（如美国留学类 StudyInAmerica）中实现。如果再增加一个国家，只要增加一个子类就可以了</p>
<h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>模板方法模式通常适用于以下场景。</p>
<ol>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
</ol>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<p>策略模式的主要优点如下。</p>
<ol>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
</ol>
<p>其主要缺点如下。</p>
<ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类。</li>
</ol>
<h2 id="策略模式的结构与实现"><a href="#策略模式的结构与实现" class="headerlink" title="策略模式的结构与实现"></a>策略模式的结构与实现</h2><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。</p>
<p><strong>模式的结构</strong></p>
<p>策略模式的主要角色如下。</p>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" srcset="/my_world/img/loading.gif" lazyload alt="策略模式实现"></p>
<p><strong>模式的实现</strong></p>
<p>策略模式的实现代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> strategy;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyPattern</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        Context c=<span class="hljs-keyword">new</span> Context();
        Strategy s=<span class="hljs-keyword">new</span> ConcreteStrategyA();
        c.setStrategy(s);
        c.strategyMethod();
        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);
        s=<span class="hljs-keyword">new</span> ConcreteStrategyB();
        c.setStrategy(s);
        c.strategyMethod();
    &#125;
&#125;
<span class="hljs-comment">//抽象策略类</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span></span>
<span class="hljs-class"></span>&#123;   
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//策略方法</span>
&#125;
<span class="hljs-comment">//具体策略类A</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;具体策略A的策略方法被访问！&quot;</span>);
    &#125;
&#125;
<span class="hljs-comment">//具体策略类B</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span>
<span class="hljs-class"></span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span>
<span class="hljs-function">  </span>&#123;
      System.out.println(<span class="hljs-string">&quot;具体策略B的策略方法被访问！&quot;</span>);
  &#125;
&#125;
<span class="hljs-comment">//环境类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> Strategy strategy;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Strategy <span class="hljs-title">getStrategy</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> strategy;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStrategy</span><span class="hljs-params">(Strategy strategy)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.strategy=strategy;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        strategy.strategyMethod();
    &#125;
&#125;</code></pre></div>
<h2 id="策略模式的应用实例"><a href="#策略模式的应用实例" class="headerlink" title="策略模式的应用实例"></a>策略模式的应用实例</h2><p>策略模式在“大闸蟹”做菜中的应用。</p>
<p>分析：关于大闸蟹的做法有很多种，我们以清蒸大闸蟹和红烧大闸蟹两种方法为例，介绍策略模式的应用。</p>
<p>首先，定义一个大闸蟹加工的抽象策略类（CrabCooking），里面包含了一个做菜的抽象方法 CookingMethod()；然后，定义清蒸大闸蟹（SteamedCrabs）和红烧大闸蟹（BraisedCrabs）的具体策略类，它们实现了抽象策略类中的抽象方法；由于本程序要显示做好的结果图（点此下载要显示的结果图），所以将具体策略类定义成 JLabel 的子类；最后，定义一个厨房（Kitchen）环境类，它具有设置和选择做菜策略的方法；客户类通过厨房类获取做菜策略，并把做菜结果图在窗体中显示出来</p>
<h2 id="策略模式的应用场景"><a href="#策略模式的应用场景" class="headerlink" title="策略模式的应用场景"></a>策略模式的应用场景</h2><p>策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。</p>
<ol>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ol>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<p>命令模式的主要优点如下。</p>
<ol>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ol>
<p>其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p>
<h2 id="命令模式的结构与实现"><a href="#命令模式的结构与实现" class="headerlink" title="命令模式的结构与实现"></a>命令模式的结构与实现</h2><p>可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离，其结构如下。</p>
<p><strong>模式的结构</strong></p>
<p>命令模式包含以下主要角色。</p>
<ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>
<li>具体命令角色（Concrete    Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210830-command-1-command-1.svg" srcset="/my_world/img/loading.gif" lazyload alt="命令模式实现"></p>
<p><strong>模式的实现</strong></p>
<p>命令模式的代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> command;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandPattern</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        Command cmd=<span class="hljs-keyword">new</span> ConcreteCommand();
        Invoker ir=<span class="hljs-keyword">new</span> Invoker(cmd);
        System.out.println(<span class="hljs-string">&quot;客户访问调用者的call()方法...&quot;</span>);
        ir.call();
    &#125;
&#125;
<span class="hljs-comment">//调用者</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> Command command;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span><span class="hljs-params">(Command command)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.command=command;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.command=command;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;调用者执行命令command...&quot;</span>);
        command.execute();
    &#125;
&#125;
<span class="hljs-comment">//抽象命令</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-comment">//具体命令</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> Receiver receiver;
    ConcreteCommand()
    &#123;
        receiver=<span class="hljs-keyword">new</span> Receiver();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        receiver.action();
    &#125;
&#125;
<span class="hljs-comment">//接收者</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;接收者的action()方法被调用...&quot;</span>);
    &#125;
&#125;</code></pre></div>
<h2 id="命令模式的应用实例"><a href="#命令模式的应用实例" class="headerlink" title="命令模式的应用实例"></a>命令模式的应用实例</h2><p>用命令模式实现客户去餐馆吃早餐的实例。</p>
<p>分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。</p>
<p>首先，定义一个早餐类（Breakfast），它是抽象命令类，有抽象方法 cooking()，说明要做什么；再定义其子类肠粉类（ChangFen）、馄饨类（HunTun）和河粉类（HeFen），它们是具体命令类，实现早餐类的 cooking() 方法，但它们不会具体做，而是交给具体的厨师去做；具体厨师类有肠粉厨师（ChangFenChef）、馄蚀厨师（HunTunChef）和河粉厨师（HeFenChef），他们是命令的接收者，由于本实例要显示厨师做菜的效果图（点此下载要显示的效果图），所以把每个厨师类定义为 JFrame 的子类；最后，定义服务员类（Waiter），它接收客户的做菜请求，并发出做菜的命令。客户类是通过服务员类来点菜的</p>
<h2 id="命令模式的应用场景"><a href="#命令模式的应用场景" class="headerlink" title="命令模式的应用场景"></a>命令模式的应用场景</h2><p>命令模式通常适用于以下场景。</p>
<ol>
<li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li>
<li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li>
<li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li>
</ol>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>注意：责任链模式也叫职责链模式。</p>
<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p>
<p>责任链模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
</ol>
<p>其主要缺点如下。</p>
<ol>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ol>
<h2 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p>
<p><strong>模式的结构</strong></p>
<p>职责链模式主要包含以下角色。</p>
<ol>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg" srcset="/my_world/img/loading.gif" lazyload alt="责任链模式实现"></p>
<p><strong>模式的实现</strong></p>
<p>职责链模式的实现代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chainOfResponsibility;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainOfResponsibilityPattern</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-comment">//组装责任链 </span>
        Handler handler1=<span class="hljs-keyword">new</span> ConcreteHandler1(); 
        Handler handler2=<span class="hljs-keyword">new</span> ConcreteHandler2(); 
        handler1.setNext(handler2); 
        <span class="hljs-comment">//提交请求 </span>
        handler1.handleRequest(<span class="hljs-string">&quot;two&quot;</span>);
    &#125;
&#125;
<span class="hljs-comment">//抽象处理者角色</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> Handler next;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler next)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.next=next; 
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123; 
        <span class="hljs-keyword">return</span> next; 
    &#125;   
    <span class="hljs-comment">//处理请求的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span>;       
&#125;
<span class="hljs-comment">//具体处理者角色1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(request.equals(<span class="hljs-string">&quot;one&quot;</span>)) 
        &#123;
            System.out.println(<span class="hljs-string">&quot;具体处理者1负责处理该请求！&quot;</span>);       
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            <span class="hljs-keyword">if</span>(getNext()!=<span class="hljs-keyword">null</span>) 
            &#123;
                getNext().handleRequest(request);             
            &#125;
            <span class="hljs-keyword">else</span>
            &#123;
                System.out.println(<span class="hljs-string">&quot;没有人处理该请求！&quot;</span>);
            &#125;
        &#125; 
    &#125; 
&#125;
<span class="hljs-comment">//具体处理者角色2</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(request.equals(<span class="hljs-string">&quot;two&quot;</span>)) 
        &#123;
            System.out.println(<span class="hljs-string">&quot;具体处理者2负责处理该请求！&quot;</span>);       
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            <span class="hljs-keyword">if</span>(getNext()!=<span class="hljs-keyword">null</span>) 
            &#123;
                getNext().handleRequest(request);             
            &#125;
            <span class="hljs-keyword">else</span>
            &#123;
                System.out.println(<span class="hljs-string">&quot;没有人处理该请求！&quot;</span>);
            &#125;
        &#125; 
    &#125;
&#125;</code></pre></div>
<h2 id="模式的应用实例-1"><a href="#模式的应用实例-1" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用责任链模式设计一个请假条审批模块。</p>
<p>分析：假如规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；这个实例适合使用职责链模式实现。</p>
<p>首先，定义一个领导类（Leader），它是抽象处理者，包含了一个指向下一位领导的指针 next 和一个处理假条的抽象处理方法 handleRequest(int LeaveDays)；然后，定义班主任类（ClassAdviser）、系主任类（DepartmentHead）和院长类（Dean），它们是抽象处理者的子类，是具体处理者，必须根据自己的权力去实现父类的 handleRequest(int LeaveDays) 方法，如果无权处理就将假条交给下一位具体处理者，直到最后；客户类负责创建处理链，并将假条交给链头的具体处理者（班主任）。</p>
<h2 id="模式的应用场景-1"><a href="#模式的应用场景-1" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>前边已经讲述了关于责任链模式的结构与特点，下面介绍其应用场景，责任链模式通常在以下几种情况使用。</p>
<ol>
<li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li>
<li>可动态指定一组对象处理请求，或添加新的处理者。</li>
<li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>
</ol>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p>状态模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li>
<li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>
</ol>
<p>状态模式的主要缺点如下。</p>
<ol>
<li>状态模式的使用必然会增加系统的类与对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>
</ol>
<h2 id="状态模式的结构与实现"><a href="#状态模式的结构与实现" class="headerlink" title="状态模式的结构与实现"></a>状态模式的结构与实现</h2><p>状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。现在我们来分析其基本结构和实现方法。</p>
<p><strong>模式的结构</strong></p>
<p>状态模式包含以下主要角色。</p>
<ol>
<li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete    State）角色：实现抽象状态所对应的行为。</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png" srcset="/my_world/img/loading.gif" lazyload alt="状态模式实现"></p>
<p><strong>模式的实现</strong></p>
<p>状态模式的实现代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> state;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatePatternClient</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;       
        Context context=<span class="hljs-keyword">new</span> Context();    <span class="hljs-comment">//创建环境       </span>
        context.Handle();    <span class="hljs-comment">//处理请求</span>
        context.Handle();
        context.Handle();
        context.Handle();
    &#125;
&#125;
<span class="hljs-comment">//环境类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> State state;
    <span class="hljs-comment">//定义环境类的初始状态</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.state=<span class="hljs-keyword">new</span> ConcreteStateA();
    &#125;
    <span class="hljs-comment">//设置新状态</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>.state=state;
    &#125;
    <span class="hljs-comment">//读取状态</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span>(state);
    &#125;
    <span class="hljs-comment">//对请求做处理</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        state.Handle(<span class="hljs-keyword">this</span>);
    &#125;
&#125;
<span class="hljs-comment">//抽象状态类</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">(Context context)</span></span>;
&#125;
<span class="hljs-comment">//具体状态A类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">(Context context)</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;当前状态是 A.&quot;</span>);
        context.setState(<span class="hljs-keyword">new</span> ConcreteStateB());
    &#125;
&#125;
<span class="hljs-comment">//具体状态B类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">(Context context)</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;当前状态是 B.&quot;</span>);
        context.setState(<span class="hljs-keyword">new</span> ConcreteStateA());
    &#125;
&#125;</code></pre></div>
<h2 id="状态模式的应用实例"><a href="#状态模式的应用实例" class="headerlink" title="状态模式的应用实例"></a>状态模式的应用实例</h2><p>用“状态模式”设计一个学生成绩的状态转换程序。</p>
<p>分析：本实例包含了“不及格”“中等”和“优秀” 3 种状态，当学生的分数小于 60 分时为“不及格”状态，当分数大于等于 60 分且小于 90 分时为“中等”状态，当分数大于等于 90 分时为“优秀”状态，我们用状态模式来实现这个程序。</p>
<p>首先，定义一个抽象状态类（AbstractState），其中包含了环境属性、状态名属性和当前分数属性，以及加减分方法 addScore(intx) 和检查当前状态的抽象方法 checkState()；然后，定义“不及格”状态类 LowState、“中等”状态类 MiddleState 和“优秀”状态类 HighState，它们是具体状态类，实现 checkState() 方法，负责检査自己的状态，并根据情况转换；最后，定义环境类（ScoreContext），其中包含了当前状态对象和加减分的方法 add(int score)，客户类通过该方法来改变成绩状态。</p>
<h2 id="状态模式的应用场景"><a href="#状态模式的应用场景" class="headerlink" title="状态模式的应用场景"></a>状态模式的应用场景</h2><p>通常在以下情况下可以考虑使用状态模式。</p>
<ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<p>观察者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
<p>它的主要缺点如下。</p>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
<h2 id="模式的结构与实现-2"><a href="#模式的结构与实现-2" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。</p>
<p><strong>模式的结构</strong></p>
<p>观察者模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete    Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg" srcset="/my_world/img/loading.gif" lazyload alt="观察者模式实现"></p>
<p><strong>模式的实现</strong></p>
<p>观察者模式的实现代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> observer;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverPattern</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        Subject subject=<span class="hljs-keyword">new</span> ConcreteSubject();
        Observer obs1=<span class="hljs-keyword">new</span> ConcreteObserver1();
        Observer obs2=<span class="hljs-keyword">new</span> ConcreteObserver2();
        subject.add(obs1);
        subject.add(obs2);
        subject.notifyObserver();
    &#125;
&#125;
<span class="hljs-comment">//抽象目标</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">protected</span> List&lt;Observer&gt; observers=<span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();   
    <span class="hljs-comment">//增加观察者方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer observer)</span></span>
<span class="hljs-function">    </span>&#123;
        observers.add(observer);
    &#125;    
    <span class="hljs-comment">//删除观察者方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Observer observer)</span></span>
<span class="hljs-function">    </span>&#123;
        observers.remove(observer);
    &#125;   
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//通知观察者方法</span>
&#125;
<span class="hljs-comment">//具体目标</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;具体目标发生改变...&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);       
       
        <span class="hljs-keyword">for</span>(Object obs:observers)
        &#123;
            ((Observer)obs).response();
        &#125;
       
    &#125;          
&#125;
<span class="hljs-comment">//抽象观察者</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">response</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//反应</span>
&#125;
<span class="hljs-comment">//具体观察者1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteObserver1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">response</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;具体观察者1作出反应！&quot;</span>);
    &#125;
&#125;
<span class="hljs-comment">//具体观察者1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteObserver2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">response</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;具体观察者2作出反应！&quot;</span>);
    &#125;
&#125;</code></pre></div>
<h2 id="模式的应用实例-2"><a href="#模式的应用实例-2" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司的进口产品成本或出口公司的出口产品收入以及公司的利润率的影响。</p>
<p>分析：当“人民币汇率”升值时，进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降低且利润率降低；当“人民币汇率”贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。</p>
<p>这里的汇率（Rate）类是抽象目标类，它包含了保存观察者（Company）的 List 和增加/删除观察者的方法，以及有关汇率改变的抽象方法 change(int number)；而人民币汇率（RMBrate）类是具体目标， 它实现了父类的 change(int number) 方法，即当人民币汇率发生改变时通过相关公司；公司（Company）类是抽象观察者，它定义了一个有关汇率反应的抽象方法 response(int number)；进口公司（ImportCompany）类和出口公司（ExportCompany）类是具体观察者类，它们实现了父类的 response(int number) 方法，即当它们接收到汇率发生改变的通知时作为相应的反应。</p>
<h2 id="模式的应用场景-2"><a href="#模式的应用场景-2" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>通过前面的分析与应用实例可知观察者模式适合以下几种情形。</p>
<ul>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
</ul>
<p>策略模式—自助餐</p>
<p>命令模式—遥控器</p>
<p>责任链—院长&gt;&gt;系主任&gt;&gt;班主任</p>
<p>状态模式—成绩判断，A状态为优秀，B状态为中等</p>
<p>观察者模式—天气预报</p>
<p>中介者模式—房产中介</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/my_world/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/my_world/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">行为型模式</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/my_world/content/idea%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">idea使用小贴士</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">
                        <span class="hidden-mobile">软件设计的创建型模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content" id="times">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备2021041688号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://fastly.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://fastly.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://fastly.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/my_world/js/events.js" ></script>
<script  src="/my_world/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/my_world/js/img-lazyload.js" ></script>
  



  



  <script  src="https://fastly.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://fastly.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://fastly.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/my_world/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://fastly.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://fastly.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  










  
<script src="/my_world/js/love.js"></script>
<script src="/my_world/js/ribbon_flow.js"></script>
<script src="/my_world/js/runningday.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/my_world/js/boot.js" ></script>


</body>
</html>
