

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/my_world/img/favicon.png">
  <link rel="icon" href="/my_world/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#336699">
  <meta name="description" content="">
  <meta name="author" content="Vsoapmac">
  <meta name="keywords" content="">
  
  <title>自动化测试框架大总结（一） | My note</title>

  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/my_world/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/my_world/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/my_world/css/scrollbar.css">
<link rel="stylesheet" href="/my_world/css/customfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"my_world.github.io","root":"/my_world/","version":"1.8.11","typing":{"enable":true,"typeSpeed":60,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"./xml/local-search.xml"};
  </script>
  <script  src="/my_world/js/utils.js" ></script>
  <script  src="/my_world/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" style="box-shadow:none;" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/my_world/">&nbsp;<strong>Infinite</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/my_world/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/my_world/img/post.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="自动化测试框架大总结（一）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-14 19:35" pubdate>
        2021年8月14日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      197
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">自动化测试框架大总结（一）</h1>
            
            <div class="markdown-body">
              <p>自动化测试一般是指软件测试的自动化，软件测试就是在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。它是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。由于以下原因，自动化测试非常重要：</p>
<ul>
<li>手动测试所有工作流、所有阶段都需要花费时间和金钱</li>
<li>手动测试多语言站点很困难</li>
<li>软件测试中的自动化测试不需要人工干预</li>
<li>自动化测试可提高测试执行速度</li>
<li>自动化有助于增加测试范围</li>
<li>长时间手工测试可能会变得很无聊，因此容易出错</li>
</ul>
<blockquote>
<p>引用<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353489122">软件测试入门系列之七：自动化测试 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="哪些测试用例可以自动化"><a href="#哪些测试用例可以自动化" class="headerlink" title="哪些测试用例可以自动化"></a>哪些测试用例可以自动化</h1><blockquote>
<p>引用<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353489122">软件测试入门系列之七：自动化测试 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>可以使用以下标准选择要自动化的测试用例，以提高自动化的投资回报率</p>
<ul>
<li>高风险-关键业务测试案例</li>
<li>重复执行的测试用例</li>
<li>非常繁琐或难以手动执行的测试用例</li>
<li>耗时的测试用例</li>
</ul>
<p>以下类别的测试用例不适合自动化：</p>
<ul>
<li>新设计的测试用例，并且至少一次不手动执行</li>
<li>需求经常变化的测试用例</li>
<li>临时执行的测试用例</li>
</ul>
<h1 id="自动化测试流程"><a href="#自动化测试流程" class="headerlink" title="自动化测试流程"></a>自动化测试流程</h1><blockquote>
<p>引用<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353489122">软件测试入门系列之七：自动化测试 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>自动化过程中遵循以下步骤</p>
<ol>
<li>选择测试工具</li>
<li>定义自动化范围</li>
<li>规划，设计和开发</li>
<li>测试执行</li>
<li>维护</li>
</ol>
<h1 id="使用语言"><a href="#使用语言" class="headerlink" title="使用语言"></a>使用语言</h1><p>以下均使用python作为主要的计算机语言，虽然有些可以使用其他的语言，比如说java。</p>
<p><strong>python 特点/特性：</strong></p>
<ul>
<li>易于学习，入门所需时间极短</li>
<li>少量代码即可实现功能，python代码非常精简，只需要少量代码即可构造更多功能</li>
<li>可扩展性非常好，python上有各种各样的模块、工具库，导入即可使用</li>
<li>支持多平台Windows/Linux/macOS，python作为目前美国高校最受欢迎的编程语言之一，可在多个领域平台中广泛使用</li>
<li>可与多种编程语言集成（C/Java/C#/ObjectC/Ruby等），且实现稳定性一流</li>
</ul>
<h1 id="设备连接"><a href="#设备连接" class="headerlink" title="设备连接"></a>设备连接</h1><ul>
<li>真机（Android）</li>
<li>Android 模拟器</li>
<li>电脑（Web自动化等）</li>
</ul>
<p>注意，Web自动化需要安装驱动，下面会提及</p>
<p>真机需要连接上电脑，然后在真机上打开USB调试方可使用</p>
<h1 id="Airtest"><a href="#Airtest" class="headerlink" title="Airtest"></a>Airtest</h1><p>官网：<a target="_blank" rel="noopener" href="https://airtest.netease.com/">Airtest Project (netease.com)</a></p>
<p>教程：<a target="_blank" rel="noopener" href="https://airtest.doc.io.netease.com/tutorial/1_quick_start_guide/">5分钟上手自动化测试——Airtest+Poco快速上手 - Airtest Project Docs (netease.com)</a><br>文档：<a target="_blank" rel="noopener" href="https://airtest.readthedocs.io/zh_CN/latest/all_module/airtest.core.api.html">airtest.core.api module — airtest 文档</a></p>
<p>Airtest是一套跨平台的测试框架，它提供了跨平台的API，包括安装应用、模拟输入、断言等。 基于图像识别技术定位UI元素，你无需嵌入任何代码即可进行自动化测。测试脚本运行后可以自动生成详细的HTML测试报告，让你迅速定位失败的测试点，适用于游戏和App，支持平台有Windows、Android和iOS。</p>
<p>Airtest 集成的多个测试框架，基于web自动化测试的selenuim框架，基于Chrome Devtools Protocol协议，自动录制生成selenium脚本，精确定位与操作界面元素，支持多浏览器（Chrome、Safari、Firfox等主流浏览器）；Poco基于UI控件识别的自动化框架，目前支持Unity3D/cocos2dx-/Android原生app/iOS原生app/微信小程序，也可以在其他引擎中自行接入poco-sdk来使用。</p>
<p>AirtestIDE 是一个强大的GUI工具，是网易配套推出的跨平台UI自动化测试编辑器，它内置了Airtest和Poco的相关插件功能，可以帮助你快速简单地完成录制/编写测试脚本。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>进入官网安装Airtest IDE即可。</p>
<p>python需要使用pip安装，命令为：</p>
<div class="code-wrapper"><pre><code class="hljs shell">pip install airtest</code></pre></div>
<h2 id="官方Demo"><a href="#官方Demo" class="headerlink" title="官方Demo"></a>官方Demo</h2><p>官方Demo总会有它的价值。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *
<span class="hljs-comment"># 通过ADB连接本地Android设备</span>
connect_device(<span class="hljs-string">&quot;Android:///&quot;</span>)
<span class="hljs-comment">#安装待测软件apk，路径信息。</span>
install(<span class="hljs-string">&quot;path/to/your/apk&quot;</span>)
<span class="hljs-comment">#开始运行app</span>
start_app(<span class="hljs-string">&quot;com.pingan.certicationApp&quot;</span>)
<span class="hljs-comment">#点击某个图片，Airtest中基于图像识别语法，图片自己提供。</span>
touch(Template(<span class="hljs-string">&quot;image_of_a_button.png&quot;</span>))
<span class="hljs-comment">#滑动语音，开头图片跟结尾图片</span>
swipe(Template(<span class="hljs-string">&quot;slide_start.png&quot;</span>), Template(<span class="hljs-string">&quot;slide_end.png&quot;</span>))
<span class="hljs-comment">#添加断言的图片</span>
assert_exists(Template(<span class="hljs-string">&quot;success.png&quot;</span>))
<span class="hljs-comment">#点击Android上的返回键</span>
<span class="hljs-comment">#keyevent(&quot;BACK&quot;)</span>
<span class="hljs-comment">#点击Android上的Home键返回</span>
<span class="hljs-comment">#home()</span>
<span class="hljs-comment">#uninstall(&quot;package_name_of_your_apk&quot;)</span></code></pre></div>
<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p>在AirtestIDE中新建的脚本，后缀都为 <code>.air</code> ，但实际上我们在运行的时候， <strong>运行的是.air目录下的同名.py文件</strong> 。因此，就像一个普通的python脚本那样，当我们需要使用airtest的接口时（例如touch指令），我们需要在.py脚本的最前面import airtest的api。我们可以在AirtestIDE里新建一个脚本，就能看到默认的初始化代码:</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span>
__author__ = <span class="hljs-string">&quot;user&quot;</span>

<span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *
<span class="hljs-comment"># 从api中import接口后，就能直接使用airtest的各个接口了</span>
auto_setup(__file__)  <span class="hljs-comment"># 自动初始化设备</span></code></pre></div>
<p>在Airtest中，需要编写大量的截图语句，像这样:</p>
<div class="code-wrapper"><pre><code class="hljs python">touch(Template(<span class="hljs-string">&quot;image_of_a_button.png&quot;</span>))</code></pre></div>
<p>其中的 <code>Template(&quot;xx.png&quot;)</code> 即为一个图片对象，如果要手工进行截图和代码编写，工作量会比较大，因此这里推荐大家使用专用的 <a target="_blank" rel="noopener" href="http://airtest.netease.com/">AirtestIDE</a> 进行截图语句的开发，会使脚本的编写事半功倍。</p>
<p>在 <a target="_blank" rel="noopener" href="http://airtest.netease.com/">官网</a> 下载AirtestIDE，解压后即可使用，里面附带的Airtest辅助窗对于编写Airtest的脚本语句来说十分便捷：</p>
<p><img src="https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/airtest_api_info/airtest_assistant.png" srcset="/my_world/img/loading.gif" lazyload alt="鼠标悬停即可"></p>
<p>鼠标放在Airtest辅助窗的按钮上能看到相关接口参数信息，直接点击按钮就能生成对应的语句，或是可以直接在当前连接的设备画面上进行截图，截取完成后将会在脚本窗口生成带截图的语句。</p>
<h2 id="apk操作"><a href="#apk操作" class="headerlink" title="apk操作"></a>apk操作</h2><h3 id="打开app"><a href="#打开app" class="headerlink" title="打开app"></a>打开app</h3><p>虽然打开app时可以使用Airtest截图打开，但是请注意：<strong>打开应用尽量使用start_app而不是截图脚本</strong>相对用截图脚本来启动应用，脚本会更加简洁，兼容性也会更好。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打开网易云音乐</span>
start_app(<span class="hljs-string">&quot;com.netease.cloudmusic&quot;</span>)</code></pre></div>
<p>查看打开的app的包名有3种办法</p>
<p><strong>第一种</strong></p>
<p>cmd中输入命令：<code>adb shell am monitor</code><br>然后启动需要获取包名的应用</p>
<p><strong>第二种</strong></p>
<p>cmd中输入命令：<code>adb shell pm list packages -3</code><br>查看自己安装的app包名</p>
<p><strong>第三种</strong></p>
<p>下载雷电模拟器的包名类名查看器，找到app后直接点击复制包名（方便快捷）</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://www.ldmnq.com/app/210.html">包名类名查看器电脑版下载<em>包名类名查看器PC版下载</em>雷电安卓模拟器 (ldmnq.com)</a></p>
<h3 id="停止应用运行"><a href="#停止应用运行" class="headerlink" title="停止应用运行"></a>停止应用运行</h3><div class="code-wrapper"><pre><code class="hljs python">driver.close_app()</code></pre></div>
<h3 id="安装-卸载应用"><a href="#安装-卸载应用" class="headerlink" title="安装/卸载应用"></a>安装/卸载应用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 安装应用</span>
install(<span class="hljs-string">r&quot;D:\demo\tutorial-blackjack-release-signed.apk&quot;</span>)

<span class="hljs-comment"># 卸载应用</span>
uninstall(<span class="hljs-string">&quot;com.netease.cloudmusic&quot;</span>)</code></pre></div>
<h2 id="调用本地adb执行测试"><a href="#调用本地adb执行测试" class="headerlink" title="调用本地adb执行测试"></a>调用本地adb执行测试</h2><p>阅读源码可知道，airtest使用的是自带的adb，这个时候就需要调用系统的adb才能不进行冲突，修改源码：</p>
<p><code>%python_home%\site-packages\airtest\core\android\android.py</code></p>
<p>如果是linux，使用<code>which adb</code>寻找adb</p>
<p>第45行中，ADB初始化的时候加形参<code>adb_path</code>，让它等于自己的adb：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># init adb</span>
self.adb = ADB(self.serialno,adb_path=<span class="hljs-string">&quot;F:/environment/Android_SDK/platform-tools/adb.exe&quot;</span>,server_addr=host, display_id=self.display_id, input_event=self.input_event)
self.adb.wait_for_device()</code></pre></div>
<h2 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h2><p>在执行代码过程中，不可避免会到更改手机状态的操作，这个时候需要用到shell命令来调试手机，Airtest中的driver封装了执行shell命令的方法。</p>
<p>获取当前设备/连接当前设备</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 连接设备</span>
dev = connect_device(<span class="hljs-string">&quot;Android:///device1&quot;</span>)
<span class="hljs-comment"># 获取当前设备</span>
dev = device()</code></pre></div>
<p>运行adb shell命令</p>
<div class="code-wrapper"><pre><code class="hljs python">dev.shell(<span class="hljs-string">&quot;dumpsys wifi | grep mWifiInfo&quot;</span>) <span class="hljs-comment"># 检查wifi网络状态</span>

dev.shell(<span class="hljs-string">&quot;svc wifi disable&quot;</span>) <span class="hljs-comment"># 关闭wifi</span>
dev.shell(<span class="hljs-string">&quot;svc wifi enable&quot;</span>) <span class="hljs-comment"># 开启wifi</span>

dev.shell(<span class="hljs-string">&quot;svc data disable&quot;</span>) <span class="hljs-comment"># 关闭数据网络</span>
dev.shell(<span class="hljs-string">&quot;svc data enable&quot;</span>) <span class="hljs-comment"># 开启数据网络</span></code></pre></div>
<h2 id="Android自动化测试常用API"><a href="#Android自动化测试常用API" class="headerlink" title="Android自动化测试常用API"></a>Android自动化测试常用API</h2><p><strong>auto<em>setup(_<em>file</em></em>)</strong>：自动初始化设备，脚本运行命令行有两种形式，命令行中的参数包含<code>device</code>、<code>log</code>等</p>
<div class="code-wrapper"><pre><code class="hljs python">auto_setup(__file__) <span class="hljs-comment"># 在运行时的命令行中如果传入了类似--device Android:///这样的设备参数，那么脚本在初始化时会自动连上对应的设备，不需要再另外写代码连接了。</span>
auto_setup(__file__,devices=[<span class="hljs-string">&quot;Android://127.0.0.1:5037/5PZTQWQOGES8RWUG&quot;</span>]) <span class="hljs-comment"># 如果没有在初始化时连上设备，可以在接口中指定运行脚本的设备，或者使用connect_device接口来连接设备。</span></code></pre></div>
<p><strong>device()</strong>：获取到当前使用中的设备。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 在Android中，有一个平台独有的接口list_app可以列出所有安装过的应用</span>
dev = device()  <span class="hljs-comment"># 先获取到当前设备对象，这里的dev即是一个Android对象</span>
<span class="hljs-built_in">print</span>(dev.list_app())  <span class="hljs-comment"># 然后就可以调用平台独有接口了</span></code></pre></div>
<p><strong>connect_device()</strong>：连接设备，其中<code>127.0.0.1</code>代表本机IP，<code>5037</code>是默认的<code>adb port</code>，<code>serialno</code>是<code>android</code>手机的序列号。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *
<span class="hljs-comment"># 连上第一台手机</span>
dev1 = connect_device(<span class="hljs-string">&quot;Android://127.0.0.1:5037/serialno1&quot;</span>) 
<span class="hljs-comment"># 连上第二台手机</span>
dev2 = connect_device(<span class="hljs-string">&quot;Android://127.0.0.1:5037/serialno2&quot;</span>)</code></pre></div>
<p><strong>set_current()</strong>：在多个设备中进行切换</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 第一种：传入数字0、1、2等，切换当前操作的手机到Airtest连接的第1台、第2台、第3台手机</span>
set_current(<span class="hljs-number">0</span>)
set_current(<span class="hljs-number">1</span>)
set_current(<span class="hljs-number">2</span>)

<span class="hljs-comment"># 第二种：切换当前操作的手机到序列号为serialno1、serialno2的手机</span>
set_current(<span class="hljs-string">&quot;serialno1&quot;</span>)
set_current(<span class="hljs-string">&quot;serialno2&quot;</span>)</code></pre></div>
<p><strong>touch()</strong>：点击操作，可以是图片，也可以是坐标（坐标可以是绝对，可以是动态，推荐使用动态，可以在不同手机的分辨率下点击正确的位置）</p>
<div class="code-wrapper"><pre><code class="hljs python">touch(Template(<span class="hljs-string">r&quot;scriptshots/tpl1623669702383.png&quot;</span>, record_pos=(<span class="hljs-number">0.177</span>, -<span class="hljs-number">0.018</span>), resolution=(<span class="hljs-number">1600</span>, <span class="hljs-number">900</span>))) <span class="hljs-comment"># 根据录制脚本时所截取的图像进行点击</span>

touch([<span class="hljs-number">500</span>,<span class="hljs-number">500</span>]) <span class="hljs-comment"># 绝对坐标点击</span>

w,h = dev.get_current_resolution() <span class="hljs-comment"># 获取当前手机分辨率</span>
touch([<span class="hljs-number">0.5</span>*w, <span class="hljs-number">0.5</span>*h]) <span class="hljs-comment"># 动态坐标点击，推荐使用</span></code></pre></div>
<p><strong>wait()</strong>：可以等待画面中某个图片出现，如果在指定的时间范围内匹配到了该图片，就会返回图片所处位置的焦点，否则抛出<code>TargetNotFoundError</code>异常</p>
<div class="code-wrapper"><pre><code class="hljs python">wait(Template(<span class="hljs-string">r&quot;tpl1606821804906.png&quot;</span>))  <span class="hljs-comment"># timeout after ST.FIND_TIMEOUT</span>
<span class="hljs-comment"># find Template every 3 seconds, timeout after 120 seconds</span>
wait(Template(<span class="hljs-string">r&quot;tpl1606821804906.png&quot;</span>), timeout=<span class="hljs-number">120</span>, interval=<span class="hljs-number">3</span>)
<span class="hljs-comment"># 可以在每次查找目标失败时，指定一个回调函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notfound</span>():</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No target found&quot;</span>)
	wait(Template(<span class="hljs-string">r&quot;tpl1607510661400.png&quot;</span>), intervalfunc=notfound)</code></pre></div>
<p><strong>swipe()</strong>：可以从一个位置滑动到另外一个位置</p>
<div class="code-wrapper"><pre><code class="hljs python">swipe(Template(<span class="hljs-string">r&quot;tpl1574067097045.png&quot;</span>), vector=[<span class="hljs-number">0</span>, -<span class="hljs-number">0.5</span>]) <span class="hljs-comment"># 以图片的坐标为原点，向下滑动0.5</span>

w,h = d.get_current_resolution()
swipe([<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.5</span>*h],vector=[<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>]) <span class="hljs-comment"># 以屏幕中间为原点，向上滑动0.5</span>

swipe([<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.3</span>*h],[<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.8</span>*h]) <span class="hljs-comment"># 一个坐标滑动到另外一个坐标</span>
swipe(Template(<span class="hljs-string">r&quot;tpl1574067097045.png&quot;</span>),Template(<span class="hljs-string">r&quot;tpl1574054095465.png&quot;</span>)) <span class="hljs-comment"># 一个图片的坐标滑动到另外一个图片的坐标</span>
swipe([<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.3</span>*h],Template(<span class="hljs-string">r&quot;tpl1574067097045.png&quot;</span>)) <span class="hljs-comment"># 一个坐标滑动到一个图片的坐标</span></code></pre></div>
<p><strong>exists()</strong>：判断画面中是否存在某个图片,如果匹配到图片，返回图片所处位置的焦点，否则返回False</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> exists(Template(<span class="hljs-string">r&quot;tpl1606822430589.png&quot;</span>)):
	touch(Template(<span class="hljs-string">r&quot;tpl1606822430589.png&quot;</span>))</code></pre></div>
<p><strong>text()</strong>：输入文本</p>
<div class="code-wrapper"><pre><code class="hljs python">text(<span class="hljs-string">&quot;test&quot;</span>)
text(<span class="hljs-string">&quot;test&quot;</span>, enter=<span class="hljs-literal">False</span>)<span class="hljs-comment"># enter – 是否在输入完毕后，执行一次 Enter ，默认是True</span>
text(<span class="hljs-string">&quot;test&quot;</span>, search=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 在Android上，有时你需要在输入完毕后点击搜索按钮</span></code></pre></div>
<p><strong>sleep()</strong>：线程挂起</p>
<div class="code-wrapper"><pre><code class="hljs py">sleep(<span class="hljs-number">10</span>) <span class="hljs-comment"># 括号里面的单位为秒S</span></code></pre></div>
<p><strong>keyevent()</strong>：输入某个键，例如 home、back 等等</p>
<div class="code-wrapper"><pre><code class="hljs python">keyevent(<span class="hljs-string">&quot;HOME&quot;</span>)<span class="hljs-comment"># 按Home键</span></code></pre></div>
<p><strong>pinch()</strong>：指定放大还是缩小，还可以指定中心位置点和放大缩小的比率</p>
<div class="code-wrapper"><pre><code class="hljs python">pinch(in_or_out=<span class="hljs-string">&#x27;out&#x27;</span>, center=(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>), percent=<span class="hljs-number">0.4</span>)<span class="hljs-comment"># in_or_out后可输入&quot;in&quot;或者&quot;out&quot;，意思是缩小、放大</span></code></pre></div>
<p><strong>assert_exists()</strong>：设备屏幕上存在断言目标</p>
<div class="code-wrapper"><pre><code class="hljs python">assert_exists(Template(<span class="hljs-string">r&quot;tpl1607324047907.png&quot;</span>), <span class="hljs-string">&quot;assert exists&quot;</span>)</code></pre></div>
<p><strong>assert_not_exists()</strong>：设备屏幕上不存在断言目标</p>
<div class="code-wrapper"><pre><code class="hljs python">assert_not_exists(Template(<span class="hljs-string">r&quot;tpl1607324047907.png&quot;</span>), <span class="hljs-string">&quot;assert not exists&quot;</span>)</code></pre></div>
<p><strong>assert_equal()</strong>：断言两个值相等</p>
<div class="code-wrapper"><pre><code class="hljs python">assert_equal(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, msg=<span class="hljs-string">&quot;assert 1==1&quot;</span>)</code></pre></div>
<p><strong>assert_not_equal()</strong>：断言两个值不相等</p>
<div class="code-wrapper"><pre><code class="hljs python">assert_not_equal(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, msg=<span class="hljs-string">&quot;assert 1!=2&quot;</span>)</code></pre></div>
<p>assert_exists()与assert_equal()的区别在于，assert_exists断言的对象是图片，assert_equal断言的对象是数值</p>
<p><strong>snapshot()</strong>：截图到指定的路径下</p>
<div class="code-wrapper"><pre><code class="hljs python">snapshot(filename=<span class="hljs-string">&#x27;xxx/test.jpg&#x27;</span>,mag=<span class="hljs-string">&#x27;截图成功&#x27;</span>)</code></pre></div>
<h2 id="wifi远程运行"><a href="#wifi远程运行" class="headerlink" title="wifi远程运行"></a>wifi远程运行</h2><p>前面这些方法都是通过有线连接运行的，但是在无线下，Airtest也能运行，这和uiautomator如出一辙</p>
<p>确保手机开启了usb调试，用数据线把手机和电脑连接起来，之后在终端里面执行命令：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> tcpip <span class="hljs-number">8112</span></code></pre></div>
<p>其中的端口号可以自行设定，但不能和已有的端口冲突。执行后出现<code>restarting in TCP mode port</code>字样就可以将数据线拔下了。</p>
<p>在手机的wifi设置上，找到正在连接wifi的IP地址</p>
<p><img src="../../image/image-20220323144010699.png" srcset="/my_world/img/loading.gif" lazyload alt="wifi大概设置"></p>
<p>之后在Airtest IDE中找到远程设备连接，输入：</p>
<div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">adb</span> connect <span class="hljs-number">192.168.31.165:8112</span></code></pre></div>
<p>192.168.31.165就是IP，8112就是设置的端口号，点击连接后，刷新ADB即可</p>
<p><img src="../../image/image-20220323144452676.png" srcset="/my_world/img/loading.gif" lazyload alt="设置"></p>
<p>注意：</p>
<ul>
<li>更换一个网络环境需要使用新IP重新connect即可。</li>
<li>但是如果手机重启了，就需要重新连接数据线再次开启端口。</li>
<li>开启端口可以通过adb，也可以直接在手机上打开，但一般需要root权限和特殊软件。</li>
</ul>
<h2 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h2><p><strong>录屏功能仅适用于安卓平台</strong>，所以当测试设备是安卓真机或者部分安卓模拟器时才能够对脚本的运行过程进行录屏操作。</p>
<p>在命令行使用 <code>airtest run</code> 运行脚本时，可以通过添加 <code>--recording</code> 参数来录制脚本运行的视频。（运行结束后，录屏文件会默认保存在log文件夹里面，使用 <code>recording_手机序列号</code> 来命名录屏文件）</p>
<div class="code-wrapper"><pre><code class="hljs python">airtest run <span class="hljs-string">&quot;D:\test\Airtest_example.air&quot;</span>  --device android://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">5037</span>/emulator-<span class="hljs-number">5554</span>?cap_method=MINICAP_STREAM^&amp;^&amp;ori_method=MINICAPORI^&amp;^&amp;touch_method=MINITOUCH --log <span class="hljs-string">&quot;D:/test\41f68fdf265d8c13998d0a1a7b992889&quot;</span> --recording</code></pre></div>
<p>也可以在脚本中开启关闭录屏</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 开启录屏</span>
recorder.start_recording(max_time=<span class="hljs-number">10</span>)
<span class="hljs-comment"># 结束录屏</span>
recorder.stop_recording(output=<span class="hljs-string">&quot;test.mp4&quot;</span>)</code></pre></div>
<h2 id="Windows自动化测试常用API"><a href="#Windows自动化测试常用API" class="headerlink" title="Windows自动化测试常用API"></a>Windows自动化测试常用API</h2><p><strong>device()</strong>：连接设备</p>
<div class="code-wrapper"><pre><code class="hljs python">win = device()</code></pre></div>
<p><strong>key_press(key)</strong>：通过发送键盘扫描码模拟键盘按键按下</p>
<div class="code-wrapper"><pre><code class="hljs python">win.key_press(<span class="hljs-string">&#x27;W&#x27;</span>)</code></pre></div>
<p><strong>key_release(key)</strong>：通过发送键盘扫描码模拟键盘按键释放</p>
<div class="code-wrapper"><pre><code class="hljs python">win.key_release(<span class="hljs-string">&#x27;W&#x27;</span>)</code></pre></div>
<p><strong>mouse_move(pos)</strong>：模拟鼠标移动</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> win32api
x, y = win32api.GetCursorPos()
win.mouse_move((x+<span class="hljs-number">10</span>, y+<span class="hljs-number">10</span>))</code></pre></div>
<p><strong>mouse_down(button)</strong>：模拟鼠标按下（鼠标左右键或其他）</p>
<div class="code-wrapper"><pre><code class="hljs python">win.mouse_down(<span class="hljs-string">&#x27;right&#x27;</span>)</code></pre></div>
<p><strong>mouse_up(button)</strong>：模拟鼠标释放（鼠标左右键或其他）</p>
<div class="code-wrapper"><pre><code class="hljs python">win.mouse_up(<span class="hljs-string">&#x27;right&#x27;</span>)</code></pre></div>
<h2 id="Windows脚本一些常见问题以及解决方案"><a href="#Windows脚本一些常见问题以及解决方案" class="headerlink" title="Windows脚本一些常见问题以及解决方案"></a>Windows脚本一些常见问题以及解决方案</h2><h3 id="游戏窗口嵌入问题"><a href="#游戏窗口嵌入问题" class="headerlink" title="游戏窗口嵌入问题"></a>游戏窗口嵌入问题</h3><p>一些游戏在使用窗口嵌入模式时会出现包括无法框选窗口或者画面消失在内的问题。如果窗口无法框选的话，可以尝试搜索窗口。如果连接窗口以后整个游戏窗口消失的话，可以选择无嵌入模式。如果仍旧无法连接窗口，可以尝试桌面模式。</p>
<p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/search.png" srcset="/my_world/img/loading.gif" lazyload alt="搜索窗口"></p>
<p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/no_embedded.png" srcset="/my_world/img/loading.gif" lazyload alt="无嵌入模式"></p>
<p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/desk.png" srcset="/my_world/img/loading.gif" lazyload alt="桌面模式"></p>
<h3 id="使用桌面模式的图像脚本处理"><a href="#使用桌面模式的图像脚本处理" class="headerlink" title="使用桌面模式的图像脚本处理"></a>使用桌面模式的图像脚本处理</h3><p>因为使用了桌面模式，如果你的脚本当中涉及到图像识别，那很有可能在跑脚本的过程中识别到脚本中的图像，而不是游戏画面当中的图像。此时可以右键单击脚本，选择 <strong>图片/代码模式切换</strong> ，将模式转换成代码模式，就能顺利运行脚本了。</p>
<p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/mode.gif" srcset="/my_world/img/loading.gif" lazyload alt="运行gif图"></p>
<h3 id="PC游戏的光标限制"><a href="#PC游戏的光标限制" class="headerlink" title="PC游戏的光标限制"></a>PC游戏的光标限制</h3><p>一些PC游戏对光标进行了限制，玩家无法将光标移出游戏画面以外。在编写脚本的时候，可以利用<code>Tab+Alt</code>的方式进行窗口切换。</p>
<h2 id="IOS的WebDriverAgent安装过程"><a href="#IOS的WebDriverAgent安装过程" class="headerlink" title="IOS的WebDriverAgent安装过程"></a>IOS的WebDriverAgent安装过程</h2><p>在进行IOS的自动化测试中，我们需要用到WebDriverAgent来驱动手机。所以需要用到MacOS的Xcode来编译安装（作者已经试过用Windows，事实证明只能用MacOS来安装WebDriverAgent）。但是Windows用户占大部分，不可能让他们为了某个需求而专门买一台MacOS系统的电脑，所以需要在Windows中将MacOS系统装进虚拟机中。</p>
<p>关于Vmware安装MacOS的教程，链接如下：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337036027">全网最详细的VMware虚拟机安装MacOS系统教程，没有之一！！！附全部资源 - 知乎 (zhihu.com)</a></p>
<p>在【使用记事本打开后缀为<code>.vmx</code>的[macOS 10.14.vmx]的文件】这一部分的添加代码，语句应如下：</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">smc.version</span> = <span class="hljs-string">&quot;0&quot;</span>
<span class="hljs-attr">cpuid.0.eax</span> = <span class="hljs-string">&quot;0000:0000:0000:0000:0000:0000:0000:1011&quot;</span>
<span class="hljs-attr">cpuid.0.ebx</span> = <span class="hljs-string">&quot;0111:0101:0110:1110:0110:0101:0100:0111&quot;</span>
<span class="hljs-attr">cpuid.0.ecx</span> = <span class="hljs-string">&quot;0110:1100:0110:0101:0111:0100:0110:1110&quot;</span>
<span class="hljs-attr">cpuid.0.edx</span> = <span class="hljs-string">&quot;0100:1001:0110:0101:0110:1110:0110:1001&quot;</span>
<span class="hljs-attr">cpuid.1.eax</span> = <span class="hljs-string">&quot;0000:0000:0000:0001:0000:0110:0111:0001&quot;</span>
<span class="hljs-attr">cpuid.1.ebx</span> = <span class="hljs-string">&quot;0000:0010:0000:0001:0000:1000:0000:0000&quot;</span>
<span class="hljs-attr">cpuid.1.ecx</span> = <span class="hljs-string">&quot;1000:0010:1001:1000:0010:0010:0000:0011&quot;</span>
<span class="hljs-attr">cpuid.1.edx</span> = <span class="hljs-string">&quot;0000:0111:1000:1011:1111:1011:1111:1111&quot;</span>
<span class="hljs-attr">featureCompat.enable</span> = <span class="hljs-string">&quot;TRUE&quot;</span></code></pre></div>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42848413/article/details/115260253">VMware16安装Mac11.1Big Sur遇到“客户机操作系统已禁用 CPU。请关闭或重置虚拟机。”解决方案<em>strzlz的博客-CSDN博客</em>客户端操作系统已禁用cpu,请关闭或重置虚拟机</a></p>
</blockquote>
<p>成功安装MacOS虚拟机后，在虚拟机的网络设置中直接调整为【桥接模式】即可用MacOS上网</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rAy4fB5MOCFC48o5pYK9pA">脱离Mac搞iOS自动化，tidevice工具教你轻松实现！</a></p>
<h2 id="终端筛选日志级别"><a href="#终端筛选日志级别" class="headerlink" title="终端筛选日志级别"></a>终端筛选日志级别</h2><p>运行脚本后，终端除了最上面的1条运行脚本的命令之外，剩余的就是一些 [debug]、[info]等log信息，如果只关注log里面的[error]信息，可以在脚本代码开头加上 <code>log</code> 级别的设定：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span>
__author__ = <span class="hljs-string">&quot;user&quot;</span>
<span class="hljs-keyword">import</span> logging
logger = logging.getLogger(<span class="hljs-string">&quot;airtest&quot;</span>)
logger.setLevel(logging.ERROR)</code></pre></div>
<p>这样运行时只会在初始化手机时会有少量 <code>log</code> 输出，初始化完毕后就能够对 <code>logger</code> 进行过滤了。</p>
<p>若是在Airtest IDE中运行脚本，则只需要在log输出窗口中直接点击筛选即可。</p>
<h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><ol>
<li>使用airtest ide运行</li>
<li>使用命令行运行脚本</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs python">airtest run untitled.air --device Android:///手机设备号 --log log/ <span class="hljs-comment"># 使用airtest命令运行</span>
python -m airtest run untitled.air --device Android:///手机设备号 --log log/ <span class="hljs-comment"># 使用python命令行运行</span>
airtest run test.air --device Android:/// --log logs/ --no-image<span class="hljs-comment"># 使用airtest命令运行，但不保存截图</span></code></pre></div>
<p>关于安卓的手机设备号码，其字符串定义为<code>Android://&lt;adbhost[localhost]&gt;:&lt;adbport[5037]&gt;/&lt;serialno&gt;</code>，其中，adbhost是adb server所在主机的ip，默认是本机127.0.0.1，adb port默认是5037，<strong>serialno是android手机的序列号</strong>。更多adb的方面的内容请参考文档<a target="_blank" rel="noopener" href="https://developer.android.com/studio/command-line/adb?hl=zh-cn"> ADB</a> 。</p>
<p>在平时的脚本运行中，我们一般可以这样写:</p>
<ul>
<li>什么都不填写，会默认取当前连接中的第一台手机：<code>Android:///</code></li>
<li>连接本机默认端口连的一台设备号为79d03fa的手机：<code>Android://127.0.0.1:5037/79d03fa</code></li>
<li>用本机的adb连接一台adb connect过的远程设备，注意10.254.60.1:5555其实是serialno：<code>Android://127.0.0.1:5037/10.254.60.1:5555</code></li>
<li>连接一个Windows窗口，窗口句柄为123456：<code>Windows:///123456</code></li>
<li>连接一个Windows窗口，窗口名称匹配某个正则表达式：<code>Windows:///?title_re=Unity.*</code></li>
<li>连接windows桌面，不指定任何窗口：<code>Windows:///</code> </li>
<li>连接iOS手机：<code>iOS:///127.0.0.1:8100</code></li>
</ul>
<p><strong>注意：</strong> 如果自己拼写的设备字符串无法正确连接设备，但是在AirtestIDE中可以正常连接的话，可以考虑先在AirtestIDE中运行一次脚本，然后将运行时自动生成的命令行里 <code>--device Android:///</code> 参数复制出来，即可在代码中使用了，这种做法可以极大程度避免设备字符串编写错误的问题。</p>
<p>除了上述命令行外，也可以通过python调用命令行输入命令来达到目的，这样就可以直接在python中开启.air项目</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span>
<span class="hljs-keyword">import</span> os
os.system(<span class="hljs-string">&quot;airtest run test01.air --device Android:///127.0.0.1:7555&quot;</span>)</code></pre></div>
<p>注意，该.py文件需要放在.air文件夹外面，具体目录如下</p>
<p><img src="../../image/代码运行目录演示.png" srcset="/my_world/img/loading.gif" lazyload alt="目录演示"></p>
<h2 id="用bat文件执行Airtest脚本"><a href="#用bat文件执行Airtest脚本" class="headerlink" title="用bat文件执行Airtest脚本"></a>用bat文件执行Airtest脚本</h2><p>首先看下如何新建 <code>.bat</code> 文件。首先我们需要在电脑上新建一个 <code>.txt</code> 文件，并输入以下内容：</p>
<div class="code-wrapper"><pre><code class="hljs awk">::关闭回显
@echo off
::切换到D盘
D:
::进入D盘的test目录
cd D:\test
::执行 airtest run 命令
start airtest run newsLogin.air
<span class="hljs-keyword">exit</span></code></pre></div>
<p>其中 <code>::xxx</code> 表示的是注释内容，可以不写入 <code>.txt</code> 文件中；另外示例脚本的路径为 <code>D:\test\newsLogin.air</code> ，所以这里还做了切换到脚本路径的操作，读者可以根据自己脚本的实际情况来进行切换。</p>
<p>还需要注意的是，在上述示例中已经在示例脚本的开头添加了设备和 <code>log</code> 的初始化内容，所以不用另外在运行命令后面加上各种运行参数：</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">auto<span class="hljs-constructor">_setup(<span class="hljs-params">__file__</span>,<span class="hljs-params">logdir</span>=True,<span class="hljs-params">devices</span>=[<span class="hljs-string">&quot;Android://127.0.0.1:5037/emulator-5554&quot;</span>])</span></code></pre></div>
<p>如果测试设备相对固定，也建议直接将这些参数写到脚本中，可以简化命令行运行脚本的命令。</p>
<p>写完以上几条命令后，关掉 <code>.txt</code> 文件，将他的后缀名 <code>txt</code> 改成 <code>bat</code> ，之后会弹出重命名的警示弹窗，点击“是”即可。</p>
<h2 id="用bat文件顺序执行多个Airtest脚本"><a href="#用bat文件顺序执行多个Airtest脚本" class="headerlink" title="用bat文件顺序执行多个Airtest脚本"></a>用bat文件顺序执行多个Airtest脚本</h2><p>使用 <code>.bat</code> 文件成功执行单个airtest脚本之后，试试用 <code>.bat</code> 文件顺序执行多个airtest脚本：</p>
<div class="code-wrapper"><pre><code class="hljs awk">@echo off
D:
cd D:\test
title 正在执行第一个脚本
airtest run newsLogin.air
title 正在执行第二个脚本
airtest run newsUsing.air
title 正在执行第三个脚本
airtest run newsExit.air
<span class="hljs-keyword">exit</span></code></pre></div>
<p>可以看到，在上述登录网易新闻的示例脚本之外又增加了两个脚本，分别用来实现使用网易新闻和退出登录等操作。</p>
<p>所以在 <code>.bat</code> 文件中分别写了三条用于运行对应脚本的命令，其中 <code>title xxx</code> 用来指定命令提示窗口的标题，可以清晰地看出当前是在执行第几个脚本。最终的执行效果如下：</p>
<h2 id="用bat文件实现多机运行"><a href="#用bat文件实现多机运行" class="headerlink" title="用bat文件实现多机运行"></a>用bat文件实现多机运行</h2><p>在 <code>.bat</code> 文件中，<code>start</code> 可以启动单独的命令行窗口来运行指定程序或命令。所以可以利用 <code>start</code> 命令开启多个命令行窗口，实现在多台设备上执行同一个脚本：</p>
<div class="code-wrapper"><pre><code class="hljs awk">@echo off
D:
cd D:\test
start <span class="hljs-string">&quot;正在使用雷电模拟器跑脚本&quot;</span> airtest run newsLogin.air --device Android:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">5037</span>/emulator-<span class="hljs-number">5554</span>
start <span class="hljs-string">&quot;正在使用mumu模拟器跑脚本&quot;</span> airtest run newsLogin.air --device Android:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">5037</span>/<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7555</span>
<span class="hljs-keyword">exit</span></code></pre></div>
<p>上述命令可以实现在1台雷电模拟器和1台mumu模拟器上跑同一个脚本，效果如下：</p>
<p>当然，还可以给每一台设备单独配置1个 <code>.bat</code> 文件，最后再写1个总的 <code>.bat</code> 文件来调度前面用于在特定设备上运行脚本的 <code>.bat</code> 。 </p>
<h2 id="提升脚本成功率"><a href="#提升脚本成功率" class="headerlink" title="提升脚本成功率"></a>提升脚本成功率</h2><p>Airtest的上手并不复杂，可以说只要有一点Python脚本基础就能够轻松入门，然而随着产出的脚本代码越来越多，我们将会发现一个很严峻的问题：我们的脚本的运行结果，有时候似乎不受我们的控制。例如我们想要先判断当前画面上是否存在一个图标，只有在它存在时才进行下一步操作，然而明明画面上并没有，Airtest依然认为这个图标存在，打开报告一看才发现，它将屏幕上另外一个区域的内容判断认为是我们想找的图标了。再比如更加常见的一种情形是：我们框选了画面上的几个字，想要让它识别出来，但是运行结果时好时坏，Airtest常常认为我们选择的内容并不存在，但有时又能运行成功。</p>
<p>这个问题是Airtest的运行原理导致的，我们使用了图像识别的技术在当前游戏画面中查找对应的图片，然而图像识别并不能达到人眼识别的准确度，它只能尽可能地去寻找一个最符合预期的结果。这就经常导致了我们认为不存在的图片，它认为存在，或者 <strong>我们认为在画面上一眼就能找到的内容，Airtest认为不存在</strong> 。</p>
<p>也就是说，<strong>图像识别不是万能的！！！</strong> 它是有 <strong>成功率</strong> 的，假设一个脚本里有10张图片，每张图片的识别成功率都能达到95%之高，10张图片全部都正确识别的概率也不过60%而已。更何况，有许多图片因为种种原因，识别成功率远远低于95%这个值，要想脚本运行100%正确就更难了。</p>
<p>因此，我们在编写完脚本后，可以让脚本多运行几次，然后对成功率低的部分进行改进，这是几个值得注意的改进点：</p>
<ul>
<li>截图时尽量 <strong>保证截取的图像辨识度高、独立清晰</strong> ，例如截取一个按钮图像时，尽量不要带上太多的嘈杂背景图案，避免在背景变化后难以成功识别的问题</li>
<li>图像识别使用的算法 <strong>更适合用来识别按钮类（带边框）、图标类的图像</strong> ，仅仅单独截取几个文字的识别成功率很低，请尽量调整图片截取内容来达到较好的识别效果，避免截取识别效果较差的内容</li>
<li>Airtest会尽可能地尝试适配 <strong>不同分辨率</strong> 的手机，但是在某些游戏上可能有自定义的分辨率适配规则，可以根据自己游戏的分辨率适配情况来自定义，攻略在 <a target="_blank" rel="noopener" href="https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/1_script_settings/">这里</a></li>
<li>若有大量重复的、非常相似的图标堆叠在一起时，有可能识别效果不佳，在我们眼中也许每一个图标上面的文字是不一样的，然而在<code>Airtest</code>的眼中它们实在是太相似了。我们可以尝试修改截图，借助一些其他的背景样式，修改成辨识度更高的图片。</li>
<li>尽管我们提供了便捷的自动录制功能，能够直接将当前所有操作一步一步转换成代码，但是这种情况下自动截取的图片往往不太理想，需要手工再对截图进行调整</li>
</ul>
<p><strong>图像识别的配置项</strong></p>
<p>在Airtest进行图像识别的过程中，有一些常见的配置项可以调整，以提升脚本运行的成功率：</p>
<ul>
<li>在AirtestIDE中，可以通过双击图片，修改 <code>threshold</code> 的值来改变图像识别的阈值，阈值越高，对图像匹配的精度要求也就越高</li>
<li>在识别图像时，Airtest会先将图像转为 <strong>灰度</strong> 图再进行识别。因此假如有两个按钮，形状内容相同，只有颜色不同的情况下，Airtest将认为它们都是相同内容。不过，我们可以通过双击图片，勾选设置里的 <code>RGB</code> 选项来强制使用彩色图像识别</li>
<li>除了可以修改 <code>threshold</code> 和 <code>rgb</code> 两个值以外，双击图片还能够设置识别成功后我们对于图像的点击位置 <code>target_pos</code> ，例如我们可以在识别出一个图标后，指定Airtest去点击这个图标的右下角/左上角等位置</li>
<li>具体的脚本配置方法可以在 <a target="_blank" rel="noopener" href="https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/1_script_settings/">5.2 Airtest脚本相关配置</a>里查看</li>
</ul>
<p>这里是大佬总结的使用airtest时的注意点，请注意细看，这会对接下来的开发有很大的帮助。网址点击即可：<a target="_blank" rel="noopener" href="https://blog.csdn.net/AirtestProject/article/details/108364907">写了10000条Airtest截图脚本总结出来的截图经验，赶紧收藏！_AirtestProject的博客-CSDN博客_airtest 截图</a></p>
<h1 id="Poco"><a href="#Poco" class="headerlink" title="Poco"></a>Poco</h1><p>官网：<a target="_blank" rel="noopener" href="https://airtest.netease.com/home/">Airtest Project (netease.com)</a></p>
<p>教程：<a target="_blank" rel="noopener" href="https://airtest.doc.io.netease.com/IDEdocs/poco_framework/poco_quick_start/">Poco快速上手 - Airtest Project Docs (netease.com)</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://poco.readthedocs.io/zh_CN/latest/index.html">欢迎使用Poco (ポコ) UI自动化框架 — poco 1.0 文档</a></p>
<p>poco是一种基于UI控件搜索的自动化框架，与airtest不同，它的操作方式与appium相似。</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs shell">pip install pocoui</code></pre></div>
<h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> poco.drivers.unity3d <span class="hljs-keyword">import</span> UnityPoco

poco = UnityPoco()

poco(<span class="hljs-string">&#x27;btn_start&#x27;</span>).click()
time.sleep(<span class="hljs-number">1.5</span>)

shell = poco(<span class="hljs-string">&#x27;shell&#x27;</span>).focus(<span class="hljs-string">&#x27;center&#x27;</span>)
<span class="hljs-keyword">for</span> star <span class="hljs-keyword">in</span> poco(<span class="hljs-string">&#x27;star&#x27;</span>):
    star.drag_to(shell)
time.sleep(<span class="hljs-number">1</span>)

<span class="hljs-keyword">assert</span> poco(<span class="hljs-string">&#x27;scoreVal&#x27;</span>).get_text() == <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;score correct.&quot;</span>
poco(<span class="hljs-string">&#x27;btn_back&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;Button&#x27;</span>).click()</code></pre></div>
<h2 id="使用指南-1"><a href="#使用指南-1" class="headerlink" title="使用指南"></a>使用指南</h2><p>Poco在大多数平台中，需要 <strong>事先接入Poco-SDK才可正常使用</strong> ，在少数平台（如Android原生APP）可直接使用Poco，目前支持平台如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">平台</th>
<th style="text-align:left">Airtest</th>
<th style="text-align:left">Poco</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cocos2dx-js, Cocos2dx-lua</td>
<td style="text-align:left">√</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://poco-chinese.readthedocs.io/zh_CN/latest/source/doc/integration.html#cocos2dx-lua">接入文档</a></td>
</tr>
<tr>
<td style="text-align:left">Unity3D</td>
<td style="text-align:left">√</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://poco-chinese.readthedocs.io/zh_CN/latest/source/doc/integration.html#unity3d">接入文档</a></td>
</tr>
<tr>
<td style="text-align:left">Native Android APP</td>
<td style="text-align:left">√</td>
<td style="text-align:left">直接使用</td>
</tr>
<tr>
<td style="text-align:left">iOS</td>
<td style="text-align:left">√</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://airtest.doc.io.netease.com/IDEdocs/device_connection/4_ios_connection/">帮助文档</a></td>
</tr>
<tr>
<td style="text-align:left">Egret</td>
<td style="text-align:left">√</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/AirtestProject/Poco-SDK/tree/master/Egret">接入文档</a></td>
</tr>
<tr>
<td style="text-align:left">Other engines</td>
<td style="text-align:left">√</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://poco-chinese.readthedocs.io/zh_CN/latest/source/doc/implementation_guide.html">可自行接入</a></td>
</tr>
<tr>
<td style="text-align:left">WeChat Applet&amp;webview</td>
<td style="text-align:left">√</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://airtest.doc.io.netease.com/IDEdocs/poco_framework/poco_webview/">参考文档</a> 随着微信更新可能会失效</td>
</tr>
<tr>
<td style="text-align:left">Windows, MacOS</td>
<td style="text-align:left">√</td>
<td style="text-align:left">敬请期待</td>
</tr>
<tr>
<td style="text-align:left">Netease</td>
<td style="text-align:left">√</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="http://git-qa.gz.netease.com/maki/netease-ide-plugin">帮助文档</a></td>
</tr>
</tbody>
</table>
</div>
<p>在airtest ide中新建脚本，可以在ide中直接编写poco即可，和airtest一样，可以使用录制来加速编写代码效率。但是airtest ide中没有poco的简要说明。</p>
<h2 id="初始化pocoui"><a href="#初始化pocoui" class="headerlink" title="初始化pocoui"></a>初始化pocoui</h2><p>这里用Android作为例子，不同的引擎有不同的初始化方式，详情看文档，这里用的最多就是Android，所以只示例了Android。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> poco.drivers.android.uiautomation <span class="hljs-keyword">import</span> AndroidUiautomationPoco
poco = AndroidUiautomationPoco(use_airtest_input=<span class="hljs-literal">True</span>,screenshot_each_action=<span class="hljs-literal">False</span>)</code></pre></div>
<h2 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h2><p>通过元素name</p>
<div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;com.android.systemui:id/mobile_settings_button&quot;</span>).click()<span class="hljs-comment">#.click()为点击，后面会讲到</span></code></pre></div>
<p>通过元素text</p>
<div class="code-wrapper"><pre><code class="hljs python">poco(text=<span class="hljs-string">&quot;电话&quot;</span>).click()</code></pre></div>
<p>通过坐标</p>
<div class="code-wrapper"><pre><code class="hljs python">poco().click([<span class="hljs-number">0.507</span>,<span class="hljs-number">0.013</span>])</code></pre></div>
<p>长按点击</p>
<div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;蓝牙。&quot;</span>).long_click()<span class="hljs-comment"># 默认的长按点击，笔者比较喜欢用这个（因为不用动脑而且不会出现很奇葩的错误）</span></code></pre></div>
<h2 id="发送文本"><a href="#发送文本" class="headerlink" title="发送文本"></a>发送文本</h2><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;cn.mobile.mms:id/embedded_text_editor&quot;</span>).set_text(<span class="hljs-string">&quot;0000&quot;</span>)</code></pre></div>
<h2 id="滑动页面（相比Airtest，用这个最好）"><a href="#滑动页面（相比Airtest，用这个最好）" class="headerlink" title="滑动页面（相比Airtest，用这个最好）"></a>滑动页面（相比Airtest，用这个最好）</h2><p>滑动页面是通过坐标完成的，在airtest中所有的坐标使用相对坐标，查看坐标的方法为：选项—&gt;设置—&gt;勾选【实时坐标显示】和【相对坐标】。鼠标移动到设备窗口即可查看相对坐标</p>
<div class="code-wrapper"><pre><code class="hljs python">poco.swipe([<span class="hljs-number">0.507</span>,<span class="hljs-number">0.013</span>],[<span class="hljs-number">0.507</span>,<span class="hljs-number">0.575</span>])
poco.swipe(<span class="hljs-string">&quot;down&quot;</span>)
poco.swipe(<span class="hljs-string">&quot;up&quot;</span>)</code></pre></div>
<h2 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h2><p>有些元素是变化的，可能在某个时间段存在，某个时间段又消失了，这个时候我们可以判断元素是否存在</p>
<div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).exists</code></pre></div>
<p>可以配合if，如果元素存在，则执行动作</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span>(poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).exists):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入框存在，点击&quot;</span>);
    poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).click()</code></pre></div>
<h2 id="控件等待"><a href="#控件等待" class="headerlink" title="控件等待"></a>控件等待</h2><h3 id="仅等待不报错"><a href="#仅等待不报错" class="headerlink" title="仅等待不报错"></a>仅等待不报错</h3><p>可以使用<code>wait</code>方法，指定时间等待控件出现，再进行点击操作（该方法的返回值是控件本身，所以后面可以紧跟控件操作，比如点击、长按）</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 在10s内等待控件出现，如出现，则进行长按操作</span>
poco(texture=<span class="hljs-string">&quot;icon&quot;</span>).wait(timeout=<span class="hljs-number">10</span>).long_click()</code></pre></div>
<h3 id="等待后不满足则报错"><a href="#等待后不满足则报错" class="headerlink" title="等待后不满足则报错"></a>等待后不满足则报错</h3><p>Poco控件还支持另外2个等待事件，<code>wait_for_appearance()</code>和<code>wait_for_disappearance()</code>；这两个API可以等待页面上 <strong>某1个UI</strong> 出现或者消失，等待的超时时间 <code>timeout</code> 默认为120秒，如果在超时时长之内元素没有出现或者消失的话，会报 <code>PocoTargetTimeout</code> 的错误。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 等待黄色小鱼出现</span>
poco(<span class="hljs-string">&quot;yellow&quot;</span>).wait_for_appearance(timeout=<span class="hljs-number">20</span>)

<span class="hljs-comment"># 等待计分文本控件消失</span>
poco(text=<span class="hljs-string">&quot;Count:&quot;</span>).wait_for_disappearance(timeout=<span class="hljs-number">3</span>)</code></pre></div>
<h3 id="Poco类的等待事件"><a href="#Poco类的等待事件" class="headerlink" title="Poco类的等待事件"></a>Poco类的等待事件</h3><p>这里有两个poco类的等待方法：<code>wait_for_any()</code>和<code>wait_for_all()</code>。与上述等待事件不同的是，<code>wait_for_any()</code> 和 <code>wait_for_all()</code> 可以给定多个UI对象让其等待。（需要注意这两个方法是Poco类的方法）</p>
<p><code>wait_for_all()</code> 是在超时时长结束之前，需要 <strong>等待所有给定的UI对象都显示出来</strong> ，即一次轮询所有UI，例如等待三个图标都显示之后，再点击返回按钮</p>
<div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;wait_ui2&quot;</span>).click()
yellow = poco(<span class="hljs-string">&quot;yellow&quot;</span>)
blue = poco(<span class="hljs-string">&quot;blue&quot;</span>)
black = poco(<span class="hljs-string">&quot;black&quot;</span>)

poco.wait_for_all([yellow,blue,black])
poco(<span class="hljs-string">&quot;btn_back&quot;</span>).click()</code></pre></div>
<p><code>wait_for_any()</code> 则是在超时时长结束之前，<strong>等待任意一个UI显示出来</strong>，即一次轮询任何一个给定的UI。</p>
<div class="code-wrapper"><pre><code class="hljs python">bomb = poco(<span class="hljs-string">&quot;bomb&quot;</span>)
yellow = poco(<span class="hljs-string">&quot;yellow&quot;</span>)
blue = poco(<span class="hljs-string">&quot;blue&quot;</span>)

<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    fish = poco.wait_for_any([bomb,yellow,blue])
    <span class="hljs-built_in">print</span>(fish.get_name())</code></pre></div>
<p>可以看到，只要页面出出现了等待的任一UI，<code>wait_for_any()</code> 方法都会返回第一个等待到的UI。</p>
<h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><p>通过python的for循环可以 <strong>遍历任何序列的项目</strong> ，如一个列表或者字符串。</p>
<p>举个例子，<code>poco(&quot;playDragAndDrop&quot;).child(&quot;star&quot;)</code> 得到的就是1个控件序列（包含了5个星星元素）， <code>star</code> 代表控件序列中的1个元素。因此通过这个循环，可以遍历了5个星星元素的序列，并把每个星星元素依次拖动到贝壳上：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> star <span class="hljs-keyword">in</span> poco(<span class="hljs-string">&quot;playDragAndDrop&quot;</span>).child(<span class="hljs-string">&quot;star&quot;</span>):
    star.drag_to(poco(<span class="hljs-string">&quot;shell&quot;</span>))</code></pre></div>
<p><img src="https://airtest.doc.io.netease.com/IDEdocs/poco_framework/poco_API/for.gif" srcset="/my_world/img/loading.gif" lazyload alt=""></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>poco源码中会杀死uiautomator的进程，因为这个目前笔者不再使用该框架，目前用airtest+uiautomator2编写自动化脚本</p>
<h1 id="判断运行时间"><a href="#判断运行时间" class="headerlink" title="判断运行时间"></a>判断运行时间</h1><p>若有判断程序运行时延的需要，可以计算运行的时间即可。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time

first = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始的时间: &quot;</span>+<span class="hljs-built_in">str</span>(first))
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;运行程序&quot;</span>)
end = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束的时间: &quot;</span>+<span class="hljs-built_in">str</span>(end))
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;运行程序用了:&quot;</span>+<span class="hljs-built_in">str</span>(end-first)+<span class="hljs-string">&quot;秒&quot;</span>)</code></pre></div>
<p>该方法包含了其他程序使用CPU的时间，是程序从开始到结束的时间。单位为秒</p>
<h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><p>官网：<a target="_blank" rel="noopener" href="https://www.selenium.dev/">Selenium</a></p>
<p>文档：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://selenium-python.readthedocs.io/index.html">https://selenium-python.readthedocs.io/index.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://seleniumhq.github.io/selenium/docs/api/py/api.html">https://seleniumhq.github.io/selenium/docs/api/py/api.html</a></p>
</li>
</ul>
<p>Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作，不同是Selenium 可以直接运行在浏览器上，它支持所有主流的浏览器（包括PhantomJS这些无界面的浏览器）。</p>
<p>Selenium 可以根据我们的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。</p>
<p>注意：本笔记默认读者会<strong>CSS，HTML</strong>等基础的Web语言</p>
<h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs python">pip install selenium</code></pre></div>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><blockquote>
<p>引用<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c82c965c014">selenium教程 - 简书 (jianshu.com)</a></p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># IPython2 测试代码</span>

<span class="hljs-comment"># 导入 webdriver</span>
<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver

<span class="hljs-comment"># 要想调用键盘按键操作需要引入keys包</span>
<span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys

<span class="hljs-comment"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span>
driver = webdriver.PhantomJS()

<span class="hljs-comment"># 如果没有在环境变量指定PhantomJS位置</span>
<span class="hljs-comment"># driver = webdriver.PhantomJS(executable_path=&quot;./phantomjs&quot;))</span>

<span class="hljs-comment"># get方法会一直等到页面被完全加载，然后才会继续程序，通常测试会在这里选择 time.sleep(2)</span>
driver.get(<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>)

<span class="hljs-comment"># 获取页面名为 wrapper的id标签的文本内容</span>
data = driver.find_element_by_id(<span class="hljs-string">&quot;wrapper&quot;</span>).text

<span class="hljs-comment"># 打印数据内容</span>
<span class="hljs-built_in">print</span> data

<span class="hljs-comment"># 打印页面标题 &quot;百度一下，你就知道&quot;</span>
<span class="hljs-built_in">print</span> driver.title

<span class="hljs-comment"># 生成当前页面快照并保存</span>
driver.save_screenshot(<span class="hljs-string">&quot;baidu.png&quot;</span>)

<span class="hljs-comment"># id=&quot;kw&quot;是百度搜索输入框，输入字符串&quot;长城&quot;</span>
driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(<span class="hljs-string">u&quot;马云&quot;</span>)

<span class="hljs-comment"># id=&quot;su&quot;是百度搜索按钮，click() 是模拟点击</span>
driver.find_element_by_id(<span class="hljs-string">&quot;su&quot;</span>).click()

<span class="hljs-comment"># 获取新的页面快照</span>
driver.save_screenshot(<span class="hljs-string">&quot;马云.png&quot;</span>)

<span class="hljs-comment"># 打印网页渲染后的源代码</span>
<span class="hljs-built_in">print</span> driver.page_source

<span class="hljs-comment"># 获取当前页面Cookie</span>
<span class="hljs-built_in">print</span> driver.get_cookies()

<span class="hljs-comment"># ctrl+a 全选输入框内容</span>
driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(Keys.CONTROL,<span class="hljs-string">&#x27;a&#x27;</span>)

<span class="hljs-comment"># ctrl+x 剪切输入框内容</span>
driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(Keys.CONTROL,<span class="hljs-string">&#x27;x&#x27;</span>)

<span class="hljs-comment"># 输入框重新输入内容</span>
driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(<span class="hljs-string">u&quot;王健林&quot;</span>)

<span class="hljs-comment"># 模拟Enter回车键</span>
driver.find_element_by_id(<span class="hljs-string">&quot;su&quot;</span>).send_keys(Keys.RETURN)

<span class="hljs-comment"># 清除输入框内容</span>
driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).clear()

<span class="hljs-comment"># 生成新的页面快照</span>
driver.save_screenshot(<span class="hljs-string">&quot;王健林.png&quot;</span>)

<span class="hljs-comment"># 获取当前url</span>
<span class="hljs-built_in">print</span> driver.current_url

<span class="hljs-comment"># 关闭当前页面，如果只有一个页面，会关闭浏览器</span>
<span class="hljs-comment"># driver.close()</span>

<span class="hljs-comment"># 关闭浏览器</span>
driver.quit()</code></pre></div>
<h2 id="引用Selenium"><a href="#引用Selenium" class="headerlink" title="引用Selenium"></a>引用Selenium</h2><p>使用<code>from selenium import webdriver</code>和<code>from selenium.webdriver.common.keys import Keys</code>引用Selenium和Selenium keys（用于使用特定的按键，比如说F2等等）包</p>
<h2 id="初始化Selenium"><a href="#初始化Selenium" class="headerlink" title="初始化Selenium"></a>初始化Selenium</h2><p>首先安装浏览器驱动，笔者用的是Edge和Chrome（这个用的最多），这两个驱动分别在<a target="_blank" rel="noopener" href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">Microsoft Edge Driver - Microsoft Edge Developer</a>和<a target="_blank" rel="noopener" href="http://chromedriver.storage.googleapis.com/index.html">chromedriver存储目录</a></p>
<p>下载，下载方法如下：</p>
<ol>
<li>Edge</li>
</ol>
<p>进入网页，找到Stable Channel，根据自己的系统位数选择下载即可。</p>
<p><img src="../../image/image-20210815014016616.png" srcset="/my_world/img/loading.gif" lazyload alt="下载图示"></p>
<ol>
<li>Chrome</li>
</ol>
<p>首先查看自己Chrome的版本号，在Chrome输入<code>chrome://version</code>即可查看Chrome的版本号</p>
<p><img src="../../image/image-20210815014209789.png" srcset="/my_world/img/loading.gif" lazyload alt="看到该字样即可"></p>
<p>进入网页，找到相应的版本号后，点击下载即可</p>
<p>保存好浏览器驱动后，使用如下代码，让Selenium找到相应的驱动后即可开启浏览器</p>
<div class="code-wrapper"><pre><code class="hljs python">driver = webdriver.Chrome(<span class="hljs-string">&quot;xxx/browserDriver/chromedriver.exe&quot;</span>)<span class="hljs-comment"># Chrome 浏览器驱动存放路径</span>
driver = webdriver.Edge(<span class="hljs-string">&quot;xxx/browserDriver/msedgedriver.exe&quot;</span>)<span class="hljs-comment"># Edge 浏览器驱动存放路径</span></code></pre></div>
<p>也可以将浏览器驱动存放在python的根目录下，不用输入存放路径</p>
<div class="code-wrapper"><pre><code class="hljs python">driver = webdriver.Chrome()
driver = webdriver.Edge()</code></pre></div>
<p>这样，Selenium初始化完毕。</p>
<p>可以使用headless无UI进行selenium，通常运用在爬虫中，特别的，headless模式通常运用在Chrome浏览器中</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Chrome后台静默运行</span>
__options = webdriver.ChromeOptions()
__options.add_argument(<span class="hljs-string">&#x27;--no-sandbox&#x27;</span>) <span class="hljs-comment"># 解决DevToolsActivePort文件不存在的报错</span>
__options.add_argument(<span class="hljs-string">&#x27;--start-maximized&#x27;</span>) <span class="hljs-comment"># 最大化运行（全屏窗口）,不设置，取元素会报错</span>
__options.add_argument(<span class="hljs-string">&#x27;--disable-infobars&#x27;</span>) <span class="hljs-comment"># 禁用浏览器正在被自动化程序控制的提示</span>
__options.add_argument(<span class="hljs-string">&#x27;window-size=1920x1080&#x27;</span>) <span class="hljs-comment"># 设置浏览器分辨率</span>
__options.add_argument(<span class="hljs-string">&#x27;--disable-gpu&#x27;</span>) <span class="hljs-comment"># 谷歌文档提到需要加上这个属性来规避bug</span>
__options.add_argument(<span class="hljs-string">&#x27;--hide-scrollbars&#x27;</span>)  <span class="hljs-comment"># 隐藏滚动条，应对一些特殊页面</span>
__options.add_argument(<span class="hljs-string">&#x27;blink-settings=imagesEnabled=false&#x27;</span>) <span class="hljs-comment"># 不加载图片，提升运行速度</span>
__options.add_argument(<span class="hljs-string">&#x27;--headless&#x27;</span>) <span class="hljs-comment"># 浏览器不提供可视化界面。Linux下如果系统不支持可视化不加这条会启动失败</span>
__options.add_argument(<span class="hljs-string">&quot;--ignore-certificate-errors&quot;</span>) <span class="hljs-comment"># 忽视掉证书认证的不安全连接的错误</span>
<span class="hljs-comment"># 传入user-agent，欺骗网站，使得它认为是在实际的浏览器上运行,这样的话运行的网络速度是和UI运行的时候是一样的</span>
__options.add_argument(<span class="hljs-string">&#x27;user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36&quot;&#x27;</span>)
__options.add_argument(<span class="hljs-string">&quot;--ignore-ssl-errors&quot;</span>)
__driver = webdriver.Chrome(executable_path = <span class="hljs-string">&quot;./browserDriver/chromedriver.exe&quot;</span>,options=__options)<span class="hljs-comment"># Chrome 浏览器驱动存放路径</span></code></pre></div>
<p>user-agent可以通过在Chrome浏览器中输入<code>chrome://version</code>的用户代理查找到，这里笔者使用的是最新的chrome浏览器（作为自动化工具）</p>
<h2 id="打开网址"><a href="#打开网址" class="headerlink" title="打开网址"></a>打开网址</h2><div class="code-wrapper"><pre><code class="hljs python">driver.get(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>)</code></pre></div>
<h2 id="定位UI元素"><a href="#定位UI元素" class="headerlink" title="定位UI元素"></a>定位UI元素</h2><blockquote>
<p>引用<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c82c965c014">selenium教程 - 简书 (jianshu.com)</a>，有少量修改</p>
</blockquote>
<p>通过如下选择器可以精准找到网页的HTML元素和标签。</p>
<div class="code-wrapper"><pre><code class="hljs python">find_element_by_id
find_elements_by_name
find_elements_by_xpath
find_elements_by_link_text
find_elements_by_partial_link_text
find_elements_by_tag_name
find_elements_by_class_name
find_elements_by_css_selector</code></pre></div>
<p>示例：</p>
<div class="code-wrapper"><pre><code class="hljs python">driver.find_element_by_id(<span class="hljs-string">&quot;txtMobileTexter&quot;</span>).send_keys(<span class="hljs-string">&quot;12345&quot;</span>)<span class="hljs-comment"># 通过id获取元素，发送字符12345</span>
driver.find_element_by_xpath(<span class="hljs-string">&quot;//*[@id=&#x27;mobileSelSend&quot;</span>).click()<span class="hljs-comment"># 通过xpath获取元素，并点击</span>
driver.find_element_by_link_text(<span class="hljs-string">&quot;发送&quot;</span>).text<span class="hljs-comment"># 通过元素中的字符获取元素获取文本</span>
<span class="hljs-comment"># 获取指定元素，并判断是否存在</span>
<span class="hljs-keyword">try</span>:
    driver.find_element_by_xpath(<span class="hljs-string">&quot;/html/body/div[1]/div[1]/div[2]/div[2]/span&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成功&quot;</span>)
<span class="hljs-keyword">except</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;失败&quot;</span>)</code></pre></div>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">从根节点选取，使用绝对路径，路径必须完全匹配</td>
</tr>
<tr>
<td style="text-align:center">//</td>
<td style="text-align:center">从整个文档中选取，使用相对路径</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">从当前节点开始选取</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">从当前节点父节点开始选取</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:center">选取属性</td>
</tr>
<tr>
<td style="text-align:center">text()</td>
<td style="text-align:center">获取文本</td>
</tr>
</tbody>
</table>
</div>
<p><strong>案例</strong></p>
<blockquote>
<p>引用<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43430036/article/details/84836516">(7条消息) Scrapy爬虫：XPath语法_灵动的艺术的博客-CSDN博客_scrapy xpath语法</a></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">路径表达式</th>
<th style="text-align:center"><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">body</td>
<td style="text-align:center">选取 body 元素的所有子节点。</td>
</tr>
<tr>
<td style="text-align:center">/head</td>
<td style="text-align:center">选取根元素下head。假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td>
</tr>
<tr>
<td style="text-align:center">div/a</td>
<td style="text-align:center">选取属于 div 的子元素的所有 a 元素。</td>
</tr>
<tr>
<td style="text-align:center">//a</td>
<td style="text-align:center">选取所有 a 子元素，而不管它们在文档中的位置。</td>
</tr>
<tr>
<td style="text-align:center">div//a</td>
<td style="text-align:center">选择属于 div 元素的后代的所有 a 元素，而不管它们位于 bookstore 之下的什么位置。</td>
</tr>
<tr>
<td style="text-align:center">//@class</td>
<td style="text-align:center">选取名为 class 的所有属性。</td>
</tr>
<tr>
<td style="text-align:center">./a</td>
<td style="text-align:center">选取当前元素下的a</td>
</tr>
<tr>
<td style="text-align:center">…/a</td>
<td style="text-align:center">选取父元素下的a</td>
</tr>
<tr>
<td style="text-align:center">a/@href</td>
<td style="text-align:center">选取a标签的href属性</td>
</tr>
<tr>
<td style="text-align:center">a/text()</td>
<td style="text-align:center">选取a标签下的文本</td>
</tr>
</tbody>
</table>
</div>
<h2 id="图像验证码识别"><a href="#图像验证码识别" class="headerlink" title="图像验证码识别"></a>图像验证码识别</h2><p>很多网站上都有图像验证码，这是自动化测试的一大难题，这里用EasyOCR来识别网站的图像验证码文字，但是一旦碰到识别准确率不高的情况下需要手动处理。</p>
<h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><div class="code-wrapper"><pre><code class="hljs shell">pip install easyocr</code></pre></div>
<p>需要花费一些时间</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> easyocr</code></pre></div>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>步骤非常简单，一共有三步：</p>
<ul>
<li>创建识别对象</li>
<li>读取并识别图像</li>
<li>导出文本</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 导入easyocr</span>
<span class="hljs-keyword">import</span> easyocr
<span class="hljs-comment"># 创建reader对象</span>
reader = easyocr.Reader([<span class="hljs-string">&#x27;ch_sim&#x27;</span>,<span class="hljs-string">&#x27;en&#x27;</span>]) 
<span class="hljs-comment"># 读取图像</span>
result = reader.readtext(<span class="hljs-string">&#x27;test.jpg&#x27;</span>)
<span class="hljs-comment"># 结果</span>
result</code></pre></div>
<h2 id="鼠标动作链"><a href="#鼠标动作链" class="headerlink" title="鼠标动作链"></a>鼠标动作链</h2><blockquote>
<p>以下代码和文字（包括本小章节到页面等待章节前）引用了网址<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c82c965c014">selenium教程 - 简书 (jianshu.com)</a>，有少量修改</p>
</blockquote>
<p>引入鼠标动作库<code>from selenium.webdriver import ActionChains</code>这样就可以使用复杂的鼠标动作了。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 鼠标移动到 ac 位置</span>
ac = driver.find_element_by_xpath(<span class="hljs-string">&#x27;element&#x27;</span>)
ActionChains(driver).move_to_element(ac).perform()

<span class="hljs-comment"># 在 ac 位置单击</span>
ac = driver.find_element_by_xpath(<span class="hljs-string">&quot;elementA&quot;</span>)
ActionChains(driver).move_to_element(ac).click(ac).perform()

<span class="hljs-comment"># 在 ac 位置双击</span>
ac = driver.find_element_by_xpath(<span class="hljs-string">&quot;elementB&quot;</span>)
ActionChains(driver).move_to_element(ac).double_click(ac).perform()

<span class="hljs-comment"># 在 ac 位置右击</span>
ac = driver.find_element_by_xpath(<span class="hljs-string">&quot;elementC&quot;</span>)
ActionChains(driver).move_to_element(ac).context_click(ac).perform()

<span class="hljs-comment"># 在 ac 位置左键单击按住</span>
ac = driver.find_element_by_xpath(<span class="hljs-string">&#x27;elementF&#x27;</span>)
ActionChains(driver).move_to_element(ac).click_and_hold(ac).perform()

<span class="hljs-comment"># 将 elementD 拖拽到 elementE&#x27;) 位置</span>
ac1 = driver.find_element_by_xpath(<span class="hljs-string">&#x27;elementD&#x27;</span>)
ac2 = driver.find_element_by_xpath(<span class="hljs-string">&#x27;elementE&#x27;</span>)
ActionChains(driver).drag_and_drop(ac1, ac2).perform()</code></pre></div>
<p>如果是普通的点击，也可以直接使用如下代码点击，不用ActionChains类</p>
<div class="code-wrapper"><pre><code class="hljs python">driver.find_element_by_xpath(<span class="hljs-string">&quot;//button[@type=&#x27;button&#x27;]&quot;</span>).click()</code></pre></div>
<h2 id="选择表单"><a href="#选择表单" class="headerlink" title="选择表单"></a>选择表单</h2><p>若碰到<select> </select>标签的下拉框，需要使用引用<code>from selenium.webdriver.support.ui import Select</code>。代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 找到 name 的选项卡</span>
select = Select(driver.find_element_by_name(<span class="hljs-string">&#x27;status&#x27;</span>))
<span class="hljs-comment"># </span>
select.select_by_index(<span class="hljs-number">1</span>)
select.select_by_value(<span class="hljs-string">&quot;0&quot;</span>)
select.select_by_visible_text(<span class="hljs-string">u&quot;未审核&quot;</span>)</code></pre></div>
<p>以上是三种选择下拉框的方式，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。</p>
<ul>
<li><strong>index</strong> 索引从 0 开始</li>
<li><strong>value</strong>是option标签的一个属性值，并不是显示在下拉框中的值</li>
<li><strong>visible_text</strong>是在option标签文本的值，是显示在下拉框的值</li>
</ul>
<p>全部取消选择的代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs python">select.deselect_all()</code></pre></div>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>首先区分出上传按钮的种类，大体上可以分为两种</p>
<ul>
<li>一种是input框</li>
<li>另外一种就比较复杂，通过js、flash等实现，标签非input</li>
</ul>
<h3 id="input上传"><a href="#input上传" class="headerlink" title="input上传"></a>input上传</h3><p>该方法大概针对该类型的html：</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span></code></pre></div>
<p>遇到该类型的html，selenium可以十分简单粗暴得上传图片：</p>
<div class="code-wrapper"><pre><code class="hljs python">upload = driver.find_element_by_id(<span class="hljs-string">&#x27;file&#x27;</span>)
upload.send_keys(<span class="hljs-string">&#x27;d:\\all_money.wmv&#x27;</span>)  <span class="hljs-comment"># send_keys</span></code></pre></div>
<h3 id="非input上传"><a href="#非input上传" class="headerlink" title="非input上传"></a>非input上传</h3><p>这种上传千奇百怪，有用a标签的，有用div的，有用button的，有用object的，selenium没有办法通过直接在网页上处理掉这些上传，唯一的办法就是打开OS弹框，去处理弹框。</p>
<p>但是OS弹框涉及的层面已经不是selenium能解决的了，大体上有以下几种解决方案：</p>
<ul>
<li>autoIT：借助外力，我们去调用其生成的au3或exe文件。</li>
<li>pywin32库：识别对话框句柄，进而操作</li>
<li>SendKeys库</li>
<li>keybd_event：跟pywin32库类似，但是是模拟按键，ctrl+a，ctrl+c， ctrl+v…</li>
</ul>
<h2 id="页面前进和后退"><a href="#页面前进和后退" class="headerlink" title="页面前进和后退"></a>页面前进和后退</h2><div class="code-wrapper"><pre><code class="hljs python">driver.forward()     <span class="hljs-comment"># 前进</span>
driver.back()        <span class="hljs-comment"># 后退</span></code></pre></div>
<h2 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h2><p><strong>切换窗口</strong></p>
<p>浏览器会有很多窗口，所以要有方法来实现窗口的切换</p>
<div class="code-wrapper"><pre><code class="hljs python">driver.switch_to.window(<span class="hljs-string">&quot;this is window name&quot;</span>)</code></pre></div>
<p>也可以使用 window_handles 方法来获取每个窗口的操作对象</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> driver.window_handles:
    driver.switch_to.window(handle)</code></pre></div>
<p><strong>切换到iframe（通过页面的UI）</strong></p>
<p>页面中可能会存在iframe元素，需要切换到iframe里面才可以让Selenium操作里面的内容</p>
<div class="code-wrapper"><pre><code class="hljs python">driver.switch_to.frame(driver.find_element_by_xpath(<span class="hljs-string">&quot;/html/body/div[3]/div[5]/div[1]/div[7]/iframe&quot;</span>))</code></pre></div>
<h2 id="弹窗处理"><a href="#弹窗处理" class="headerlink" title="弹窗处理"></a>弹窗处理</h2><p>当触发了某个事件之后，页面出现了弹窗提示，处理如下代码提示或者获取提示信息方法</p>
<div class="code-wrapper"><pre><code class="hljs python">alert = driver.switch_to.alert()
alert.accept()<span class="hljs-comment"># 点击弹窗的确认</span>
alert.text<span class="hljs-comment"># 获取弹窗文本内容</span></code></pre></div>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>获取页面每个Cookies值</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> cookie <span class="hljs-keyword">in</span> driver.get_cookies():
    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;%s -&gt; %s&quot;</span> % (cookie[<span class="hljs-string">&#x27;name&#x27;</span>], cookie[<span class="hljs-string">&#x27;value&#x27;</span>])</code></pre></div>
<p>删除Cookies</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># By name</span>
driver.delete_cookie(<span class="hljs-string">&quot;CookieName&quot;</span>)

<span class="hljs-comment"># all</span>
driver.delete_all_cookies()</code></pre></div>
<h2 id="页面等待"><a href="#页面等待" class="headerlink" title="页面等待"></a>页面等待</h2><p>现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。</p>
<p>为了避免这种元素定位困难而且会提高产生 ElementNotVisibleException 的概率。所以 Selenium 提供了两种等待方式，一种是隐式等待，一种是显式等待。</p>
<p>隐式等待是等待特定的时间，显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。</p>
<p><strong>显式等待</strong></p>
<p>引入WebDriverWait</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait</code></pre></div>
<p>WebDriverWait的API</p>
<div class="code-wrapper"><pre><code class="hljs python">WebDriverWait(driver,timeout,poll_frequency=<span class="hljs-number">0.5</span>,ignored_exceptions=<span class="hljs-literal">None</span>)</code></pre></div>
<p>说明：</p>
<ul>
<li>driver：浏览器驱动</li>
<li>timeout：最长超时时间，默认以秒为单位</li>
<li>poll_frequency：检测的间隔步长，默认为0.5s</li>
<li>ignored_exceptions：超时后的抛出的异常信息，默认抛出NoSuchElementExeception异常。</li>
</ul>
<p>WebDriverWait通常与until()或者until_not()方法结合使用：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 调用该方法提供的驱动程序作为参数，直到返回值为True</span>
WebDriverWait(driver,<span class="hljs-number">10</span>).until(method，message=<span class="hljs-string">&quot;&quot;</span>)
<span class="hljs-comment"># 调用该方法提供的驱动程序作为参数，直到返回值为False</span>
WebDriverWait(driver,<span class="hljs-number">10</span>).until_not(method，message=<span class="hljs-string">&quot;&quot;</span>)</code></pre></div>
<p>可以自定义等待条件：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#设置等待</span>
wait = WebDriverWait(driver,<span class="hljs-number">10</span>,<span class="hljs-number">0.5</span>)
<span class="hljs-comment">#使用匿名函数</span>
wait.until(<span class="hljs-keyword">lambda</span> diver:driver.find_element_by_id(<span class="hljs-string">&#x27;kw&#x27;</span>))</code></pre></div>
<p>WebDriverWait与expected_conditions方法结合使用：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
<span class="hljs-comment"># WebDriverWait 库，负责循环等待</span>
<span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait
<span class="hljs-comment"># expected_conditions 类，负责条件出发</span>
<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC

<span class="hljs-comment"># 页面一直循环，直到 id=&quot;myDynamicElement&quot; 出现</span>
wait = WebDriverWait(driver,<span class="hljs-number">10</span>)
element = wait.until(EC.presence_of_element_located((By.ID,<span class="hljs-string">&quot;myDynamicElement&quot;</span>)))</code></pre></div>
<p>如果不写步长参数，程序默认会 0.5s 调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。</p>
<p><code>expected_conditions</code>类提供的预期条件判断的方法如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>title_is</td>
<td>判断当前页面的 title 是否完全等于（==）预期字符串，返回布尔值</td>
</tr>
<tr>
<td>title_contains</td>
<td>判断当前页面的 title 是否包含预期字符串，返回布尔值</td>
</tr>
<tr>
<td><strong>presence_of_element_located</strong></td>
<td>判断某个元素是否被加到了 dom 树里，并不代表该元素一定可见</td>
</tr>
<tr>
<td>visibility_of_element_located</td>
<td>判断元素是否可见（可见代表元素非隐藏，并且元素宽和高都不等于 0）</td>
</tr>
<tr>
<td>visibility_of</td>
<td>同上一方法，只是上一方法参数为locator，这个方法参数是 定位后的元素</td>
</tr>
<tr>
<td>presence_of_all_elements_located</td>
<td>判断是否至少有 1 个元素存在于 dom 树中。举例：如果页面上有 n 个元素的 class 都是’wp’，那么只要有 1 个元素存在，这个方法就返回 True</td>
</tr>
<tr>
<td>text_to_be_present_in_element</td>
<td>判断某个元素中的 text 是否 包含 了预期的字符串</td>
</tr>
<tr>
<td>text_to_be_present_in_element_value</td>
<td>判断某个元素中的 value 属性是否包含 了预期的字符串</td>
</tr>
<tr>
<td>frame_to_be_available_and_switch_to_it</td>
<td>判断该 frame 是否可以 switch进去，如果可以的话，返回 True 并且 switch 进去，否则返回 False</td>
</tr>
<tr>
<td>invisibility_of_element_located</td>
<td>判断某个元素中是否不存在于dom树或不可见</td>
</tr>
<tr>
<td>element_to_be_clickable</td>
<td>判断某个元素中是否可见并且可点击</td>
</tr>
<tr>
<td>staleness_of</td>
<td>等某个元素从 dom 树中移除，注意，这个方法也是返回 True或 False</td>
</tr>
<tr>
<td>element_to_be_selected</td>
<td>判断某个元素是否被选中了,一般用在下拉列表</td>
</tr>
<tr>
<td>element_selection_state_to_be</td>
<td>判断某个元素的选中状态是否符合预期</td>
</tr>
<tr>
<td>element_located_selection_state_to_be</td>
<td>跟上面的方法作用一样，只是上面的方法传入定位到的 element，而这个方法传入 locator</td>
</tr>
<tr>
<td>alert_is_present</td>
<td>判断页面上是否存在 alert</td>
</tr>
</tbody>
</table>
</div>
<p><strong>隐式等待</strong></p>
<p>隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver

driver = webdriver.Chrome()
driver.implicitly_wait(<span class="hljs-number">10</span>) <span class="hljs-comment"># seconds</span>
driver.get(<span class="hljs-string">&quot;http://www.xxxxx.com/loading&quot;</span>)
myDynamicElement = driver.find_element_by_id(<span class="hljs-string">&quot;myDynamicElement&quot;</span>)</code></pre></div>
<h2 id="Airtest-Selenium"><a href="#Airtest-Selenium" class="headerlink" title="Airtest-Selenium"></a>Airtest-Selenium</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>airtest-selenium库是基于selenium库的进一步封装，有如下几个特点: </p>
<ol>
<li>对切换标签的界面进行了友好封装</li>
<li>支持图像识别功能</li>
<li>自动进行log记录(参考selenium-java的监听模式)</li>
<li>兼容selenium的原生api</li>
</ol>
<p>注意：<strong>Airtest-Selenium暂时不兼容selenium4，需要将selenium版本更改为3.0的版本后才能使用，否则会报<code>WebElement&#39; object has no attribute &#39;_w3c&#39;</code>的错误，可以在pycharm中将selenium修改为3.x的版本</strong></p>
<h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h3><div class="code-wrapper"><pre><code class="hljs shell">pip install airtest-selenium
pip install pynput</code></pre></div>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 引入selenium的webdriver模块</span>
<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
<span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys
<span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">from</span> airtest_selenium.proxy <span class="hljs-keyword">import</span> WebChrome</code></pre></div>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>需要把Chrome浏览器的驱动放在python的根目录上，具体下载在Selenium中说明。注意，要引用<code>from airtest_selenium.proxy import WebChrome</code>的接口</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#创建一个实例，代码运行到这里，会打开一个chrome浏览器</span>
driver = WebChrome()</code></pre></div>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ul>
<li><strong>driver.airtest_touch</strong>：airtest-selenium封装的图像点击</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python">driver.airtest_touch(Template(......))</code></pre></div>
<ul>
<li><strong>driver.assert_template</strong>：airtest-selenium封装的图像存在断言</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python">driver.assert_template(Template(......), <span class="hljs-string">&quot;请填写测试点&quot;</span>)</code></pre></div>
<ul>
<li><strong>snapshot</strong>：airtest-selenium封装的页面截图操作</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python">driver.snapshot()</code></pre></div>
<ul>
<li><strong>previous_tab</strong>：airtest-selnium封装的切换到上一个标签页的操作</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python">driver.switch_to_previous_tab()</code></pre></div>
<ul>
<li><strong>new_tab</strong>：airtest-selenium封装的切换到新打开标签页的操作</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs python">driver.switch_to_new_tab()</code></pre></div>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><div class="code-wrapper"><pre><code class="hljs routeros">python -m airtest <span class="hljs-builtin-name">run</span></code></pre></div>
<p>或者与selenium相同，在main方法中运行</p>
<h2 id="Ubuntu运行selenium"><a href="#Ubuntu运行selenium" class="headerlink" title="Ubuntu运行selenium"></a>Ubuntu运行selenium</h2><p>selenium不仅仅能在windows上运行，也能在linux上运行，这里用Ubuntu去运行。</p>
<blockquote>
<p>源自：<a target="_blank" rel="noopener" href="https://www.jerrycoding.com/article/linux-selenium/">Linux Ubuntu 下安装使用selenium 环境搭建-学习笔记-JerryCoding个人博客</a></p>
</blockquote>
<h3 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h3><div class="code-wrapper"><pre><code class="hljs shell">sudo apt-get install libxss1 libappindicator1 libindicator7 # 安装依赖库
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb # 获取chrome安装包
sudo dpkg -i google-chrome*.deb # 开始安装
google-chrome --version # 查看版本</code></pre></div>
<h3 id="下载chromedriver"><a href="#下载chromedriver" class="headerlink" title="下载chromedriver"></a>下载chromedriver</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">执行如下命令（第一条用于获取最新版本号，第二条用于下载）：</span>
LATEST=$(wget -q -O - http://chromedriver.storage.googleapis.com/LATEST_RELEASE)
wget http://chromedriver.storage.googleapis.com/$LATEST/chromedriver_linux64.zip
<span class="hljs-meta"></span>
<span class="hljs-meta">#</span><span class="bash"> 解压</span>
unzip chromedriver_linux64.zip
<span class="hljs-meta"></span>
<span class="hljs-meta">#</span><span class="bash"> 修改权限</span>
chmod +x chromedriver
<span class="hljs-meta"></span>
<span class="hljs-meta">#</span><span class="bash"> 可以移动driver 省的指定位置</span>
sudo mv chromedriver /usr/bin/
<span class="hljs-meta"></span>
<span class="hljs-meta">#</span><span class="bash"> 查看版本</span>
./chromedriver --version</code></pre></div>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
<span class="hljs-comment"># 如果没有将driver移动到 sudo mv chromedriver /usr/bin/ 要指定 driverpath</span>
driverpath = <span class="hljs-string">&#x27;&#x27;</span>       
driver = webdriver.Chrome(executable_path=driverpath)
driver.get(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>)
<span class="hljs-built_in">print</span>(driver.title)</code></pre></div>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/my_world/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/my_world/tags/airtest/">airtest</a>
                    
                      <a class="hover-with-bg" href="/my_world/tags/poco/">poco</a>
                    
                      <a class="hover-with-bg" href="/my_world/tags/selectium/">selectium</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/my_world/content/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%AD%90-%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF%E4%BB%A5%E5%8F%8A%E8%AF%AD%E6%B3%95%E6%8E%A2%E7%A9%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">英语句子/作文模板以及语法探究</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/my_world/content/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">正则表达式快速入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content" id="times">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备2021041688号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://fastly.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://fastly.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://fastly.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/my_world/js/events.js" ></script>
<script  src="/my_world/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/my_world/js/img-lazyload.js" ></script>
  



  



  <script  src="https://fastly.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://fastly.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://fastly.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/my_world/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://fastly.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://fastly.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  










  
<script src="/my_world/js/love.js"></script>
<script src="/my_world/js/ribbon_flow.js"></script>
<script src="/my_world/js/runningday.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/my_world/js/boot.js" ></script>


</body>
</html>
