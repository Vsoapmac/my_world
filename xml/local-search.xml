<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python基础大全（二）</title>
    <link href="/my_world/content/python%E5%9F%BA%E7%A1%80%E5%A4%A7%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/my_world/content/python%E5%9F%BA%E7%A1%80%E5%A4%A7%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>该篇用于总结一些库的使用或工具类总和，若需要看更多工具包看该链接：<a href="https://zhuanlan.zhihu.com/p/533695865">推荐收藏！深度盘点上千个优秀的 Python 工具包！ - 知乎 (zhihu.com)</a></p><h1 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging</code></pre></div><h2 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h2><div class="code-wrapper"><pre><code class="hljs python">logging.debug(<span class="hljs-string">&quot;这里是debug信息&quot;</span>)logging.info(<span class="hljs-string">&quot;这里是信息&quot;</span>)logging.warning(<span class="hljs-string">&quot;这里是警告信息&quot;</span>)logging.error(<span class="hljs-string">&quot;这里是错误信息&quot;</span>)logging.critical(<span class="hljs-string">&quot;这里是严重错误信息&quot;</span>)</code></pre></div><h2 id="工具类总和"><a href="#工具类总和" class="headerlink" title="工具类总和"></a>工具类总和</h2><p><code>DataTimeUtils</code>在该文章下面的<code>datetime</code>工具类整合中，<code>FilePathUtils</code>的主要工作为获取绝对路径，自己编写即可</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging,sys,os<span class="hljs-keyword">from</span> Utils.DataTimeUtils <span class="hljs-keyword">import</span> DataTimeUtils<span class="hljs-keyword">from</span> Utils.FilePathUtils <span class="hljs-keyword">import</span> FilePathUtils<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;log公共类&quot;&quot;&quot;</span>    logger = logging.getLogger(<span class="hljs-string">&quot;GameUtilsLogger&quot;</span>) <span class="hljs-comment"># 用该变量使用log模块</span><span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setAirtestLogLevel</span>(<span class="hljs-params">cls, level=logging.ERROR</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        设置airtest显示log的level</span><span class="hljs-string"></span><span class="hljs-string">        :param level: log等级，默认error</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        logger = logging.getLogger(<span class="hljs-string">&quot;airtest&quot;</span>)        logger.setLevel(level)<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setBasicLoggingSettings</span>(<span class="hljs-params">cls, level=logging.INFO, is_print_log=<span class="hljs-literal">True</span>, is_write_log=<span class="hljs-literal">False</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        基础的Log设置</span><span class="hljs-string"></span><span class="hljs-string">        :param level: log的level，默认INFO</span><span class="hljs-string">        :param is_print_log: 是否打印log文件，默认True</span><span class="hljs-string">        :param is_write_log: 是否写入log文件，默认false</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-comment">## 写入Log的基础设置</span>        formatter = logging.Formatter(<span class="hljs-string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,                                      datefmt=<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)        cls.logger.setLevel(level)        <span class="hljs-keyword">if</span> (is_write_log):            today = DataTimeUtils.getDay()            year = DataTimeUtils.getTimeByPattern(DataTimeUtils.YEAR_PATTERN)            month = DataTimeUtils.getTimeByPattern(DataTimeUtils.MONTH_PATTERN)            <span class="hljs-comment"># 检测Log文件是否存在，不存在则创建</span>            path = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;FilePathUtils.getProduceAbs()&#125;</span>log/<span class="hljs-subst">&#123;year&#125;</span>/<span class="hljs-subst">&#123;month&#125;</span>月/&quot;</span>            filename = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;today&#125;</span>.log&quot;</span>            <span class="hljs-comment"># 文件夹不存在则创建</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> os.path.exists(path)):                os.makedirs(path)            <span class="hljs-comment"># 文件不存在则创建</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> os.path.exists(path + filename)):                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path + filename, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:                    f.close()            file_handler = logging.FileHandler(path + filename)            file_handler.setFormatter(formatter)            file_handler.setLevel(level)            cls.logger.addHandler(file_handler)        <span class="hljs-keyword">if</span> (is_print_log):            <span class="hljs-comment">## 打印Log的基础设置</span>            console_handler = logging.StreamHandler(sys.stdout)            console_handler.setFormatter(formatter)  <span class="hljs-comment"># %(asctime)s</span>            console_handler.setLevel(level)            cls.logger.addHandler(console_handler)</code></pre></div><h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><h2 id="工具类总和-1"><a href="#工具类总和-1" class="headerlink" title="工具类总和"></a>工具类总和</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> datetime<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataTimeUtils</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;时间工具类&quot;&quot;&quot;</span>    ACCURACY_TIME_PATTERN = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span> <span class="hljs-comment"># 年-月-日 时:分:秒</span>    YEAR_MONTH_DAYS_PATTERN = <span class="hljs-string">&quot;%Y-%m-%d&quot;</span> <span class="hljs-comment"># 年-月-日</span>    YEAR_PATTERN = <span class="hljs-string">&quot;%Y&quot;</span> <span class="hljs-comment"># 年</span>    MONTH_PATTERN = <span class="hljs-string">&quot;%m&quot;</span> <span class="hljs-comment"># 月</span>    WEEK_PATTEN = <span class="hljs-string">&quot;%w&quot;</span> <span class="hljs-comment"># 周</span>    DAYS_PATTERN = <span class="hljs-string">&quot;%d&quot;</span> <span class="hljs-comment"># 日</span>    HOUR_PATTERN = <span class="hljs-string">&quot;%H&quot;</span> <span class="hljs-comment"># 时,24小时</span>    MINUTE_PATTERN = <span class="hljs-string">&quot;%M&quot;</span> <span class="hljs-comment"># 分</span>    SECOND_PATTERN = <span class="hljs-string">&quot;%S&quot;</span> <span class="hljs-comment"># 秒</span><span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recordTime</span>(<span class="hljs-params">cls</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        记录当前时间</span><span class="hljs-string"></span><span class="hljs-string">        :return: 时间浮点</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> time.time()<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">caculate</span>(<span class="hljs-params">cls,start,end,round_index = <span class="hljs-number">3</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        计算时间差</span><span class="hljs-string"></span><span class="hljs-string">        :param start: 开始时间</span><span class="hljs-string">        :param end: 结束时间</span><span class="hljs-string">        :param round_index: 结果位数，默认保留3位</span><span class="hljs-string">        :return: 时间差</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">round</span>(end - start,round_index)<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTime</span>(<span class="hljs-params">cls,days=<span class="hljs-number">0</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取某准确日期，自选</span><span class="hljs-string"></span><span class="hljs-string">        :param days: 今天为0，昨天为-1，以此类推，默认为0</span><span class="hljs-string">        :return: 日期，格式为年-月-日-时-分-秒</span><span class="hljs-string">        &quot;&quot;&quot;</span>        now = datetime.datetime.now()        <span class="hljs-keyword">return</span> (now + datetime.timedelta(days=days)).strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTimeByPattern</span>(<span class="hljs-params">cls,pattern,days=<span class="hljs-number">0</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        根据格式获取某准确日期，格式自选，可直接获取该类的类变量</span><span class="hljs-string"></span><span class="hljs-string">        :param days: 今天为0，昨天为-1，以此类推，默认为0</span><span class="hljs-string">        :param pattern: 生成日期的格式</span><span class="hljs-string">        :return: 日期</span><span class="hljs-string">        &quot;&quot;&quot;</span>        now = datetime.datetime.now()        <span class="hljs-keyword">return</span> (now + datetime.timedelta(days=days)).strftime(pattern)<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">caculateDays</span>(<span class="hljs-params">cls,lastday,today</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        计算天数差</span><span class="hljs-string"></span><span class="hljs-string">        :param lastday: 以前的准确日期，格式为年-月-日</span><span class="hljs-string">        :param today: 到今天的准确日期，格式为年-月-日</span><span class="hljs-string">        :return: 天数差</span><span class="hljs-string">        &quot;&quot;&quot;</span>        d1 = datetime.datetime.strptime(lastday, <span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)        d2 = datetime.datetime.strptime(today, <span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)        d = d2-d1        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(d.days)<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getDay</span>(<span class="hljs-params">cls,days=<span class="hljs-number">0</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取某日期，自选</span><span class="hljs-string"></span><span class="hljs-string">        :param days: 今天为0，昨天为-1，以此类推</span><span class="hljs-string">        :return: 日期，格式为年-月-日</span><span class="hljs-string">        &quot;&quot;&quot;</span>        now = datetime.datetime.now()        <span class="hljs-keyword">return</span> (now + datetime.timedelta(days=days)).strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)</code></pre></div><h1 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h1><p>完成一个python项目以后，可以使用 PyInstaller将Python程序生成可直接运行的程序，这个程序就可以被分发到对应的 Windows 或 Mac OS X 平台上，并且不需要部署python环境下运行程序。</p><blockquote><p>引用 <a href="http://c.biancheng.net/view/2690.html">Python PyInstaller安装和使用教程（详解版） (biancheng.net)</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs shell">pip install pyinstaller</code></pre></div><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>创建一个main.py，使用命令行工具进入到此python文件目录下，执行如下命令：</p><div class="code-wrapper"><pre><code class="hljs shell">pyinstaller -D main.py</code></pre></div><p>完毕后将dist目录下的程序提取出来即可，PyInstaller支持如下表所示的常用选项。</p><div class="table-container"><table><thead><tr><th>指令</th><th>行为</th></tr></thead><tbody><tr><td>-h，—help</td><td>查看该模块的帮助信息</td></tr><tr><td>-F，-onefile</td><td>产生单个的可执行文件</td></tr><tr><td>-D，—onedir</td><td>产生一个目录（包含多个文件）作为可执行程序</td></tr><tr><td>-a，—ascii</td><td>不包含 Unicode 字符集支持</td></tr><tr><td>-d，—debug</td><td>产生 debug 版本的可执行文件</td></tr><tr><td>-w，—windowed，—noconsolc</td><td>指定程序运行时不显示命令行窗口（仅对 Windows 有效）</td></tr><tr><td>-c，—nowindowed，—console</td><td>指定使用命令行窗口运行程序（仅对 Windows 有效）</td></tr><tr><td>-o DIR，—out=DIR</td><td>指定 spec 文件的生成目录。如果没有指定，则默认使用当前目录来生成 spec 文件</td></tr><tr><td>-p DIR，—path=DIR</td><td>设置 Python 导入模块的路径（和设置 PYTHONPATH 环境变量的作用相似）。也可使用路径分隔符（Windows 使用分号，Linux 使用冒号）来分隔多个路径</td></tr><tr><td>-n NAME，—name=NAME</td><td>指定项目（产生的 spec）名字。如果省略该选项，那么第一个脚本的主文件名将作为 spec 的名字</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础大全（一）</title>
    <link href="/my_world/content/python%E5%9F%BA%E7%A1%80%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/my_world/content/python%E5%9F%BA%E7%A1%80%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License) 协议。</p><p>官方宣布，2020 年 1 月 1 日， 停止 Python 2 的更新。Python 2.7 被确定为最后一个 Python 2.x 版本。</p><p>笔者使用的是<strong>python3.8</strong>，<strong>该博文并不适合完全零基础的读者</strong>，并且<strong>不会将所有的python基础全部展示出来</strong>，该博客旨在解决一些python的关键用法，python零基础请移步以下网址：</p><ol><li><a href="https://www.runoob.com/python3/python3-basic-syntax.html">Python3 基础语法 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.w3school.com.cn/python/index.asp">Python 教程 (w3school.com.cn)</a></li></ol><h1 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h1><p>安装python有两种方式</p><ol><li><p>直接安装python环境，网址：<a href="https://www.python.org/downloads/">Download Python | Python.org</a></p></li><li><p>安装conda环境，搭建虚拟python环境，推荐这个办法搭建python环境，可使用不同python环境进行编程，具体搜笔者的另外一个博客，Anaconda</p></li></ol><h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><ol><li>pycharm（笔者正在使用的ide）</li><li>vscode</li></ol><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><blockquote><p>引用：<a href="https://zhuanlan.zhihu.com/p/344543685">Python代码注释规范代码实例解析 - 知乎 (zhihu.com)</a></p></blockquote><ul><li>注释不是越多越好。对于一目了然的代码，不需要添加注释。</li><li>对于复杂的操作，应该在操作开始前写上相应的注释。</li><li>对于不是一目了然的代码，应该在代码之后添加注释。</li><li>绝对不要描述代码。一般阅读代码的人都了解Python的语法，只是不知道代码要干什么</li></ul><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>描述某个变量（某行代码）的作用</p><p>第一种写法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 注释</span>ui = <span class="hljs-number">1</span></code></pre></div><p>第二种写法：</p><div class="code-wrapper"><pre><code class="hljs python">ui = <span class="hljs-number">1</span> <span class="hljs-comment"># 注释</span></code></pre></div><p>突出某段代码的重要性</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># ==================</span><span class="hljs-comment"># 请勿删除该变量！！！！</span><span class="hljs-comment"># ==================</span>ui = <span class="hljs-number">1</span></code></pre></div><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>描述某个类的作用</p><p>格式如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;类用处&quot;&quot;&quot;</span></code></pre></div><p>使用实例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;类用处&quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span></code></pre></div><h2 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h2><p>描述某个方法的作用</p><p>DocStrings 文档字符串使用惯例：它的首行简述函数功能，第二行空行，第三行为函数的具体描述。</p><p>格式如下（reST风格）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">方法的用处</span><span class="hljs-string"></span><span class="hljs-string">:param parm: 形参的用处</span><span class="hljs-string">:return: 返回的数据</span><span class="hljs-string">&quot;&quot;&quot;</span></code></pre></div><p>这是现在流行的一种风格，reST风格，Sphinx的御用格式，比较紧凑。</p><ul><li><p>param为说明传入的形参</p></li><li><p>return为说明返回的数据</p></li></ul><p>使用实例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self,parm01,parm02</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    方法的用处</span><span class="hljs-string">    </span><span class="hljs-string">    :param parm01: 形参的用处01</span><span class="hljs-string">    :param parm02: 形参的用处02</span><span class="hljs-string">    :return: 返回的数据</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span></code></pre></div><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><p>字符串是 Python 中最常用的数据类型。我们可以使用引号(<code>&#39;</code>或<code>&quot;</code>)来创建字符串。</p><p>创建字符串很简单，只要为变量分配一个值即可。例如：</p><div class="code-wrapper"><pre><code class="hljs python">String1 = <span class="hljs-string">&#x27;Hello World!&#x27;</span>String2 = <span class="hljs-string">&quot;Hello python&quot;</span></code></pre></div><h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>调用<code>len</code>，该方法不仅仅用在字符串，也可以统计列表，元组的长度</p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-built_in">len</span>(name)</code></pre></div><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>对标java的<code>indexOf(int ch,int fromindex)</code>，索引是通过字符串下标返回该下标的字符</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]</code></pre></div><p>其中str为变量，0是头下标，1是尾下标</p><h3 id="特定字符串"><a href="#特定字符串" class="headerlink" title="特定字符串"></a>特定字符串</h3><p>调用find函数，返回首字母在匹配字符串的下标</p><div class="code-wrapper"><pre><code class="hljs python">name.find(<span class="hljs-string">&quot;World&quot;</span>)</code></pre></div><h3 id="判断某字符串是否在该字符串里"><a href="#判断某字符串是否在该字符串里" class="headerlink" title="判断某字符串是否在该字符串里"></a>判断某字符串是否在该字符串里</h3><p>用<code>in</code>关键字，若存在则返回True</p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;world&quot;</span> <span class="hljs-keyword">in</span> name)</code></pre></div><h3 id="计算子字符串在字符串中出现的次数"><a href="#计算子字符串在字符串中出现的次数" class="headerlink" title="计算子字符串在字符串中出现的次数"></a>计算子字符串在字符串中出现的次数</h3><p>调用<code>count</code>方法</p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&quot;helloworld&quot;</span>count = name.count(<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(name))<span class="hljs-built_in">print</span>(count)</code></pre></div><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="删除某特定尾字符"><a href="#删除某特定尾字符" class="headerlink" title="删除某特定尾字符"></a>删除某特定尾字符</h3><p>调用<code>rstrip</code>，如果方法不传参则默认删除空格符</p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&quot;helloworld;&quot;</span><span class="hljs-built_in">print</span>(name)count = name.rstrip(<span class="hljs-string">&#x27;;&#x27;</span>)<span class="hljs-built_in">print</span>(count)</code></pre></div><h2 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h2><h3 id="字符串类型转换为其他类型"><a href="#字符串类型转换为其他类型" class="headerlink" title="字符串类型转换为其他类型"></a>字符串类型转换为其他类型</h3><p>int类型（整数类型）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>)<span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>) <span class="hljs-comment"># 强转</span></code></pre></div><p>float类型（浮点类型）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;0.05&#x27;</span><span class="hljs-built_in">float</span>(<span class="hljs-built_in">str</span>)</code></pre></div><p>这里提一下浮点类型的四舍五入，可以调用round函数计算</p><div class="code-wrapper"><pre><code class="hljs python">number = <span class="hljs-number">5.454245435</span><span class="hljs-built_in">round</span>(number,<span class="hljs-number">3</span>)</code></pre></div><p>number为传入的浮点类型，3位保留3位数</p><h3 id="其他类型转换成字符串类型"><a href="#其他类型转换成字符串类型" class="headerlink" title="其他类型转换成字符串类型"></a>其他类型转换成字符串类型</h3><div class="code-wrapper"><pre><code class="hljs python">number = <span class="hljs-number">1</span><span class="hljs-built_in">str</span>(number)</code></pre></div><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一个特殊的字符序列，它能帮助人们方便的检查一个字符串是否与某种模式匹配。</p><p>可用<a href="https://regexr-cn.com/">RegExr: 学习、构建 和 测试 正则表达式 Test RegEx (regexr-cn.com)</a>生成正则表达式</p><h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re</code></pre></div><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none</p><div class="code-wrapper"><pre><code class="hljs python">re.match(pattern, string, flags=<span class="hljs-number">0</span>)</code></pre></div><p>形参作用如下（按传入顺序）：</p><ul><li>pattern：匹配的正则表达式</li><li>string：要匹配的字符串</li><li>flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> rename = <span class="hljs-string">&quot;helloworld&quot;</span>matcher = re.match(<span class="hljs-string">&quot;hello&quot;</span>,name)<span class="hljs-built_in">print</span>(matcher)</code></pre></div><p>匹配完成后，可用<code>span</code>方法在起始位置匹配</p><div class="code-wrapper"><pre><code class="hljs python">matcher.span()</code></pre></div><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>扫描整个字符串并返回第一个成功的匹配</p><div class="code-wrapper"><pre><code class="hljs python">re.search(pattern, string, flags=<span class="hljs-number">0</span>)</code></pre></div><p>形参作用如下（按传入顺序）：</p><ul><li>pattern：匹配的正则表达式</li><li>string：要匹配的字符串</li><li>flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> rename = <span class="hljs-string">&quot;helloworld&quot;</span>matcher = re.search(<span class="hljs-string">&quot;hello&quot;</span>,name)<span class="hljs-built_in">print</span>(matcher)</code></pre></div><p>匹配完成后，可用<code>group</code>方法在返回匹配的字</p><div class="code-wrapper"><pre><code class="hljs python">matcher.group()</code></pre></div><h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>替换字符串中的匹配项</p><div class="code-wrapper"><pre><code class="hljs python">re.sub(pattern, repl, string, count=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>)</code></pre></div><p>形参作用如下（按传入顺序）：</p><ul><li>pattern：匹配的正则表达式</li><li>repl : 替换的字符串，也可以是一个函数</li><li>string：要匹配的字符串</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配</li><li>flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> rename = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-built_in">print</span>(name)name = re.sub(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;bello&quot;</span>,name)<span class="hljs-built_in">print</span>(name)</code></pre></div><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>不与其他共享，自己独享，如函数和方法的局部变量，实例变量</p><p>写的时候，在变量左边加两个下斜杆（_）即可</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">__a = <span class="hljs-number">1</span>__b = <span class="hljs-string">&quot;1&quot;</span></code></pre></div><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>单个变量赋值</p><div class="code-wrapper"><pre><code class="hljs python">i = <span class="hljs-number">1000</span>  <span class="hljs-comment"># int型</span>j = <span class="hljs-number">1000.0</span>  <span class="hljs-comment"># float型</span>name = <span class="hljs-string">&quot;tom&quot;</span>  <span class="hljs-comment"># 字符串型</span><span class="hljs-built_in">print</span>(i)<span class="hljs-built_in">print</span>(j)<span class="hljs-built_in">print</span>(name)</code></pre></div><p>多个变量赋值</p><ol><li>给多个变量同时赋值，变量的值相同：<code>a = b = c = 1</code></li><li>为多个变量指定多个值：<code>a, b, c = 1, 2, &quot;tom&quot;</code></li></ol><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>class内，不在class的任何方法内，使用类变量时，将类实例化后调用</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span>:</span>    a = <span class="hljs-string">&quot;123&quot;</span>    __b = <span class="hljs-number">1</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test01</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(self.a) <span class="hljs-comment"># 方法调用类变量</span>            <span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test02</span>(<span class="hljs-params">cls</span>):</span>        <span class="hljs-built_in">print</span>(cls.__b) <span class="hljs-comment"># 静态方法调用类变量</span></code></pre></div><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>函数内、class的方法（类方法、静态方法、实例方法）内，且变量前面没有修饰</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test01</span>(<span class="hljs-params">self</span>):</span>a = <span class="hljs-number">1</span> <span class="hljs-comment"># 局部变量</span></code></pre></div><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量供全局共享，全局类和函数均可访问，达到同步作用。同时还可以被外部文件访问。</p><p>全局变量使用的时候，需要用global显示声明。<br>一般情况下，如果函数直接调用全局变量，不做更新的话，一般没有问题，但如果有重新赋值，又没有在函数内部使用 global声明的话， 就相当于在内部创建了一个同名的局部变量，局部变量优先级要高于全局变量。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfunc</span>():</span>  <span class="hljs-keyword">global</span> x  x = <span class="hljs-string">&quot;fantastic&quot;</span></code></pre></div><h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p>class的构造方法内，使用self修饰</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>    self.a = <span class="hljs-number">1</span> <span class="hljs-comment"># 实力变量</span></code></pre></div><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>调用<code>del</code>，可删除变量</p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&quot;helloworld&quot;</span><span class="hljs-built_in">print</span>(name)<span class="hljs-keyword">del</span>(name)<span class="hljs-built_in">print</span>(name)</code></pre></div><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>用来描述具有相同的属性和方法的对象的集合。</p><h3 id="类中双下划线函数的作用"><a href="#类中双下划线函数的作用" class="headerlink" title="类中双下划线函数的作用"></a>类中双下划线函数的作用</h3><p>使用demo类</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我调用了init方法&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">cls</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我调用了new方法&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行function&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我调用了del方法&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    a = A()    a.method()</code></pre></div><h4 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h4><p>负责进行对象的初始化，它是python中的构造方法</p><p>demo类中执行到__init__输出的是</p><div class="code-wrapper"><pre><code class="hljs csharp">我调用了<span class="hljs-keyword">init</span>方法</code></pre></div><h4 id="new"><a href="#new" class="headerlink" title="__new__"></a>__new__</h4><p>负责创建类实例的静态方法，__new__的执行顺序优先于__init__</p><p>依照Python官方文档的说法，__new__方法主要是当用户继承一些不可变的class时(比如int, str, tuple)， 提供给用户一个自定义这些类的实例化过程的途径。</p><p>__new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供</p><p>__new__必须要有返回值，返回实例化出来的实例，这点在实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例</p><p>demo类中执行到__new__输出的是</p><div class="code-wrapper"><pre><code class="hljs csharp">我调用了<span class="hljs-keyword">new</span>方法我调用了<span class="hljs-keyword">init</span>方法</code></pre></div><h4 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h4><p>负责销毁实例化对象，在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间。</p><p>大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制，能自动将不需要使用的实例对象进行销毁。</p><p>无论是手动销毁，还是 Python垃圾回收机制自动销毁，都会调用 __del__方法。</p><p>demo类中执行到__del__输出的是</p><div class="code-wrapper"><pre><code class="hljs ada">我调用了<span class="hljs-keyword">new</span>方法我调用了init方法执行<span class="hljs-keyword">function</span><span class="hljs-title">我调用了del方法</span></code></pre></div><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;创建类&quot;&quot;&quot;</span>    a = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-comment"># 类变量</span></code></pre></div><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>当创建了这个类的实例时就会调用该方法</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>    <span class="hljs-keyword">pass</span></code></pre></div><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>类方法</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test01</span>(<span class="hljs-params">self</span>):</span>    <span class="hljs-keyword">pass</span></code></pre></div><p>私有方法</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__test01</span>(<span class="hljs-params">self</span>):</span>    <span class="hljs-keyword">pass</span></code></pre></div><p>抽象方法（不需要实例化对象直接调用，像调用类变量，例如：<code>Test01.test01()</code>）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test01</span>(<span class="hljs-params">cls</span>):</span>    <span class="hljs-keyword">pass</span></code></pre></div><h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><p>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。</p><div class="code-wrapper"><pre><code class="hljs python">test01 = Test01() <span class="hljs-comment"># 创建一个名为test01对象</span>test02 = Test01() <span class="hljs-comment"># 创建一个名为test02对象</span></code></pre></div><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>访问方法</p><div class="code-wrapper"><pre><code class="hljs python">test01.test01() <span class="hljs-comment"># 调用类方法</span></code></pre></div><p>调用类变量</p><div class="code-wrapper"><pre><code class="hljs python">test01.a</code></pre></div><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>在模块中，有一个<code>__init__.py</code>的文件，这个文件说明该文件夹为一个<strong>包</strong>，该文件夹的名字为<strong>包名</strong></p><p><code>__init__.py</code>可以指定某个包下导入的类，例如，在<code>Utils</code>包中的<code>__init__</code>文件写入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .DataTimeUtils <span class="hljs-keyword">import</span> DataTimeUtils<span class="hljs-keyword">from</span> .YAMLReader <span class="hljs-keyword">import</span> YAMLReader__all__ = [<span class="hljs-string">&quot;DataTimeUtils&quot;</span>,           <span class="hljs-string">&quot;YAMLReader&quot;</span>,]</code></pre></div><p>在其他类中导入时使用<code>from Utils import *</code>即可导入<code>__init__</code>文件中指定的所有类</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Utils <span class="hljs-keyword">import</span> *<span class="hljs-built_in">print</span>(DataTimeUtils.getDay(<span class="hljs-number">0</span>))</code></pre></div><p>也可以指定某一个特定的类</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Utils <span class="hljs-keyword">import</span> DataTimeUtils<span class="hljs-built_in">print</span>(DataTimeUtils.getDay(<span class="hljs-number">0</span>))</code></pre></div><p>该办法可以让导入更加容易，并且一定程度封闭该包下的类，<strong>但是该方法实测过会损耗性能</strong></p><p><code>__init__.py</code>默认不写时，可导入该包下的类，用<code>from Utils.DataTimeUtils import DataTimeUtils</code>即可</p><h2 id="引用类"><a href="#引用类" class="headerlink" title="引用类"></a>引用类</h2><h3 id="from-…-import-…"><a href="#from-…-import-…" class="headerlink" title="from …. import …."></a>from …. import ….</h3><p>引用类时，使用<code>from Test.Test02 import Test02</code>，具体是<code>from 包名.类名 import 类名</code>，调用时，直接实例化即可，例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Utils.DataTimeUtils <span class="hljs-keyword">import</span> DataTimeUtilsdtu = DataTimeUtils()dtu.getDay(<span class="hljs-number">0</span>)</code></pre></div><p>当一个py文件中没有类时（面向过程编程），使用<code>from Test.Test02 import function</code>，具体是<code>from 包名.py文件名 import 方法名</code>，想要使用该方法时，直接调用即可，例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Test.Test02 <span class="hljs-keyword">import</span> functionfunction()</code></pre></div><h3 id="import-…"><a href="#import-…" class="headerlink" title="import …."></a>import ….</h3><p>引用类时，使用<code>import Utils.DataTimeUtils</code>，具体是<code>import 包名.模块名（py文件名）</code>，调用时，需要完整写出<code>包名.模块名.类名()</code>去实例化一个类，例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> Utils.DataTimeUtilsdtu = Utils.DataTimeUtils.DataTimeUtils()day = dtu.getDay(<span class="hljs-number">0</span>)</code></pre></div><p>当一个py文件中没有类时（面向过程编程），使用<code>import Test02</code>，具体是<code>import 包名.模块名（py文件名）</code>，想要使用该模块中的方法时，使用<code>模块名.方法名()</code>即可调用该方法，例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> Test02Test02.function()</code></pre></div><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过继承创建的新类称为<strong>子类</strong>或<strong>派生类</strong>，被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。</p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">base</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;父类&quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span>(<span class="hljs-params">base</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;子类&quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span></code></pre></div><p>一个类可以继承多个类，称为<strong>多继承</strong>，使用时尽量单继承</p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">base01</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;父类1&quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">base02</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;父类2&quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span>(<span class="hljs-params">base01,base02</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;子类&quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span></code></pre></div><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>子类可以调用父类的方法与类变量，并且可以调用祖先（父类的父类）的方法与类变量</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">base</span>:</span>    a = <span class="hljs-string">&quot;1&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base_test01</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span>(<span class="hljs-params">base</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test01</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(self.a)        <span class="hljs-built_in">print</span>(self.base_test01())</code></pre></div><h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>子类可以重写父类的方法</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">base</span>:</span>    a = <span class="hljs-string">&quot;1&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base_test01</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span>(<span class="hljs-params">base</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base_test01</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test01&quot;</span>)</code></pre></div><h3 id="继承实现接口"><a href="#继承实现接口" class="headerlink" title="继承实现接口"></a>继承实现接口</h3><p>在python中，是没有<code>interface</code>的，实现接口，可以使用<code>abc</code>模块实现，例</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> abc<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">base</span>(<span class="hljs-params">metaclass = abc.ABCMeta</span>):</span><span class="hljs-meta">    @abc.abstractmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base_test01</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">pass</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span>(<span class="hljs-params">base</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base_test01</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)</code></pre></div><p><code>@abc.abstractmethod</code>定义该方法为抽象方法，<code>metaclass = abc.ABCMeta</code>定义该类为抽象基类</p><p>若继承的接口类没有实现<code>base_test01</code>，则报错：</p><div class="code-wrapper"><pre><code class="hljs shell">TypeError: Can&#x27;t instantiate abstract class Test01 with abstract methods base_test01</code></pre></div><p>在继承抽象类的过程中，应该尽量避免多继承；而在继承接口的时候，反而鼓励多继承接口。</p><p>在抽象类中，可以对一些抽象方法做出基础实现；而在接口类中，任何方法都只是一种规范，具体的功能需要子类实现。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射（Reflection） 允许运行中的 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。反射的具体作用如下：</p><ul><li>反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。</li><li>反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。</li><li>测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。</li></ul><p>也就是说，利用反射，我们可以获取以下程序：</p><ul><li>Class 对象</li><li>类中的所有字段</li><li>类中的所有构造方法</li><li>类中的所有非构造方法</li></ul><p>反射看起来像是破坏了封装性，但是反射是可以作为一个工具，用来帮助程序员实现本不可能实现的功能（perform operations which would otherwise be impossible）。很多程序架构，尤其是三方框架，无法保证自己的封装是完美的。如果没有反射，对于外部类的私有成员，我们将一筹莫展，所以我们有了反射这一后门，为程序设计提供了更大的灵活性。工具本身并没有错，关键在于如何正确地使用。</p><p>新建一个类，该类为测试python反射的对象：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span>    <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span>    name = <span class="hljs-string">&quot;123&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">havePencil</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;He has a pencil&quot;</span>)</code></pre></div><h2 id="判断属性或方法是否存在"><a href="#判断属性或方法是否存在" class="headerlink" title="判断属性或方法是否存在"></a>判断属性或方法是否存在</h2><p>调用内置函数，返回值为bool（若存在则返回True）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">hasattr</span>(<span class="hljs-built_in">object</span>,<span class="hljs-string">&#x27;attrName&#x27;</span>)</code></pre></div><p>形参说明：</p><ul><li><code>object</code>：对象，可以是实例化对象</li><li><code>attrName</code>：字符串，用于判断对象是否存在该属性或者方法</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Student <span class="hljs-keyword">import</span> Student<span class="hljs-comment"># student = Student()</span>has_bool = <span class="hljs-built_in">hasattr</span>(Student,<span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment"># 是否存在该属性</span>has_bool = <span class="hljs-built_in">hasattr</span>(Student,<span class="hljs-string">&quot;havePencil&quot;</span>) <span class="hljs-comment"># 是否存在该方法</span><span class="hljs-built_in">print</span>(has_bool)</code></pre></div><h2 id="添加-设置属性"><a href="#添加-设置属性" class="headerlink" title="添加/设置属性"></a>添加/设置属性</h2><p>调用内置函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(<span class="hljs-built_in">object</span>,<span class="hljs-string">&#x27;attrName&#x27;</span>,value)</code></pre></div><p>形参说明：</p><ul><li><code>object</code>：对象，可以是实例化对象</li><li><code>attrName</code>：字符串，对象的属性</li><li><code>value</code>：对象属性的值</li></ul><p>object中，传入的对象是具体的实例化对象，则改变的是该对象的属性，否则会改变整体的对象属性</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Student <span class="hljs-keyword">import</span> Studentstudent1 = Student()student2 = Student()<span class="hljs-built_in">print</span>(student2.<span class="hljs-built_in">id</span>)<span class="hljs-built_in">setattr</span>(student2,<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 改变student2对象中的id属性</span><span class="hljs-built_in">print</span>(student2.<span class="hljs-built_in">id</span>)<span class="hljs-built_in">print</span>(student1.<span class="hljs-built_in">id</span>)<span class="hljs-built_in">setattr</span>(Student,<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-number">3</span>) <span class="hljs-comment"># 改变全部Student对象中的id属性</span><span class="hljs-built_in">print</span>(student1.<span class="hljs-built_in">id</span>)<span class="hljs-built_in">print</span>(student2.<span class="hljs-built_in">id</span>)</code></pre></div><h2 id="获取属性或方法"><a href="#获取属性或方法" class="headerlink" title="获取属性或方法"></a>获取属性或方法</h2><p>调用内置函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">getattr</span>(<span class="hljs-built_in">object</span>,<span class="hljs-string">&#x27;attrName&#x27;</span>)</code></pre></div><p>形参说明：</p><ul><li><code>object</code>：对象，可以是实例化对象</li><li><code>attrName</code>：字符串，用于获取该对象的属性或者方法</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> FunctionType<span class="hljs-keyword">from</span> Student <span class="hljs-keyword">import</span> Student<span class="hljs-built_in">id</span> = <span class="hljs-built_in">getattr</span>(Student, <span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment"># 获取对象的属性</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>)havePencil = <span class="hljs-built_in">getattr</span>(Student, <span class="hljs-string">&quot;havePencil&quot;</span>) <span class="hljs-comment"># 获取对象的方法，返回FunctionType类型</span><span class="hljs-built_in">print</span>(havePencil(Student())) <span class="hljs-comment"># 调用时加()并传入对象</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(havePencil) <span class="hljs-keyword">is</span> FunctionType)</code></pre></div><h2 id="删除属性或方法"><a href="#删除属性或方法" class="headerlink" title="删除属性或方法"></a>删除属性或方法</h2><p>调用内置函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">delattr</span>(<span class="hljs-built_in">object</span>,<span class="hljs-string">&#x27;attrName&#x27;</span>)</code></pre></div><p>形参说明：</p><ul><li><code>object</code>：对象，可以是实例化对象</li><li><code>attrName</code>：字符串，用于删除该对象的属性或者方法</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Student <span class="hljs-keyword">import</span> Studentstudent1 = Student()<span class="hljs-built_in">print</span>(student1.<span class="hljs-built_in">id</span>)<span class="hljs-built_in">delattr</span>(student2,<span class="hljs-string">&#x27;id&#x27;</span>) <span class="hljs-comment"># 删除student1对象中的id属性</span><span class="hljs-built_in">print</span>(student1.<span class="hljs-built_in">id</span>)</code></pre></div><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h2><p>如果想用python读取文件，第一步要用open函数打开文件。open()是python的内置函数，它会返回一个文件对象，这个文件对象拥有read、readline、write、close等方法。</p><p>open函数有两个参数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file&#x27;</span>,<span class="hljs-string">&#x27;mode&#x27;</span>)</code></pre></div><p>其中，<strong>file</strong>为需要打开的文件路径，<strong>mode</strong>为打开文件的模式，如只读、追加、写入等</p><p><strong>mode常用的模式：</strong></p><ul><li>r：表示文件只能读取</li><li>w：表示文件只能写入，若文件不存在会创建一个</li><li>a：表示打开文件，在原有内容的基础上追加内容，在末尾写入</li><li>w+：表示可以对文件进行读写双重操作</li></ul><p>mode参数可以省略不填，默认模式为r；mode参数还可以指定以什么样的编码方式读写文本，默认情况下open是以文本形式打开文件的，比如上面的四种mode模式。</p><p>当你需要以字节（二进制）形式读写文件时，只需要在mode参数中追加’b’即可：</p><ul><li>rb：以二进制格式打开一个文件，用于只读</li><li>wb：以二进制格式打开一个文件，用于只写</li><li>ab：以二进制格式打开一个文件，用于追加</li><li>wb+:以二进制格式打开一个文件，用于读写</li></ul><h3 id="with关键字"><a href="#with关键字" class="headerlink" title="with关键字"></a>with关键字</h3><p>在打开文件时，很多人通常直接用open(‘file’)。在文件读写时可以使用 <code>with</code> 关键字。优点是当子句体结束后文件会正确关闭，即使在某个时刻引发了异常。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;workfile&#x27;</span>) <span class="hljs-keyword">as</span> f:    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>):    read_data = f.write(<span class="hljs-string">&quot;test&quot;</span>)f.closed</code></pre></div><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>打开文件并处理完毕后，需要关闭文件，这里用到close方法。</p><p>f.close() 用来关闭文件并立即释放它使用的所有系统资源。如果没有显式地关闭文件，Python的垃圾回收器最终将销毁该对象并关闭打开的文件，但这个文件可能会保持打开状态一段时间。</p><p>应该要养成使用close()的习惯。使用方法很简单：</p><div class="code-wrapper"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(file) <span class="hljs-comment"># 打开文件</span>f.close() <span class="hljs-comment"># 关闭文件</span></code></pre></div><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>当使用open函数打开文件后，就可以使用该文件对象的各种方法了，read就是其中一种。</p><p>read()会读取一些数据并将其作为字符串（在文本模式下）或字节对象（在二进制模式下）返回。</p><p>read方法有一个参数：</p><div class="code-wrapper"><pre><code class="hljs python">f.read(size) <span class="hljs-comment"># f为文件对象</span></code></pre></div><p>参数size（可选）为数字，表示从已打开文件中读取的字节计数，默认情况下为读取全部。</p><p>假设有一个文件sample1.txt，内容如下：</p><div class="code-wrapper"><pre><code class="hljs text">This is python big data analysis!</code></pre></div><p>现在读取该文件：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span>  <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;sample1.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:content = f.read()    <span class="hljs-built_in">print</span>(content)    f.close()</code></pre></div><h3 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h3><p>readline方法从文件中读取整行，包括换行符’\n’。</p><p>换行符（\n）留在字符串的末尾，如果文件不以换行符结尾，则在文件的最后一行省略，这使得返回值明确无误。</p><p>如果 f.readline() 返回一个空的字符串，则表示已经到达了文件末尾，而空行使用 ‘\n’ 表示，该字符串只包含一个换行符。</p><p>f.readline()有一个参数：</p><div class="code-wrapper"><pre><code class="hljs python">f.readline(size)</code></pre></div><p>参数size表示从文件读取的字节数。</p><p>假设有一个文件sample2.txt，共三行，内容如下：</p><div class="code-wrapper"><pre><code class="hljs text">hello,my friends!This is python big data analysis,let&#x27;s study.</code></pre></div><p>用readline函数读取该文件：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:    <span class="hljs-built_in">print</span>(f.readline())    <span class="hljs-built_in">print</span>(f.readline(<span class="hljs-number">5</span>))    f.close()</code></pre></div><p>readline方法会记住上一个readline函数读取的位置，接着读取下一行。</p><h3 id="readlines"><a href="#readlines" class="headerlink" title="readlines"></a>readlines</h3><p>readlines方法和readline方法长得像，但功能不一样，前面说过readline方法只读取一行，readlines方法则是读取所有行，返回的是所有行组成的列表。</p><p>readlines方法没有参数，使用更加简单。依旧以sample2.txt为例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:    <span class="hljs-built_in">print</span>(f.readlines())    f.close()</code></pre></div><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>write方法顾名思义，就是将字符串写入到文件里。</p><p>它只有一个参数：</p><div class="code-wrapper"><pre><code class="hljs text">f.write([str]) # f为文件对象</code></pre></div><p>参数[str]代表要写入的字符串</p><p>使用起来也很简单，比如将下面字符串（注意里面的转行符’\n’）</p><div class="code-wrapper"><pre><code class="hljs text">&#x27;hello,my friends!\nthis is python big data analysis&#x27;</code></pre></div><p>写入到文件sample3.txt里。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;sample3.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:    f.write(<span class="hljs-string">&#x27;hello,my friends!\nthis is python big data analysis&#x27;</span>)    f.close()</code></pre></div><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os</code></pre></div><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><div class="code-wrapper"><pre><code class="hljs python">os.remove(path)  <span class="hljs-comment"># path是文件的路径，如果这个路径是一个文件夹，则会抛出OSError的错误，这时需用用rmdir()来删除</span>os.rmdir(path)  <span class="hljs-comment"># path是文件夹路径，注意文件夹需要时空的才能被删除</span>os.unlink(<span class="hljs-string">&#x27;F:\新建文本文档.txt&#x27;</span>)  <span class="hljs-comment"># unlink的功能和remove一样是删除一个文件，但是删除一个删除一个正在使用的文件会报错。</span></code></pre></div><h3 id="判断是否存在该文件"><a href="#判断是否存在该文件" class="headerlink" title="判断是否存在该文件"></a>判断是否存在该文件</h3><p>使用<code>os.path.exists</code>判断某个文件是否存在</p><div class="code-wrapper"><pre><code class="hljs python">is_exists = os.path.exists(<span class="hljs-string">&quot;test.png&quot;</span>)<span class="hljs-built_in">print</span>(is_exists)</code></pre></div><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><div class="code-wrapper"><pre><code class="hljs python">os.mkdir(<span class="hljs-string">&#x27;d:\hello&#x27;</span>) <span class="hljs-comment"># 在一级目录中创建</span>os.makedirs(<span class="hljs-string">&#x27;d:\hello\world\123&#x27;</span>) <span class="hljs-comment"># 创建多级目录</span></code></pre></div><h3 id="获取某文件的绝对路径"><a href="#获取某文件的绝对路径" class="headerlink" title="获取某文件的绝对路径"></a>获取某文件的绝对路径</h3><div class="code-wrapper"><pre><code class="hljs python">abs_path = os.path.abspath(<span class="hljs-string">&quot;test.png&quot;</span>) <span class="hljs-comment"># 返回test.png的绝对路径</span>py_abs_path = os.path.abspath(os.path.dirname(__file__)) <span class="hljs-comment"># 返回当前py文件下的绝对路径</span><span class="hljs-built_in">print</span>(abs_path)<span class="hljs-built_in">print</span>(py_abs_path)</code></pre></div><h3 id="检索目录下的文件"><a href="#检索目录下的文件" class="headerlink" title="检索目录下的文件"></a>检索目录下的文件</h3><div class="code-wrapper"><pre><code class="hljs python">path = <span class="hljs-string">&#x27;d:\hello&#x27;</span><span class="hljs-comment"># 遍历指定目录下所有文件和子文件夹文件</span><span class="hljs-keyword">for</span> root,dirs,files <span class="hljs-keyword">in</span> os.walk(path):    <span class="hljs-built_in">print</span>(files)</code></pre></div><ul><li>root：根目录</li><li>dirs：根目录包含的子文件夹</li><li>files：根目录包含的子文件</li></ul><h3 id="改变当前工作目录到指定的路径"><a href="#改变当前工作目录到指定的路径" class="headerlink" title="改变当前工作目录到指定的路径"></a>改变当前工作目录到指定的路径</h3><div class="code-wrapper"><pre><code class="hljs python">os.chdir(path)</code></pre></div><h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutil</code></pre></div><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><div class="code-wrapper"><pre><code class="hljs python">shutil.move(src = <span class="hljs-string">&quot;./test.txt&quot;</span>,dst = <span class="hljs-string">&quot;./test&quot;</span>) <span class="hljs-comment"># src为源文件，dst为要移动过去的目标文件夹</span></code></pre></div><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><div class="code-wrapper"><pre><code class="hljs python">shutil.copy(src=<span class="hljs-string">&quot;./test/test.txt&quot;</span>,dst=<span class="hljs-string">&quot;./&quot;</span>) <span class="hljs-comment"># src为源文件，dst为要复制过去的目标文件夹</span></code></pre></div><h2 id="相对路径解决办法"><a href="#相对路径解决办法" class="headerlink" title="相对路径解决办法"></a>相对路径解决办法</h2><p>python操作文件的时候，相对路径是把<strong>运行的当前的.py文件</strong>作为基准的</p><p>假设当前的目录为：</p><ul><li>Test<ul><li>test.py</li></ul></li><li>image<ul><li>test.png</li></ul></li><li>main.py</li></ul><p>当运行<code>main.py</code>操作<code>test.png</code>这个文件的时候，相对路径则是<code>./image/test.png</code></p><p>但是，当运行<code>test.py</code>操作<code>test.png</code>这个文件的时候，相对路径则是<code>../image/test.png</code></p><p>因为这个，可能在编写代码，进行代码单元测试时可能正常，结果到运行整个项目的时候，就报错了，但是发现错误时，需要将代码里的所有的路径全部改一遍，如果代码量多，则增加工作量，显然不是明智之举。而在开发的时候，由于思维惯性，不可避免会发生这种错误。以下提供解决办法</p><h3 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h3><p>在开发的时候根据启动类，调整开发思维，将所有的相对路径以启动类为基准进行编写</p><p>该方法强烈不推荐，对某个模块进行测试的时候会非常麻烦</p><h3 id="动态获取绝对路径"><a href="#动态获取绝对路径" class="headerlink" title="动态获取绝对路径"></a>动态获取绝对路径</h3><p>思路：</p><ol><li>在父类中获取改py文件的绝对路径</li><li>通过字符串搜索项目所在根目录，返回路径</li><li>将路径定义为类变量（或全局变量），子类应用即可</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> osabs_path = os.path.abspath(os.path.dirname(__file__)) <span class="hljs-comment"># 返回当前py文件下的绝对路径</span>root_path = abs_path[<span class="hljs-number">0</span>:abs_path.find(<span class="hljs-string">&quot;Test&quot;</span>)] <span class="hljs-comment"># 返回根目录</span><span class="hljs-built_in">print</span>(root_path) <span class="hljs-comment"># 子类用self.root_path即可</span></code></pre></div><h3 id="动态切换当前工作目录"><a href="#动态切换当前工作目录" class="headerlink" title="动态切换当前工作目录"></a>动态切换当前工作目录</h3><p>思路</p><ol><li>动态获取当前绝对路径<code>abs_path</code></li><li>每个类调用<code>os.chdir(abs_path)</code>，动态切换当前工作目录到该路径中</li></ol><div class="code-wrapper"><pre><code class="hljs python">abs_path = os.path.abspath(os.path.dirname(__file__))os.chdir(abs_path)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue框架大总结</title>
    <link href="/my_world/content/vue%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <url>/my_world/content/vue%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>官方文档：<a href="https://cn.vuejs.org/guide/introduction.html">简介 | Vue.js (vuejs.org)</a></p></blockquote><p>Vue (发音为 /vjuː/，类似 <strong>view</strong>) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。</p><p>当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。微软的WPF带来了新的技术体验，如Silverlight、音频、视频、3D、动画……，这导致了软件UI层更加细节化、可定制化。同时，在技术层面，WPF也带来了 诸如Binding、Dependency Property、Routed Events、Command、DataTemplate、ControlTemplate等新特性。</p><p>MVVM（Model-View-ViewModel）框架的由来便是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。</p><p><img src="../../image/image-20220911101236425.png" alt=""></p><p><strong>model模型</strong></p><p>指的是后端传过来的数据。</p><p><strong>view视图</strong></p><p>指的是所有看到的页面，可以理解为将数据以某种方式呈现给用户。</p><p><strong>ViewModel</strong></p><p>指的是视图模型，他是连接view和model的桥梁。</p><p>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点</p><p><strong>1. 低耦合</strong>。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p><strong>2. 可重用性</strong>。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p><p><strong>3. 独立开发</strong>。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。</p><p><strong>4. 可测试</strong>。界面素来是比较难于测试的，测试可以针对ViewModel来写。</p><h1 id="Node-js的部署"><a href="#Node-js的部署" class="headerlink" title="Node.js的部署"></a>Node.js的部署</h1><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>用以下命令安装node.js</p><div class="code-wrapper"><pre><code class="hljs shell">sudo apt install nodejs</code></pre></div><p>用以下命令安装npm</p><div class="code-wrapper"><pre><code class="hljs shell">sudo apt install npm</code></pre></div><p>完毕后打开终端，输入<code>node -v</code>和<code>npm -v</code>检查配置是否正常</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><blockquote><p>下载地址：<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p></blockquote><p>进入网址，下载压缩包版本的包</p><p><img src="../../image/image-20220911095250305.png" alt="选择Windows Binary(.zip)"></p><p>下载完成后，解压，注意记住路径，例子为<code>D:\environment\node-v14.9.0-win-x64\</code></p><p><img src="../../image/image-20220911095539051.png" alt="解压完成后大概是这样"></p><p>配置环境变量，将node.js的路径复制进去即可，紧接着打开cmd，输入<code>node -v</code>和<code>npm -v</code>检查配置是否正常，若配置成功输入以上命令没有反应，重启电脑即可</p><p><img src="../../image/image-20220911095905096.png" alt="成功"></p><p>设置<code>node_global</code>和<code>node_cache</code>，在命令行中输入以下两条命令</p><div class="code-wrapper"><pre><code class="hljs shell">npm config set prefix &quot;D:\environment\node-v14.9.0-win-x64\node_global&quot;npm config set cache &quot;D:\environment\node-v14.9.0-win-x64\node_cache&quot;</code></pre></div><p>配置镜像，输入以下命令</p><div class="code-wrapper"><pre><code class="hljs shell">npm config set registry=http://registry.npm.taobao.org</code></pre></div><p>通过<code>npm config list</code>即可检查所有的配置信息</p><h1 id="Vue、Vue-cli的配置"><a href="#Vue、Vue-cli的配置" class="headerlink" title="Vue、Vue-cli的配置"></a>Vue、Vue-cli的配置</h1><p>输入以下命令安装</p><div class="code-wrapper"><pre><code class="hljs shell">npm install vue -gnpm install @vue/cli -g</code></pre></div><p>安装完毕，需要配置global的环境变量，上面我们已经配置好<code>prefix</code>了，根据prefix中的<code>node_global</code>路径配置即可，完成后，所有的环境变量如图</p><p><img src="../../image/image-20220911100652745.png" alt="环境变量"></p><p>打开cmd，输入<code>vue -V</code>检查配置是否正常，若配置成功输入以上命令没有反应，重启电脑即可</p><p><img src="../../image/image-20220911100758408.png" alt="配置成功"></p><p>至此，全部环境部署成功</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的邮件发送指南</title>
    <link href="/my_world/content/python%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%8C%87%E5%8D%97/"/>
    <url>/my_world/content/python%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。</p><p>python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>python3自带，无需安装</p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> smtplib<span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText<span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header</code></pre></div><h1 id="简单发送邮件实例"><a href="#简单发送邮件实例" class="headerlink" title="简单发送邮件实例"></a>简单发送邮件实例</h1><p>目标：发送1封邮件，无附件</p><h2 id="定义发送内容、接受与发送地址"><a href="#定义发送内容、接受与发送地址" class="headerlink" title="定义发送内容、接受与发送地址"></a>定义发送内容、接受与发送地址</h2><p>首先定义内容，分别为：</p><ul><li>邮件服务器地址：<code>smtp.xxx.com</code>，xxx的内容填邮箱的号，例如：<code>163</code>、<code>139</code>等</li><li>发送方邮箱</li><li>发送方密码，强烈推荐授权密码，这个去相应的邮箱地址获取即可</li><li>收件方邮箱</li><li>邮件标题</li><li>邮件内容</li></ul><div class="code-wrapper"><pre><code class="hljs python">server = <span class="hljs-string">&#x27;smtp.163.com&#x27;</span> <span class="hljs-comment"># 发送邮件服务器地址</span>sender = <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span> <span class="hljs-comment"># 发送方账号</span>sender_password = <span class="hljs-string">&#x27;xxxxxx&#x27;</span> <span class="hljs-comment"># 发送方密码（或授权密码）</span>receiver = <span class="hljs-string">&#x27;xxxxx@163.com&#x27;</span> <span class="hljs-comment"># 收件方邮箱</span>title = <span class="hljs-string">&#x27;Python SMTP 测试邮件&#x27;</span> <span class="hljs-comment"># 邮件标题</span>content = <span class="hljs-string">&#x27;Python 测试邮件发送。。。。&#x27;</span> <span class="hljs-comment"># 邮件内容</span></code></pre></div><p>使用<code>MIMEText(_text,_subtype,_charset)</code>方法，三个参数的作用如下：</p><ul><li><code>_text</code>：文本内容</li><li><code>_subtype</code>：设置文本格式，默认为<code>plain</code>，若为<code>html</code>则设置文本格式为html格式</li><li><code>_charset</code>：设置编码，通常为<code>utf-8</code></li></ul><div class="code-wrapper"><pre><code class="hljs python">message = MIMEText(content, <span class="hljs-string">&#x27;plain&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 发送内容 （文本内容，发送格式，编码格式）</span>message[<span class="hljs-string">&#x27;From&#x27;</span>] = sender <span class="hljs-comment"># 发送地址</span>message[<span class="hljs-string">&#x27;To&#x27;</span>] = receiver <span class="hljs-comment"># 接受地址</span>message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(title,<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 邮件标题</span></code></pre></div><h2 id="开始发送"><a href="#开始发送" class="headerlink" title="开始发送"></a>开始发送</h2><p>使用<code>SMTP</code>进行发送，步骤为：</p><ol><li>创建SMTP对象</li><li>连接服务器</li><li>登录邮箱账号</li><li>发送邮件</li><li>关闭smtp</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    smtp = smtplib.SMTP() <span class="hljs-comment"># 创建SMTP对象</span>    smtp.connect(server) <span class="hljs-comment"># 连接服务器</span>    smtp.login(sender, sender_password) <span class="hljs-comment"># 登录邮箱账号</span>    smtp.sendmail(sender, receiver, message.as_string()) <span class="hljs-comment"># 发送账号信息</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;发送成功&#x27;</span>)<span class="hljs-keyword">except</span> smtplib.SMTPException:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;邮件发送失败&#x27;</span>)<span class="hljs-keyword">finally</span>:    smtp.quit()</code></pre></div><h2 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h2><p>点击发送后，查看到发送成功</p><p><img src="../../image/image-20220704105310461.png" alt="发送成功"></p><h1 id="发送多封带有附件的邮件实例"><a href="#发送多封带有附件的邮件实例" class="headerlink" title="发送多封带有附件的邮件实例"></a>发送多封带有附件的邮件实例</h1><p>目标：发送多封邮件，有附件，目标为不同的多个人，邮件格式为html</p><p>引入<code>MIMEMultipart</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> email.mime.multipart <span class="hljs-keyword">import</span> MIMEMultipart</code></pre></div><h2 id="定义发送内容、接受与发送地址-1"><a href="#定义发送内容、接受与发送地址-1" class="headerlink" title="定义发送内容、接受与发送地址"></a>定义发送内容、接受与发送地址</h2><p>首先定义内容，分别为：</p><ul><li>邮件服务器地址：<code>smtp.xxx.com</code>，xxx的内容填邮箱的号，例如：<code>163</code>、<code>139</code>等</li><li>发送方邮箱</li><li>发送方密码，强烈推荐授权密码，这个去相应的邮箱地址获取即可</li><li>收件方邮箱</li><li>邮件标题</li><li>邮件内容，注意用html书写</li></ul><div class="code-wrapper"><pre><code class="hljs python">server = <span class="hljs-string">&#x27;smtp.163.com&#x27;</span> <span class="hljs-comment"># 发送邮件服务器地址</span>sender = <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span> <span class="hljs-comment"># 发送方账号</span>sender_password = <span class="hljs-string">&#x27;xxxxxx&#x27;</span> <span class="hljs-comment"># 发送方密码（或授权密码）</span>receiver = [<span class="hljs-string">&#x27;xxxxx@163.com&#x27;</span>,<span class="hljs-string">&#x27;xxxxx@163.com&#x27;</span>] <span class="hljs-comment"># 收件方邮箱，用列表存储</span>title = <span class="hljs-string">&#x27;Python SMTP 测试邮件&#x27;</span> <span class="hljs-comment"># 邮件标题</span>message = <span class="hljs-string">&quot;&lt;p&gt;Python 邮件发送测试...&lt;/p&gt; &lt;p&gt;&lt;a href=\&quot;http://www.baidu.com\&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;&quot;</span> <span class="hljs-comment"># 邮件内容</span></code></pre></div><p>使用<code>MIMEMultipart()</code>方法，首先添加正文：</p><div class="code-wrapper"><pre><code class="hljs python">message = MIMEMultipart()  <span class="hljs-comment"># 创建一个带附件的实例</span>message[<span class="hljs-string">&#x27;From&#x27;</span>] = sender <span class="hljs-comment"># 发送地址</span>message[<span class="hljs-string">&#x27;To&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(receiver) <span class="hljs-comment"># 接受地址</span>message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(title,<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 邮件标题</span>message.attach(MIMEText(content, <span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 添加邮件正文内容</span></code></pre></div><p>其次添加附件：</p><div class="code-wrapper"><pre><code class="hljs python">appendix = MIMEText(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;12138.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>).read(), <span class="hljs-string">&#x27;base64&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 构造附件，传送当前目录下的12138.txt 文件</span>appendix[<span class="hljs-string">&quot;Content-Type&quot;</span>] = <span class="hljs-string">&#x27;application/octet-stream&#x27;</span> <span class="hljs-comment"># 此处为固定的格式，可以在浏览器中查看到相关信息</span>appendix[<span class="hljs-string">&quot;Content-Disposition&quot;</span>] = <span class="hljs-string">&#x27;attachment; filename=&quot;12138.txt&quot;&#x27;</span> <span class="hljs-comment"># 这里的 filename 命名任意，即在邮件中显示的名称</span>message.attach(appendix) <span class="hljs-comment"># 添加附件</span></code></pre></div><p>当然也可以增加另外一个附件，再次使用上面的方法即可。</p><h2 id="开始发送-1"><a href="#开始发送-1" class="headerlink" title="开始发送"></a>开始发送</h2><p>使用<code>SMTP</code>进行发送，步骤为：</p><ol><li>创建SMTP对象</li><li>连接服务器</li><li>登录邮箱账号</li><li>发送邮件</li><li>关闭smtp</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    smtp = smtplib.SMTP() <span class="hljs-comment"># 创建SMTP对象</span>    smtp.connect(server) <span class="hljs-comment"># 连接服务器</span>    smtp.login(sender, sender_password) <span class="hljs-comment"># 登录邮箱账号</span>    smtp.sendmail(sender, receiver, message.as_string()) <span class="hljs-comment"># 发送账号信息</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;发送成功&#x27;</span>)<span class="hljs-keyword">except</span> smtplib.SMTPException:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;邮件发送失败&#x27;</span>)<span class="hljs-keyword">finally</span>:    smtp.quit()</code></pre></div><h1 id="发送嵌有图片的邮件"><a href="#发送嵌有图片的邮件" class="headerlink" title="发送嵌有图片的邮件"></a>发送嵌有图片的邮件</h1><p>目标：发送多封邮件，有附件，目标为不同的多个人，邮件格式为html并嵌入图片</p><p>引入<code>MIMEImage</code>和<code>MIMEMultipart</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> email.mime.image <span class="hljs-keyword">import</span> MIMEImage<span class="hljs-keyword">from</span> email.mime.multipart <span class="hljs-keyword">import</span> MIMEMultipart</code></pre></div><h2 id="定义发送内容、接受与发送地址-2"><a href="#定义发送内容、接受与发送地址-2" class="headerlink" title="定义发送内容、接受与发送地址"></a>定义发送内容、接受与发送地址</h2><p>首先定义内容，分别为：</p><ul><li>邮件服务器地址：<code>smtp.xxx.com</code>，xxx的内容填邮箱的号，例如：<code>163</code>、<code>139</code>等</li><li>发送方邮箱</li><li>发送方密码，强烈推荐授权密码，这个去相应的邮箱地址获取即可</li><li>收件方邮箱</li><li>邮件标题</li><li>邮件内容，注意用html书写，<code>img</code>标签中的<code>src</code>必须为<code>cid:xxx</code></li></ul><div class="code-wrapper"><pre><code class="hljs python">server = <span class="hljs-string">&#x27;smtp.163.com&#x27;</span> <span class="hljs-comment"># 发送邮件服务器地址</span>sender = <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span> <span class="hljs-comment"># 发送方账号</span>sender_password = <span class="hljs-string">&#x27;xxxxxx&#x27;</span> <span class="hljs-comment"># 发送方密码（或授权密码）</span>receiver = [<span class="hljs-string">&#x27;xxxxx@163.com&#x27;</span>,<span class="hljs-string">&#x27;xxxxx@163.com&#x27;</span>] <span class="hljs-comment"># 收件方邮箱，用列表存储</span>title = <span class="hljs-string">&#x27;Python SMTP 测试邮件&#x27;</span> <span class="hljs-comment"># 邮件标题</span>message = <span class="hljs-string">&quot;&lt;p&gt;Python 邮件发送测试...&lt;/p&gt; &lt;p&gt;&lt;a href=\&quot;http://www.baidu.com\&quot;&gt;这是一个链接&lt;/a&gt;&lt;img src=\&quot;cid:image1\&quot; alt=\&quot;image1\&quot;&gt;&lt;/p&gt;&quot;</span> <span class="hljs-comment"># 邮件内容</span></code></pre></div><p>使用<code>MIMEMultipart()</code>方法，首先添加正文：</p><div class="code-wrapper"><pre><code class="hljs python">message = MIMEMultipart()  <span class="hljs-comment"># 创建一个带附件的实例</span>message[<span class="hljs-string">&#x27;From&#x27;</span>] = sender <span class="hljs-comment"># 发送地址</span>message[<span class="hljs-string">&#x27;To&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(receiver) <span class="hljs-comment"># 接受地址</span>message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(title,<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 邮件标题</span>message.attach(MIMEText(content, <span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 添加邮件正文内容</span></code></pre></div><p>其次添加附件：</p><div class="code-wrapper"><pre><code class="hljs python">appendix = MIMEText(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;12138.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>).read(), <span class="hljs-string">&#x27;base64&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 构造附件，传送当前目录下的12138.txt 文件</span>appendix[<span class="hljs-string">&quot;Content-Type&quot;</span>] = <span class="hljs-string">&#x27;application/octet-stream&#x27;</span> <span class="hljs-comment"># 此处为固定的格式，可以在浏览器中查看到相关信息</span>appendix[<span class="hljs-string">&quot;Content-Disposition&quot;</span>] = <span class="hljs-string">&#x27;attachment; filename=&quot;12138.txt&quot;&#x27;</span> <span class="hljs-comment"># 这里的 filename 命名任意，即在邮件中显示的名称</span>message.attach(appendix) <span class="hljs-comment"># 添加附件</span></code></pre></div><p>使用<code>MIMEImage</code>为上面的正文设置id</p><div class="code-wrapper"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;img.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)msgImage = MIMEImage(fp.read()) <span class="hljs-comment"># 添加图片附件</span>fp.close()msgImage.add_header(<span class="hljs-string">&#x27;Content-ID&#x27;</span>, <span class="hljs-string">&#x27;image1&#x27;</span>) <span class="hljs-comment"># 这个id用于上面html获取图片</span>message.attach(msgImage)</code></pre></div><h2 id="开始发送-2"><a href="#开始发送-2" class="headerlink" title="开始发送"></a>开始发送</h2><p>使用<code>SMTP</code>进行发送，步骤为：</p><ol><li>创建SMTP对象</li><li>连接服务器</li><li>登录邮箱账号</li><li>发送邮件</li><li>关闭smtp</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    smtp = smtplib.SMTP() <span class="hljs-comment"># 创建SMTP对象</span>    smtp.connect(server) <span class="hljs-comment"># 连接服务器</span>    smtp.login(sender, sender_password) <span class="hljs-comment"># 登录邮箱账号</span>    smtp.sendmail(sender, receiver, message.as_string()) <span class="hljs-comment"># 发送账号信息</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;发送成功&#x27;</span>)<span class="hljs-keyword">except</span> smtplib.SMTPException:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;邮件发送失败&#x27;</span>)<span class="hljs-keyword">finally</span>:    smtp.quit()</code></pre></div><h1 id="工具类整合"><a href="#工具类整合" class="headerlink" title="工具类整合"></a>工具类整合</h1><p>直接复制即可</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-  </span><span class="hljs-keyword">import</span> smtplib  <span class="hljs-keyword">from</span> email.mime.image <span class="hljs-keyword">import</span> MIMEImage  <span class="hljs-keyword">from</span> email.mime.multipart <span class="hljs-keyword">import</span> MIMEMultipart  <span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText  <span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header  <span class="hljs-keyword">import</span> os      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailSenderUitls</span>:</span>      <span class="hljs-string">&quot;&quot;&quot;邮件工具类&quot;&quot;&quot;</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spilt_path_filename</span>(<span class="hljs-params">self,bar_type,filepath</span>):</span>          <span class="hljs-string">&quot;&quot;&quot;  </span><span class="hljs-string">        通过文件路径切割文件路径与文件名称  </span><span class="hljs-string">        在调用该类方法时，建议用它切割文件路径  </span><span class="hljs-string">  </span><span class="hljs-string">        :param bar_type: 斜杆的类型，与列表中所有的文件路径对应。eg.D:/bar.txt，那么该参数为&#x27;/&#x27;；D:\bar.txt，那么该参数为&#x27;\&#x27;  </span><span class="hljs-string">        :param filepath: 文件路径，!!!必须是列表!!!，斜杆类型必须一致，eg.[&quot;D:/bar.txt&quot;,&quot;D:/bar/bar.txt&quot;]  </span><span class="hljs-string">        :return: 是否发送成功，成功为1，不成功为0  </span><span class="hljs-string">        &quot;&quot;&quot;</span>        filepath_list = []          filename_list = []          <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> filepath:              split_path = os.path.split(path)              file_path = split_path[<span class="hljs-number">0</span>] + bar_type              file_name = split_path[<span class="hljs-number">1</span>]              filepath_list.append(file_path)              filename_list.append(file_name)          <span class="hljs-keyword">return</span> [filepath_list,filename_list]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendEmail_Text</span>(<span class="hljs-params">self,sender,sender_password,receiver,title,content,smtp_server</span>):</span>          <span class="hljs-string">&quot;&quot;&quot;  </span><span class="hljs-string">        发送纯文本邮件  </span><span class="hljs-string">  </span><span class="hljs-string">        :param sender: 发送人邮件  </span><span class="hljs-string">        :param sender_password: 发送人邮件的密码或授权码  </span><span class="hljs-string">        :param receiver: 接收人邮件，可以为多个，用列表填充  </span><span class="hljs-string">        :param title: 邮件标题  </span><span class="hljs-string">        :param content: 邮件正文内容  </span><span class="hljs-string">        :param smtp_server: 邮件发送的服务器  </span><span class="hljs-string">        :return: 是否发送成功，成功为1，不成功为0  </span><span class="hljs-string">        &quot;&quot;&quot;</span>        message = MIMEText(content, <span class="hljs-string">&#x27;plain&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 发送内容 （文本内容，发送格式，编码格式）  </span>        message[<span class="hljs-string">&#x27;From&#x27;</span>] = sender  <span class="hljs-comment"># 发送地址  </span>        message[<span class="hljs-string">&#x27;To&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(receiver)  <span class="hljs-comment"># 接受地址  </span>        message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(title, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 邮件标题  </span>          <span class="hljs-keyword">try</span>:              smtp = smtplib.SMTP()  <span class="hljs-comment"># 创建SMTP对象  </span>            smtp.connect(smtp_server)  <span class="hljs-comment"># 连接服务器  </span>            smtp.login(sender, sender_password)  <span class="hljs-comment"># 登录邮箱账号  </span>            smtp.sendmail(sender, receiver, message.as_string())  <span class="hljs-comment"># 发送账号信息  </span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>          <span class="hljs-keyword">except</span> smtplib.SMTPException <span class="hljs-keyword">as</span> e:              <span class="hljs-built_in">print</span>(e)              <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>          <span class="hljs-keyword">finally</span>:              smtp.quit()          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendEmail_Html</span>(<span class="hljs-params">self,sender,sender_password,receiver,title,content_html,smtp_server</span>):</span>          <span class="hljs-string">&quot;&quot;&quot;  </span><span class="hljs-string">        发送HTML格式邮件，强烈推荐用这个发送纯文本邮件  </span><span class="hljs-string">  </span><span class="hljs-string">        :param sender: 发送人邮件  </span><span class="hljs-string">        :param sender_password: 发送人邮件的密码或授权码  </span><span class="hljs-string">        :param receiver: 接收人邮件，可以为多个，用列表填充  </span><span class="hljs-string">        :param title: 邮件标题  </span><span class="hljs-string">        :param content_html: 邮件正文内容，HTML格式，这会在邮件上显示格式  </span><span class="hljs-string">        :param smtp_server: 邮件发送的服务器  </span><span class="hljs-string">        :return: 是否发送成功，成功为1，不成功为0  </span><span class="hljs-string">        &quot;&quot;&quot;</span>        message = MIMEText(content_html, <span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 发送内容 （文本内容，发送格式，编码格式）  </span>        message[<span class="hljs-string">&#x27;From&#x27;</span>] = sender  <span class="hljs-comment"># 发送地址  </span>        message[<span class="hljs-string">&#x27;To&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(receiver)  <span class="hljs-comment"># 接受地址  </span>        message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(title, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 邮件标题  </span>          <span class="hljs-keyword">try</span>:              smtp = smtplib.SMTP()  <span class="hljs-comment"># 创建SMTP对象  </span>            smtp.connect(smtp_server)  <span class="hljs-comment"># 连接服务器  </span>            smtp.login(sender, sender_password)  <span class="hljs-comment"># 登录邮箱账号  </span>            smtp.sendmail(sender, receiver, message.as_string())  <span class="hljs-comment"># 发送账号信息  </span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>          <span class="hljs-keyword">except</span> smtplib.SMTPException <span class="hljs-keyword">as</span> e:              <span class="hljs-built_in">print</span>(e)              <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>          <span class="hljs-keyword">finally</span>:              smtp.quit()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendEmail_file</span>(<span class="hljs-params">self,sender,sender_password,receiver,title,content_html,file_path,file_name,smtp_server</span>):</span>          <span class="hljs-string">&quot;&quot;&quot;  </span><span class="hljs-string">        发送HTML格式邮件，并带上附件  </span><span class="hljs-string">  </span><span class="hljs-string">        :param sender: 发送人邮件  </span><span class="hljs-string">        :param sender_password: 发送人邮件的密码或授权码  </span><span class="hljs-string">        :param receiver: 接收人邮件，可以为多个，用列表填充  </span><span class="hljs-string">        :param title: 邮件标题  </span><span class="hljs-string">        :param content_html: 邮件正文内容，HTML格式，这会在邮件上显示格式  </span><span class="hljs-string">        :param file_path: 附件路径，只是路径不包括附件名，如src/main/，!!!必须用列表存!!!，eg.[&#x27;src/main/&#x27;,&#x27;src/jar/&#x27;]  </span><span class="hljs-string">        :param file_name: 附件名称，!!!必须用列表存!!!，每个附件名称的下标与路径列表对应，eg.[&#x27;1.txt&#x27;,&#x27;2.jar&#x27;]，与附件路径例子组合成src/main/1.txt；src/jar/2.jar  </span><span class="hljs-string">        :param smtp_server: 邮件发送的服务器  </span><span class="hljs-string">        :return: 是否发送成功，成功为1，不成功为0  </span><span class="hljs-string">        &quot;&quot;&quot;</span>        message = MIMEMultipart()  <span class="hljs-comment"># 创建一个带附件的实例  </span>        message[<span class="hljs-string">&#x27;From&#x27;</span>] = sender  <span class="hljs-comment"># 发送地址  </span>        message[<span class="hljs-string">&#x27;To&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(receiver)  <span class="hljs-comment"># 接受地址  </span>        message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(title, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 邮件标题  </span>        message.attach(MIMEText(content_html, <span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>))  <span class="hljs-comment"># 添加邮件正文内容  </span>          i = <span class="hljs-number">0</span>          <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-built_in">len</span>(file_path)):              <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path[i]+file_name[i], <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:                  appendix = MIMEText(file.read(), <span class="hljs-string">&#x27;base64&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 构造附件，传送文件  </span>                appendix[<span class="hljs-string">&quot;Content-Type&quot;</span>] = <span class="hljs-string">&#x27;application/octet-stream&#x27;</span>  <span class="hljs-comment"># 此处为固定的格式，可以在浏览器中查看到相关信息  </span>                appendix[<span class="hljs-string">&quot;Content-Disposition&quot;</span>] = <span class="hljs-string">f&#x27;attachment; filename=&quot;<span class="hljs-subst">&#123;file_name[i]&#125;</span>&quot;&#x27;</span>  <span class="hljs-comment"># 这里的 filename 命名任意，即在邮件中显示的名称  </span>                message.attach(appendix)  <span class="hljs-comment"># 添加附件  </span>                file.close()              i = i+<span class="hljs-number">1</span>            <span class="hljs-keyword">try</span>:              smtp = smtplib.SMTP()  <span class="hljs-comment"># 创建SMTP对象  </span>            smtp.connect(smtp_server)  <span class="hljs-comment"># 连接服务器  </span>            smtp.login(sender, sender_password)  <span class="hljs-comment"># 登录邮箱账号  </span>            smtp.sendmail(sender, receiver, message.as_string())  <span class="hljs-comment"># 发送账号信息  </span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>          <span class="hljs-keyword">except</span> smtplib.SMTPException <span class="hljs-keyword">as</span> e:              <span class="hljs-built_in">print</span>(e)              <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>          <span class="hljs-keyword">finally</span>:              smtp.quit()          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendEmail_image</span>(<span class="hljs-params">self,sender,sender_password,receiver,title,content_html,file_path,file_name,image_path,image_name,smtp_server</span>):</span>          <span class="hljs-string">&quot;&quot;&quot;  </span><span class="hljs-string">        发送HTML格式邮件，内嵌图片，并带上附件。  </span><span class="hljs-string">  </span><span class="hljs-string">        :param sender: 发送人邮件  </span><span class="hljs-string">        :param sender_password: 发送人邮件的密码或授权码  </span><span class="hljs-string">        :param receiver: 接收人邮件，可以为多个，用列表填充  </span><span class="hljs-string">        :param title: 邮件标题  </span><span class="hljs-string">        :param content_html: 邮件正文内容，HTML格式，这会在邮件上显示格式，注意img标准中src格式为cid:xxx，xxx与形参image_name相同  </span><span class="hljs-string">        :param file_path: 附件路径，只是路径不包括附件名，如src/main/，!!!必须用列表存!!!，eg.[&#x27;src/main/&#x27;,&#x27;src/jar/&#x27;]  </span><span class="hljs-string">        :param file_name: 附件名称，!!!必须用列表存!!!，每个附件名称的下标与路径列表对应，eg.[&#x27;1.txt&#x27;,&#x27;2.jar&#x27;]，与附件路径例子组合成src/main/1.txt；src/jar/2.jar  </span><span class="hljs-string">        :param image_path: 图片路径，只是路径不包括附件名，如src/main/，!!!必须用列表存!!!，eg.[&#x27;src/main/&#x27;,&#x27;src/jar/&#x27;]  </span><span class="hljs-string">        :param image_name: 图片名称，!!!必须用列表存!!!，每个附件名称的下标与路径列表对应，eg.[&#x27;1.png&#x27;,&#x27;2.jpg&#x27;]，与附件路径例子组合成src/main/1.png；src/jar/2.jpg  </span><span class="hljs-string">        :param smtp_server: 邮件发送的服务器  </span><span class="hljs-string">        :return: 是否发送成功，成功为1，不成功为0  </span><span class="hljs-string">        &quot;&quot;&quot;</span>        message = MIMEMultipart()  <span class="hljs-comment"># 创建一个带附件的实例  </span>        message[<span class="hljs-string">&#x27;From&#x27;</span>] = sender  <span class="hljs-comment"># 发送地址  </span>        message[<span class="hljs-string">&#x27;To&#x27;</span>] = <span class="hljs-string">&#x27;,&#x27;</span>.join(receiver)  <span class="hljs-comment"># 接受地址  </span>        message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(title, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 邮件标题  </span>        message.attach(MIMEText(content_html, <span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>))  <span class="hljs-comment"># 添加邮件正文内容  </span>          i = <span class="hljs-number">0</span>          <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-built_in">len</span>(file_path)):              <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path[i]+file_name[i], <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:                  appendix = MIMEText(file.read(), <span class="hljs-string">&#x27;base64&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 构造附件，传送文件  </span>                appendix[<span class="hljs-string">&quot;Content-Type&quot;</span>] = <span class="hljs-string">&#x27;application/octet-stream&#x27;</span>  <span class="hljs-comment"># 此处为固定的格式，可以在浏览器中查看到相关信息  </span>                appendix[<span class="hljs-string">&quot;Content-Disposition&quot;</span>] = <span class="hljs-string">f&#x27;attachment; filename=&quot;<span class="hljs-subst">&#123;file_name[i]&#125;</span>&quot;&#x27;</span>  <span class="hljs-comment"># 这里的 filename 命名任意，即在邮件中显示的名称  </span>                message.attach(appendix)  <span class="hljs-comment"># 添加附件  </span>                file.close()              i = i+<span class="hljs-number">1</span>            i = <span class="hljs-number">0</span>          <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-built_in">len</span>(image_path)):              <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(image_path[i]+image_name[i], <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:                  msgImage = MIMEImage(file.read())  <span class="hljs-comment"># 添加图片附件  </span>                msgImage.add_header(<span class="hljs-string">&#x27;Content-ID&#x27;</span>, image_name[i])  <span class="hljs-comment"># 这个id用于上面html获取图片  </span>                message.attach(msgImage)                  file.close()              i = i+<span class="hljs-number">1</span>            <span class="hljs-keyword">try</span>:              smtp = smtplib.SMTP()  <span class="hljs-comment"># 创建SMTP对象  </span>            smtp.connect(smtp_server)  <span class="hljs-comment"># 连接服务器  </span>            smtp.login(sender, sender_password)  <span class="hljs-comment"># 登录邮箱账号  </span>            smtp.sendmail(sender, receiver, message.as_string())  <span class="hljs-comment"># 发送账号信息  </span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>          <span class="hljs-keyword">except</span> smtplib.SMTPException <span class="hljs-keyword">as</span> e:              <span class="hljs-built_in">print</span>(e)              <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>          <span class="hljs-keyword">finally</span>:              smtp.quit()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python基础</tag>
      
      <tag>SMTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda的使用指南</title>
    <link href="/my_world/content/conda%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/my_world/content/conda%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Conda是适用于任何语言的软件包、依赖项和环境管理系统—包括Python，R，Ruby，Lua，Scala，Java，JavaScript，C / C ++，FORTRAN等。</p><p>Conda是在Windows、macOS和Linux上运行的开源软件包管理系统和环境管理系统。Conda可以快速安装、运行和更新软件包及其依赖项。Conda可以轻松地在本地计算机上的环境中创建，保存，加载和切换。它是为Python程序创建的，但可以打包和分发适用于任何语言的软件。</p><p>Conda作为软件包管理器，可以帮助您查找和安装软件包。如果您需要一个能够使用不同版本Python的软件包，则无需切换到其他环境管理器，因为conda也是环境管理器。仅需几个命令，您就可以设置一个完全独立的环境来运行不同版本的Python，同时继续在正常环境中运行喜欢的Python版本。</p><p>在默认配置下，conda可以安装和管理来自repo.anaconda.com仓库的7,500多个软件包，该仓库由Anaconda生成，审查和维护。</p><p>Conda也可以与Travis CI和AppVeyor等持续集成系统结合使用，以提供对代码的频繁，自动化测试。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p>Anaconda地址：</p><ol><li>官网：<a href="https://www.anaconda.com/">Anaconda | The World’s Most Popular Data Science Platform</a></li><li>清华大学开源软件镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li></ol><p>安装教程：<a href="https://blog.csdn.net/zlc2351951436/article/details/123823988">Anaconda安装教程傻瓜教程_干饭人小周26的博客-CSDN博客_anaconda安装</a></p><p>关于环境变量，实际上只需要三条，在系统变量中的path添加如下三条：</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\Anaconda3<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\Anaconda3\Scripts<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\Anaconda3\Library\bin</code></pre></div><p>笔者的配置，配置完重启即可：</p><p><img src="../../image/image-20220630145638416.png" alt="环境变量配置"></p><p>重启完成，打开cmd，输入<code>python -V</code>和<code>conda -V</code>查看是否配置成功</p><p><img src="../../image/image-20220630150018335.png" alt="笔者的配置"></p><h1 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><div class="code-wrapper"><pre><code class="hljs shell">conda init</code></pre></div><h2 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h2><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置清华镜像</span>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/<span class="hljs-meta">#</span><span class="bash">设置bioconda</span>conda config --add channels biocondaconda config --add channels conda-forge<span class="hljs-meta">#</span><span class="bash">设置搜索时显示通道地址</span>conda config --set show_channel_urls yes</code></pre></div><h2 id="更新conda"><a href="#更新conda" class="headerlink" title="更新conda"></a>更新conda</h2><div class="code-wrapper"><pre><code class="hljs shell">conda update -n base conda #update最新版本的conda</code></pre></div><h2 id="显示所有的虚拟环境"><a href="#显示所有的虚拟环境" class="headerlink" title="显示所有的虚拟环境"></a>显示所有的虚拟环境</h2><div class="code-wrapper"><pre><code class="hljs shell">conda env listconda info --envs</code></pre></div><h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><div class="code-wrapper"><pre><code class="hljs shell">conda create -n xxxx python=xxxx #创建pythonxxx的名为xxxx虚拟环境conda create -n test python=3.8 #创建python3.8的名为test虚拟环境</code></pre></div><h2 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h2><div class="code-wrapper"><pre><code class="hljs shell">conda activate env_nameconda activate test</code></pre></div><h2 id="关闭环境"><a href="#关闭环境" class="headerlink" title="关闭环境"></a>关闭环境</h2><div class="code-wrapper"><pre><code class="hljs shell">conda deactivate</code></pre></div><h2 id="卸载环境"><a href="#卸载环境" class="headerlink" title="卸载环境"></a>卸载环境</h2><div class="code-wrapper"><pre><code class="hljs shell">conda remove --name env_name --allconda remove --name test --all</code></pre></div><h2 id="导出环境"><a href="#导出环境" class="headerlink" title="导出环境"></a>导出环境</h2><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">获得环境中的所有配置</span>conda env export --name myenv &gt; myenv.yml<span class="hljs-meta">#</span><span class="bash">重新还原环境</span>conda env create -f myenv.yml</code></pre></div><h1 id="Anaconda的使用"><a href="#Anaconda的使用" class="headerlink" title="Anaconda的使用"></a>Anaconda的使用</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>打开开始菜单，点击Anaconda Navigator进入Anaconda。</p><p>点击Environments，等待可操作后，点击Create创建虚拟环境。</p><p><img src="../../image/image-20220630113618738.png" alt="创建虚拟环境"></p><p>创建的虚拟环境的路径在<code>$$\Anaconda3\envs\</code>下，在其他IDE中导入即可</p><p>也可以导出Anaconda中的环境，在其他Anaconda环境中使用。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>difflib使用指南</title>
    <link href="/my_world/content/difflib%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/my_world/content/difflib%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此模块提供用于比较序列的类和函数。 例如，它可被用于比较文件，并可产生多种格式的不同文件差异信息，包括 HTML 和上下文以及统一的 diff 数据。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>无需安装，python3自带</p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> difflib</code></pre></div><h1 id="对比字符串"><a href="#对比字符串" class="headerlink" title="对比字符串"></a>对比字符串</h1><p>该逻辑使用的是<code>Differ()</code>，这个类的作用是比较由文本行组成的序列，并产生可供人阅读的差异或增量信息。输出的符号如下：</p><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>‘-’</td><td>包含在第一个系列行中，但不包含第二个</td></tr><tr><td>‘+’</td><td>包含在第二个系列行中，但不包含第一个</td></tr><tr><td>’ ’</td><td>两个系列行一致</td></tr><tr><td>‘?’</td><td>存在增量差异</td></tr><tr><td>‘^’</td><td>存在差异字符</td></tr></tbody></table></div><p>思路：</p><ol><li>初始化<code>difflib.Differ()</code></li><li>将文章用<code>splitlines</code>分开</li><li>调用<code>compare()</code>比较，将比较结果转换成<code>list</code></li><li>使用<code>&quot;&quot;.join</code>结果，输出</li></ol><p>需要比较的字段：</p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-string">&quot;&quot;&quot;egg\ndiff\njsjs&quot;&quot;&quot;</span>b = <span class="hljs-string">&quot;&quot;&quot;eggs\ndif\njson&quot;&quot;&quot;</span></code></pre></div><p> 逻辑：</p><div class="code-wrapper"><pre><code class="hljs python">d = difflib.Differ() <span class="hljs-comment"># 初始化</span>a = a.splitlines(keepends=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 换行符分开a</span>b = b.splitlines(keepends=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 换行符分开b</span>compare = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">list</span>(d.compare(a, b))) <span class="hljs-comment"># 比较，并转换成List，然后变成字符串</span><span class="hljs-built_in">print</span>(compare) <span class="hljs-comment"># 输出</span></code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs shell">- egg+ eggs?    +- diff?    -+ dif- jsjs+ json</code></pre></div><h1 id="生成可视化HTML"><a href="#生成可视化HTML" class="headerlink" title="生成可视化HTML"></a>生成可视化HTML</h1><p>该逻辑使用的是<code>HtmlDiff()</code>，并使用<code>make_file</code>生成文件，形参作用如下：</p><ul><li><code>fromlines</code>：比较的源文本</li><li><code>tolines</code>：比较的对象</li><li><code>fromdesc</code>：在生成的HTML中源文本的标题</li><li><code>todesc</code>：在生成的HTML中对象的标题</li><li><code>charset</code>：生成HTML的编码格式</li></ul><p>思路：</p><ol><li>初始化<code>difflib.HtmlDiff()</code></li><li>将文章用<code>splitlines</code>分开</li><li>调用<code>make_file()</code>比较</li><li>将结果输出到文件中</li></ol><p>文章：</p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-string">&quot;&quot;&quot;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Integer</span><span class="hljs-string">eu lacus accumsan arcu fermentum euismod. Donec pulvinar porttitor</span><span class="hljs-string">tellus. Aliquam venenatis. Donec facilisis pharetra tortor.  In nec</span><span class="hljs-string">mauris eget magna consequat convallis. Nam sed sem vitae odio</span><span class="hljs-string">pellentesque interdum. Sed consequat viverra nisl. Suspendisse arcu</span><span class="hljs-string">metus, blandit quis, rhoncus ac, pharetra eget, velit. Mauris</span><span class="hljs-string">urna. Morbi nonummy molestie orci. Praesent nisi elit, fringilla ac,</span><span class="hljs-string">suscipit non, tristique vel, mauris. Curabitur vel lorem id nisl porta</span><span class="hljs-string">adipiscing. Suspendisse eu lectus. In nunc. Duis vulputate tristique</span><span class="hljs-string">enim. Donec quis lectus a justo imperdiet tempus.&quot;&quot;&quot;</span>b = <span class="hljs-string">&quot;&quot;&quot;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Integer</span><span class="hljs-string">eu lacus accumsan arcu fermentum euismod. Donec pulvinar, porttitor</span><span class="hljs-string">tellus. Aliquam venenatis. Donec facilisis pharetra tortor. In nec</span><span class="hljs-string">mauris eget magna consequat convallis. Nam cras vitae mi vitae odio</span><span class="hljs-string">pellentesque interdum. Sed consequat viverra nisl. Suspendisse arcu</span><span class="hljs-string">metus, blandit quis, rhoncus ac, pharetra eget, velit. Mauris</span><span class="hljs-string">urna. Morbi nonummy molestie orci. Praesent nisi elit, fringilla ac,</span><span class="hljs-string">suscipit non, tristique vel, mauris. Curabitur vel lorem id nisl porta</span><span class="hljs-string">adipiscing. Duis vulputate tristique enim. Donec quis lectus a justo</span><span class="hljs-string">imperdiet tempus. Suspendisse eu lectus. In nunc. &quot;&quot;&quot;</span></code></pre></div><p>逻辑：</p><div class="code-wrapper"><pre><code class="hljs python">d = difflib.HtmlDiff() <span class="hljs-comment"># 初始化</span>a = a.splitlines(keepends=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 换行符分开a</span>b = b.splitlines(keepends=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 换行符分开b</span>out_file = <span class="hljs-string">&quot;./test.html&quot;</span> <span class="hljs-comment"># 定义输出文件的路径</span>result = d.make_file(fromlines=a, tolines=b, fromdesc=<span class="hljs-string">&quot;a&quot;</span>, todesc=<span class="hljs-string">&quot;b&quot;</span>, charset=<span class="hljs-string">&quot;UTF-8&quot;</span>) <span class="hljs-comment"># 生成文件</span><span class="hljs-comment"># 写入文件</span><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(out_file, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:    file.writelines(result)</code></pre></div><p>输出：</p><p><img src="../../image/image-20220628105132995.png" alt="test.html"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python时间获取</title>
    <link href="/my_world/content/python%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96/"/>
    <url>/my_world/content/python%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工具类封装"><a href="#工具类封装" class="headerlink" title="工具类封装"></a>工具类封装</h1><p>可以将time，datetime直接封装成类，直接使用即可</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> datetime<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataTimeUtils</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;时间工具类&quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recordTime</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        记录当前时间</span><span class="hljs-string"></span><span class="hljs-string">        :return: 时间浮点</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> time.time()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">caculate</span>(<span class="hljs-params">self,start,end,round_index = <span class="hljs-number">3</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        计算时间差</span><span class="hljs-string"></span><span class="hljs-string">        :param start:开始时间</span><span class="hljs-string">        :param end:结束时间</span><span class="hljs-string">        :param round_index:结果位数，默认保留3位</span><span class="hljs-string">        :return:时间差</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">round</span>(end - start,round_index)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNow</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前时间</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前时间</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> datetime.datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNowForFile</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前时间(文件路径友好值)</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前时间(文件路径友好值)</span><span class="hljs-string">        &quot;&quot;&quot;</span>        data = datetime.datetime.now().strftime(<span class="hljs-string">&quot;_%m%d_&quot;</span>)        time = datetime.datetime.now().strftime(<span class="hljs-string">&quot;%H%M&quot;</span>)        now = data + time        <span class="hljs-keyword">return</span> now    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHour</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前小时</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前小时</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> datetime.datetime.now().hour    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMinute</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前分钟</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前分钟</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> datetime.datetime.now().minute    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSecond</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前秒</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前秒</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> datetime.datetime.now().second    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getDateToday</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前日期</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前日期</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> datetime.date.today()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTodayYear</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前年</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前年</span><span class="hljs-string">        &quot;&quot;&quot;</span>        today = self.getDateToday()        <span class="hljs-keyword">return</span> today.year    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTodayMonth</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前月</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前月</span><span class="hljs-string">        &quot;&quot;&quot;</span>        today = self.getDateToday()        <span class="hljs-keyword">return</span> today.month    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTodayDay</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取当前日</span><span class="hljs-string"></span><span class="hljs-string">        :return:当前日</span><span class="hljs-string">        &quot;&quot;&quot;</span>        today = self.getDateToday()        <span class="hljs-keyword">return</span> today.day</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA的GUI编程</title>
    <link href="/my_world/content/JAVA%E7%9A%84GUI%E7%BC%96%E7%A8%8B/"/>
    <url>/my_world/content/JAVA%E7%9A%84GUI%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>GUI代表graphics user interface 一般翻译为图形用户接口或图形用户界面，这里讲的是桌面级应用编程。精挑细选之后，最终决定使用Swing来作为GUI编程的主力。</p><h1 id="Swing简介"><a href="#Swing简介" class="headerlink" title="Swing简介"></a>Swing简介</h1><p>Swing 是一个用于 Java GUI 编程（图形界面设计）的工具包（类库）；换句话说，Java 可以用来开发带界面的 PC 软件，使用到的工具就是 Swing。</p><p>Swing 使用纯粹的 Java 代码来模拟各种控件（使用 Java 自带的作图函数绘制出各种控件），没有使用本地操作系统的内在方法，所以 Swing 是跨平台的。也正是因为 Swing 的这种特性，人们通常把 Swing 控件称为轻量级控件。</p><p>这套 Java Swing 教程从实用的角度出发，通过大量实例全面介绍 Java Swing 中的各种控件、布局、事件、窗口等。</p><h2 id="Swing-和-AWT"><a href="#Swing-和-AWT" class="headerlink" title="Swing 和 AWT"></a>Swing 和 AWT</h2><p>AWT（Abstract Window Toolkit，抽象窗口工具）是一套早期的 Java GUI 开发工具，Swing 也是在 AWT 的基础上发展起来的。</p><p>AWT 的初衷是用来开发小型的图形界面程序，提供的功能较少，诸如剪切板、打印支持、键盘导航、弹出式菜单、滚动窗格等很多重要的功能在 AWT 中都不具备；此外，AWT 发生错误的几率也很高。</p><p>Java 官方看到了 AWT 的不足，就开始着手开发新的 GUI 类库，以继续占领 Java GUI 开发的市场，这就是后来的 Swing。</p><p>Swing 弥补了 AWT 的不足，并对 AWT 进行了扩充，几乎支持了所有的常用控件和功能，它们不但更加漂亮，而且更加易用，真正实现了“一次编译，到处运行”的承诺。</p><h1 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h1><p>Swing为java自带库，不需要额外再引入依赖。</p><h2 id="Intellij-IDEA-JFormDesigner-插件"><a href="#Intellij-IDEA-JFormDesigner-插件" class="headerlink" title="Intellij IDEA JFormDesigner 插件"></a>Intellij IDEA JFormDesigner 插件</h2><p>玩过QT的都知道QT Designer有多方便，如果没玩过QT，也不知道QT Designer，可以说QT Designer 加快了编写QT的效率，组件拖动可以很快速搭建出一个窗口来。这里用Intellij IDEA安装Swing Designer 插件，用于设计swing窗口。</p><p>按路径打开<code>Settings -&gt; plugins</code>，在Marketplace搜索<code>JFormDesigner</code>，下载安装即可</p><p><img src="../../image/image-20220614100218812.png" alt="JFormDesigner插件"></p><p>右键项目，以次找到<code>New -&gt; Swing UI Designer -&gt; GUI Form</code>，即可打开Swing Dersigner设计界面</p><p><img src="../../image/image-20220614145108824.png" alt="JFormDesigner设计界面"></p><blockquote><p>JFormDesigner破解教程：<a href="https://www.cnblogs.com/MuQuanyu-YuGod/p/15000694.html">JavaGUI 03 JFormDesigner 破解 - MuQuanyu的博客 - 博客园 (cnblogs.com)</a></p><p>JFormDesigner使用教程：<a href="https://zhuanlan.zhihu.com/p/465066522">Java GUI 桌面应用开发 - 知乎 (zhihu.com)</a></p></blockquote><h1 id="第一个GUI程序"><a href="#第一个GUI程序" class="headerlink" title="第一个GUI程序"></a>第一个GUI程序</h1><p>新建项目，并在pom.xml中引入</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.jgoodies<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jgoodies-forms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>右键，新建<code>JFormDesigner Form</code></p><p><img src="../../image/image-20220614155412279.png" alt="">    </p><p>输入Frame的名字，点击ok</p><p><img src="../../image/image-20220614155509771.png" alt=""></p><p>分别拖动<code>JTextArea、JLabel</code>，将窗口设计成这样：</p><p><img src="../../image/image-20220614155858107.png" alt=""></p><p>点击this，设置Properties和Size Policy如下：</p><p><img src="../../image/image-20220614161131970.png" alt=""></p><p>右键Ok按钮，点击Add Events Handler新建ActionListener</p><p><img src="../../image/image-20220614160326079.png" alt=""></p><p>ActionListener的方法命名默认即可</p><p><img src="../../image/image-20220614160427833.png" alt=""></p><p>点击ok后，进入到代码页面，在<code>// TODO add your code here</code>下添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs java">JOptionPane.showMessageDialog(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;helloworld&quot;</span>); <span class="hljs-comment">// 弹框</span></code></pre></div><p>随后在构造方法中加上代码：</p><div class="code-wrapper"><pre><code class="hljs java">setVisible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// Windows 风格</span>String lookAndFeel = <span class="hljs-string">&quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;</span>;<span class="hljs-keyword">try</span> &#123;    UIManager.setLookAndFeel(lookAndFeel);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);&#125;</code></pre></div><p>并写main方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">new</span> FirstFrame();&#125;</code></pre></div><p>启动项目，可看到运行成功</p><p><img src="../../image/image-20220614161545682.png" alt="第一个swing程序"></p><p>点击ok，出现弹窗，点击确定退出</p><p><img src="../../image/image-20220614161614388.png" alt="弹窗消息"></p><p>swing同样支持第三方主题，这里推荐FlatLaf，首先在依赖引入FlatLaf</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.formdev<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flatlaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>FlatLaf支持4种主题,包括<code>Flat Light</code>,<code>Flat Dark</code>,<code>Flat IntelliJ</code>,<code>Flat Darcula</code>，这里使用作为例子<code>Flat IntelliJ</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    UIManager.setLookAndFeel(<span class="hljs-keyword">new</span> FlatIntelliJLaf());&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);&#125;</code></pre></div><p>点击启动，可发现主题已经更换成功</p><p><img src="../../image/image-20220614164923384.png" alt="主界面"></p><p><img src="../../image/image-20220614164939761.png" alt="弹窗"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swing</tag>
      
      <tag>GUI编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android搭建-从入门到入土（二）</title>
    <link href="/my_world/content/Android%E6%90%AD%E5%BB%BA-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/my_world/content/Android%E6%90%AD%E5%BB%BA-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算器制作"><a href="#计算器制作" class="headerlink" title="计算器制作"></a>计算器制作</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本节涉及到的知识面为：</p><ul><li>默认Activity配置</li><li>Activity获取layout中组件</li><li>Activity中组件的监听器</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>新建项目，删除包下的<code>java</code>文件和<code>res/layout</code>下的xml文件，删除后文件结构大概长这样</p><p><img src="../../image/image-20220608101304335.png" alt="文件结构"></p><h2 id="新建Activity"><a href="#新建Activity" class="headerlink" title="新建Activity"></a>新建Activity</h2><p>在前一章节中，新建项目是选择Basic Activity。这样IDE会默认生成一些类和layout文件，但是我们设计自己的Activity就需要选择empty Activity，这样创建的页面会非常清洁。</p><p>在layout中右键按照如下图新建一个empty Activity</p><p><img src="../../image/image-20220608101545571.png" alt="新建empty Activity"></p><h2 id="编辑UI"><a href="#编辑UI" class="headerlink" title="编辑UI"></a>编辑UI</h2><p>首先认识IDE的编辑界面的功能</p><p><img src="../../image/image-20220608105050022.png" alt="xml编辑功能展示"></p><p>打开<code>activity_main.xml</code>，在Design界面中首先加入LinearLayout，然后分别拖动Button、TextView、EditText、Space，放到合适的位置后，在Code页面中更改它们的text属性，更改后代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;409dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;729dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;1dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteX</span>=<span class="hljs-string">&quot;1dp&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;75dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;56dp&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">&quot;textPersonName&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;输入式子&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:ems</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/editTextTextPersonName2&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;75dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;计算结果显示&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView3&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;67dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;点我计算&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button3&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></code></pre></div><p>注意，之前删除MainActivity后，系统会找不到默认的Activity，这个时候就需要在<code>AndroidManifest.xml</code>中增加默认Activity，就是在activity中添加过滤器，其中<code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</code>为启动时的首个页面，代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">          <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.test.helloworld&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><span class="hljs-tag">            <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/app_name&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:roundIcon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/Theme.Helloworld&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><span class="hljs-tag">                <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span></code></pre></div><p>点击运行后，在虚拟机中可看到结果</p><p><img src="../../image/image-20220608112726711.png" alt="运行结果"></p><h2 id="运行逻辑编辑"><a href="#运行逻辑编辑" class="headerlink" title="运行逻辑编辑"></a>运行逻辑编辑</h2><p>可看到在layout中的组件都有它们相应的id，比如说我们创建的button，可看到它的id为<code>button3</code>，这个可以在<code>android:id=&quot;@+id/button3&quot;</code>中找到</p><p>回到MainActivity.java中，寻找该id并返回Button类，并且为该类添加监听器。我们可以利用这个方法来进行组件之间的联动，比如说可以将标签变为按钮被点击了</p><div class="code-wrapper"><pre><code class="hljs java"> Button caculate = <span class="hljs-keyword">this</span>.findViewById(R.id.button3); <span class="hljs-comment">// 获取layout中的按钮</span>TextView textView3 = <span class="hljs-keyword">this</span>.findViewById(R.id.textView3); <span class="hljs-comment">// 获取layout中的标签</span><span class="hljs-comment">/* 设置按钮监听器，点击按钮后让标签变成按钮被点击了 */</span>caculate.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;        textView3.setText(<span class="hljs-string">&quot;按钮被点击了&quot;</span>);    &#125;&#125;);</code></pre></div><p>运行后，当点击按钮后，会发现标签文字更改了</p><p><img src="../../image/image-20220608151606684.png" alt="按钮文字更改了"></p><p>以此类推，我们可以获取输入框中用户输入的字，然后对字进行处理并输出结果。总代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 计算式子并返回结果，该方法只支持减法，并且只支持减一次(类似于10-5这种)</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> caculated 算式</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 结果</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">caculate</span><span class="hljs-params">(String caculated)</span></span>&#123;        String[] minus = caculated.split(<span class="hljs-string">&quot;-&quot;</span>);        <span class="hljs-keyword">int</span> caculate = Integer.valueOf(minus[<span class="hljs-number">0</span>]) - Integer.valueOf(minus[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">return</span> String.valueOf(caculate);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main); <span class="hljs-comment">// 获取layout</span>        Button caculate_confirm = <span class="hljs-keyword">this</span>.findViewById(R.id.button3); <span class="hljs-comment">// 获取layout中的按钮</span>        EditText editText = <span class="hljs-keyword">this</span>.findViewById(R.id.editText3); <span class="hljs-comment">// 获取layout中的编辑框</span>        TextView textView = <span class="hljs-keyword">this</span>.findViewById(R.id.textView3); <span class="hljs-comment">// 获取layout中的标签</span>        <span class="hljs-comment">/* 设置按钮监听器，点击按钮后让标签变成结果 */</span>        caculate_confirm.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                String equation = editText.getText().toString();                textView.setText(caculate(equation));            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>运行，在输入框中输入<code>2000-1000</code>，可看到结果显示在标签上</p><p><img src="../../image/image-20220608153859829.png" alt="结果运算"></p><h1 id="电话制作"><a href="#电话制作" class="headerlink" title="电话制作"></a>电话制作</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>本节涉及到的知识面为：</p><ul><li>Intent类</li><li>安卓权限</li></ul><h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><p>新建项目，这一次选择的是empty Activity</p><p><img src="../../image/image-20220609095717114.png" alt="选择空Activity"></p><p>这样的操作新建项目后，项目是十分清洁的，就不用删除多余的Activity和配置默认Activity了（有特殊需求的除外）</p><h2 id="编辑UI-1"><a href="#编辑UI-1" class="headerlink" title="编辑UI"></a>编辑UI</h2><p>打开<code>activity_main.xml</code>，在Design界面中首先加入LinearLayout，然后分别拖动Phone、Space、Button，放到合适的位置后，在Code页面中更改它们的text属性，更改后代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;409dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;729dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;1dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteX</span>=<span class="hljs-string">&quot;1dp&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">&quot;phone&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:ems</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/editTextPhone&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;346dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;点我打电话&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></code></pre></div><p>运行后效果如下：</p><p><img src="../../image/image-20220609100649854.png" alt=""></p><h2 id="运行逻辑编辑-1"><a href="#运行逻辑编辑-1" class="headerlink" title="运行逻辑编辑"></a>运行逻辑编辑</h2><p>通过id查找组件后，对按钮填加监听器，获取电话框的内容。</p><p>对于打电话的内容，借助于 Intent 可以轻松实现拨打电话的应用程序。只需声明一个拨号的 Intent 对象，并使用 startActivity() 方法启动即可。</p><p>创建 Intent 对象的代码为 Intent intent = new Intent(action,uri)，其中 URI 是要拨叫的号码数据，通过 Uri.parse() 方法把“tel:1234”格式的字符串转换为 URI。</p><p>而 Action 有两种使用方式：</p><ul><li>Intent.ACTION_CALL。是直接进行呼叫的方式，这种方式需要应用程序具有 android.permission.CALL_PHONE 权限。</li><li>Intent.ACTION_DIAL。不是不直接进行呼叫，而是启动 <a href="http://c.biancheng.net/android/">Android</a> 系统的拨号应用程序，然后由用户进行拨号。这种方式不需要任何权限的设置。</li></ul><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs java">EditText phone = <span class="hljs-keyword">this</span>.findViewById(R.id.editTextPhone); <span class="hljs-comment">// 电话</span>Button call = <span class="hljs-keyword">this</span>.findViewById(R.id.button); <span class="hljs-comment">// 点我打电话按钮</span>call.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;        String phoneText = phone.getText().toString(); <span class="hljs-comment">// 获取电话</span>        Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_CALL, Uri.parse(<span class="hljs-string">&quot;tel:&quot;</span>+phoneText)); <span class="hljs-comment">// 设置打电话意图</span>        startActivity(intent); <span class="hljs-comment">// 开启意图</span>    &#125;&#125;);</code></pre></div><p>运行后，点击按钮后，发现运行出错，而报错的内容如下：</p><div class="code-wrapper"><pre><code class="hljs shell">java.lang.SecurityException: Permission Denial: starting Intent &#123; act=android.intent.action.CALL dat=tel:xxxxxxxxxxx cmp=com.android.server.telecom/.components.UserCallActivity &#125; from ProcessRecord&#123;97b69f4 19614:com.test.phonecall/u0a432&#125; (pid=19614, uid=10432) requires android.permission.CALL_PHONE</code></pre></div><p>大致翻译可知道，该操作需要权限，权限为：<code>android.permission.CALL_PHONE</code></p><p>打开<code>AndroidManifest.xml</code>，在<code>application</code>标签前添加：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CALL_PHONE&quot;</span> /&gt;</span></code></pre></div><p>在Android 6.0 以下的手机，无论是什么权限都可以直接通过，直接使用权限。但是在Android 6.0 以上会<strong>被系统手机拒绝</strong>，所以<strong>需要代码中动态申请权限</strong>，并且让用户接受了才能使用，增加了安全性。申请权限的代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 检查权限，若不存在则申请权限</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request_check_permissions</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(<span class="hljs-keyword">this</span>, Manifest.permission.CALL_PHONE)!= PackageManager.PERMISSION_GRANTED) &#123;        String[] permissions = &#123;Manifest.permission.CALL_PHONE&#125;; <span class="hljs-comment">// 权限列表</span>        <span class="hljs-comment">// 最后的请求码是对应回调方法的请求码</span>        ActivityCompat.requestPermissions(<span class="hljs-keyword">this</span>,permissions,<span class="hljs-number">1001</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;你已经有权限了，可以直接拨打电话&quot;</span>, Toast.LENGTH_LONG).show(); <span class="hljs-comment">// 跳出弹窗提示</span>    &#125;&#125;</code></pre></div><p>MainActivity.java的代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查权限，若不存在则申请权限</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request_check_permissions</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(<span class="hljs-keyword">this</span>, Manifest.permission.CALL_PHONE)!= PackageManager.PERMISSION_GRANTED) &#123;            String[] permissions = &#123;Manifest.permission.CALL_PHONE&#125;; <span class="hljs-comment">// 权限列表</span>            <span class="hljs-comment">// 最后的请求码是对应回调方法的请求码</span>            ActivityCompat.requestPermissions(<span class="hljs-keyword">this</span>,permissions,<span class="hljs-number">1001</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;你已经有权限了，可以直接拨打电话&quot;</span>, Toast.LENGTH_LONG).show(); <span class="hljs-comment">// 跳出弹窗提示</span>        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        EditText phone = <span class="hljs-keyword">this</span>.findViewById(R.id.editTextPhone); <span class="hljs-comment">// 电话</span>        Button call = <span class="hljs-keyword">this</span>.findViewById(R.id.button); <span class="hljs-comment">// 点我打电话按钮</span>        call.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                String phoneText = phone.getText().toString(); <span class="hljs-comment">// 获取电话</span>                request_check_permissions();                Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_CALL, Uri.parse(<span class="hljs-string">&quot;tel:&quot;</span>+phoneText)); <span class="hljs-comment">// 设置打电话意图</span>                startActivity(intent); <span class="hljs-comment">// 开启意图</span>            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>运行，输入号码后，系统会申请权限，点击允许</p><p><img src="../../image/image-20220609110538429.png" alt="权限申请"></p><p>再次打开app，输入号码，点击按钮，发现弹框出现，并且能成功打电话了</p><p><img src="../../image/image-20220609110648625.png" alt="弹框，并直接打电话"></p><p>注意，<code>Intent.ACTION_CALL</code>改为<code>Intent.ACTION_DIAL</code>后，无需申请权限，到这里，电话程序编写完毕。</p><h1 id="聊天软件制作"><a href="#聊天软件制作" class="headerlink" title="聊天软件制作"></a>聊天软件制作</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>本节涉及到的知识面为：</p><ul><li>多界面的切换与逻辑</li><li>jar包的导入</li><li>安卓中的websocket通信</li></ul><h2 id="准备-2"><a href="#准备-2" class="headerlink" title="准备"></a>准备</h2><p>新建项目，选择empty Activity</p><h2 id="编辑UI-2"><a href="#编辑UI-2" class="headerlink" title="编辑UI"></a>编辑UI</h2><p>打开<code>activity_main.xml</code>，在Design界面中首先加入LinearLayout，然后分别拖动EditText、Multiline Text、Space、Button，放到合适的位置后，在Code页面中更改它们的text属性，更改后代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;409dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;729dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;1dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteX</span>=<span class="hljs-string">&quot;1dp&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;145dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">&quot;textPersonName&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:ems</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edit&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;192dp&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">&quot;textMultiLine&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;start|top&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:ems</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/multiply_line&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;27dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;发送&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/send&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;24dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;服务器设置&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button2&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></code></pre></div><p>运行后效果如下：</p><p><img src="../../image/image-20220609144927605.png" alt="主页面"></p><p>EditText作为消息发送的文字书写处，Multiline Text作为接收文字的显示处（本篇暂时不写该逻辑）。</p><h3 id="二级页面制作与跳转"><a href="#二级页面制作与跳转" class="headerlink" title="二级页面制作与跳转"></a>二级页面制作与跳转</h3><p>在layout中右键新建一个empty Acitivity，命名为ServerSettings，打开<code>activity_server_settings.xml</code>在Design界面中首先加入LinearLayout，然后分别拖动EditText、TextView、Space、Button，放到合适的位置后，在Code页面中更改它们的text属性，更改后代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.ServerSettings&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;409dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;729dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;1dp&quot;</span> <span class="hljs-attr">tools:layout_editor_absoluteX</span>=<span class="hljs-string">&quot;1dp&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;191dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;服务器id:端口&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;19dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;64dp&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">&quot;textPersonName&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:ems</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/editTextTextPersonName&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;85dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;连接&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;23dp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;返回聊天页面&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button3&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></code></pre></div><p>进入到mainActivity.java中，使用intent类为”服务器设置”按钮设置页面跳转：</p><div class="code-wrapper"><pre><code class="hljs java">Button serverSettingView = <span class="hljs-keyword">this</span>.findViewById(R.id.button2);serverSettingView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(); <span class="hljs-comment">// 设置意图</span>        intent.setClass(MainActivity.<span class="hljs-keyword">this</span>,ServerSettings.class); <span class="hljs-comment">// 设置跳转的页面</span>        startActivity(intent); <span class="hljs-comment">// 开始运行</span>    &#125;&#125;);</code></pre></div><p>进入到ServerSettings.java中，使用intent类为”返回聊天页面”按钮设置页面跳转：</p><div class="code-wrapper"><pre><code class="hljs java">Button MainActivityView = <span class="hljs-keyword">this</span>.findViewById(R.id.button2);MainActivityView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(); <span class="hljs-comment">// 设置意图</span>        intent.setClass(ServerSettings.<span class="hljs-keyword">this</span>,MainActivity.class); <span class="hljs-comment">// 设置跳转的页面</span>        startActivity(intent); <span class="hljs-comment">// 开始运行</span>    &#125;&#125;);</code></pre></div><p>这样跳转就准备完成了</p><p>这里有个坑需要注意，在进行intent跳转后，第二个Acitivity会先调用onCreate方法，<strong>也就是重新创建了一个Acitvity</strong>，而不是onstart()。</p><h3 id="AndroidManifest-xml多个页面的配置"><a href="#AndroidManifest-xml多个页面的配置" class="headerlink" title="AndroidManifest.xml多个页面的配置"></a>AndroidManifest.xml多个页面的配置</h3><p>前面知道，<code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</code>为启动app后的首个页面，对于其他页面，使用<code>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</code>即可</p><p>AndroidManifest.xml的代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">          <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.test.talk&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><span class="hljs-tag">            <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/app_name&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:roundIcon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/Theme.Talk&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 主页面 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><span class="hljs-tag">                <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 服务器设置页面 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><span class="hljs-tag">                <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ServerSettings&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span></code></pre></div><p>在所有的配置完成之后，运行，点击按钮跳转成功。这是二级页面的页面效果：</p><p><img src="../../image/image-20220609152911831.png" alt="二级页面"></p><h2 id="运行逻辑编写"><a href="#运行逻辑编写" class="headerlink" title="运行逻辑编写"></a>运行逻辑编写</h2><h3 id="新建websocket服务器"><a href="#新建websocket服务器" class="headerlink" title="新建websocket服务器"></a>新建websocket服务器</h3><p>新建一个Maven项目，在依赖中添加：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.java-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Java-WebSocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>新建server.java，并继承<code>WebSocketServer</code>，代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * websocket服务端</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">server</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSocketServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> InetSocketAddress(port));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(WebSocket webSocket, ClientHandshake clientHandshake)</span> </span>&#123;        System.out.println(webSocket.getLocalSocketAddress() + <span class="hljs-string">&quot;进来了&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">(WebSocket webSocket, <span class="hljs-keyword">int</span> i, String s, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(WebSocket webSocket, String s)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;收到消息:&quot;</span>+s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(WebSocket webSocket, Exception e)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        server server = <span class="hljs-keyword">new</span> server(<span class="hljs-number">8111</span>); <span class="hljs-comment">// 设置端口号</span>        server.start(); <span class="hljs-comment">// 开启服务器</span>        System.out.println(<span class="hljs-string">&quot;服务器端启动，端口号为: &quot;</span>+server.getPort());        <span class="hljs-comment">// 等待输入</span>        BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            String in = bufferedReader.readLine(); <span class="hljs-comment">// 不断读取输入的行数据</span>            server.broadcast(in); <span class="hljs-comment">// 服务端接受输入的行数据</span>            <span class="hljs-comment">/* 如果输入exit命令，则关闭服务器 */</span>            <span class="hljs-keyword">if</span>(in.equals(<span class="hljs-string">&quot;exit&quot;</span>))&#123;                server.stop(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 停止server</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="导入java-websocket包"><a href="#导入java-websocket包" class="headerlink" title="导入java_websocket包"></a>导入java_websocket包</h3><p>在本地Maven仓库中，按照路径<code>\repository\org\java-websocket\Java-WebSocket\</code>找到自己服务端的java-webSocket版本，这里用的是1.5.3，打开<code>1.5.3</code>文件夹，将<code>Java-WebSocket-1.5.3.jar</code>复制进安卓项目的<code>libs</code>文件夹中，如图：</p><p><img src="../../image/image-20220609154100262.png" alt="libs中的jar"></p><p>整个项目用的是本地的Maven仓库，若是用在线的仓库，请把该仓库的jar下载下来。若是不知道本地仓库的地址，选择IDEA菜单中的<code>File -&gt; Settings</code>，搜索框中输入Maven，点击Maven即可查看IDEA设置的本地仓库地址</p><p><img src="../../image/image-20220609154627484.png" alt="本地仓库地址"></p><p>打开app下的build.gradle，在dependencies中添加<code>implementation files(&quot;libs/Java-WebSocket-1.5.3.jar&quot;)</code>，具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs json">dependencies &#123;    implementation &#x27;androidx.appcompat:appcompat:<span class="hljs-number">1.2</span><span class="hljs-number">.0</span>&#x27;    implementation &#x27;com.google.android.material:material:<span class="hljs-number">1.3</span><span class="hljs-number">.0</span>&#x27;    implementation &#x27;androidx.constraintlayout:constraintlayout:<span class="hljs-number">2.0</span><span class="hljs-number">.4</span>&#x27;    testImplementation &#x27;junit:junit:<span class="hljs-number">4.</span>+&#x27;    androidTestImplementation &#x27;androidx.test.ext:junit:<span class="hljs-number">1.1</span><span class="hljs-number">.2</span>&#x27;    androidTestImplementation &#x27;androidx.test.espresso:espresso-core:<span class="hljs-number">3.3</span><span class="hljs-number">.0</span>&#x27;    implementation files(<span class="hljs-string">&quot;libs/Java-WebSocket-1.5.3.jar&quot;</span>)&#125;</code></pre></div><p>这就和Maven的引入依赖是一样的。项目中有两个build.gradle，注意一定要在app文件夹下的build.gradle引入依赖才有效</p><p>这里有个坑，打开server端项目中的pom.xml，按ctrl+鼠标左键点击java-websocket，其中有一段是这样的</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.json<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;org.json.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre></div><p>也就是说，maven导入依赖的时候，<strong>顺便也把其他的主要依赖也导进去了</strong>，但是在gradle不行，所以我们也要添加其他依赖，看代码，可知道需要引入的依赖为<code>org.slf4j</code>，照葫芦画瓢，在本地仓库中找到<code>org.slf4j</code>的jar包即可。</p><p>所以最终的依赖为：</p><div class="code-wrapper"><pre><code class="hljs json">implementation files(<span class="hljs-string">&quot;libs/Java-WebSocket-1.5.3.jar&quot;</span>)implementation files(<span class="hljs-string">&quot;libs/slf4j-api-1.7.5.jar&quot;</span>)</code></pre></div><p>依赖配置完毕后，使用gradle -&gt; build刷新项目即可</p><h3 id="安卓项目新建WebSocket客户端"><a href="#安卓项目新建WebSocket客户端" class="headerlink" title="安卓项目新建WebSocket客户端"></a>安卓项目新建WebSocket客户端</h3><p>websocket中通常涉及多线程，所以需要设置同步，并加上线程锁</p><p>通常WebSocket客户端只需要创建一个对象即可，使用单例模式创建对象</p><p>在安卓项目中新建AppWebSocketClient.java，并且继承WebSocketClient，具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 客户端</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppWebSocketClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSocketClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AppWebSocketClient client;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">AppWebSocketClient</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> URISyntaxException </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> URI(url));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 单例模式创建对象，加上线程锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url websocket地址</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> AppWebSocketClient对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> URISyntaxException url无法连接错误</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AppWebSocketClient <span class="hljs-title">getInstance</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> URISyntaxException </span>&#123;        <span class="hljs-keyword">if</span>(client == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span> (AppWebSocketClient.class) &#123;                client = <span class="hljs-keyword">new</span> AppWebSocketClient(url);            &#125;        &#125;        <span class="hljs-keyword">return</span> client;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(ServerHandshake serverHandshake)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String s)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;服务端发送了一个请求:&quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, String s, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;关闭客户端&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Exception e)</span> </span>&#123;    &#125;&#125;</code></pre></div><h3 id="WebSocket客户端与Activity整合"><a href="#WebSocket客户端与Activity整合" class="headerlink" title="WebSocket客户端与Activity整合"></a>WebSocket客户端与Activity整合</h3><p>可以知道，WebSocket单独创建项目的时候，连接是没有什么问题的。但是与安卓整合的时候，需要额外做一些东西</p><p>首先建立组件交互，打开<code>ServerSettings.java</code>，引入上面创建的<code>AppWebSocketClient.java</code>，按钮创建监听器并书写逻辑。ServerSettings.java的具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 服务器设置页面</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerSettings</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> AppWebSocketClient client;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 页面跳转</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pageTransfer</span><span class="hljs-params">()</span></span>&#123;        Button MainActivityView = <span class="hljs-keyword">this</span>.findViewById(R.id.button3);        MainActivityView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                Intent intent = <span class="hljs-keyword">new</span> Intent(); <span class="hljs-comment">// 添加意图</span>                intent.setClass(ServerSettings.<span class="hljs-keyword">this</span>,MainActivity.class); <span class="hljs-comment">// 设置跳转页面的类</span>                startActivity(intent); <span class="hljs-comment">// 开始跳转</span>            &#125;        &#125;);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连接socket服务器</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectSocket</span><span class="hljs-params">()</span></span>&#123;        Button Connect = <span class="hljs-keyword">this</span>.findViewById(R.id.button);        EditText IPandPort = <span class="hljs-keyword">this</span>.findViewById(R.id.editTextTextPersonName);        Connect.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                String IPandPortString = IPandPort.getText().toString();                <span class="hljs-keyword">if</span>(client == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">try</span> &#123;                        client = AppWebSocketClient.getInstance(<span class="hljs-string">&quot;ws://&quot;</span> + IPandPortString + <span class="hljs-string">&quot;//&quot;</span>);                        client.connectBlocking(); <span class="hljs-comment">// 连接服务器直到连接成功</span>                        Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;连接服务器成功&quot;</span>, Toast.LENGTH_LONG).show(); <span class="hljs-comment">// 跳出弹窗提示</span>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);                    &#125;                &#125;<span class="hljs-keyword">else</span>&#123;                    Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;已经连接，无需再次连接&quot;</span>, Toast.LENGTH_LONG).show(); <span class="hljs-comment">// 跳出弹窗提示</span>                &#125;            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_server_settings);        pageTransfer();        connectSocket();    &#125;&#125;</code></pre></div><p>注意，<strong>安卓开WebSocket要开权限</strong>，具体权限为<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code>，该权限为请求网络权限，在<code>AndroidManifest.xml</code>中添加即可，该权限不需要动态请求权限。</p><h3 id="多页面共用AppWebSocketClient类"><a href="#多页面共用AppWebSocketClient类" class="headerlink" title="多页面共用AppWebSocketClient类"></a>多页面共用AppWebSocketClient类</h3><p>我们虽然在<code>ServerSettings.java</code>中开启了SocketClient，但是该页面为连接部分，实际上需要在<code>MainActivity.java</code>中发送消息</p><p>这里的思路如下：</p><ul><li>ServerSettings.java中的AppWebSocketClient定义为类变量，在连接时新建对象并赋值即可</li><li>MainActivity.java中获取ServerSettings.java中的AppWebSocketClient类变量，直接使用即可</li></ul><p>这里有几点说明：</p><ol><li>由于AppWebSocketClient中为单例模式，并且创建了线程锁。所以在Activity中创建AppWebSocketClient对象时只能创建一次，所以在连接时只能连接一次，再次连接会报错。（这一点在代码上已经增加了容错，思路就是通过检测类变量是否为空对象，为空就连接，不为空就提示）</li><li>MainActivity中调用ServerSettings的AppWebSocketClient类变量时，要在<code>onStart</code>中调用。这是由Activity的生命周期决定的。</li></ol><p>MainActivity的具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 主页面</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 页面跳转</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pageTransfer</span><span class="hljs-params">()</span></span>&#123;        Button serverSettingView = <span class="hljs-keyword">this</span>.findViewById(R.id.button2);        serverSettingView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                Intent intent = <span class="hljs-keyword">new</span> Intent();                intent.setClass(MainActivity.<span class="hljs-keyword">this</span>,ServerSettings.class);                startActivity(intent);            &#125;        &#125;);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送消息</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sockectSendMessage</span><span class="hljs-params">()</span> </span>&#123;        AppWebSocketClient client = ServerSettings.client; <span class="hljs-comment">// 获取ServerSettings页面中连接的client</span>        EditText messageView = <span class="hljs-keyword">this</span>.findViewById(R.id.edit);        Button send = <span class="hljs-keyword">this</span>.findViewById(R.id.send);        send.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                String message = messageView.getText().toString();                <span class="hljs-keyword">if</span>(client == <span class="hljs-keyword">null</span>)&#123;                    Toast.makeText(getApplicationContext(),<span class="hljs-string">&quot;还未连接服务器，请重新连接服务器&quot;</span>,Toast.LENGTH_LONG).show(); <span class="hljs-comment">// 提示未连接</span>                &#125;<span class="hljs-keyword">else</span>&#123;                    client.send(message);                &#125;            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        pageTransfer();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onStart();        sockectSendMessage();    &#125;&#125;</code></pre></div><p>这里还有一种办法，就是用<code>intent.putExtra()</code>这个方法将第一个页面的参数传进去，在第二个页面中使用<code>getIntent()</code>获取意图，并使用<code>intent.getxxxExtra()</code>将参数拿过来即可，xxx代表着数据类型，比如说在<code>putExtra</code>中传入的数据类型为String，则就是调用getStringExtra，其他数据类型以此类推。</p><p>使用该方法传对象的时候，该对象需要序列化，即在对象中<code>implements Serializable</code>，并在其他页面中调用<code>getSerializableExtra</code>获取对象。</p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>用真机，注意一定要是真机，与电脑连接同一个WIFI，并开启USB调试后连接电脑，待连接完毕后，启动安卓项目，让app安装到真机上。</p><p>启动server.java，放在后台，不要关闭服务端</p><p><img src="../../image/image-20220610113356308.png" alt="服务端启动"></p><p>在电脑中的cmd输入ipconfig，查看电脑ip，这里为<code>192.168.3.117</code>，在安卓中的服务器设置页面中输入ip与服务端的端口，为：<code>192.168.3.117:8111</code>，输入完毕后点击连接，连接成功后弹出提示。</p><p><img src="../../image\365241a2b714bd523f37f7ffd6047c5.jpg" alt="连接成功"></p><p>可以看到服务端也有提示</p><p><img src="../../image/image-20220610113821201.png" alt="服务端提示"></p><p>在主页面输入123456，点击发送</p><p><img src="../../image/a8229dfa0fe4deebbae3219483734ef.jpg" alt="输入消息"></p><p>可看到服务端有消息收到</p><p><img src="../../image/image-20220610114055060.png" alt="收到客户端的消息"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android搭建--从入门到入土（一）</title>
    <link href="/my_world/content/Android%E6%90%AD%E5%BB%BA-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/my_world/content/Android%E6%90%AD%E5%BB%BA-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>安卓（Android）是一种基于Linux内核（不包含GNU的自由及开放源代码的操作系统。主要使用于移动设备，如智能手机和平板电脑，由美国Google领导及开发。Android操作系统最初由安迪·鲁宾开发，主要支持手机。2005年8月由Google收购注资。2007年11月，Google与84家硬件制造商、软件开发商及电信营运商组建开放手机联盟共同研发改良Android系统。随后Google以Apache开源许可证的授权方式，发布了Android的源代码。第一部Android智能手机发布于2008年10月。Android逐渐扩展到平板电脑及其他领域上，如电视、数码相机、游戏机、智能手表等。2011年第一季度，Android在全球的市场份额首次超过塞班系统，跃居全球第一。 2013年的第四季度，Android平台手机的全球市场份额已经达到78.1%。2013年09月24日谷歌开发的操作系统Android在迎来了5岁生日，全世界采用这款系统的设备数量已经达到10亿台。</p><p><strong>Android 开发优势</strong></p><ul><li>开放源代码</li><li>众多开发者及强大的社区</li><li>不断增长的市场</li><li>国际化的 App 集成</li><li>低廉的开发成本</li><li>更高的成功几率</li><li>丰富的开发环境</li></ul><h1 id="Android开发环境搭建"><a href="#Android开发环境搭建" class="headerlink" title="Android开发环境搭建"></a>Android开发环境搭建</h1><h2 id="JAVA环境搭建"><a href="#JAVA环境搭建" class="headerlink" title="JAVA环境搭建"></a>JAVA环境搭建</h2><p>目前使用稳定的jdk11，搭建教程如下：</p><blockquote><p><a href="https://www.runoob.com/java/java-environment-setup.html">Java 开发环境配置 | 菜鸟教程 (runoob.com)</a></p></blockquote><p>jdk各大版本的下载地址：</p><blockquote><p><a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a></p></blockquote><h2 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h2><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>目前受欢迎的开发Android的IDE有如下：</p><ul><li>Android Studio</li><li>Eclipse（附带Android插件）</li><li>Intellij Idea</li></ul><h3 id="IDEA搭建Android环境"><a href="#IDEA搭建Android环境" class="headerlink" title="IDEA搭建Android环境"></a>IDEA搭建Android环境</h3><h1 id="第一个安卓程序"><a href="#第一个安卓程序" class="headerlink" title="第一个安卓程序"></a>第一个安卓程序</h1><p>首先在idea中新建一个安卓程序</p><p>点击new，在Generators中选择Android，并选择Basic Activity</p><p><img src="../../image/image-20220531105621296.png" alt=""></p><p>输入相关信息后，点击create，注意<strong>代码保存的路径中不能有中文</strong></p><p><img src="../../image/image-20220531105819653.png" alt=""></p><p>选择AVD Manager，下载一个虚拟机，这里选择Pixel 2，并且API选择为30</p><p><img src="../../image/image-20220531110302380.png" alt="选择安卓虚拟机"></p><p><img src="../../image/image-20220531110322010.png" alt="选择API"></p><p>启动虚拟机（点击绿色播放ICON）</p><p><img src="../../image/image-20220531110400954.png" alt=""></p><p>运行项目，等待build完成后即可在虚拟机中看到我们的第一个安卓项目，注意API要求的java版本，这里要求的是java11，如果低于该版本则报错，当然也可以改成jdk1.8</p><p><img src="../../image/image-20220531110619723.png" alt=""></p><p><img src="../../image/image-20220531110810011.png" alt="报错"></p><h1 id="项目目录详解"><a href="#项目目录详解" class="headerlink" title="项目目录详解"></a>项目目录详解</h1><blockquote><p>源自<a href="http://c.biancheng.net/view/2968.html">Android使用XML文件定义用户界面 (biancheng.net)</a></p></blockquote><p>新建项目后，目录如下：</p><p><img src="../../image/5-1Z401113Z5Y7.jpg" alt="项目目录"></p><p>下面对 Android 目录进行简单介绍：</p><ul><li>以<code>.</code>开头的目录是 IDE 生成的辅助目录，无须用户干预。</li><li>HelloAndroid 文件夹是模块目录，编程工作主要集中在这个目录中，相当于使用 Eclipse 构建的工程文件夹，包含 build、src、res 等文件夹。</li><li>res 目录为 Android 工程中所使用的资源目录，用户 UI 所涉及的资源基本都放置在该目录下。res 目录下的每一项资源文件都会由 AAPT（Android Asset Packaging Tool）为其生成一个对应的 public static final 类型的 ID 号，放置到 build 目录下的 R.java 文件中，Android 系统根据该 ID 号来访问对应资源。</li><li>build 目录由 IDE 自动生成，不需要用户修改，由系统维护。</li><li>res/drawable/ 目录用来存放工程中使用到的图片文件，drawable 之后的 hdpi、ldpi、mdpi 分别放高分辨率、低分辨率和中分辨率的图片以适应不同分辨率的手机，Android 系统会根据用户手机的配置信息自动选取合适分辨率的图片文件，无须程序员干预。</li><li>res/layout/ 目录下存放着定义 UI 布局文件用的 XML 文件，默认文件名为 main.xml。</li><li>res/values/ 目录下存放着用于存储工程中所使用到的一些字符串信息的文件，默认文件名为 strings.xml。</li></ul><h1 id="Android四大核心组件"><a href="#Android四大核心组件" class="headerlink" title="Android四大核心组件"></a>Android四大核心组件</h1><blockquote><p>源自：<a href="http://c.biancheng.net/view/2918.html">Android四大核心组件：Activity+Service+BroadcastReceiver+ContentProvider (biancheng.net)</a></p></blockquote><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>Activity 是 Android 应用程序核心组件中最基本的一种，是用户和应用程序交互的窗口。</p><p>在 Android 应用程序中，一个 Activity 通常对应一个单独的视图。一个 Android 应用程序是由一个或多个 Activity 组成的，这些 Activity 相当于 Web 应用程序中的网页，用于显示信息，并且相互之间可以进行跳转。和网页跳转不同的是，Activity 之间的跳转可以有返回值。</p><p>新打开一个视图时，之前的那个视图会被置为暂停状态，并且压入历史堆栈中，用户可以通过回退操作返回以前打开过的视图。Activity 是由 Android 系统进行维护的，它有自己的生命周期，即“产生、运行、销毁”，但是在这个过程中会调用许多方法，如创建 onCreate()、激活 onStart()、恢复 onResume()、暂停 onPause()、停止 onStop()、销毁 onDestroy()和重启 onRestart() 等。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service 是一种类似于 Activity 但是没有视图的程序，它没有用户界面，可以在后台运行很长时间，相当于操作系统中的一个服务。</p><p>Android 定义了两种类型的 Service，即本地 Service 和远程 Service。本地 Service 是只能由承载该 Service 的应用程序访问的组件，而远程 Service 是供在设备上运行的其他应用程序远程访问的 Service。</p><p>通过 Context.startService(Intent service) 可以启动一个 Service，通过 Context. bindService() 可以绑定一个 Service。</p><h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p>BroadcastReceiver 的意思是“广播接收者”，顾名思义，它用来接收来自系统和其他应用程序的广播，并做出回应。</p><p>在 Android 系统中，当有特定事件发生时就会产生相应的广播。广播体现在方方面面。例如，当开机过程完成后，系统会产生一条广播，接收到这条广播就能实现开机启动服务的功能；当网络状态改变时，系统会产生一条广播，接收到这条广播就能及时地做出提示和保存数据等操作；当电池电量改变时，系统会产生一条广播，接收到这条广播就能在电量低时告知用户及时保存进度等。</p><p>BroadcastReceiver 不能生成 UI，通过 NotificationManager 来通知用户有事件发生，对于用户来说是隐式的。</p><p>BroadcastReceiver 的 2 种注册方式：</p><ul><li>在 AndroidManifest. xml 中进行静态注册；</li><li>在运行时的代码中使用 Context.registerReceiver() 进行动态注册。</li></ul><p>只要注册了 BroadcastReceiver，即使对应的事件广播来临时应用程序并未启动，系统也会自动启动该应用程序对事件进行处理。另外，用户还可以通过 Context.sendBroadcast() 将自己的 Intent 对象广播给其他的应用程序。</p><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>文件、数据库等数据在 Android 系统内是私有的，仅允许被特定应用程序直接使用。在两个程序之间，数据的交换或共享由 ContentProvider 实现。</p><p>ContentProvider 类实现了一组标准方法的接口，从而能够让其他的应用保存或读取 ContentProvider 提供的各种数据类型。</p><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent 并不是 Android 应用程序四大核心组件之一，但是其重要性无可替代，因此在这里我们做一下简单介绍。</p><p>Android 应用程序核心组件中的三大核心组件 —— Activity、Service、BroadcastReceiver。通过消息机制被启动激活，而所使用的消息就是 Intent。Intent 是对即将要进行的操作的抽象描述，承担了 Android 应用程序三大核心组件相互之间的通信功能。</p><h1 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h1><p><img src="../../image/image-20220607155340410.png" alt="安卓生命周期"></p><h2 id="activity三种状态"><a href="#activity三种状态" class="headerlink" title="activity三种状态"></a>activity三种状态</h2><p><strong>active</strong>：当Activity运行在屏幕前台(处于当前任务活动栈的最上面)，此时它获取了焦点能响应用户的操作，属于活动状态，同一个时刻只会有一个Activity处于活动(Active)。</p><p><strong>paused</strong>：当Activity失去焦点但仍对用户可见(如在它之上有另一个透明的Activity或Toast、AlertDialog等弹出窗口时)它处于暂停状态。暂停的Activity仍然是存活状态(它保留着所有的状态和成员信息并保持和窗口管理器的连接)，但是当系统内存极小时可以被系统杀掉。</p><p><strong>stoped</strong>：完全被另一个Activity遮挡时处于停止状态，它仍然在内存中保留着所有的状态和成员信息。只是对用户不可见，当其他地方需要内存时它往往被系统杀掉。</p><h2 id="activity七个方法"><a href="#activity七个方法" class="headerlink" title="activity七个方法"></a>activity七个方法</h2><p><strong>onCreate()</strong>：当Activity第一次被实例化的时候系统会调用，整个生命周期只调用1次这个方法。通常用于初始化设置，为Activity设置所要使用的布局文件，为按钮绑定监听器等静态的设置操作。</p><p><strong>onStart()</strong>：当Activity可见未获得用户焦点不能交互时系统会调用。</p><p><strong>onRestart()</strong>：当Activity已经停止然后重新被启动时系统会调用。</p><p><strong>onResume()</strong>：当Activity可见且获得用户焦点能交互时系统会调用。</p><p><strong>onPause()</strong>：用来存储持久数据。到这一步是可见但不可交互的，系统会停止动画等消耗CPU的事情。从上文的描述已经知道，应该在这里保存你的一些数据，因为这个时候你的程序的优先级降低，有可能被系统收回。</p><p><strong>onStop()</strong>：当Activity被新的Activity完全覆盖不可见时被系统调用。</p><p><strong>onDestroy()</strong>：当Activity（用户调用finish()或系统由于内存不足）被系统销毁杀掉时系统调用，（整个生命周期只调用1次）用来释放onCreate()方法中创建的资源，如结束线程等。</p><h2 id="一个activity的启动过程"><a href="#一个activity的启动过程" class="headerlink" title="一个activity的启动过程"></a>一个activity的启动过程</h2><ol><li>第一个Activity的启动顺序：onCreate() -&gt; onStart() -&gt; onResume()</li><li>当另一个Activity启动时：第一个Activity onPause() -&gt; 第二个Activity onCreate() -&gt; onStart() -&gt; onResume() -&gt; 第一个Activity onStop()</li><li>当返回到第一个Activity时：第二个Activity onPause() -&gt; 第一个Activity onRestart() -&gt; onStart()-&gt; onResume() -&gt; 第二个Activity onStop() -&gt; onDestroy()</li></ol><p>每一个Activity都处于某一个状态，对于开发者来说，是无法控制其应用程序处于某一个状态的，这些均由系统来完成。</p><h1 id="Android-GUI编程"><a href="#Android-GUI编程" class="headerlink" title="Android GUI编程"></a>Android GUI编程</h1><blockquote><p>本章节文章源自：<a href="http://c.biancheng.net/android/40/">Android GUI（图形用户界面）开发 (biancheng.net)</a></p></blockquote><h2 id="View和ViewGroup"><a href="#View和ViewGroup" class="headerlink" title="View和ViewGroup"></a>View和ViewGroup</h2><p>Android 系统中的所有 UI 类都是建立在 View 和 ViewGroup 两个类的基础之上的，所有 View 的子类称为 Widget，所有 ViewGroup 的子类称为 Layout。</p><p>Activity 是 Android 应用程序与用户交互的接口，每一个屏幕视图都对应一个 Activity。</p><p>Activity 本身无法显示在屏幕上，其更像一个用于装载可显示组件的容器。就好比一个 <a href="http://c.biancheng.net/jsp/">JSP</a> 页面，它本身并没有显示出来任何东西，负责显示的是 JSP 页面内的各种 HTML 标签，而 JSP 页面好比一个容器，负责将这些表情装载到页面内。</p><p>那么在 Android 应用程序里，谁才是真正负责显示的那部分呢？答案是 View 和 ViewGroup，其中 ViewGroup 是 View 的子类。</p><p>Android UI 界面是通过 View（视图）和 ViewGroup 及其派生类组合而成的。</p><p>View 是所有 UI 组件的基类，基本上所有的高级 UI 组件都是继承 View 类实现的，如 TextView（文本框）、Button、List、EditText（编辑框）、Checkbox 等。一个 View 在屏幕占据一块矩形区域，负责渲染这块矩形区域，也可以处理这块矩形区域发生的事件，并可以设置该区域是否可见以及获取焦点等。</p><p>ViewGroup 是容纳这些组件的容器，其本身也是从 View 中派生出来的，它继承于 Android.view.View，功能就是装载和管理下一层的 View 对象或 ViewGroup 对象，也就是说它是一个容纳其他元素的容器，负责对添加进来的 View 和 ViewGroup 进行管理和布局。</p><p>View 和 ViewGroup 的关系如图所示：</p><p><img src="../../image/image-20220607162017573.png" alt="关系图"></p><p>可以看到，ViewGroup 可以包含一个或任意个 View（视图），也可以包含作为更低层次的子 ViewGroup，而子 ViewGroup 又可以包含下一层的叶子节点的 View 和 ViewGroup。这种灵活的层次关系可以形成复杂的 UI 布局。</p><p>在开发过程中形成的用户界面 UI 一般来自于 View 和 ViewGroup 类的直接子类或者间接子类。</p><p>例如，View 派生出的直接子类有 AnalogClock、ImageView、KeyboardView、ProgressBar、Space、SurfaceView、TextView、TextureView、ViewGroup、ViewStub 等。</p><p>ViewGroup 派生出的直接子类有 AbsoluteLayout、FragmentBreadCrumbs、FrameLayout、GridLayout、LinearLayout、RelativeLayout、SlidingDrawer 等。</p><h2 id="XML文件定义用户界面"><a href="#XML文件定义用户界面" class="headerlink" title="XML文件定义用户界面"></a>XML文件定义用户界面</h2><p>单击打开 values 文件夹下的 string.xml 文件显示出如下代码：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span>Hello Android!<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>HelloAndroid<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre></div><p>文件的开头部分<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>定义了 XML 的版本号和字符编码，这个部分在所有的 XML 文件中都会有，由系统自动添加，不需要修改。</p><p>\<resources> 标签定义了 hello 和 app_name 两个变量，可以被 HelloAndroid 工程直接使用。当该文件被修改时，gen 目录下的 R.java 文件也会跟随进行更新。</p><p>双击 main.xml 文件，代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/hello&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre></div><p>在 <LinearLayout ...> 和 \</LinearLayout> 之间可以添加各种 UI 组件并设置组件的相关属性，例如组件的高度、宽度、内容等，后边会详细介绍各种常见组件的使用方法。</p><p>在 HelloAndroid 实例中添加的是一个 TextView 组件，相当于一个显示内容的标签。Android SDK 提供了<code>@[&lt;package_ name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt;</code>方式，以便于从 XML 文件中访问工程的资源。</p><p>下面简单介绍一下 TextView 中的属性：</p><ul><li>android:layout_width=”fill_parent” 指定其宽度覆盖满容器的宽。</li><li>android:layout_height= “wrap_content” 指定其高度跟随其显示内容变化。</li><li>android:id=”@+id/textView1” 指明该 TextView 的 ID 值为 R.java 文件中 ID 类的成员常量 textView1。</li><li>android:text=”@string/hello” 指明该 TextView 组件显示的内容为资源文件 string.xml 中定义的 hello 变量的内容。</li><li>android:text 属性也可以直接指定要显示的字符串，但是在实际的工程开发过程中不鼓励这种方式，而应该使用资源文件中的变量，因为这样便于工程维护和国际化。</li></ul><p>在本教程中，为了节省篇幅，部分显示内容简单的组件使用了字符串直接赋值的方法。</p><p>Android 工程中使用到的资源文件都会在 gen 目录下的 R.java 中生成对应项，由系统为每个资源分配一个十六进制的整型数值，唯一标明每个资源。</p><p>HelloAndroid 工程中的 R.java 文件代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">R</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">attr</span> </span>&#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawable</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ic_launcher = <span class="hljs-number">0x7f020000</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">id</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> textView1 = <span class="hljs-number">0x7f050000</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">layout</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> main = <span class="hljs-number">0x7f030000</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">string</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> app_name = <span class="hljs-number">0x7f040001</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hello = <span class="hljs-number">0x7f040000</span>;    &#125;&#125;</code></pre></div><p>由该文件可见，R 为静态最终类。其中 public static final class layout 代表的是 res/layout 文件夹的内容，layout 类的每个整型常量代表该文件夹下的一个 XML 布局文件。</p><p>例如，public static final int main 代表的是 main.xml 文件，0x7f030000 为系统 main.xml 文件生成的整型数值。在 Android 工程中根据该数值找到 main.xml 文件。public static final class string 代表的是 res/values/strings.xml 文件，string 类中的每个整型常量型成员代表 strings.xml 文件中定义的一个变量。例如，public static final int app_name 代表 strings.xml 中定义的 app_name 变量，public static final int hello 代表 stings.xml 文件中定义的 hello 变量。</p><p>在工程开发过程中，可以通过 [<package_name>.]R.<resource_type>.<resource_name> 方式来访问 R 中定义的任意资源。其中：</p><ul><li>package_name 为资源文件被放置的包路径，一般可以省略。</li><li>resource_type 为资源类型，例如 layout、string、color、drawable、menu 等。</li><li>resource_ name 指的是为资源文件在类中定义的整型常量的名字。</li></ul><p>请看下面的例子：</p><div class="code-wrapper"><pre><code class="hljs java">setContentView(R.layout.main);</code></pre></div><p>这行代码中，通过 R.layout.main 找到了布局文件 main.xml，并通过 setContentView 方法将其设置为当前 Activity 的视图。要从视图中查找某个组件，需要使用 findViewById 方法，通过组件 ID 获取组件的对象。</p><p>例如，要获取 main.xml 中的 TextView 组件对象，需要执行以下代码：</p><div class="code-wrapper"><pre><code class="hljs java">TextView textview=(TextView)findViewById(R.id.textView1);</code></pre></div><h2 id="Android五大布局"><a href="#Android五大布局" class="headerlink" title="Android五大布局"></a>Android五大布局</h2><p><img src="../../image/image-20220607163454707.png" alt="五大布局"></p><h3 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h3><p>FrameLayout 又称单帧布局，是 Android 所提供的布局方式里最简单的布局方式，它指定屏幕上的一块空白区域，在该区域填充一个单一对象。例如图片、文字、按钮等。</p><p>应用程序开发人员不能为 FrameLayout 中填充的组件指定具体填充位置，默认情况下，这些组件都将被固定在屏幕的左上角，后放入的组件会放在前一个组件上进行覆盖填充，形成部分遮挡或全部遮挡。</p><p>开发人员可以通过组件的 android:layout_gravity 属性对组件位置进行适当的修改。</p><p>实例 FrameLayoutDemo 演示了 FrameLayout 的布局效果。该布局中共有 4 个 TextView 组件，前 3 个组件以默认方式放置到布局中，第 4 个组件修改 gravity 属性后放置到布局中，运行效果如图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/190401/5-1Z401163A3602.jpg" alt="FrameLayout的布局效果"></p><p>实例 FrameLayoutDemo 中的布局文件 main.xml 的代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#00ff00&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textsize</span>=<span class="hljs-string">&quot;1OOdip&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/first&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text2&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#00ffff&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textsize</span>=<span class="hljs-string">&quot;70dip&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/second&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text3&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#ffOOOO&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textsize</span>=<span class="hljs-string">&quot;40dip&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/third&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text4&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#fffffOO&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;40dip&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;bottom&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/forth&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span></code></pre></div><p>其中：</p><div class="code-wrapper"><pre><code class="hljs xml">android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;</code></pre></div><p>表明 FrameLayout 布局覆盖了整个屏幕空间。</p><p>实例 FrameLayoutDemo 中的 strings.xml 文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>FrameLayoutDemo<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>第一层<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span>第二层<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;third&quot;</span>&gt;</span>第三层<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forth&quot;</span>&gt;</span>第四层<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre></div><p>从运行后的结果可见，前 3 个被放置到 FrameLayout 的 TextView 组件都是以屏幕左上角为基点进行叠加的。第4个 TextView 因为设置了 android:layout_gravity=”bottom” 属性而显示到了布局的下方。可自行将 android:layout_gravity 属性值修改为其他属性，查看运行效果。</p><h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h3><p>LinearLayout 又称线性布局，该布局应该是 Android 视图设计中最经常使用的布局。该布局可以使放入其中的组件以水平方式或者垂直方式整齐排列，通过 android:orientation 属性指定具体的排列方式，通过 weight 属性设置每个组件在布局中所占的比重。</p><p>实例 LinearLayoutDemo 演示了 LinearLayout 布局的使用方法，效果如图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/190402/5-1Z402100601X5.PNG" alt=""></p><p>实例 LinearLayoutDemo 中的 strings.xml 文件代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>LinearLayoutDemo<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;yellow&quot;</span>&gt;</span>yellow<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span>green<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span>blue<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;row1&quot;</span>&gt;</span>row one<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;row2&quot;</span>&gt;</span>row two<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;row3&quot;</span>&gt;</span>row three<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;row4&quot;</span>&gt;</span>row four<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre></div><p>实例 LinearLayoutDemo 中的布局文件 main.xml 代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#aa0000&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/red&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#00aa00&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/green&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#0000aa&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/blue&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#aaaa00&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/yellow&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/row1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;15pt&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/row2&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;15pt&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/row3&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;15pt&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/row4&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;15pt&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre></div><p>该布局中放置了两个 LinearLayout 布局对象。</p><p>第一个 LinearLayout 布局通过 android:orientation=”horizontal” 属性将布局设置为横向线性排列。</p><p>第二个 LinearLayout 布局通过 android:orientation=”vertical” 属性将布局设置为纵向线性排列。</p><p>每个 LinearLayout 布局中都放入了 4 个 TextView，并通过 android:layout_weight 属性设置每个组件在布局中所占的比重相同，即各组件大小相同。</p><p>layout_weight 用于定义一个线性布局中某组件的重要程度。所有的组件都有一个 layout_weight 值，默认为 0。意思是需要显示多大的视图就占据多大的屏幕空间。若赋值为大于 0 的值，则将可用的空间分割，分割的大小取决于当前的 layout_weight 数值与其他空间的 layout_weight 值的比率。</p><p>例如水平方向上有两个按钮，每个按钮的 layout_weight 数值都设置为 1，那么这两个按钮平分宽度；若第一个为 1，第二个为 2，则可将空间的三分之一分给第一个，三分之二分给第二个。</p><p>将 LinearLayoutDemo 中水平 LinearLayout 的第 4 个 TextView 的 android:layout_weight 属性赋值为 2，运行效果如图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/190402/5-1Z402095929C3.PNG" alt="修改android:layout_weight属性"></p><p>LinearLayout 布局可使用嵌套。活用 LinearLayou 布局可以设计出各种各样漂亮的布局方式。</p><h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h3><p>RelativeLayout 又称相对布局。从名称上可以看出，这种布局方式是以一种让组件以相对于容器或者相对于容器中的另一个组件的相对位置进行放置的布局方式。</p><p>RelativeLayout 布局提供了一些常用的布局设置属性用于确定组件在视图中的相对位置。下面列举了 RelativeLayout 相关属性及其所代表的含义。</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>android:layout_above=”@id/xxx”</td><td>将控件置于给定 ID 控件之上</td></tr><tr><td>android:layout_below=”@id/xxx”</td><td>将控件置于给定 ID 控件之下</td></tr><tr><td>android:layout_toLeftOf=”@id/xxx”</td><td>将控件的右边缘和给定 ID 控件的左边缘对齐</td></tr><tr><td>android:layout_toRightOf=”@id/xxx”</td><td>将控件的左边缘和给定 ID 控件的右边缘对齐</td></tr><tr><td>android:layout_alignBaseline=”@id/xxx”</td><td>将控件的 baseline 与给定 ID 的 baseline 对齐</td></tr><tr><td>android:layout_alignTop=”@id/xxx”</td><td>将控件的上边缘和给定 ID 控件的上边缘对齐</td></tr><tr><td>android:layout_alignBottom=”@id/xxx”</td><td>将控件的底边缘和给定 ID 控件的底边缘对齐</td></tr><tr><td>android:layout_alignLeft=”@id/xxx”</td><td>将控件的左边缘和给定 ID 控件的左边缘对齐</td></tr><tr><td>android:layout_alignRight=”@id/xxx”</td><td>将控件的右边缘和给定 ID 控件的右边缘对齐</td></tr><tr><td>android:layout_alignParentLeft=”true”</td><td>将控件的左边缘和父控件的左边缘对齐</td></tr><tr><td>android:layout_alignParentTop=”true”</td><td>将控件的上边缘和父控件的上边缘对齐</td></tr><tr><td>android:layout_alignParentRight=”true”</td><td>将控件的右边缘和父控件的右边缘对齐</td></tr><tr><td>android:layout_alignParentBottom=”true”</td><td>将控件的底边缘和父控件的底边缘对齐</td></tr><tr><td>android:layout_centerInParent=”true”</td><td>将控件置于父控件的中心位置</td></tr><tr><td>android:layout_centerHorizontal=”true”</td><td>将控件置于水平方向的中心位置</td></tr><tr><td>android:layout_centerVertical=”true”</td><td>将控件置于垂直方向的中心位置</td></tr></tbody></table></div><p>实例 RelativeLayoutDemo 演示了相对布局的使用方法，其运行效果如图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/190402/5-1Z402105010N8.PNG" alt="RelativeLayout布局效果"></p><p>实例 RelativeLayoutDemo 中的布局文件 main.xml 代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/label&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/hello&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/enter&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentLeft</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_below</span>=<span class="hljs-string">&quot;@+id/label&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentRight</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_below</span>=<span class="hljs-string">&quot;@+id/enter&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/butltext&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ok&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignBottom</span>=<span class="hljs-string">&quot;@+id/button1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentLeft</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/but2text&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span></code></pre></div><p>该 RelativeLayout 布局的过程如下：</p><p>1）放置一个 ID 为 label 的 TextView 组件。</p><p>2）通过 android:layout_below=”@+id/label” 属性将 ID 为 enter 的组件 EditText 放置到 TextView 的下面。</p><p>3）在布局中加入一个 ID 为 button1 的 Button，通过 android:layout_below=”@+id/enter” 属性将该 Button 放置到 enter 的下面，通过 android:layout_alignParentRight= “true” 属性将 Button 放置到相对布局的右侧。</p><p>4）在相对布局中加入一个名为 ok 的 Button，通过 android:layout_alignBottom=”@+ id/button1” 属性将该 Button 底边与 button1 对齐，通过 android:layout_alignParentLeft =”true” 属性将该 Button 放置到布局的左边。</p><h3 id="TableLayout"><a href="#TableLayout" class="headerlink" title="TableLayout"></a>TableLayout</h3><p>TableLayout 又称为表格布局，以行列的方式管理组件。</p><p>TableLayout 布局没有边框，可以由多个 TableRow 对象或者其他组件组成，每个 TableRow 可以由多个单元格组成，每个单元格是一个 View。TableRow 不需要设置宽度 layout_width 和高度 layout_height，其宽度一定是 match_parent，即自动填满父容器，高度一定为 wrap_content，即根据内容改变高度。但对于 TableRow 中的其他组件来说，是可以设置宽度和高度的，只是必须是 wrap_content 或者 fill_parent。</p><p>实例 TableLayoutDemo 演示了使用 TableLayout 制作 UI 的方法，效果如图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/190402/5-1Z40211252R28.PNG" alt="TableLayout布局效果"></p><p>实例 TableLayoutDemo 中 strings.xml 的代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span>Hello World,TableLayout!<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>TableLayoutDemo<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;column1&quot;</span>&gt;</span>第一行第一列<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;column2&quot;</span>&gt;</span>第一行第二列<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;column3&quot;</span>&gt;</span>第一行第三列<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;empty&quot;</span>&gt;</span>最左面的可伸缩TextView<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;row2column2&quot;</span>&gt;</span>第二行第三列<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;row2column3&quot;</span>&gt;</span>End<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;merger&quot;</span>&gt;</span>合并三个单元格<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre></div><p>实例 TableLayoutDemo 中的布局文件 main.xml 的代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">TableLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/column1&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/column2&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/column3&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">TableRow</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#fff000&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;单独的一个TextView&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_span</span>=<span class="hljs-string">&quot;3&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/merger&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#f00&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">TableRow</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#fa05&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;单独的一个TextView&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/empty&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/row2column2&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;string/row2column3&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">TableRow</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TableLayout</span>&gt;</span></code></pre></div><p>布局文件 main.xml 在 TableLayout 布局内添加了两个 TableRow 和两个 TextView，形成了如图 6 所示的效果。从运行效果看，第一行和第五行都没能完全显示。</p><p>TableLayout 布局提供了几个特殊属性，可以实现以下特殊效果。</p><ul><li>android:shrinkColumns 属性：该属性用于设置可收缩的列。当可收缩的列太宽以至于布局内的其他列不能完全显示时，可收缩列会纵向延伸，压缩自己所占的空间，以便于其他列可以完全显示出来。android:shrinkColumns=”1” 表示将第 2 列设置为可收缩列，列数从 0 开始。</li><li>android:stretchColumns 属性：该属性用于设置可伸展的列。可伸展的列会自动扩展长度以填满所有可用空间。android:stretchColumns=”1” 表示将第 2 列设置为可伸展的列。</li><li>android:collapseColumns 属性：该属性用于设置隐藏列。android:collapseColumns=”1” 表示将第 2 列隐藏不显示。</li></ul><p>在\<TableLayout> 标签添加属性 android:shrinkColumns=”0”，再次运行，效果如图 7 所示，可以看出第一行和第五行都完全显示出来了。</p><p><img src="http://c.biancheng.net/uploads/allimg/190402/5-1Z402130319260.PNG" alt="完全显示的效果"></p><h3 id="AbsoluteLayout"><a href="#AbsoluteLayout" class="headerlink" title="AbsoluteLayout"></a>AbsoluteLayout</h3><p>AbsoluteLayout 又称绝对布局，放入该布局的组件需要通过 android:layout_x 和 android:layout_y 两个属性指定其准确的坐标值，并显示在屏幕上。</p><p>理论上，AbsoluteLayout 布局可用以完成任何的布局设计，灵活性很大，但是在实际的工程应用中不提倡使用这种布局。因为使用这种布局不但需要精确计算每个组件的大小，增大运算量，而且当应用程序在不同屏幕尺寸的手机上运行时会产生不同效果。</p><p>实例 AbsoluteLayoutDemo 演示了 AbsoluteLayout 布局的使用方法，效果如图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/190402/5-1Z402140446426.png" alt="AbsoluteLayout布局效果"></p><p>实例 AbsoluteLayoutDemo 的布局文件 main.xml 代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">AbsoluteLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_x</span>=<span class="hljs-string">&quot;32px&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_y</span>=<span class="hljs-string">&quot;53px&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button2&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_x</span>=<span class="hljs-string">&quot;146px&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_y</span>=<span class="hljs-string">&quot;53px&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button3&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_x</span>=<span class="hljs-string">&quot;85px&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_y</span>=<span class="hljs-string">&quot;135px&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">AbsoluteLayout</span>&gt;</span></code></pre></div><p>其中：</p><div class="code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>layout_x=<span class="hljs-string">&quot;85px&quot;</span><span class="hljs-symbol">android:</span>layout_y=<span class="hljs-string">&quot;135px&quot;</span></code></pre></div><p>表示将组件放置到以屏幕左上角为坐标原点的坐标系下，x 值为 85 像素、y 值为 135 像素的位置。</p><p>在这里简单介绍一下 Android 系统常用的尺寸类型的单位。</p><ul><li>像素：缩写为 px。表示屏幕上的物理像素。</li><li>磅：points，缩写为 pt。1pt 等于 1 英寸的 1/72，常用于印刷业。</li><li>放大像素：sp。主要用于字体的显示，Android 默认使用 sp 作为字号单位。</li><li>密度独立像素：缩写为 dip 或 dp。该尺寸使用 160dp 的屏幕作为参考，然后用该屏幕映射到实际屏幕，在不同分辨率的屏幕上会有相应的缩放效果以适用于不同分辨率的屏幕。若用 px 的话，320px 占满 HVGA 的宽度，到 WVGA 上就只能占一半不到的屏幕了，那一定不是你想要的。</li><li>毫米：mm。</li></ul><h4 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h4><p>WebView 组件是 AbsoluteLayout 的子类，用于显示 Web 页面。借助于 WebView，可以方便地开发自己的网络浏览器。此处仅对 WebView 的基本用法进行介绍，在后面进行 Web App 的学习时会有更进一步的讲解。</p><p>创建工程 WebViewDemo，为其在 AndroidManifest.xml 文件中添加 Internet 访问权限：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></code></pre></div><p>在布局文件 main.xml 中添加一个 WebView 组件。Main.xml 内容如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">WebView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/webView1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre></div><p>实例 WebViewDemo 中的 Activity 文件 WebViewDemoActivity.java 代码如下：</p><div class="code-wrapper"><pre><code class="hljs xml">package introduction.android.webView;import android.app.Activity;import android.os.Bundle;import android.webkit.WebView;public class WebViewDemoActivity extends Activity &#123;    private WebView webView;    /**     * Called when the acctivity is first crested.     */    @Override    public void onCreate(Bundle saveInstanceState) &#123;        super.onCreate(saveInstanceState);        setContentView(R.layout.main);        webView = (WebView) findViewById(R.id.webView1);        webView.getSettings().setJavaScriptEnabled(true);        webView.loadUrl(&quot;http://www.google.com&quot;);    &#125;&#125;</code></pre></div><p>运行效果如图所示：</p><p><img src="http://c.biancheng.net/uploads/allimg/190402/5-1Z402145U3258.jpg" alt="WebViewDemo运行界面"></p><h2 id="Android组件"><a href="#Android组件" class="headerlink" title="Android组件"></a>Android组件</h2><p>所有组件均可在IDE中拖动，具体功能参考：<a href="http://c.biancheng.net/view/2996.html">Android Button：按钮控件 (biancheng.net)</a>等讲解</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数公式大全（二）</title>
    <link href="/my_world/content/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/my_world/content/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><h2 id="章节概括"><a href="#章节概括" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>具体型线性方程组<ul><li>齐次线性方程组<ul><li>有解的条件</li><li>解的性质</li><li>基础解系和解的结构</li><li>求解方法与步骤</li></ul></li><li>非齐次<ul><li>有解的条件</li><li>解的性质</li><li>求解的方法与步骤</li></ul></li></ul></li><li>抽象性线性方程组<ul><li>有解的条件与解的判定</li><li>解的结构</li><li>基础解系的讨论</li><li>系数矩阵列向量与解的关系</li></ul></li><li>两个方程组的公共解</li><li>同解方程组</li></ul><h2 id="方程组的基本形式"><a href="#方程组的基本形式" class="headerlink" title="方程组的基本形式"></a>方程组的基本形式</h2><script type="math/tex; mode=display">\begin{cases}a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = 0\\a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = 0\\\vdots \\a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mn}x_n = 0\\\end{cases}</script><script type="math/tex; mode=display">\begin{cases}a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = b_1\\a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = b_2\\\vdots \\a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mn}x_n = b_m\\\end{cases}</script><p><strong>矩阵形式</strong></p><script type="math/tex; mode=display">令A = \begin{pmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{m1} & a_{m2} & \cdots & a_{mn} \\\end{pmatrix},X = \begin{pmatrix}x_{1} \\x_{2} \\\vdots \\x_{n} \\\end{pmatrix},b = \begin{pmatrix}b_{1} \\b_{2} \\\vdots \\b_{m} \\\end{pmatrix}</script><script type="math/tex; mode=display">\begin{align}AX = 0\\AX = b\end{align}</script><p><strong>向量形式</strong></p><script type="math/tex; mode=display">令\alpha_1 = \begin{pmatrix}a_{11}\\a_{21}\\\vdots\\a_{m1}\\\end{pmatrix},\alpha_2 = \begin{pmatrix}a_{12}\\a_{22}\\\vdots\\a_{m2}\\\end{pmatrix},\cdots,\alpha_n = \begin{pmatrix}a_{1n}\\a_{2n}\\\vdots\\a_{mn}\\\end{pmatrix},b = \begin{pmatrix}b_{1} \\b_{2} \\\vdots \\b_{m} \\\end{pmatrix}</script><script type="math/tex; mode=display">\begin{align}x_1\alpha_1 + x_2\alpha_2 + \cdots + x_n\alpha_n = 0 \\x_1\alpha_1 + x_2\alpha_2 + \cdots + x_n\alpha_n = b\end{align}</script><h2 id="系数矩阵与增广系数矩阵"><a href="#系数矩阵与增广系数矩阵" class="headerlink" title="系数矩阵与增广系数矩阵"></a>系数矩阵与增广系数矩阵</h2><p><strong>系数矩阵</strong></p><script type="math/tex; mode=display">A = \begin{pmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{m1} & a_{m2} & \cdots & a_{mn} \\\end{pmatrix}</script><p><strong>增广系数矩阵</strong></p><script type="math/tex; mode=display">\overline{A}  = \begin{pmatrix}a_{11} & a_{12} & \cdots & a_{1n} & | & b_1\\a_{21} & a_{22} & \cdots & a_{2n} & | & b_2\\\vdots & \vdots &        & \vdots &        & \vdots\\a_{m1} & a_{m2} & \cdots & a_{mn} & | & b_m\\\end{pmatrix}</script><p><strong>A,B合并矩阵</strong></p><script type="math/tex; mode=display">(A,B) = \begin{pmatrix}a_{11} & a_{12} & \cdots & a_{1n} & | & b_{11} & b_{12} & \cdots & b_{1n}\\a_{21} & a_{22} & \cdots & a_{2n} & | & b_{21} & b_{22} & \cdots & b_{2n}\\\vdots & \vdots &        & \vdots &        & \vdots &  \vdots &   &\vdots\\a_{m1} & a_{m2} & \cdots & a_{mn} & | & b_{m1} & b_{m2} & \cdots & b_{mn}\\\end{pmatrix}</script><h2 id="行阶梯形矩阵"><a href="#行阶梯形矩阵" class="headerlink" title="行阶梯形矩阵"></a>行阶梯形矩阵</h2><blockquote><p>原链接：<a href="https://blog.csdn.net/myarrow/article/details/53365048">线性代数知识汇总<em>MyArrow的专栏-CSDN博客</em>线性代数</a></p></blockquote><p><img src="../../image/行阶梯形矩阵.png" alt="行阶梯形矩阵"></p><h2 id="解向量"><a href="#解向量" class="headerlink" title="解向量"></a>解向量</h2><p>解向量是线性方程组的一个解。因为一组解在空间几何里可以表示为一个向量，所以叫做解向量。</p><h2 id="基础解系"><a href="#基础解系" class="headerlink" title="基础解系"></a>基础解系</h2><p>基础解系是指方程组的解集的极大线性无关组，即若干个无关的解构成的能够表示任意解的组合</p><p>基础解系需要满足三个条件：</p><ol><li>基础解系中所有量均是方程组的解；</li><li>基础解系线性无关，即基础解系中任何一个量都不能被其余量表示；</li><li>方程组的任意解均可由基础解系线性表出，即方程组的所有解都可以用基础解系的量来表示。</li></ol><script type="math/tex; mode=display">n-r(A) = 无关解向量个数 = 自由变量个数 = 线性无关解向量的个数</script><p>一般设自由变量为1，然后求基础解系的其他数，画行阶梯形，不是直角的一方为自由变量。若只有一个自由变量，则设自由变量为1；若有2个自由变量，则设自由变量为1,0和0,1；若有3个自由变量，则设自由变量为1,0,0和0,0,1。</p><blockquote><p>原视频：<a href="https://www.bilibili.com/video/BV11C4y187PM?from=search&amp;seid=4031408942362126119&amp;spm_id_from=333.337.0.0">快速学会齐次线性方程组的解法——基础解系，通解一并解决！_哔哩哔哩_bilibili</a></p></blockquote><h3 id="解的结构"><a href="#解的结构" class="headerlink" title="解的结构"></a>解的结构</h3><p>可表示为$Ax = B$的通解形式</p><script type="math/tex; mode=display">\alpha + k_1\xi_1 + k_2\xi_2 + \cdots + k_t\xi_t</script><script type="math/tex; mode=display">t = n - r(A),\alpha 是非齐次方程组的特解(\beta_1,\beta_2,\cdots,\beta_n),k是任意常数,\xi 是解向量</script><h4 id="求基础解系例子"><a href="#求基础解系例子" class="headerlink" title="求基础解系例子"></a>求基础解系例子</h4><script type="math/tex; mode=display">\left\{\begin{matrix}x_1 + x_2 = 0 \\x_2 - x_4 = 0\end{matrix}\right.</script><p>由上可得$x_1 = -x_4,x_2 = x_4$，则得以下通解：</p><script type="math/tex; mode=display">X = \begin{pmatrix}-x_4\\x_4\\x_3\\x_4\\\end{pmatrix} = x_3\begin{pmatrix}0\\0\\1\\0\\\end{pmatrix}+x_4\begin{pmatrix}-1\\1\\0\\1\\\end{pmatrix}</script><p>则方程组的基础解系为：</p><script type="math/tex; mode=display">\xi_1 = \begin{pmatrix}0\\0\\1\\0\\\end{pmatrix},\xi_2=\begin{pmatrix}-1\\1\\0\\1\\\end{pmatrix}</script><h2 id="线性方程组解的结论"><a href="#线性方程组解的结论" class="headerlink" title="线性方程组解的结论"></a>线性方程组解的结论</h2><h3 id="结论1"><a href="#结论1" class="headerlink" title="结论1"></a>结论1</h3><script type="math/tex; mode=display">AX = 0只有零解(唯一解) \Leftrightarrow r(A) = n(未知数x的个数) \Leftrightarrow 向量组线性无关</script><script type="math/tex; mode=display">AX = 0有非零解(无穷解) \Leftrightarrow r(A) < n(未知数x的个数) \Leftrightarrow 向量组线性相关</script><script type="math/tex; mode=display">线性无关：(\alpha_1 , \alpha_2,\alpha_3,\cdots,\alpha_s)X = 0</script><script type="math/tex; mode=display">线性表示：(\alpha_1 , \alpha_2,\alpha_3,\cdots,\alpha_n)X = \beta，称\beta用\alpha_1 , \alpha_2,\alpha_3,\cdots,\alpha_n线性表示</script><h3 id="结论2"><a href="#结论2" class="headerlink" title="结论2"></a>结论2</h3><script type="math/tex; mode=display">AX = B有解 \Leftrightarrow r(A) = r(\overline{A})</script><script type="math/tex; mode=display">AX = B有无穷多组解 \Leftrightarrow r(A) = r(\overline{A}) < n(未知数x的个数)，|A| = 0</script><script type="math/tex; mode=display">AX = B有只有零解 \Leftrightarrow r(A) = r(\overline{A}) = n(未知数x的个数)</script><script type="math/tex; mode=display">AX = B无解 \Leftrightarrow r(A) \neq r(\overline{A})</script><h2 id="求通解例子"><a href="#求通解例子" class="headerlink" title="求通解例子"></a>求通解例子</h2><script type="math/tex; mode=display">判断方程组\begin{cases}x_1 - x_2 +2x_3 - 3x_4 = 2\\x_1 - 2x_2 + x_3 - 2x_4 = -1\\x_2 + x_3 - 3x_4 = 3\\\end{cases}是否有解，若有解求出通解</script><script type="math/tex; mode=display">\overline{A}  = \begin{pmatrix}1 & -1 & 2 & -3 & 2\\1 & -2 & 1 & -2 & -1\\0 & 1 & 1 & -1 & 3\\\end{pmatrix} \rightarrow \begin{pmatrix}1 & -1 & 2 & -3 & 2\\0 & -1 & -1 & 1 & -3\\0 & 1 & 1 & -1 & 3\\\end{pmatrix}\rightarrow \begin{pmatrix}1 & -1 & 2 & -3 & 2\\0 & -1 & -1 & 1 & -3\\0 & 0 & 0 & 0 & 0\\\end{pmatrix}\rightarrow \begin{pmatrix}1 & 0 & 3 & -4 & 5\\0 & -1 & -1 & 1 & -3\\0 & 0 & 0 & 0 & 0\\\end{pmatrix}</script><script type="math/tex; mode=display">因为r(A) = r(\overline{A}) = 2 < 4，所以原方程组有无穷多个解</script><script type="math/tex; mode=display">等价方程组为\begin{cases}x_1 = -3x_3 + 4x_4 + 5\\x_2 = -x_3 + x_4 + 3\\\end{cases}</script><script type="math/tex; mode=display">通解为：X = \begin{pmatrix}-3x_3 + 4x_4 + 5\\-x_3 + x_4 + 3\\x_3\\x_4\\\end{pmatrix} = x_3\begin{pmatrix}-3\\-1\\1\\0\\\end{pmatrix}+x_4\begin{pmatrix}4\\1\\0\\1\\\end{pmatrix}+\begin{pmatrix}5\\3\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">得该方程组的基础解系为:\xi_1 =\begin{pmatrix}-3\\-1\\1\\0\\\end{pmatrix},\xi_2 =\begin{pmatrix}4\\1\\0\\1\\\end{pmatrix},\alpha =\begin{pmatrix}5\\3\\0\\0\\\end{pmatrix}</script><h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><h2 id="章节概括-1"><a href="#章节概括-1" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>特征值与特征向量<ul><li>定义</li><li>性质</li><li>求法<ul><li>具体型矩阵</li><li>抽象型矩阵</li></ul></li></ul></li><li>相似<ul><li>矩阵相似<ul><li>定义</li><li>性质</li></ul></li><li>矩阵的相似对角化<ul><li>定义</li><li>可相似对角化的条件<ul><li>两个充分</li><li>两个必要</li></ul></li><li>相似对角化的步骤</li></ul></li><li>应用<ul><li>实对称矩阵的相似对角化</li><li>反问题<ul><li>反求参数</li><li>反求A</li></ul></li><li>求$A^k$与$f(A)$</li></ul></li></ul></li></ul><h2 id="特征值、特征向量"><a href="#特征值、特征向量" class="headerlink" title="特征值、特征向量"></a>特征值、特征向量</h2><p>设<strong>A</strong>为n阶矩阵，若存在一个数$\lambda$和非零向量$X$，使得$AX = \lambda X$，称$\lambda$为矩阵<strong>A</strong>的特征值，称$X$为矩阵<strong>A</strong>的属于特征值$\lambda$的特征向量</p><h2 id="特征多项式、特征方程"><a href="#特征多项式、特征方程" class="headerlink" title="特征多项式、特征方程"></a>特征多项式、特征方程</h2><script type="math/tex; mode=display">令A = \begin{pmatrix}a_{11} & a_{12} & \cdots & a_{1n}\\a_{21} & a_{22} & \cdots & a_{2n}\\\vdots & \vdots &        & \vdots\\a_{n1} & a_{n2} & \cdots & a_{nn}\\\end{pmatrix}</script><script type="math/tex; mode=display">称|\lambda E-A|=\begin{vmatrix}\lambda - a_{11} & - a_{12} & \cdots & - a_{1n}\\- a_{21} & \lambda - a_{22} & \cdots & - a_{2n}\\\vdots & \vdots &        & \vdots\\- a_{n1} & - a_{n2} & \cdots & \lambda - a_{nn}\\\end{vmatrix}为矩阵A的特征多项式</script><script type="math/tex; mode=display">|\lambda E-A| = 0 称为矩阵A的特征方程</script><h2 id="求特征值的方法"><a href="#求特征值的方法" class="headerlink" title="求特征值的方法"></a>求特征值的方法</h2><script type="math/tex; mode=display">利用|\lambda E-A|=\begin{vmatrix}\lambda - a_{11} & - a_{12} & \cdots & - a_{1n}\\- a_{21} & \lambda - a_{22} & \cdots & - a_{2n}\\\vdots & \vdots &        & \vdots\\- a_{n1} & - a_{n2} & \cdots & \lambda - a_{nn}\\\end{vmatrix}把矩阵化成行列式</script><script type="math/tex; mode=display">将某行中含有\lambda的式子一行/列的元素尽可能化成0，之后按行/列展开。或者提公因子</script><script type="math/tex; mode=display">将结果相乘，将最后的式子因式分解，得出(\lambda -\lambda_1)的形式，令它们等于0，得出\lambda</script><h2 id="求特征向量的方法"><a href="#求特征向量的方法" class="headerlink" title="求特征向量的方法"></a>求特征向量的方法</h2><script type="math/tex; mode=display">将\lambda带入|\lambda E-A|，令|\lambda E-A|X = 0,X则是矩阵A的特征向量</script><script type="math/tex; mode=display">例如，\lambda=1,求出|E - A| = A,通过A的n行乘以特征向量的一列为0求得X</script><script type="math/tex; mode=display">\begin{align}根据\left\{\begin{matrix}ax + by + cz & = 0 \\Ax + By + Cz & = 0\end{matrix}\right. \\得到 \\\frac{x}{\begin{vmatrix}b & c \\B & C \\\end{vmatrix}} = \frac{-y}{\begin{vmatrix}a & c \\A & C \\\end{vmatrix}} = \frac{z}{\begin{vmatrix}a & b \\A & B \\\end{vmatrix}} \end{align}</script><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><script type="math/tex; mode=display">tr(A)为矩阵A主对角线上元素之和，称为矩阵A的迹</script><script type="math/tex; mode=display">\lambda_1 + \lambda_2 + \cdots + \lambda_n  = a_{11} + a_{22} + \cdots + a_{nn} = tr(A)</script><script type="math/tex; mode=display">\lambda_1 * \lambda_2 * \cdots * \lambda_n = |A|</script><script type="math/tex; mode=display">不同特征值的特征向量线性无关</script><script type="math/tex; mode=display">A有n个不同的特征值,则A有n个线性无关的特征向量</script><script type="math/tex; mode=display">实对称矩阵不同特征值对应的特征向量正交</script><script type="math/tex; mode=display">线性无关特征向量个数≤特征值重数</script><script type="math/tex; mode=display">\begin{align}AX = \lambda X \\AA^*X = A^*\lambda X\\|A|EX = A^*\lambda X\\A^* = \frac{|A|}{\lambda}\end{align}</script><script type="math/tex; mode=display">|\lambda E-A| = 0 => r(\lambda E-A) \le 2 => r(\lambda E-A) = n-k(线性无关的特征向量个数，k = n - r(A))</script><script type="math/tex; mode=display">A为实对称矩阵，r(A) = n，则\lambda的个数为n-1(重特征值算为1个)</script><h2 id="矩阵相似"><a href="#矩阵相似" class="headerlink" title="矩阵相似"></a>矩阵相似</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>设<strong>A、B</strong>为两个n阶矩阵，若存在可逆矩阵<strong>P</strong>，使得$P^{-1}AP = B$，则称<strong>A</strong>与<strong>B</strong>相似，记作$A\sim B$</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>矩阵A和矩阵B相似，$A\sim B$</p><ol><li>A、B的特征值相等</li><li>若A、B皆为可逆矩阵，则$A^{-1}\sim B^{-1}$</li><li>A、B的行列式相等，$|A| = |B|$</li><li>A、B的迹（正对角线相加）相等，$tr(A) = tr(B)$</li><li>$A^m \sim B^m$</li></ol><h3 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h3><p>若一个矩阵与对角矩阵相似，则称矩阵可以对角化</p><p>存在可逆矩阵P，使得$P^{-1}AP = \Lambda $，其中$\Lambda$为对角矩阵，$A \sim \Lambda$</p><p>其中$P = (X_1 , X_2 , X_3)$，$X$为矩阵A的特征向量，$X = (a　b　c)^T$。<strong>其中$X_1 , X_2 , X_3$线性无关，$P$可逆</strong></p><h3 id="相似对角化性质"><a href="#相似对角化性质" class="headerlink" title="相似对角化性质"></a>相似对角化性质</h3><p>n阶方阵A可以相似对角化</p><ol><li>充分必要条件：A有n个线性无关的特征向量</li><li>属于不同特征值的特征向量一定线性无关</li><li>A有n个不相等的特征值→A可以相似对角化</li><li>若A有重特征值<ol><li>当重特征值（$\lambda _1=\lambda _2 = \cdots = \lambda _n$，n为重特征值的个数）对应的<strong>线性无关的特征向量的个数</strong>等于<strong>特征值的重数</strong>时，则A可相似对角化</li><li>$r(\lambda E-A) = n-k$，k为线性无关的特征向量个数。</li></ol></li><li>若A为m阶实对称矩阵，则A可对角化</li></ol><p>若A不可以相似对角化，则一定有重根</p><h3 id="对角矩阵的求法"><a href="#对角矩阵的求法" class="headerlink" title="对角矩阵的求法"></a>对角矩阵的求法</h3><ol><li><p>利用$|\lambda E - A| = 0$求出特征值$\lambda _1,\lambda _2,\cdots,\lambda _n$</p></li><li><script type="math/tex; mode=display">\Lambda = \begin{pmatrix}\lambda_1 &          \\          & \lambda_2\\          &           & \ddots \\          &           &           & \lambda_n\end{pmatrix}</script></li></ol><h3 id="矩阵的幂的计算"><a href="#矩阵的幂的计算" class="headerlink" title="矩阵的幂的计算"></a>矩阵的幂的计算</h3><p>设有n阶矩阵A，并且A可以对角化，对角化为$\Lambda $</p><script type="math/tex; mode=display">A^{100} = (P^{-1}\Lambda P)^{100} = P\Lambda P^{-1}*P\Lambda P^{-1}*\cdots*P\Lambda P^{-1} = P\Lambda ^{100}P^{-1}</script><h1 id="二次型及其标准形"><a href="#二次型及其标准形" class="headerlink" title="二次型及其标准形"></a>二次型及其标准形</h1><h2 id="章节概括-2"><a href="#章节概括-2" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>二次型的定义与矩阵表示</li><li>化二次型为标准形与规范形<ul><li>配方法</li><li>正交变换法</li><li>合同</li><li>惯性定理</li></ul></li><li>正定二次型<ul><li>定义</li><li>充要条件</li><li>必要条件</li><li>判定<ul><li>具体型二次型</li><li>抽象型二次型</li></ul></li></ul></li></ul><h2 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>含n个变量$x_1,x_2,\cdots,x_n$且每项皆为二次的多项式</p><p>二次型的矩阵都是对称矩阵，即$A^T = A$</p><h3 id="形态"><a href="#形态" class="headerlink" title="形态"></a>形态</h3><script type="math/tex; mode=display">f(x_1,x_2,\cdots,x_n) = a_{11}x_1^2+\cdots+a_{nn}x_n^2+2a_{12}x_1x_2 + \cdots+2a_{n-1,n}x_{n-1}x_n</script><script type="math/tex; mode=display">也可以写成 = \sum_{i=1}^{n} \sum_{j=1}^{n} a_{ij}x_ix_j</script><h2 id="二次型转换成矩阵表达式"><a href="#二次型转换成矩阵表达式" class="headerlink" title="二次型转换成矩阵表达式"></a>二次型转换成矩阵表达式</h2><ol><li>平方项的系数直接做成主对角元素</li><li>交叉项的系数除以2，放两个对称的相应位置上</li></ol><h3 id="转换示例"><a href="#转换示例" class="headerlink" title="转换示例"></a>转换示例</h3><p>$f(x_1,x_2,\cdots,x_n) = 2x_1^2 - 3x_2^2 + x_3^2$的转换</p><script type="math/tex; mode=display">令X = \begin{pmatrix}x_1 \\x_2 \\x_3 \\\end{pmatrix},A = \begin{pmatrix}2 &  0 & 0\\0 & -3 & 0 \\0 &  0 & 1\\\end{pmatrix}，则f(x_1,x_2,\cdots,x_n) = X^TAX</script><script type="math/tex; mode=display">f(x_1,x_2,\cdots,x_n) = x_1^2 - x_2^2 + 2x_3^2 + 4x_1x_2 -2x_1x_3 + 6x_2x_3的转换</script><script type="math/tex; mode=display">令X = \begin{pmatrix}x_1 \\x_2 \\x_3 \\\end{pmatrix},A = \begin{pmatrix}1 &  2 & -1\\2 & -1 & 3 \\-1 &  3 & 2\\\end{pmatrix}，则f(x_1,x_2,\cdots,x_n) = X^TAX</script><script type="math/tex; mode=display">\begin{align}提取4x_1x_2中的系数4，将该系数除于2放在a_{12}、a_{21}中\\提取-2x_1x_3中的系数-2，将该系数除于2放在a_{13}、a_{31}中\\提取6x_2x_3中的系数6，将该系数除于2放在a_{23}、a_{32}中\\\end{align}</script><h2 id="标准二次形"><a href="#标准二次形" class="headerlink" title="标准二次形"></a>标准二次形</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>只含有平方项不含交叉项的二次型</p><p><strong>系数为1和-1的标准二次型为规范二次型</strong></p><p><strong>标准形不唯一，规范形唯一，坐标变换不唯一</strong></p><h3 id="形态-1"><a href="#形态-1" class="headerlink" title="形态"></a>形态</h3><script type="math/tex; mode=display">f(x_1,x_2,\cdots,x_n) = 2x_1^2 - 3x_2^2 + x_3^2</script><script type="math/tex; mode=display">A = \begin{pmatrix}2 &  0 & 0\\0 & -3 & 0 \\0 &  0 & 1\\\end{pmatrix}</script><h3 id="惯性定理"><a href="#惯性定理" class="headerlink" title="惯性定理"></a>惯性定理</h3><p>二次型的标准型系数中正系数、负系数的个数保持不变，其中<strong>正系数的个数</strong>称为二次型的<strong>正惯性指数</strong>，<strong>负系数的个数</strong>称为二次型的<strong>负惯性指数</strong></p><p>在二次型中，利用二次型化成对称矩阵，求出该矩阵的特征值，其中<strong>正特征值的个数</strong>就是<strong>正惯性指数</strong>，<strong>负特征值的个数</strong>就是<strong>负惯性指数</strong>。0不算为任何的惯性指数</p><p>标准型相同，正、负惯性指数相同</p><h3 id="可逆的线性变换-替换"><a href="#可逆的线性变换-替换" class="headerlink" title="可逆的线性变换(替换)"></a>可逆的线性变换(替换)</h3><script type="math/tex; mode=display">设X = \begin{pmatrix}x_1\\\vdots\\x_n\\\end{pmatrix},Y = \begin{pmatrix}y_1\\\vdots\\y_n\\\end{pmatrix}</script><p>若P为可逆的矩阵，称$X=PY$为<strong>可逆的线性变换</strong>，若P为<strong>正交矩阵</strong>，称$X=PY$为正交变换，<strong>正交变换是一种特殊的可逆线性变换</strong></p><h3 id="二次型的标准化"><a href="#二次型的标准化" class="headerlink" title="二次型的标准化"></a>二次型的标准化</h3><p>设$f(X) = X^TAX$为一个二次型，若经过可逆的线性变换$X = PY$把二次型$f(X) = X^TAX$化为</p><script type="math/tex; mode=display">f(X) = X^TAX \overset{X=PY}{===>} Y^T(P^TAP)Y = l_1y_1^2+l_2y_2^2+\cdots+l_my_m^2</script><h3 id="二次型的标准化方法"><a href="#二次型的标准化方法" class="headerlink" title="二次型的标准化方法"></a>二次型的标准化方法</h3><blockquote><p>链接：<a href="https://blog.csdn.net/weixin_45826022/article/details/106214444">二次型化标准形的五种方法<em>终曲-CSDN博客</em>二次型化为标准型</a></p></blockquote><h4 id="配方法"><a href="#配方法" class="headerlink" title="配方法"></a>配方法</h4><p>将$x_1，x_2，x_3，\cdots，x_n$转换为$y_1，y_2，y_3，\cdots，y_n$的式子，若转化后的式子不是标准型，继续化成$z_1，z_2，z_3，\cdots，z_n$的式子</p><ol><li>先提取和配$x_1$，再提取和配$x_2$，接着提取和配$x_3$，$\cdots$，配完$x_1$后，后面的式子不能出现$x_1$，以下同理。</li></ol><p>例子：</p><ol><li>将二次型$f(x_1,x_2,x_3) = x_1^2 + x_2x_3$转换成标准型</li></ol><script type="math/tex; mode=display">令\left\{\begin{matrix}x_1 = y_1\\x_2 = y_2-y_3\\x_3 = y_2+y_3\end{matrix}\right.，即X = PY，其中X = \begin{pmatrix}x_1\\x_2\\x_3\end{pmatrix}，Y=\begin{pmatrix}y_1\\y_2\\y_3\end{pmatrix}，P = \begin{pmatrix}1 & 0 & 0\\0 & 1 & -1\\0 & 1 & 1\end{pmatrix}</script><script type="math/tex; mode=display">因为|P|\neq 0,P可逆，则f(x_1,x_2,x_3) = X^TAX \overset{X=PY}{=} Y^T(P^TAP)Y = y_1^2 + y_2^2 - y_3^2</script><ol><li>将二次型$f(x_1,x_2,x_3) = x_1^2 + 2x_1x_2 + 2x_1x_3 - 4x_3^2$转换成标准型</li></ol><script type="math/tex; mode=display">\begin{align}x_1^2 + 2x_1x_2 + 2x_1x_3 - 4x_3^2 \\= x_1^2 +2x_1(x_2 + x_3) -4x_3^2 \\= x_1^2 +2x_1(x_2 + x_3) +(x_2 + x_3)^2 - (x_2 + x_3)^2 -4x_3^2 \\= (x_1 + x_2 + x_3)^2 - (x_2 + x_3)^2 -4x_3^2\end{align}</script><script type="math/tex; mode=display">令\left\{\begin{matrix}y_1 = x_1+x_2+x_3\\y_2 = x_2+x_3\\y_3 = x_3\end{matrix}\right.，求得\left\{\begin{matrix}x_1 = y_1-y_2\\x_2 = y_2-y_3\\x_3 = y_3\end{matrix}\right.，即X = PY，P = \begin{pmatrix}1 & -1 & 0\\0 & 1 & -1\\0 & 0 & 1\end{pmatrix}</script><script type="math/tex; mode=display">因为|P|\neq 0,P可逆，则f(x_1,x_2,x_3) = X^TAX \overset{X=PY}{=} Y^T(P^TAP)Y = y_1^2 - y_2^2 - 4y_3^2</script><h4 id="正交变换法"><a href="#正交变换法" class="headerlink" title="正交变换法"></a>正交变换法</h4><ol><li>将二次型转换成系数矩阵A</li><li>求A的特征值$\lambda_1,\lambda_2,\lambda_3,\cdots,\lambda_n$</li><li>求特征向量$\xi_1,\xi_2,\xi_3,\cdots,\xi_n$</li></ol><h2 id="矩阵合同"><a href="#矩阵合同" class="headerlink" title="矩阵合同"></a>矩阵合同</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>设<strong>A,B</strong>为n阶矩阵，若存在可逆矩阵P，使得$P^TAP = B$，称矩阵A与B合同，记$A\simeq B$</p><h3 id="二次型合同"><a href="#二次型合同" class="headerlink" title="二次型合同"></a>二次型合同</h3><p>设$X^TAX$与$X^TBX$为两个二次型，若矩阵A合同于B，称二次型$X^TAX$与$X^TBX$合同</p><h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h3><p>设<strong>A,B</strong>为n阶<strong>可逆矩阵</strong>，$A\simeq B$</p><ol><li>$A\simeq B，B\simeq C，则A\simeq C$</li><li>$r(A) = r(B)$</li><li>$A^T = A \Leftrightarrow B^T = B$</li><li>$A^{-1}\simeq B^{-1}$</li><li>$A^{T}\simeq B^{T}$</li></ol><h2 id="正定二次型与正定矩阵"><a href="#正定二次型与正定矩阵" class="headerlink" title="正定二次型与正定矩阵"></a>正定二次型与正定矩阵</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>设二次型$f(x_1,x_2,x_3) = X^TAX$，若对于任意的$X \neq 0$，总有$f(x_1,x_2,x_3) = X^TAX &gt; 0$，称$f(x_1,x_2,x_3) = X^TAX$为正定二次型，其中<strong>A</strong>为正定矩阵</p><p>设二次型$f(x_1,x_2,x_3) = X^TAX$，若对于任意的$X$，总有$f(x_1,x_2,x_3) = X^TAX \ge 0$，且$f(x_1,x_2,x_3) = X^TAX = 0$当且仅当$X=0$，称$f(x_1,x_2,x_3) = X^TAX$为正定二次型，其中<strong>A</strong>为正定矩阵</p><h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h3><ol><li><p>二次型$f(X) = X^TAX$正定的充分必要条件是A的<strong>特征值全为正</strong></p></li><li><p>二次型$f(X) = X^TAX$为正定二次型的充分必要条件如下，即矩阵A的所有<strong>顺序主子式都大于0</strong></p><ol><li><script type="math/tex; mode=display">a_{11} > 0，\begin{vmatrix} a_{11} & a_{12}\\ a_{21} & a_{22}\\\end{vmatrix}>0,\cdots,|A|>0</script></li></ol></li><li><p>存在可逆矩阵P，使得$A = P^TP$或$A\simeq E$</p></li><li><p>二次型$f(X) = X^TAX$的<strong>正惯性指数为n</strong>（n阶矩阵）</p></li><li><p>若A是正定矩阵，则A的逆矩阵也是正定矩阵；</p></li><li><p>两个正定矩阵的和是正定矩阵；</p></li><li><p>正实数与正定矩阵的乘积是正定矩阵。</p></li><li><p><strong>A与E合同</strong></p></li></ol><h2 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>设<strong>A</strong>为n阶矩阵，$A^TA = AA^T = E$，称A为正交矩阵</p><h3 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h3><p>设<strong>A</strong>为正交矩阵</p><ol><li>$A^{-1} = A^T$</li><li>$|A| = \pm1$</li><li>$A的特征值为\pm1$</li><li>设<strong>Q</strong>为正交矩阵，且$Y = QX$，则$||X|| = ||Y||$，在二维和三维空间中，正交变换本质上相当于坐标系作一个旋转变换</li></ol><h2 id="施密特正交变换"><a href="#施密特正交变换" class="headerlink" title="施密特正交变换"></a>施密特正交变换</h2><p>施密特正交化是对<strong>一组线性无关的向量</strong>进行的<strong>正交化变换</strong>。<strong>任意一组线性无关的向量</strong>都可以通过施密特正交化<strong>变换为一组单位正交向量</strong>。既任意一组基向量可经过施密特正交化化为一组单位正交基。</p><h3 id="正交变换过程"><a href="#正交变换过程" class="headerlink" title="正交变换过程"></a>正交变换过程</h3><script type="math/tex; mode=display">令\beta_1 = \alpha_1</script><script type="math/tex; mode=display">\beta_2 = \alpha_2 - \frac{(\beta_1,\alpha_2)}{(\beta_1,\beta_1)}\beta_1</script><script type="math/tex; mode=display">\beta_3 = \alpha_3 - \frac{(\beta_1,\alpha_3)}{(\beta_1,\beta_1)}\beta_1 - \frac{(\beta_2,\alpha_3)}{(\beta_2,\beta_2)}\beta_2</script><script type="math/tex; mode=display">(\beta_1,\alpha_2)为\beta_1与\alpha_2的内积</script><h1 id="矩阵关系总结"><a href="#矩阵关系总结" class="headerlink" title="矩阵关系总结"></a>矩阵关系总结</h1><h2 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h2><p>适用范围：同型矩阵</p><script type="math/tex; mode=display">A、B同型矩阵，存在可逆矩阵P、Q，PAQ = B，r(A) = r(B)</script><h2 id="相似"><a href="#相似" class="headerlink" title="相似"></a>相似</h2><p>适用范围：方阵</p><script type="math/tex; mode=display">A、B同阶方阵，存在可逆矩阵P，P^{-1}AP = B,\lambda_A = \lambda_B，|A| = |B|，tr(A) = tr(B)</script><h2 id="正交相似"><a href="#正交相似" class="headerlink" title="正交相似"></a>正交相似</h2><script type="math/tex; mode=display">A、B同阶方阵，存在正交矩阵P，P^{-1}AP = B，P^{T}AP = B</script><h2 id="合同"><a href="#合同" class="headerlink" title="合同"></a>合同</h2><p>适用范围：实对称矩阵</p><script type="math/tex; mode=display">A、B同阶方阵，存在可逆矩阵P，P^{T}AP = B;A、B的正负惯性指数相同，A、B特征值中正、负个数相同</script><h2 id="关系图像"><a href="#关系图像" class="headerlink" title="关系图像"></a>关系图像</h2><p><img src="../../image/image-20210923170303530.png" alt="关系图像"></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java的Websocket开发</title>
    <link href="/my_world/content/java%E7%9A%84Websocket%E5%BC%80%E5%8F%91/"/>
    <url>/my_world/content/java%E7%9A%84Websocket%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h1><p><strong>WebSocket</strong>是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。</p><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。主要用在对消息实时性比较高的场景.用来替代轮询方案</p><p>websocket使用场景具体如下：</p><ul><li>实时在线聊天</li><li>浏览器之间的协同编辑工作</li><li>多人在线游戏</li></ul><h1 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h1><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.java-websocket/Java-WebSocket --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.java-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Java-WebSocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="服务器实现"><a href="#服务器实现" class="headerlink" title="服务器实现"></a>服务器实现</h2><p>继承WebSocketServer类监听各类事件，主要有以下五个事件：</p><ul><li><strong>onStart：</strong> 服务器启动事件</li><li><strong>onOpen：</strong> 连接打开事件</li><li><strong>onMessage：</strong> 接收消息事件</li><li><strong>onClose：</strong> 连接关闭事件</li><li><strong>onError：</strong> 连接出错事件</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * websocket服务端</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">server</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSocketServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> InetSocketAddress(port));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(WebSocket webSocket, ClientHandshake clientHandshake)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;有人进来了&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">(WebSocket webSocket, <span class="hljs-keyword">int</span> i, String s, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(WebSocket webSocket, String s)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;收到来自客户端的消息: &quot;</span>+s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(WebSocket webSocket, Exception e)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        server server = <span class="hljs-keyword">new</span> server(<span class="hljs-number">8111</span>); <span class="hljs-comment">// 设置端口号</span>        server.start(); <span class="hljs-comment">// 开启服务器</span>        System.out.println(<span class="hljs-string">&quot;服务器端启动，端口号为: &quot;</span>+server.getPort());        <span class="hljs-comment">// 等待输入</span>        BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            String in = bufferedReader.readLine(); <span class="hljs-comment">// 不断读取输入的行数据</span>            server.broadcast(in); <span class="hljs-comment">// 服务端接受输入的行数据</span>            <span class="hljs-comment">/* 如果输入exit命令，则关闭服务器 */</span>            <span class="hljs-keyword">if</span>(in.equals(<span class="hljs-string">&quot;exit&quot;</span>))&#123;                server.stop(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 停止server</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>和服务端一样，继承WebSocketClient类监听各类事件，事件的作用参考</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.java_websocket.WebSocket;<span class="hljs-keyword">import</span> org.java_websocket.client.WebSocketClient;<span class="hljs-keyword">import</span> org.java_websocket.enums.ReadyState;<span class="hljs-keyword">import</span> org.java_websocket.handshake.ServerHandshake;<span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.net.URI;<span class="hljs-keyword">import</span> java.net.URISyntaxException;<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 客户端</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">client</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSocketClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">client</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> URISyntaxException </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> URI(url));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(ServerHandshake serverHandshake)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String s)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;服务端发送了一个请求:&quot;</span>+s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, String s, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;关闭客户端&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Exception e)</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> URISyntaxException, InterruptedException, IOException </span>&#123;        client client = <span class="hljs-keyword">new</span> client(<span class="hljs-string">&quot;ws://localhost:8111//&quot;</span>); <span class="hljs-comment">// 传入url</span>        System.out.println(<span class="hljs-string">&quot;建立websocket连接&quot;</span>);        client.connectBlocking(); <span class="hljs-comment">// 连接服务器，直到连接成功后继续</span>        <span class="hljs-comment">// 等待输入</span>        BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            String in = bufferedReader.readLine(); <span class="hljs-comment">// 不断读取输入的行数据</span>            <span class="hljs-comment">/* 如果输入exit命令，则关闭服务器 */</span>            <span class="hljs-keyword">if</span> (in.equals(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;                client.close(); <span class="hljs-comment">// 停止client</span>                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                client.send(in);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>先启动服务端后再启动client，在client类中的终端输入字符，可看到在server端有返回字符</p><p><img src="../../image/image-20220530155520494.png" alt="client中输入字符并按enter"></p><p><img src="../../image/image-20220530155608554.png" alt="服务端接受信息"></p><p>并且在server中的终端输入字符，也能看到client端有返回字符。</p><p><img src="../../image/image-20220530155645853.png" alt="server中输入字符并按enter"></p><p><img src="../../image/image-20220530155723915.png" alt="客户端接受信息"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>版本管理工具使用大全</title>
    <link href="/my_world/content/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8/"/>
    <url>/my_world/content/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>版本管理是为满足不同需求，对同一产品或系统进行局部的改进 和改型所产生的产品或系统系列的变更情况进行记录、跟 踪、维护和控制的过程。</p><p>它的主要功能有：</p><p>集中管理档案，安全授权机制：档案集中地存放在服务器上，经系统管理员授权给各个用户。用户通过check in和check out的方式访问服务器上的文件，未经授权的用户则无法访问服务器上的文件。</p><p>软件版本升级管理：每次登入时，在服务器上都会生成新的版本，任何版本都可以随时检出编辑。</p><p>加锁功能：在文件更新时保护文件，避免不同的用户更改同一文件时发生冲突。</p><p>提供不同版本源程序的比较。</p><h1 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h1><p>Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>windows</strong></p><blockquote><p>下载地址：<a href="https://www.tortoisesvn.net/downloads.zh.html">下载 · TortoiseSVN</a></p></blockquote><p>选好路径next即可</p><h2 id="代码仓库提取到本地"><a href="#代码仓库提取到本地" class="headerlink" title="代码仓库提取到本地"></a>代码仓库提取到本地</h2><ol><li>右键使用<code>svn checkout</code></li><li>在URL of repository中修改代码仓库地址，如：<code>http://192.168.3.1/project/xxxx</code>；在checkout directory中修改提取到本地的位置</li><li>点击OK，并等待拉取成功</li></ol><h2 id="更新目录"><a href="#更新目录" class="headerlink" title="更新目录"></a>更新目录</h2><p>本地更新到远程库中的最新文件</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">svn update</span></code></pre></div><h2 id="提交操作"><a href="#提交操作" class="headerlink" title="提交操作"></a>提交操作</h2><p>为服务器提交修改，并保存在服务器上</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">svn commit</span></code></pre></div><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p><strong>Jenkins</strong>是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><p>前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。Jenkins可以通过本机系统包Docker安装，甚至可以通过安装Java Runtime Environment的任何机器独立运行。</p><p>主要用于：</p><ol><li>持续、自动地构建/测试软件项目，如CruiseControl与DamageControl。</li><li>监控一些定时执行的任务</li></ol><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><blockquote><p>Jenkins下载地址：<a href="https://www.jenkins.io/download/">Jenkins download and deployment</a></p></blockquote><h3 id="Windows—tomcat"><a href="#Windows—tomcat" class="headerlink" title="Windows—tomcat"></a>Windows—tomcat</h3><ol><li>在下载地址中找到Windows版本，下载到本地</li><li>搭建java环境，将java加入环境变量</li><li>安装选择下一步，在端口设置中改为8181后，下一步安装完毕即可</li><li>安装tomcat，将Jenkins.war复制一份到tomcat中的webapps中</li><li>修改tomcat中的server.xml，把tomcat端口修改为8181</li><li>运行bin中的startup.bat，在浏览器中输入localhost:8181即可打开jenkins</li><li>按照jenkins中的提示一步一步走即可</li></ol><h3 id="Windows—Jenkins"><a href="#Windows—Jenkins" class="headerlink" title="Windows—Jenkins"></a>Windows—Jenkins</h3><ol><li>使用命令<code>net start jenkins</code>开启服务</li><li>在浏览器中输入<code>localhost:8233</code>开启jenkins（可在<code>jenkins.xml</code>修改端口）</li></ol><h3 id="Windows—java（推荐）"><a href="#Windows—java（推荐）" class="headerlink" title="Windows—java（推荐）"></a>Windows—java（推荐）</h3><ol><li>使用<code>java -jar jenkins.war</code>即可运行（jenkins本身是由springboot开发，所以可以直接用java命令开启）</li><li>在浏览器中输入localhost:8080即可打开jenkins</li></ol><h2 id="创建构建任务"><a href="#创建构建任务" class="headerlink" title="创建构建任务"></a>创建构建任务</h2><p>点击新建Item</p><p><img src="../../image/image-20220525150650488.png" alt="新建item"></p><p>输入任务名并点击Freestyle project，完毕后点击确定</p><p><img src="../../image/image-20220525150739437.png" alt="输入任务名称"></p><p>配置<strong>Source Code Management</strong>，这个地方用于获取git、svn中的代码，git就选择git，svn就选择Subversion</p><p>配置<strong>Build Triggers</strong>，用于定时执行任务</p><p>配置<strong>Build</strong>，Linux环境下在Build中选择<code>执行Shell</code>，Windows环境下选择<code>执行Windows批处理命令</code>（其他的也可，但是Shell命令是很普遍的，所以强烈推荐），然后输入Command，这样就可以让kenkins执行的时候执行该命令运行代码，参考如下：</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash -e</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 寻找miniconda3的sh，并激活conda环境</span>. $HOME/miniconda3/etc/profile.d/conda.shconda activate xxxxxxcd ./src/main/python -m main</code></pre></div><h2 id="定时构建"><a href="#定时构建" class="headerlink" title="定时构建"></a>定时构建</h2><p>语法：* <em> </em> <em> </em></p><p>（五颗星，多个时间点，中间用逗号隔开）</p><p>第一个表示分钟，取值0~59</p><p>第二个表示小时，取值0~23</p><p>第三个表示一个月的第几天，取值1~31</p><p>第四个表示第几月，取值1~12</p><p>第五个表示一周中的第几天，取值0~7，其中0和7代表的都是周日</p><blockquote><p>源自<a href="https://www.cnblogs.com/zhongyehai/p/10577168.html">jenkins持续集成：定时构建语法 - 向前走。 - 博客园 (cnblogs.com)</a></p></blockquote><p><img src="../../image/image-20220629164141972.png" alt="含义"></p><h2 id="超时抛弃构建"><a href="#超时抛弃构建" class="headerlink" title="超时抛弃构建"></a>超时抛弃构建</h2><p>在使用jenkins进行自动编译、构建时有些任务可能由于网络或其他原因一直阻塞，导致该项目不能再次执行编译构建。我们希望在某些任务执行时间超过一定值时将其终止。</p><p>jenkins的<code>build timeout plugin</code>插件可以帮我们完成该任务。jenkins的2.7.1版本默认就已经安装了该插件，如果默认没有安装可在插件管理中搜索进行安装。</p><p><img src="../../image/image-20220815092403407.png" alt="超时终止构建任务设置"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>svn</tag>
      
      <tag>jenkens</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学公式大全（三）</title>
    <link href="/my_world/content/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/my_world/content/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h1><h2 id="章节概括"><a href="#章节概括" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>基本概念<ul><li>平面点集的基本概念</li><li>极限</li><li>连续</li><li>偏导数</li><li>可微</li><li>偏导数的连续性</li></ul></li><li>多元函数微分法则<ul><li>链式求导规则</li><li>隐函数存在定理（公式法）</li></ul></li><li>多元函数的极值与最值<ul><li>概念</li><li>无条件极值<ul><li>隐函数</li><li>显函数</li></ul></li><li>条件极值与拉格朗日乘数法<ul><li>闭区间边界上的最值</li><li>闭区域上的最值</li></ul></li></ul></li></ul><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>设二元函数$ f(P) = f(x,y) $的定义域为D，$ P_0(x_0,y_0) $是D的聚点</p><p>如果存在常数A，对于任意给定的正数$ \epsilon $，总存在正数$ \delta $，使得当点$ P(x,y) \in D \cap U^{\circ}(P_0,\delta ) $时，都有$ |f(x,y) - A| &lt; \epsilon $成立</p><p>那么就称常数A为函数$ f(x,y) $当$ (x,y) \rightarrow (x_0,y_0) $的极限，记作</p><script type="math/tex; mode=display">\lim_{(x,y) \rightarrow (x_0,y_0)} f(x,y) = A或f(x,y) \rightarrow A((x,y) \rightarrow (x_0,y_0))</script><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><p>如果</p><script type="math/tex; mode=display">\lim_{x \rightarrow x_0 \ \ y \rightarrow y_0} f(x,y) = f(x_0,y_0)</script><p>则称$ f(x,y) $在点$ (x_0,y_0) $处连续</p><h2 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h2><p>设函数$ z = f(x,y)在点(x_0,y_0) $的某领域内有定义。若极限</p><script type="math/tex; mode=display">\lim_{\Delta x \rightarrow 0}\frac{f(x_0+\Delta x,y_0) - f(x_0,y_0)}{\Delta x}</script><p>存在，则称此极限为函数$ z = f(x,y)在点(x_0,y_0) $处对x的<strong>偏导数</strong>，记作</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}\mid_{x =x_0,y = y_0} , \frac{\partial f}{\partial x}\mid_{x =x_0,y = y_0} , z^\prime_x\mid_{x =x_0,y = y_0} , f^\prime_x(x_0,y_0)</script><p>于是</p><script type="math/tex; mode=display">f^\prime_x(x_0,y_0) = \lim_{\Delta x \rightarrow 0}\frac{f(x_0+\Delta x,y_0) - f(x_0,y_0)}{\Delta x} = \lim_{x \rightarrow x_0}\frac{f(x,y_0) - f(x_0,y_0)}{x - x_0}</script><script type="math/tex; mode=display">f^\prime_y(x_0,y_0) = \lim_{\Delta y \rightarrow 0}\frac{f(x_0,y_0+\Delta y) - f(x_0,y_0)}{\Delta y} = \lim_{y \rightarrow y_0}\frac{f(x_0,y) - f(x_0,y_0)}{y - y_0}</script><p>如果函数$ z = f(x,y) $在区域D内的偏导数$ f^\prime_x(x,y),f^\prime_y(x,y) $仍具有偏导数，则它们的偏导数称为函数$ z = f(x,y) $的<strong>二阶偏导数</strong>，按照对变量求导次序的不同，有如下四个二阶偏导数</p><script type="math/tex; mode=display">\frac{\partial}{x}(\frac{\partial z}{x}) = \frac{\partial^2 z}{\partial x^2} = f^"_{xx}(x,y),\frac{\partial}{y}(\frac{\partial z}{x}) = \frac{\partial^2 z}{\partial x\partial y} = f^"_{xy}(x,y)</script><script type="math/tex; mode=display">\frac{\partial}{y}(\frac{\partial z}{y}) = \frac{\partial^2 y}{\partial y^2} = f^"_{yy}(x,y),\frac{\partial}{x}(\frac{\partial z}{y}) = \frac{\partial^2 z}{\partial y\partial x} = f^"_{yx}(x,y)</script><p>其中$ f^”<em>{xy}(x,y)，f^”</em>{yx}(x,y) $称为<strong>混合偏导数</strong></p><p>同样可得三阶、四阶以及n阶偏导数，二阶及二阶以上的偏导数统称为<strong>高阶偏导数</strong></p><h2 id="可微"><a href="#可微" class="headerlink" title="可微"></a>可微</h2><p>如果函数$ z = f(x,y) $在点$ (x,y) $的<strong>全增量</strong>$ \Delta z = f(x+\Delta x , y + \Delta y) - f(x,y) $</p><p>可表示为</p><script type="math/tex; mode=display">\Delta z = A\Delta x+B\Delta y+o(\rho)(\rho \rightarrow 0)</script><p>其中$ \rho = \sqrt{(\Delta x)^2 + \Delta y)^2} $，A，B不依赖于$ \Delta x , \Delta y $而仅与x,y有关</p><p>则称函数$ z = f(x,y) $在点$ (x,y) $可微，而称$ A\Delta x+B\Delta y $为函数$ z = f(x,y) $在点$ (x,y) $的<strong>全微分</strong>，记作$ dz $，即</p><script type="math/tex; mode=display">dz = A\Delta x+B\Delta y</script><p>判断函数$ z = f(x,y) $在点$ (x,y) $是否可微，步骤如下：</p><ol><li>写出全增量$ \Delta z = f(x+\Delta x , y + \Delta y) - f(x,y) $</li><li>写出线性增量$ A\Delta x+B\Delta y $，其中$ A = f^\prime_x(x_0,y_0),B = f^\prime_y(x_0,y_0) $</li><li>作极限如下，若该极限等于0，则$ z = f(x,y) $在点$ (x_0,y_0) $<strong>可微</strong>，否则就不可微</li></ol><script type="math/tex; mode=display">\lim_{\Delta x \rightarrow 0,\Delta y \rightarrow 0} \frac{\Delta z - (A\Delta x+B\Delta y)}{\sqrt{(\Delta x)^2 + \Delta y)^2}}</script><h2 id="偏导数的连续性"><a href="#偏导数的连续性" class="headerlink" title="偏导数的连续性"></a>偏导数的连续性</h2><p>对于函数$ z = f(x,y) $，讨论其在某特殊点$ (x_0,y_0) $（比如二元分段函数的分段点）处偏导数是否连续，步骤为</p><ol><li>用定义法求$ f^\prime_x(x_0,y_0),f^\prime_y(x_0,y_0) $</li><li>用公式法求$ f^\prime_x(x,y),f^\prime_y(x,y) $</li><li>计算$ \lim<em>{x \rightarrow x_0,y \rightarrow y_0}f^\prime_x(x,y),\lim</em>{x \rightarrow x_0,y \rightarrow y_0}f^\prime_y(x,y) $</li></ol><p>看$ \lim<em>{x \rightarrow x_0,y \rightarrow y_0}f^\prime_x(x,y) = f^\prime_x(x_0,y_0),\lim</em>{x \rightarrow x_0,y \rightarrow y_0}f^\prime_y(x,y)=f^\prime_y(x_0,y_0) $是否成立，则$ z = f(x,y) $在点$ (x_0,y_0) $处的偏导数是连续的</p><h2 id="链式求导法则"><a href="#链式求导法则" class="headerlink" title="链式求导法则"></a>链式求导法则</h2><p>复合函数的中间变量均为一元函数的情形：</p><p>设$ z = f(u,v),u = \alpha (x),v = \beta(x) $，则$ z = f[\alpha(x),\beta(x)] $，且</p><script type="math/tex; mode=display">\frac{dz}{dx} = \frac{\partial z}{\partial u} \cdot  \frac{d u}{d x} + \frac{\partial z}{\partial v} \cdot  \frac{d v}{d x}</script><p>复合函数的中间变量均为多元函数的情形：</p><p>设$ z = f(u,v),u = \alpha (x,y),v = \beta(x,y) $，则$ z = f[\alpha(x,y),\beta(x,y)] $，且</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x} = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial x} + \frac{\partial z}{\partial v} \cdot \frac{\partial v}{\partial x}</script><script type="math/tex; mode=display">\frac{\partial z}{\partial y} = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial y} + \frac{\partial z}{\partial v} \cdot \frac{\partial v}{\partial y}</script><p>复合函数的中间变量既有一元函数，又有多元函数的情形：</p><p>设$ z = f(u,v),u = \alpha (x,y),v = \beta(y) $，则$ z = f[\alpha(x,y),\beta(y)] $，且</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x} = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial x}</script><script type="math/tex; mode=display">\frac{\partial z}{\partial y} = \frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial y} + \frac{\partial z}{\partial v} \cdot \frac{\partial v}{\partial y}</script><h2 id="隐函数存在定理（公式法）"><a href="#隐函数存在定理（公式法）" class="headerlink" title="隐函数存在定理（公式法）"></a>隐函数存在定理（公式法）</h2><p>设函数$ F(x,y,z) $在点$ P(x_0,y_0,z_0) $的某一领域内具有连续偏导数，且$ F(x,y,z) = 0,F_z^\prime(x_0,y_0,z_0) = 0 $</p><p>则方程$ F(x,y,z) = 0 $在点$ (x_0,y_0,z_0) $的某一领域内能唯一确定一个连续且具有连续偏导数的函数$ z = f(x,y) $，它满足条件$ z_0 = f(x_0,y_0) $，并有</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x} = -\frac{F^\prime_x}{F^\prime_z},\frac{\partial z}{\partial y} = -\frac{F^\prime_y}{F^\prime_z}</script><h2 id="多元函数的无条件极值"><a href="#多元函数的无条件极值" class="headerlink" title="多元函数的无条件极值"></a>多元函数的无条件极值</h2><p>二元函数取极值的必要条件（类比一元函数）</p><p>设$ z = f(x,y) $在点$ (x_0,y_0) $<strong>一阶偏导数存在</strong>并<strong>取极值</strong>，则$ f_x^\prime(x_0,y_0) = 0,f_y^\prime(x_0,y_0) = 0 $</p><p>二元函数取极值的充分条件</p><p>记$ f<em>{xx}^”(x_0,y_0) = A，f</em>{xy}^”(x<em>0,y_0) = B，f</em>{yy}^”(x_0,y_0) = C $</p><p>则$ \Delta = AC - B^2$，若$ \Delta &gt; 0$取极值（A<0取极大值，A>0取极小值）</p><p>$ \Delta &gt; 0 $不取极值，$ \Delta = 0 $方法失效</p><h2 id="条件极值与拉格朗日乘数法"><a href="#条件极值与拉格朗日乘数法" class="headerlink" title="条件极值与拉格朗日乘数法"></a>条件极值与拉格朗日乘数法</h2><p>求目标函数$ u = f(x,y,z) $在条件$ \alpha(x,y,z) = 0,\beta(x,y,z) = 0 $下的最值，则</p><ol><li>构造辅助函数$ F(x,y,z,\lambda,\mu) = f(x,y,z) +\lambda \alpha(x,y,z) +\mu \beta(x,y,z) $</li><li>令</li></ol><script type="math/tex; mode=display">\begin{cases}F_x^\prime = f_x^\prime + \lambda \alpha^\prime_x +\mu \alpha_y^\prime = 0 \\F_y^\prime = f_y^\prime + \lambda \alpha^\prime_y +\mu \alpha_y^\prime = 0 \\F_z^\prime = f_z^\prime + \lambda \alpha^\prime_z +\mu \alpha_z^\prime = 0 \\F_{\lambda}^\prime = \alpha(x,y,z) = 0 \\F_{\mu}^\prime = \beta(x,y,z) = 0 \\\end{cases}</script><ol><li>解上述方程组得备选点$ P<em>i,i = 1,2,3,\cdots,n $，并求$ f(P_i) $，取其最大值为$ u</em>{max} $，最小值为$ u_{min} $</li><li>根据实际问题，必存在最值，所得即为所求</li></ol><h1 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h1><h2 id="章节概括-1"><a href="#章节概括-1" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>概念、性质与对称性<ul><li>几何背景</li><li>性质</li><li>对称性<ul><li>普通对称性</li><li>轮换对称性</li></ul></li></ul></li><li>计算<ul><li>直角坐标系</li><li>极坐标系</li><li>极坐标系与直角坐标系选择的一般原则</li><li>极直互化</li><li>积分次序</li><li>用二重积分处理一元积分的问题</li></ul></li></ul><h2 id="几何背景"><a href="#几何背景" class="headerlink" title="几何背景"></a>几何背景</h2><p>曲顶柱体的体积</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="求区域面积"><a href="#求区域面积" class="headerlink" title="求区域面积"></a>求区域面积</h3><script type="math/tex; mode=display">\iint_D 1 \cdot d\sigma = \iint_D d\sigma = A(A表示区域D的面积)</script><h3 id="可积函数必有界"><a href="#可积函数必有界" class="headerlink" title="可积函数必有界"></a>可积函数必有界</h3><p>当f(x,y)在有界闭区域D上可积时，f(x,y)在D上必有界</p><script type="math/tex; mode=display">\iint_D [f(x,y) \pm g(x,y)]d\sigma = \iint_D f(x,y)d\sigma \pm \iint_D g(x,y)d\sigma</script><h3 id="积分的线性性质"><a href="#积分的线性性质" class="headerlink" title="积分的线性性质"></a>积分的线性性质</h3><script type="math/tex; mode=display">\iint_D kf(x,y)d\sigma = k\iint_D f(x,y)d\sigma</script><h3 id="积分的可加性"><a href="#积分的可加性" class="headerlink" title="积分的可加性"></a>积分的可加性</h3><p>设$ f(x,y) $在有界闭区域D上可积，且$ D_1 \cup D_2 = D，D_1 \cap D_2 = \oslash $，则</p><script type="math/tex; mode=display">\iint_{D_1+D_2} [f(x,y) \pm g(x,y)]d\sigma = \iint_{D_1} f(x,y)d\sigma \pm \iint_{D_2} g(x,y)d\sigma</script><h3 id="积分的保号性"><a href="#积分的保号性" class="headerlink" title="积分的保号性"></a>积分的保号性</h3><p>当$ f(x,y),g(x,y) $在有界闭区域D上可积时，若在D上</p><script type="math/tex; mode=display">f(x,y) \le g(x,y)</script><p>则有</p><script type="math/tex; mode=display">\iint_D f(x,y)d\sigma \le \iint_D g(x,y)d\sigma</script><p>特殊的，有</p><script type="math/tex; mode=display">|\iint_D f(x,y)d\sigma | \le \iint_D |f(x,y)| d\sigma</script><h3 id="估值定理"><a href="#估值定理" class="headerlink" title="估值定理"></a>估值定理</h3><p>设M,m分别是$ f(x,y) $在有界闭区域D上的最大值和最小值，A为D的面积，则有</p><script type="math/tex; mode=display">mA \le \iint_D f(x,y) d\sigma \le MA</script><h3 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h3><p>设函数$ f(x,y) $在有界闭区域D上连续，A为D的面积，则在D上至少存在一点$ (\xi,\eta) $，使得</p><script type="math/tex; mode=display">\iint_D f(x,y) d\sigma = f(\xi,\eta)A</script><h2 id="普通对称性"><a href="#普通对称性" class="headerlink" title="普通对称性"></a>普通对称性</h2><script type="math/tex; mode=display">\iint_D f(x,y) dxdy = \begin{cases} 2\iint_{D_{1}} f(x,y) dxdy, & f(x,y) = f(-x,y) \\0 & -f(x,y) = f(-x,y)\end{cases}</script><h2 id="轮换对称性"><a href="#轮换对称性" class="headerlink" title="轮换对称性"></a>轮换对称性</h2><p>若把x与y对调，区域D不变（或区域D关于$ y = x $对称），则</p><script type="math/tex; mode=display">\iint_D f(x,y) d\sigma = \iint_D f(y,x) d\sigma</script><h2 id="直角坐标系下的计算法"><a href="#直角坐标系下的计算法" class="headerlink" title="直角坐标系下的计算法"></a>直角坐标系下的计算法</h2><p>X型区域，$ \varphi_1(x) \le y \le \varphi_2(x) , a \le x \le b$：</p><p><img src="../../image/image-20220525110814843.png" alt="X型区域图像演示图"></p><script type="math/tex; mode=display">\iint_D f(x,y) d\sigma = \int_a^b dx \int_{\varphi_1(x)}^{\varphi_2(x)} f(x,y)dy</script><p>Y型区域，$ \varphi_1(y) \le x \le \varphi_2(y) , c \le y \le d$：</p><p><img src="../../image/image-20220525110851769.png" alt="Y型区域图像演示图"></p><script type="math/tex; mode=display">\iint_D f(x,y) d\sigma = \int_c^d dy \int_{\varphi_1(y)}^{\varphi_2(y)} f(x,y)dx</script><p>这里的下限都必须小于或等于上限</p><h2 id="极坐标系下的计算法"><a href="#极坐标系下的计算法" class="headerlink" title="极坐标系下的计算法"></a>极坐标系下的计算法</h2><p>极点O在区域D外部</p><p><img src="../../image/image-20220525110951461.png" alt="极点O在区域D外部"></p><script type="math/tex; mode=display">\iint f(x,y)d\sigma = \int_\alpha^\beta d\theta \int_{r_1(\theta)}^{r_2(\theta)} f(rcos\theta,rsin\theta)rdr</script><p>极点O在区域D边界上</p><p><img src="../../image/image-20220525111047749.png" alt="极点O在区域D边界上"></p><script type="math/tex; mode=display">\iint f(x,y)d\sigma = \int_\alpha^\beta d\theta \int_{0}^{r(\theta)} f(rcos\theta,rsin\theta)rdr</script><p>极点O在区域D内部</p><p><img src="../../image/image-20220525111110216.png" alt="极点O在区域D内部"></p><script type="math/tex; mode=display">\iint f(x,y)d\sigma = \int_0^{2\pi} d\theta \int_{0}^{r(\theta)} f(rcos\theta,rsin\theta)rdr</script><h2 id="极坐标系与直角坐标系的一般原则"><a href="#极坐标系与直角坐标系的一般原则" class="headerlink" title="极坐标系与直角坐标系的一般原则"></a>极坐标系与直角坐标系的一般原则</h2><ol><li>看被积函数是否为$ f(x^2+y^2),f(\frac{y}{x}),f(\frac{x}{y}) $等形式</li><li>看积分区域是否为圆或者圆的一部分</li></ol><p>如果两者兼是，那么优先选用极坐标系</p><p>以上只是一般原则，为大方向，实际情况实际分析</p><h2 id="极坐标系与直角坐标系的相互转换"><a href="#极坐标系与直角坐标系的相互转换" class="headerlink" title="极坐标系与直角坐标系的相互转换"></a>极坐标系与直角坐标系的相互转换</h2><script type="math/tex; mode=display">令\begin{cases}x = rcos\theta \\y = rsin\theta \end{cases}或\begin{cases}x-x_0 = rcos\theta \\ y-y_0 = rsin\theta \end{cases}</script><script type="math/tex; mode=display">其中D = \{(r,\theta )|\alpha \le \theta \le \beta ,r_1(\theta) \le \theta \le r_2(\theta)\}</script><script type="math/tex; mode=display">则\iint f(x,y)d\sigma = \int_\alpha^\beta d\theta \int_{r_1(\theta)}^{r_2(\theta)} rf(rcos\theta,rsin\theta)dr(注意后面多个r,dx\rightarrow rdr)</script><p><img src="../../image/极坐标变换.png" alt="极坐标变换"></p><h1 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h1><h2 id="章节概括-2"><a href="#章节概括-2" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>微分方程的概念（用概念做题）<ul><li>微分方程</li><li>常微分方程</li><li>微分方程的阶</li><li>微分方程的解</li><li>微分方程的通解</li><li>初始条件与特解</li></ul></li><li>一阶微分方程的求解<ul><li>变量可分离型</li><li>可化为变量可分离型</li><li>一阶线性微分方程</li><li>伯努利方程</li></ul></li><li>二阶可降阶微分方程的求解<ul><li>$ y^” = f(x,y^\prime) $型</li><li>$ y^” = f(y,y^\prime) $型</li></ul></li><li>高阶线性微分方程的求解<ul><li>概念</li><li>解的结构（以二阶为例）</li><li>二阶常系数齐次线性微分方程的的通解</li><li>二阶常系数非齐次线性微分方程的的特解</li><li>n阶常系数齐次线性微分方程的解</li></ul></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h3><p>表示<strong>未知函数</strong>及其<strong>导数</strong>（或者<strong>微分</strong>）与<strong>自变量</strong>之间<strong>关系</strong>的方程称为<strong>微分方程</strong></p><h3 id="常微分方程-1"><a href="#常微分方程-1" class="headerlink" title="常微分方程"></a>常微分方程</h3><p>未知函数是<strong>一元函数</strong>的<strong>微分方程</strong>称为<strong>常微分方程</strong></p><p>如：$ y^{“\prime} - y^” + y = 0 $</p><h3 id="微分方程的阶"><a href="#微分方程的阶" class="headerlink" title="微分方程的阶"></a>微分方程的阶</h3><p>方程中未知函数的<strong>最高阶导数的阶数</strong>称为<strong>微分方程的阶</strong></p><p>如：$ y^{“\prime} - y^” + y = 0 $就是三阶微分方程</p><h3 id="微分方程的通解"><a href="#微分方程的通解" class="headerlink" title="微分方程的通解"></a>微分方程的通解</h3><p>若微分方程的解中含有的<strong>独立常数</strong>的<strong>个数</strong>等于<strong>微分方程的阶数</strong>，则该解称为微分方程的<strong>通解</strong></p><h3 id="初始条件与特解"><a href="#初始条件与特解" class="headerlink" title="初始条件与特解"></a>初始条件与特解</h3><p><strong>确定通解中的常数</strong>的<strong>条件</strong>就是<strong>初始条件</strong>，确定了通解中的常数后，解就成了<strong>特解</strong></p><h2 id="一阶微分方程的求解"><a href="#一阶微分方程的求解" class="headerlink" title="一阶微分方程的求解"></a>一阶微分方程的求解</h2><h3 id="变量可分离型"><a href="#变量可分离型" class="headerlink" title="变量可分离型"></a>变量可分离型</h3><script type="math/tex; mode=display">\frac{\mathrm{d} y}{\mathrm{d} x} = \varphi _1(x)\varphi _2(x) \Rightarrow \frac{\mathrm{d} y}{\varphi _2(x)} = \varphi _1(x)dx \Rightarrow \int\frac{\mathrm{d} y}{\varphi _2(x)} = \int\varphi _1(x)dx + C (\varphi _2(x) \neq 0)</script><h3 id="可化为变量可分离型"><a href="#可化为变量可分离型" class="headerlink" title="可化为变量可分离型"></a>可化为变量可分离型</h3><script type="math/tex; mode=display">\frac{\mathrm{d} y}{\mathrm{d} x} = f(ax+by+c)令u = ax+by+c \Rightarrow \frac{\mathrm{d} u}{\mathrm{d} x} = a+b\frac{\mathrm{d} y}{\mathrm{d} x} \Rightarrow \frac{\mathrm{d} u}{\mathrm{d} x} = a+bf(u)</script><h3 id="变量替换法"><a href="#变量替换法" class="headerlink" title="变量替换法"></a>变量替换法</h3><script type="math/tex; mode=display">\frac{\mathrm{d} y}{\mathrm{d} x} = \varphi _(\frac{y}{x})(令\frac{y}{x}=u) \Rightarrow u+x\frac{du}{dx} = \varphi (u) \Rightarrow \int\frac{\mathrm{d} y}{\varphi (u)-u} = \int \frac{dx}{x} + C (\varphi (u)-u \neq 0)</script><h3 id="一阶齐次线性微分方程"><a href="#一阶齐次线性微分方程" class="headerlink" title="一阶齐次线性微分方程"></a>一阶齐次线性微分方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} + P(x)y = 0，通解公式为：y= Ce^{-\int P(x)dx} (C为任意常数)</script><h3 id="一阶非齐次线性微分方程"><a href="#一阶非齐次线性微分方程" class="headerlink" title="一阶非齐次线性微分方程"></a>一阶非齐次线性微分方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} + P(x)y = Q(x)，通解公式为：y= [\int Q(x)e^{\int P(x)dx}dx+C]e^{-\int P(x)dx} (C为任意常数)</script><h3 id="伯努利方程"><a href="#伯努利方程" class="headerlink" title="伯努利方程"></a>伯努利方程</h3><p>形如$ y^\prime + p(x)y = q(x)y^n(n\neq 0,1) $的方程，其中$p(x),q(x)$为已知的连续函数，其解法具体步骤为</p><ol><li>先变形为$ y^{-n} \cdot y^\prime + p(x)y^{1-n} = q(x)$</li><li>令$ z=y^{1-n}$，得$ \frac{dz}{dx} = (1-n)y^{-n}\frac{dy}{dx} $，则$ \frac{1}{1-n} \cdot \frac{dz}{dx} + p(x)z = q(x) $</li><li>解此一阶线性微分方程即可</li></ol><h2 id="高阶微分方程"><a href="#高阶微分方程" class="headerlink" title="高阶微分方程"></a>高阶微分方程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol><li>方程$ y^” + p(x)y^\prime + q(x)y = f(x) $称为<strong>二阶变系数线性微分方程</strong>，其中$ p(x),q(x) $叫系数函数，f(x)叫自由项，均为已知的连续函数<ol><li>当$ f(x) = 0 $时，$ y^” + p(x)y^\prime + q(x)y = 0 $为<strong>齐次方程</strong></li><li>当f(x)不恒等于0时，$ y^” + p(x)y^\prime + q(x)y = f(x) $为<strong>非齐次方程</strong></li></ol></li><li>方程$ y^” + py^\prime + qy = f(x) $称为<strong>二阶常系数线性微分方程</strong>，其中$ p,q $为常数，$ f(x) $叫自由项，为连续函数<ol><li>当$ f(x) = 0 $时，$ y^” + py^\prime + qy = 0 $为<strong>齐次方程</strong></li><li>当f(x)不恒等于0时，$ y^” + py^\prime + qy = f(x) $为<strong>非齐次方程</strong></li></ol></li></ol><h3 id="二阶可降阶微分方程的求解"><a href="#二阶可降阶微分方程的求解" class="headerlink" title="二阶可降阶微分方程的求解"></a>二阶可降阶微分方程的求解</h3><h4 id="y-prime-prime-f-x-y-prime-的方程"><a href="#y-prime-prime-f-x-y-prime-的方程" class="headerlink" title="$y^{\prime\prime} = f(x,y^{\prime})$的方程"></a>$y^{\prime\prime} = f(x,y^{\prime})$的方程</h4><p>方程中不显含未知函数y</p><ol><li>令$ y^\prime = p(x)，y^” = p^\prime $，则原方程变为一阶方程$ \frac{dp}{dx} = f(x,p) $</li><li>若求得通解为$ p = \varphi(x,C_1) $即$ y^\prime = \varphi(x,C_1) $，则原方程的通解为$ y = \int \varphi(x,C_1)dx + C_2 $</li></ol><h4 id="y-prime-prime-f-y-y-prime-的方程"><a href="#y-prime-prime-f-y-y-prime-的方程" class="headerlink" title="$y^{\prime\prime} = f(y,y^{\prime})$的方程"></a>$y^{\prime\prime} = f(y,y^{\prime})$的方程</h4><p>方程中不显含未知函数x</p><ol><li>令$ y^\prime = p，y^” = \frac{dp}{dx} \cdot p $，则原方程变为一阶方程$ p\frac{dp}{dx} = f(x,p) $</li><li>若求得通解为$ p = \varphi(x,C_1) $，则由$ p = \frac{dy}{dx} $可得$ \frac{dy}{dx} = \varphi(y,C_1) $，分离变量得$ \frac{1}{\varphi(y,C_1)}dy = dx $</li><li>两边积分得$ \int \frac{1}{\varphi(y,C_1)}dy = x+C_2 $，即可求得原方程的通解</li></ol><h3 id="微分算子法"><a href="#微分算子法" class="headerlink" title="微分算子法"></a>微分算子法</h3><p>目的为算<strong>非齐次微分方程</strong>的特解</p><blockquote><p>原视频：<a href="https://www.bilibili.com/video/BV14a4y1a7YS?from=search&amp;seid=3041435947943409782&amp;spm_id_from=333.337.0.0">超全类型微分算子法合辑，手把手教你考场实战!_哔哩哔哩_bilibili</a></p></blockquote><script type="math/tex; mode=display">y'' + py' + qy = f(x)，设特解为y^*</script><script type="math/tex; mode=display">y^* = \frac{1}{F(D)}f(x) = \frac{1}{D^2+pD+q}f(x)(F(D) = 0 时求导F'(D)后乘以x)，f(x)分以下情况</script><script type="math/tex; mode=display">f(x) = e^{kx} \rightarrow 将所有的D换成k</script><script type="math/tex; mode=display">f(x) = sinax / cosax \rightarrow 将D^2换成 -a^2</script><h2 id="解的结构（以二阶为例）"><a href="#解的结构（以二阶为例）" class="headerlink" title="解的结构（以二阶为例）"></a>解的结构（以二阶为例）</h2><p>若$y_1(x)$和$y_2(x)$是$ y^” + p(x)y’ + q(x)y = 0 $的两个解，且$ \frac{y_1(x)}{y_2(x)}\neq C $(常数)，则称$ y_1(x),y_2(x) $也是该方程的<strong>两个线性无关的解</strong>，且</p><script type="math/tex; mode=display">y(x) = C_1y_1(x) + C_2y_2(x)</script><p>是方程$ y^” + p(x)y’ + q(x)y = 0 $的通解</p><p>若$ y(x) = C_1y_1(x) + C_2y_2(x) $是$ y^” + p(x)y’ + q(x)y = 0 $的通解，$ y^*(x) $是$ y^” + p(x)y’ + q(x)y = f(x) $的一个特解，则</p><script type="math/tex; mode=display">y^*(x) + y</script><p>是$ y^” + p(x)y’ + q(x)y = f(x) $的通解</p><p>若$ y_1^{<em>}(x) $是$ y^” + p(x)y’ + q(x)y = f_1(x) $的解，$ y_2^{</em>}(x) $是$ y^” + p(x)y’ + q(x)y = f_2(x) $的解，则</p><script type="math/tex; mode=display">y_1^*(x)+y_2^*(x)</script><p>是$ y^” + p(x)y’ + q(x)y = f_1(x)+f_2(x) $的通解</p><h2 id="二阶常系数齐次线性微分方程的通解"><a href="#二阶常系数齐次线性微分方程的通解" class="headerlink" title="二阶常系数齐次线性微分方程的通解"></a>二阶常系数齐次线性微分方程的通解</h2><p>对于$ y^” + py^\prime + qy = 0 $，其对应的特征方程为$ r^2 + pr + q = 0 $，求其特征根，有以下三种情况（其中$C_1,C_2$为任意常数）：</p><ol><li>若$ p^2 - 4q &gt; 0 $，设$ r_1,r_2 $是特征方程的两个不等实根，即$ r_1 \neq r_2 $，可得其通解为</li></ol><script type="math/tex; mode=display">y = C_1e^{r_1x} + C_2e^{r_2x}</script><ol><li>若$ p^2 - 4q = 0 $，设$ r_1,r_2 $是特征方程的两个相等的实根，即二重根，令$ r_1 = r_2 = r $，可得其通解为</li></ol><script type="math/tex; mode=display">y = (C_1 + C_2x)e^{rx}</script><ol><li>若$ p^2 - 4q &lt; 0 $，设$ \alpha \pm \beta i $是特征方程的一对共轭复根，可得其通解为</li></ol><script type="math/tex; mode=display">y = e^{ax}(C_1 cos\beta x + C_2 sin\beta x)</script><h2 id="二阶常系数非齐次线性微分方程的特解"><a href="#二阶常系数非齐次线性微分方程的特解" class="headerlink" title="二阶常系数非齐次线性微分方程的特解"></a>二阶常系数非齐次线性微分方程的特解</h2><p>对于$ y^” + py^\prime + qy = f(x) $</p><p>设$ P_n(x),P_m(x) $分别为x的n次、m次多项式</p><ol><li>当自由项$ f(x) = P_n(x)e^{ax} $时，特解要设为$ y^* = e^{ax}Q_n(x)x^k $，其中<ol><li>$ e^{ax} $照抄</li><li>$ Q_n(x) $为x的n次多项式</li><li>k = 0时，a不是特征根；k = 1时，a是单特征根；k = 2时，a是二重特征根</li></ol></li><li>当自由项$ f(x) = e^{ax}[P_m(x)cos\beta x + P_n(x)sin\beta x] $时，特解要设为$ y^* = e^{ax}[Q_l^{(1)}(x)cos\beta x + Q_l^{(2)}(x)sin\beta x]x^k $，其中<ol><li>$ e^{ax} $照抄</li><li>$ l = max{m,n},Q_l^{(1)},Q_l^{(2)}(x) $分别为x的两个不同的$l$次多项式</li><li>k = 0时，$ a \pm \beta i $不是特征根；k = 1时，$ a \pm \beta i $是单特征根</li></ol></li></ol><h2 id="n阶常系数齐次线性微分方程的解"><a href="#n阶常系数齐次线性微分方程的解" class="headerlink" title="n阶常系数齐次线性微分方程的解"></a>n阶常系数齐次线性微分方程的解</h2><p>方程$ y^{(n)} + p<em>1y^{(n-1)} + \cdots + p</em>{(n-1)}y^\prime + p_n y= 0 $称为<strong>n阶常系数齐次线性微分方程</strong></p><p>其中$ p<em>1,p_2,\cdots,p_n $为常数，其对应的特征方程为$ r^{n} + p_1r^{(n-1)} + \cdots + p</em>{(n-1)}r + p_n = 0 $，求特征根</p><ol><li>特征根为单实根r时，微分方程通解中对应一项$ Ce^{rx} $</li><li>特征根为k重实根r时，微分方程通解中对应k项$ (C_1 + C_2x +\cdots + C_kx^{k-1})e^{rx} $</li><li>特征根为单复根$ a \pm \beta i(\beta &gt; 0) $时，微分方程通解中对应两项$ e^{ax}(C_1cos\beta x + C_2sin\beta x) $</li><li>特征根为k重复根$ a \pm \beta i(\beta &gt; 0) $时，微分方程通解中对应$2k$项$ e^{ax}[(C_1 + C_2x + \cdots + C_kx^{k-1})cos\beta x + (D_1 + D_2x + \cdots + D_kx^{k-1})sin\beta x)] $</li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学公式大全（二）</title>
    <link href="/my_world/content/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/my_world/content/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一元函数积分学的概念与计算"><a href="#一元函数积分学的概念与计算" class="headerlink" title="一元函数积分学的概念与计算"></a>一元函数积分学的概念与计算</h1><h2 id="章节概括"><a href="#章节概括" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>概念<ul><li>不定积分<ul><li>原函数与不定积分</li><li>原函数（不定积分存在定理）</li></ul></li><li>定积分<ul><li>定积分概念</li><li>定积分存在定理</li><li>定积分性质</li></ul></li><li>变限积分<ul><li>变限积分的概念</li><li>变限积分的性质</li><li>变限积分的求导公式</li></ul></li><li>反常积分<ul><li>反常积分的概念的通俗理解</li><li>无穷区间上反常积分的概念与敛散性</li><li>无界函数上反常积分的概念与敛散性</li><li>判敛</li></ul></li></ul></li><li>计算<ul><li>基本积分公式</li><li>凑微分法</li><li>换元法</li><li>分部积分法</li><li>有理函数积分</li></ul></li></ul><h1 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h1><h2 id="原函数与不定积分"><a href="#原函数与不定积分" class="headerlink" title="原函数与不定积分"></a>原函数与不定积分</h2><p>设函数$f(x)$定义在某区间$I$上，若存在可导函数$F(x)$，对于<strong>该区间上任意一点</strong>都有$F’(x) = f(x)$成立</p><p>则称$F(x)$是$f(x)$在区间$I$上的一个<strong>原函数</strong>，称</p><script type="math/tex; mode=display">\int f(x) dx = F(x) + C</script><p>在$f(x)$区间$I$上的不定积分</p><h2 id="原函数（不定积分）存在定理"><a href="#原函数（不定积分）存在定理" class="headerlink" title="原函数（不定积分）存在定理"></a>原函数（不定积分）存在定理</h2><ol><li>连续函数$f(x)$必有原函数$F(x)$</li><li>含有<strong>第一类间断点</strong>和<strong>无穷间断点</strong>的函数$f(x)$在包含该间断点的区间内必没有原函数$F(x)$</li><li>含有<strong>振荡间断点</strong>的函数<strong>可能</strong>有原函数</li></ol><h2 id="不定积分的基本性质"><a href="#不定积分的基本性质" class="headerlink" title="不定积分的基本性质"></a>不定积分的基本性质</h2><script type="math/tex; mode=display">[\int f(x)dx]^{\prime} = f(x)</script><script type="math/tex; mode=display">d \int f(x)dx = f(x)dx</script><script type="math/tex; mode=display">\int f^{\prime}(x)dx = \int df(x) = f(x)+C</script><script type="math/tex; mode=display">\int kf(x)dx = k \int f(x)dx (k \neq 0为常数)</script><script type="math/tex; mode=display">\int[f(x)\pm g(x)]dx = \int f(x)dx \pm \int g(x)dx</script><h2 id="积分公式"><a href="#积分公式" class="headerlink" title="积分公式"></a>积分公式</h2><script type="math/tex; mode=display">\int x^adx = \frac{1}{1+a}x^{1+a}+C(a\neq-1)</script><script type="math/tex; mode=display">\int\frac{1}{x}dx = In|x|+C</script><script type="math/tex; mode=display">\int \frac{1}{\sqrt{x}} dx = 2\sqrt{x} + C</script><script type="math/tex; mode=display">\int a^x dx = \frac{a^x}{Ina}+C</script><script type="math/tex; mode=display">\int e^xdx = e^x+C</script><script type="math/tex; mode=display">\int cosx dx = sinx+C</script><script type="math/tex; mode=display">\int \frac{1}{1+cosx}dx =tan\frac{x}{2}+C</script><script type="math/tex; mode=display">\int sinxdx = -cosx+C</script><script type="math/tex; mode=display">\int secx dx = In|secx + tanx|+C</script><script type="math/tex; mode=display">\int cscx dx = In|cscx - cotx|+C</script><script type="math/tex; mode=display">\int sec^2xdx = \int \frac{1}{cos^2x}dx = tanx +C</script><script type="math/tex; mode=display">\int csc^2xdx = \int \frac{1}{sin^2}dx = -cotx + C</script><script type="math/tex; mode=display">\int secx tanx dx = secx + C</script><script type="math/tex; mode=display">\int cscx cotxdx = -cscx +C</script><script type="math/tex; mode=display">\int \frac{1}{a^2+x^2}dx = \frac{1}{a}arctan\frac{x}{a}+C</script><script type="math/tex; mode=display">\int \frac{1}{1+x^2}dx = arctanx + C</script><script type="math/tex; mode=display">\int \frac{1}{\sqrt{a^2-x^2}}dx = arcsin\frac{x}{a} + C</script><script type="math/tex; mode=display">\int \frac{1}{\sqrt{1-x^2}}dx = arcsinx + C</script><script type="math/tex; mode=display">\int \frac{1}{a^2-x^2}dx = \frac{1}{2a}In|\frac{a+x}{a-x}|+C</script><script type="math/tex; mode=display">\int \frac{1}{\sqrt{x^2 \pm a^2}}dx = In|x+\sqrt{x^2 \pm a^2}|+C</script><h2 id="凑微分法"><a href="#凑微分法" class="headerlink" title="凑微分法"></a>凑微分法</h2><script type="math/tex; mode=display">\int f[\varphi(x)]\varphi ^{\prime}(x)dx = \int f[\varphi(x)]d\varphi(x) = \int f(u)du[令\varphi(x) = u]</script><h2 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h2><script type="math/tex; mode=display">\int udv = uv - \int vdu</script><h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h2 id="定积分概念"><a href="#定积分概念" class="headerlink" title="定积分概念"></a>定积分概念</h2><p>若函数$f(x)$在区间$[a,b]$有界</p><p>在$(a,b)$上任取$n -1$个分点$x_i(i = 1,2,3,\cdots,n-1)$</p><p>定义$x<em>0 = a$和$x_n = b$，且$a = x_0 &lt; x_1 &lt; x_2 &lt; x_3 &lt; \cdots &lt; x</em>{n-1} &lt; x<em>n = b$，记$\Delta x_k = x_k - x</em>{k-1},k = 1,2,3,\cdots,n$</p><p>并取任意一点$\xi<em>k \in [x</em>{k-1},x<em>k]$，记$\lambda = \max</em>{1 \le k \le n}{\Delta x_k}$</p><p>若当$\lambda \rightarrow 0$时，极限$\lim<em>{\lambda \rightarrow 0} \sum^n</em>{k = 1}f(\xi_k) \Delta x_k$存在分点$x_i$及其点$\xi_k$的取法无关</p><p>则称函数$f(x)$在区间$[a,b]$可积，即</p><script type="math/tex; mode=display">\int^b_a f(x)dx = \lim_{\lambda = 0} \sum^n_{k = 1}f(\xi_k) \Delta x_k</script><h2 id="定积分定义"><a href="#定积分定义" class="headerlink" title="定积分定义"></a>定积分定义</h2><script type="math/tex; mode=display">\int^b_af(x)dx = \lim_{n \rightarrow +\infty} \sum^n_{i=1}f[a+\frac{i}{n}(b-a)]\frac{b-1}{n}</script><script type="math/tex; mode=display">\int^1_0f(x)dx = \lim_{n \rightarrow +\infty} \frac{1}{n}\sum^n_{i=1}f(\frac{i}{n})</script><h2 id="定积分存在性定理"><a href="#定积分存在性定理" class="headerlink" title="定积分存在性定理"></a>定积分存在性定理</h2><ul><li><p>定积分存在的充分条件</p><ul><li>若$f(x)$在$[a,b]$上连续，则$\int_a^bf(x)dx$存在</li><li>若$f(x)$在$[a,b]$上单调，则$\int_a^bf(x)dx$存在</li><li>若$f(x)$在$[a,b]$上有界，且只有<strong>有限个间断点</strong>，则$\int_a^bf(x)dx$存在</li></ul></li><li><p>定积分存在的必要条件</p><ul><li>若$\int_a^bf(x)dx$存在，则$f(x)$在$[a,b]$上必有界</li></ul></li></ul><h2 id="偶倍奇零"><a href="#偶倍奇零" class="headerlink" title="偶倍奇零"></a>偶倍奇零</h2><script type="math/tex; mode=display">\int _{-a}^a f(x)dx = 2\int _0^a f(x)dx ,f(x)为偶函数</script><script type="math/tex; mode=display">\int _{-a}^a f(x)dx = 0,f(x)为奇函数</script><h2 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h2><p>区间长度</p><script type="math/tex; mode=display">\int_{a}^{b} dx = b-a = L，其中a<b，L为区间[a,b]的长度</script><p>积分的线性性质</p><script type="math/tex; mode=display">\int_{a}^{b} [k_1f(x) \pm k_2g(x)]dx = k_1\int_{a}^{b} f(x)dx \pm k_2\int_{b}^{a} g(x)dx</script><p>积分的可加（拆）性</p><script type="math/tex; mode=display">\int_{b}^{a} f(x)dx = \int_{c}^{a} f(x)dx + \int_{b}^{c} f(x)dx</script><p>积分的保号性</p><p>若在区间$[a,b]$上$f(x) \le g(x)$，则有</p><script type="math/tex; mode=display">\int^b_a f(x)dx \le \int^b_a g(x)dx</script><p>特殊地，有：</p><script type="math/tex; mode=display">|\int^b_a f(x)dx| \le \int^b_a |f(x)|dx</script><p>估值定理</p><p>设M，m分别是$f(x)$在$[a,b]$上的最大值和最小值，$L$为区间$[a,b]$的长度，则</p><script type="math/tex; mode=display">mL \le \int^b_a f(x)dx \le ML</script><script type="math/tex; mode=display">\int_{b}^{a} f(x)dx = -\int_{a}^{b} f(x)dx</script><script type="math/tex; mode=display">设f(x) \ge 0(a \le x \le b),\int_{b}^{a} f(x)dx \ge 0</script><script type="math/tex; mode=display">设f(x) \ge g(x)(a \le x \le b),\int_{b}^{a} f(x)dx \ge \int_{b}^{a} g(x)dx</script><h2 id="f-x-中含三角函数的积分的一些常用结论"><a href="#f-x-中含三角函数的积分的一些常用结论" class="headerlink" title="f(x)中含三角函数的积分的一些常用结论"></a>f(x)中含三角函数的积分的一些常用结论</h2><blockquote><p>原链接：<a href="https://zhuanlan.zhihu.com/p/155996719">含三角函数的积分的一些常用结论 - 知乎 (zhihu.com)</a></p></blockquote><script type="math/tex; mode=display">\int_0^{\frac{\pi}{2}} f(sinx)dx = \int_0^{\frac{\pi}{2}} f(cosx)dx</script><script type="math/tex; mode=display">\int_0^\pi xf(sinx)dx = \frac{\pi}{2}\int_0^\pi f(sinx)dx = \pi\int_0^{\frac{\pi}{2}} f(sinx)dx</script><script type="math/tex; mode=display">\int_0^\pi f(sinx)dx = 2\int_0^{\frac{\pi}{2}} f(sinx)dx</script><script type="math/tex; mode=display">\int_0^{\frac{\pi}{2}} x(f(sinx)+f(cosx))dx = \frac{\pi}{2}\int_0^{\frac{\pi}{2}} f(sinx)dx</script><script type="math/tex; mode=display">\begin{align}华里士公式：\int_0^{\frac{\pi}{2}} sin^nxdx = \int_0^{\frac{\pi}{2}} cos^nxdx \\\left\{\begin{matrix} \frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac{1}{2}\cdot \frac{\pi}{2} (n为偶数)\\ \frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac{3}{2}\cdot 1 (n为奇数)\end{matrix}\right.\\也叫做点火公式，例：\\\int_0^{\frac{\pi}{2}} sin^{10}dx = \frac{9}{10}\cdot\frac{7}{8}\cdot\frac{5}{6}\cdot\frac{3}{4}\cdot\frac{1}{2}\cdot\frac{\pi}{2}(点火成功)\\\int_0^{\frac{\pi}{2}} cos^{9}dx = \frac{8}{9}\cdot\frac{6}{7}\cdot\frac{4}{5}\cdot\frac{2}{3}(点火失败)\\\end{align}</script><h2 id="牛顿-莱布尼茨公式"><a href="#牛顿-莱布尼茨公式" class="headerlink" title="牛顿-莱布尼茨公式"></a>牛顿-莱布尼茨公式</h2><script type="math/tex; mode=display">\int _b^af(x)dx = F(b) - F(a) = F(x)|_a^b,F(x)是f(x)的原函数</script><h2 id="变限积分"><a href="#变限积分" class="headerlink" title="变限积分"></a>变限积分</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>函数$f(x)$在$[a,b]$上可积，则函数$F(x) = \int^x_a f(t)dt$在$[a,b]$上连续</li><li>函数$f(x)$在$[a,b]$上连续，则函数$F(x) = \int^x_a f(t)dt$在$[a,b]$上可导</li></ol><h3 id="求导公式"><a href="#求导公式" class="headerlink" title="求导公式"></a>求导公式</h3><script type="math/tex; mode=display">\Phi ^{\prime}(x) = [\int^x_a f(t)dt]^{\prime} = f(x)</script><script type="math/tex; mode=display">[\int^{\varphi(x)}_{\lambda(x)}f(t)dt]^{\prime} = f(\varphi(x))\varphi^\prime(x)-f(\lambda(x))\lambda^\prime(x)</script><h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><p>反常积分又叫广义积分，是对普通定积分的推广，指<strong>含有无穷上限/下限</strong>，或者<strong>被积函数含有瑕点的积分</strong>，前者称为<strong>无穷限广义积分</strong>，后者称为<strong>瑕积分</strong>（又称<strong>无界函数的反常积分</strong>）。</p><p>如果函数f(x)在点a的任意一个去心邻域内无界，那么点a称为函数f(x)的瑕点（也称无界间断点）。无界函数的反常积分又称瑕积分。广义积分积分限中使积分函数不存在的点。</p><p>形式：</p><script type="math/tex; mode=display">\int_1^{+\infty} \frac{1}{\sqrt{x^2 - x}} dx或者\int_0^1 \frac{1}{\sqrt{x - x^2}}</script><h3 id="无穷区间积分的敛散性判别法"><a href="#无穷区间积分的敛散性判别法" class="headerlink" title="无穷区间积分的敛散性判别法"></a>无穷区间积分的敛散性判别法</h3><script type="math/tex; mode=display">\int_a^{+\infty} f(x) dx = \lim_{t \rightarrow +\infty}\int_a^{t} f(x) dx</script><p>若上述极限存在，则反常积分<strong>收敛</strong>，否则称为<strong>发散</strong></p><p>例：</p><script type="math/tex; mode=display">\int_0^{+\infty} e^{-x} dx = \lim_{t \rightarrow +\infty} \int_0^{t} e^{-x} dx = \lim_{t \rightarrow +\infty} (1-e^{-t}) = 1(该积分收敛)</script><script type="math/tex; mode=display">\int_{-\infty}^b f(x) dx = \lim_{t \rightarrow -\infty}\int_t^{b} f(x) dx</script><p>若上述极限存在，则反常积分<strong>收敛</strong>，否则称为<strong>发散</strong></p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty} f(x) dx = \int_{-\infty}^{c} f(x) dx + \int_{c}^{+\infty} f(x) dx</script><p>若右边两个反常积分都<strong>收敛</strong>，则反常积分<strong>收敛</strong>，否则称为<strong>发散</strong></p><p>无穷区间的反常积分，在$p &gt; 1$时收敛，在$p \le 1$时发散</p><script type="math/tex; mode=display">\int_1^{+\infty} \frac{1}{x^p}dx</script><p>无界函数的反常积分，在$0 &lt; p &lt; 1$时收敛，在$p \ge 1$时发散</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x^p}dx，p>0，奇点 x = 0</script><h3 id="无界函数的反常积分的概念与敛散性"><a href="#无界函数的反常积分的概念与敛散性" class="headerlink" title="无界函数的反常积分的概念与敛散性"></a>无界函数的反常积分的概念与敛散性</h3><p>若b是$f(x)$的唯一瑕点，则无界函数$f(x)$的反常积分$\int_a^b f(x) dx$定义为</p><script type="math/tex; mode=display">\int_a^b f(x) dx = \lim_{\xi \rightarrow 0^+}\int^{b -\xi}_a f(x) dx</script><p>若上述极限存在，则称反常积分$\int_a^b f(x) dx$<strong>收敛</strong>，否则称为<strong>发散</strong></p><p>若a是$f(x)$的唯一瑕点，则无界函数$f(x)$的反常积分$\int_a^b f(x) dx$定义为</p><script type="math/tex; mode=display">\int_a^b f(x) dx = \lim_{\xi \rightarrow 0^-}\int^{b}_{a -\xi} f(x) dx</script><p>若上述极限存在，则称反常积分$\int_a^b f(x) dx$<strong>收敛</strong>，否则称为<strong>发散</strong></p><p>若$c \in (a,b)$是$f(x)$的唯一瑕点，则无界函数$f(x)$的反常积分$\int_a^b f(x) dx$定义为</p><script type="math/tex; mode=display">\int_a^b f(x) dx = \int_a^c f(x) dx + \int_c^b f(x) dx</script><p>若右边两个反常积分都<strong>收敛</strong>，则反常积分<strong>收敛</strong>，否则称为<strong>发散</strong></p><h3 id="无穷区间积分比较判别法"><a href="#无穷区间积分比较判别法" class="headerlink" title="无穷区间积分比较判别法"></a>无穷区间积分比较判别法</h3><script type="math/tex; mode=display">设f(x),g(x)在[a,+\infty)上连续，且0 \le f(x) \le g(x)，则</script><script type="math/tex; mode=display">\int_a^{+\infty} g(x) dx收敛 \rightarrow \int_a^{+\infty} f(x) dx 收敛(大收敛小收敛)</script><script type="math/tex; mode=display">\int_a^{+\infty} f(x) dx发散 \rightarrow \int_a^{+\infty} g(x) dx 发散(小发散大发散)</script><h3 id="无穷区间积分比较判别法的极限形式"><a href="#无穷区间积分比较判别法的极限形式" class="headerlink" title="无穷区间积分比较判别法的极限形式"></a>无穷区间积分比较判别法的极限形式</h3><script type="math/tex; mode=display">设f(x),g(x)在[a,+\infty)上非负连续，\lim_{x \rightarrow +\infty} \frac{f(x)}{g(x)} = \lambda，则</script><script type="math/tex; mode=display">当 \lambda > 0 时,\int_a^{+\infty} f(x) dx 与 \int_a^{+\infty} g(x) dx 同敛散</script><script type="math/tex; mode=display">当 \lambda = 0 时,\int_a^{+\infty} g(x) dx收敛 \rightarrow \int_a^{+\infty} f(x) dx 收敛</script><script type="math/tex; mode=display">当 \lambda = +\infty 时,\int_a^{+\infty} g(x) dx发散 \rightarrow \int_a^{+\infty} f(x) dx 发散</script><h3 id="无界函数积分的敛散性判别法"><a href="#无界函数积分的敛散性判别法" class="headerlink" title="无界函数积分的敛散性判别法"></a>无界函数积分的敛散性判别法</h3><script type="math/tex; mode=display">\int_a^b f(x) dx = \lim_{t \rightarrow +a^+}\int_t^b f(x) dx</script><script type="math/tex; mode=display">P积分: \int_a^b \frac{1}{(x-a)^p} dx\int_a^b \frac{1}{(b-x)^p} dx(p < 1时收敛;p \ge 1发散;a>0)</script><h3 id="无界函数积分比较判别法"><a href="#无界函数积分比较判别法" class="headerlink" title="无界函数积分比较判别法"></a>无界函数积分比较判别法</h3><script type="math/tex; mode=display">设f(x),g(x)在(a,b]上连续，且0 \le f(x) \le g(x)，则</script><script type="math/tex; mode=display">\int_a^{+\infty} g(x) dx收敛 \rightarrow \int_a^{+\infty} f(x) dx 收敛(大收敛小收敛)</script><script type="math/tex; mode=display">\int_a^{+\infty} f(x) dx发散 \rightarrow \int_a^{+\infty} g(x) dx 发散(小发散大发散)</script><h3 id="无界函数积分比较判别法的极限形式"><a href="#无界函数积分比较判别法的极限形式" class="headerlink" title="无界函数积分比较判别法的极限形式"></a>无界函数积分比较判别法的极限形式</h3><script type="math/tex; mode=display">设f(x),g(x)在(a,b]上非负连续，\lim_{x \rightarrow a^+} \frac{f(x)}{g(x)} = \lambda，则</script><script type="math/tex; mode=display">当 \lambda > 0 时,\int_a^{+\infty} f(x) dx 与 \int_a^{+\infty} g(x) dx 同敛散</script><script type="math/tex; mode=display">当 \lambda = 0 时,\int_a^{+\infty} g(x) dx收敛 \rightarrow \int_a^{+\infty} f(x) dx 收敛</script><script type="math/tex; mode=display">当 \lambda = +\infty 时,\int_a^{+\infty} g(x) dx发散 \rightarrow \int_a^{+\infty} f(x) dx 发散</script><h2 id="有理函数的积分"><a href="#有理函数的积分" class="headerlink" title="有理函数的积分"></a>有理函数的积分</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>形如$\int \frac{P_n(x)}{Q_m(x)}dx(n &lt; m)$的积分称为有理函数的积分，其中$P_n(x),Q_m(x)$分别是$x$的$n$次多项式和$m$次多项式</p><h2 id="换元积分法"><a href="#换元积分法" class="headerlink" title="换元积分法"></a>换元积分法</h2><p>换元必换限，不必代回原变量</p><script type="math/tex; mode=display">\begin{align}例题求解：\int _0^{In2} \sqrt{e^x-1}dx \\令 \sqrt{e^x-1} = u , 则x = In(u^2+1), dx = \frac{2u}{1+u^2}du \\当x = 0时,u = 0(下限) \\当x = In2时,u = 1(上限) \\原式 = \int _0^1u\frac{2u}{1+u^2}du = 2 \int _0^1 \frac{u^2+1-1}{1+u^2}du \\= 2 \int _0^1(1-\frac{1}{1+u^2})du = 2(u-arctanu) |_0^1 \\= 2(1 - \frac{π}{4}) = 0.4292\end{align}</script><h2 id="分部积分法-1"><a href="#分部积分法-1" class="headerlink" title="分部积分法"></a>分部积分法</h2><script type="math/tex; mode=display">\int _a^b udv = uv|_a^b - \int _a^bvdu</script><h1 id="一元函数微分学的几何应用"><a href="#一元函数微分学的几何应用" class="headerlink" title="一元函数微分学的几何应用"></a>一元函数微分学的几何应用</h1><p>假设以下曲线连续</p><h2 id="定积分表达和计算平面图形的面积"><a href="#定积分表达和计算平面图形的面积" class="headerlink" title="定积分表达和计算平面图形的面积"></a>定积分表达和计算平面图形的面积</h2><p>曲线$y = y_1(x)$与$y = y_2(x)$及$x = a,x =b(a&lt;b)$所围成的平面图形的面积</p><script type="math/tex; mode=display">S = \int^b_a |y_1(x) - y_2(x)|dx</script><p>曲线$r = r_1(\theta)$与$r = r_2(\theta)$及两射线$\theta = \alpha$与$\theta = \beta(0 &lt; \beta - \alpha \le 2\pi)$所围成的曲边扇形的面积</p><script type="math/tex; mode=display">S = \frac{1}{2}\int^\beta_\alpha |r^2_1(\theta) - r^2_2(\theta)| d\theta</script><h2 id="定积分表达和计算旋转体的体积"><a href="#定积分表达和计算旋转体的体积" class="headerlink" title="定积分表达和计算旋转体的体积"></a>定积分表达和计算旋转体的体积</h2><p>曲线$y = y(x)$与$x = a,x =b(a&lt;b)$及x轴所围成的曲边梯形<strong>绕x轴旋转一周</strong>所得到的<strong>旋转体</strong>的体积</p><script type="math/tex; mode=display">V_x = \int^b_a \pi y^2(x)dx</script><p>曲线$y = y(x)$与$x = a,x =b(a&lt;b)$及x轴所围成的曲边梯形<strong>绕y轴旋转一周</strong>所得到的<strong>旋转体</strong>的体积</p><script type="math/tex; mode=display">V_y = 2\pi \int^b_a x|y(x)|dx</script><p>曲线$y = y_1(x) \ge 0$与$y = y_2(x) \ge 0$及$x = a,x =b(a&lt;b)$所围成的平面图形<strong>绕x轴旋转一周</strong>所得到的旋转体体积</p><script type="math/tex; mode=display">V_x = \pi \int^b_a |y_1^2(x) - y_2^2(x)|dx</script><p>曲线$y = y_1(x) \ge 0$与$y = y_2(x) \ge 0$及$x = a,x =b(a&lt;b)$所围成的平面图形<strong>绕y轴旋转一周</strong>所得到的旋转体体积</p><script type="math/tex; mode=display">V_y = 2\pi \int^b_a x|y_1(x) - y_2(x)|dx</script><h2 id="定积分表达和计算函数的平均值"><a href="#定积分表达和计算函数的平均值" class="headerlink" title="定积分表达和计算函数的平均值"></a>定积分表达和计算函数的平均值</h2><p>设$x \in [a,b]$，函数$y(x)$在$[a,b]$上的平均值为</p><script type="math/tex; mode=display">\bar{y} = \frac{1}{b -a}\int^b_a y(x)dx</script><h2 id="函数切线方程与法线方程的求解"><a href="#函数切线方程与法线方程的求解" class="headerlink" title="函数切线方程与法线方程的求解"></a>函数切线方程与法线方程的求解</h2><h3 id="初等函数切线方程与法线方程公式"><a href="#初等函数切线方程与法线方程公式" class="headerlink" title="初等函数切线方程与法线方程公式"></a>初等函数切线方程与法线方程公式</h3><p>函数图形在某点$(a,b)$的切线方程为$y = kx + b$，k为斜率，b为截距</p><p>法线方程为$y = mx + c$，$m = -\frac{1}{k}$，m为法线斜率，c为法线截距</p><h3 id="导数求解切线方程与法线方程"><a href="#导数求解切线方程与法线方程" class="headerlink" title="导数求解切线方程与法线方程"></a>导数求解切线方程与法线方程</h3><p>函数$y = f(x)$在点$x_0$处的导数$f’(x_0)$在几何上表示曲线$y = f(x)$在点$M(x_0,f(x_0))$处的切线的斜率</p><p>切线方程：$y - y_0 = f’(x_0)(x - x_0)$，当$x = 0$时，截距为：$y = y_0 - x_0f’(x_0)$</p><p>法线方程：$y - y_0 = -\frac{1}{f’(x_0)}(x - x_0)$，当$y = 0$时，截距为：$x = x_0 + y_0f’(x_0)$</p><p>切点：$M(x_0,y_0)$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初等函数公式大全</title>
    <link href="/my_world/content/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
    <url>/my_world/content/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="各大初等函数图像"><a href="#各大初等函数图像" class="headerlink" title="各大初等函数图像"></a>各大初等函数图像</h1><h2 id="常数函数"><a href="#常数函数" class="headerlink" title="常数函数"></a>常数函数</h2><p>$y = C(其中C为常数)$</p><p><img src="../../image/image-20210906170255197.png" alt="常数函数图像和性质"></p><h2 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h2><p>$y = x^a,x是自变量,a是常数$</p><p><img src="../../image/image-20210906171008470.png" alt="幂函数图像和性质"></p><h2 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h2><p>$y = a^x,x是自变量，a是常数且a &gt; 0,a \neq 1$</p><p><img src="../../image/image-20210906171157330.png" alt="指数函数图像和性质"></p><h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h2><p>$y = log_ax，a是常数且a &gt; 0, a \neq 1，定义域 x \in (0,+\infty)$</p><p><img src="../../image/image-20210906171430735.png" alt="对数函数图像和性质"></p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>$正弦函数:y = sinx,定义域x \in (-\infty，+\infty),值域y\in[-1 , 1]$</p><p><img src="../../image/image-20210906171755503.png" alt="正弦函数图像"></p><p>$余弦函数:y = cosx,定义域x \in (-\infty，+\infty),值域y\in[-1 , 1]$</p><p><img src="../../image/image-20210906171817574.png" alt="余弦函数图像"></p><p><img src="../../image/image-20210906171847428.png" alt="正弦函数与余弦函数图像和性质"></p><p><img src="../../image/image-20210906172007749.png" alt="正切函数与余切函数图像"></p><p><img src="../../image/image-20210906172036688.png" alt="正切函数与余切函数性质"></p><p><img src="../../image/image-20210906172102757.png" alt="正割函数与余割函数图像"></p><p><img src="../../image/image-20210906172132191.png" alt="正割函数与余割函数性质"></p><p><img src="../../image/image-20210906172201151.png" alt="正割函数与余割函数续表"></p><p><img src="../../image/image-20210906172239117.png" alt="反正弦函数与反余弦函数图像"></p><p><img src="../../image/image-20210906172259239.png" alt="反正弦函数与反余弦函数性质"></p><p><img src="../../image/image-20210906172328326.png" alt="反正切函数与反余切函数图像"></p><p><img src="../../image/image-20210906172356060.png" alt="反正切函数与反余切函数性质"></p><h2 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h2><script type="math/tex; mode=display">(x - a)^2 + (y - b)^2 = r^2,A为圆的圆心，A的坐标为(a,b)，BA = AC = AP = r</script><p><img src="../../image/image-20210915142132138.png" alt="圆的图片"></p><h2 id="伯努利双纽线"><a href="#伯努利双纽线" class="headerlink" title="伯努利双纽线"></a>伯努利双纽线</h2><script type="math/tex; mode=display">(x^2 + y^2)^2 = a^2(x^2 - y^2),极坐标方程为r^2 = a^2cos2\theta</script><p><img src="../../image/image-20210915144444311.png" alt="第一种伯努利双纽线"></p><script type="math/tex; mode=display">(x^2 + y^2)^2 = 2a^2xy，极坐标为r^2 = a^2sin2\theta</script><p><img src="../../image/image-20210915144606635.png" alt="第二种伯努利双纽线"></p><blockquote><p>以下开始至乘法公式来自于原视频：<a href="https://www.bilibili.com/video/BV1534y1R7yk/?spm_id_from=333.788.recommend_more_video.-1">每天一遍，高数再见！—必考曲线_哔哩哔哩_bilibili</a></p></blockquote><h2 id="心形线（心脏线）"><a href="#心形线（心脏线）" class="headerlink" title="心形线（心脏线）"></a>心形线（心脏线）</h2><p><img src="../../image/image-20211217145502140.png" alt="猴屁股朝右"></p><script type="math/tex; mode=display">r = a(1 - cos\theta)(a>0)，红线段为2a</script><p><img src="../../image/image-20211217145641581.png" alt="猴屁股朝左"></p><script type="math/tex; mode=display">r = a(1 + cos\theta)(a>0)，红线段为2a</script><h2 id="阿基米德螺线"><a href="#阿基米德螺线" class="headerlink" title="阿基米德螺线"></a>阿基米德螺线</h2><p><img src="../../image/image-20211217150120819.png" alt="阿基米德螺线"></p><script type="math/tex; mode=display">r = a\theta(a > 0,\theta > 0)，当\theta由0增大时，r逐渐增大</script><h2 id="星形线"><a href="#星形线" class="headerlink" title="星形线"></a>星形线</h2><p><img src="../../image/image-20211217150746144.png" alt="星形线"></p><script type="math/tex; mode=display">\begin{cases}x = acos^3\theta  \\y = asin^3\theta \end{cases}</script><script type="math/tex; mode=display">x^{\frac{2}{3}}+y^{\frac{2}{3}} = a^{\frac{2}{3}}</script><h2 id="玫瑰线"><a href="#玫瑰线" class="headerlink" title="玫瑰线"></a>玫瑰线</h2><p><img src="../../image/image-20211217151305254.png" alt="玫瑰线"></p><script type="math/tex; mode=display">r = asin3\theta (a > 0)</script><script type="math/tex; mode=display">表达式右端是以\frac{2}{3}\pi 为周期的周期函数</script><h2 id="摆线（旋轮线）"><a href="#摆线（旋轮线）" class="headerlink" title="摆线（旋轮线）"></a>摆线（旋轮线）</h2><p><img src="../../image/image-20211217151009577.png" alt="摆线"></p><script type="math/tex; mode=display">\begin{cases}x = a(\theta-sin\theta )\\y = a(1-cos\theta )\end{cases}</script><script type="math/tex; mode=display">图中C的坐标为(\pi a，2a)</script><h1 id="乘法公式与因式分解"><a href="#乘法公式与因式分解" class="headerlink" title="乘法公式与因式分解"></a>乘法公式与因式分解</h1><script type="math/tex; mode=display">(a\pm b)^2 = a^2\pm2ab+b</script><script type="math/tex; mode=display">(a+b+c)^2 = a^2+b^2+c^2+2ab+2ac+2bc</script><script type="math/tex; mode=display">a^2 - b^2 = (a-b)(a+b)</script><script type="math/tex; mode=display">(a\pm b)^3 = a^3 \pm 3a^2b+3ab^2 \pm b^3 (杨辉三角 1 3 3 1)</script><script type="math/tex; mode=display">a^3 \pm b^3 = (a\pm b)(a^2 \mp ab + b^2)</script><script type="math/tex; mode=display">a^n - b^n = (a-b)(a^{n-1}+a^{n-2}b+\cdots+ab^{n-2}+b^{n-1})</script><h3 id="因式分解方法"><a href="#因式分解方法" class="headerlink" title="因式分解方法"></a>因式分解方法</h3><p><strong>十字相乘法</strong>（适合解决$ax^2\pm abx\pm b$类型的式子）</p><script type="math/tex; mode=display">在草稿纸上写下\begin{align}(x &&)\\(x &&)\\\end{align}的形式，括号左边相乘得ax^2，括号右边相乘得b</script><script type="math/tex; mode=display">需要尝试，使得对角相乘相加后得abx</script><blockquote><p>原视频：<a href="https://www.bilibili.com/video/BV1E4411S7TC/?spm_id_from=333.788.recommend_more_video.-1">6道题目帮你牢牢掌握十字相乘法_哔哩哔哩_bilibili</a></p></blockquote><h1 id="二次方式"><a href="#二次方式" class="headerlink" title="二次方式"></a>二次方式</h1><script type="math/tex; mode=display">ax^2 + bx + c = 0</script><script type="math/tex; mode=display">\begin{align}\Delta = b ^2 - 4ac (\Delta > 0,方程式有两个不等实根; \\\Delta = 0,方程式有两个相等实根; \\\Delta > 0,方程式有两个共轭虚根)\end{align}</script><script type="math/tex; mode=display">x_i = \frac{-b \pm \sqrt{\Delta}}{2a} = \frac{-b\pm \sqrt{b^2-4ac}}{2a}</script><script type="math/tex; mode=display">对称轴：x = -\frac{b}{2a}</script><script type="math/tex; mode=display">x_1+x_2 = -\frac{b}{a},x_1x_2 = \frac{c}{a}</script><h1 id="累加运算"><a href="#累加运算" class="headerlink" title="累加运算"></a>累加运算</h1><script type="math/tex; mode=display">\begin{align}& 大写\sum用于数学上的求和符号（总和符号） \\& \sum^n_iK 中n为上界，i为下界 \\& 即K从i开始取数，一直到n，全部加起来，即：\\& \sum^n_ix_i = x_i+x_{i+1}+x_{i+2}+\cdots+x_n \\& eg:\sum^{n = 100}_{i = 1}x_i = x_1+x_2+x_3+\cdots+x_{100}\end{align}</script><h1 id="排列与组合"><a href="#排列与组合" class="headerlink" title="排列与组合"></a>排列与组合</h1><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><script type="math/tex; mode=display">n! = 1 \cdot 2 \cdot 3 \cdots (n-1)n = n(n-1)!</script><h2 id="排列数计算公式"><a href="#排列数计算公式" class="headerlink" title="排列数计算公式"></a>排列数计算公式</h2><script type="math/tex; mode=display">\begin{align}A^m_n = n(n-1)(n-2)\cdots[n-(m-1)]\\= \frac{n(n-1)(n-2)\cdots(n-m+1)(n-m)(n-m-1) \cdots 2 \cdot 1}{(n-m)(n-m-1)\cdots2\cdot1}\\= \frac{n!}{(n-m)!}\\A^n_n = n!\end{align}</script><p>总结：</p><p>$A^m_n$为从n开始阶乘，一直乘到第m个</p><h2 id="组合数计算公式"><a href="#组合数计算公式" class="headerlink" title="组合数计算公式"></a>组合数计算公式</h2><script type="math/tex; mode=display">C^m_n = \frac{A^m_n}{A^m_m} = \frac{A^m_n}{m!}，其中C^0_n = 1</script><h1 id="根号运算"><a href="#根号运算" class="headerlink" title="根号运算"></a>根号运算</h1><script type="math/tex; mode=display">\sqrt[n]{a^m} = \sqrt[np]{a^{mp}}(a\geq0,p\neq0)</script><script type="math/tex; mode=display">\sqrt[n]{ab} = \sqrt[n]{a} \cdot \sqrt[n]{b}(a\geq0,b\geq0)</script><script type="math/tex; mode=display">\sqrt[n]{a^m} = (\sqrt[n]{a})^m(a\geq0)</script><script type="math/tex; mode=display">\sqrt[n]{\frac{a}{b}} = \frac{\sqrt[n]{a}}{\sqrt[n]{b}}(a\geq0,b>0)</script><script type="math/tex; mode=display">\sqrt[n]{\sqrt[m]{a}} = \sqrt[mn]{a},其中m,n\in N</script><h1 id="指数运算"><a href="#指数运算" class="headerlink" title="指数运算"></a>指数运算</h1><script type="math/tex; mode=display">a^m\cdot a^n=a^{m+n}</script><script type="math/tex; mode=display">(a^m)^n=a^{mn}</script><script type="math/tex; mode=display">(ab)^n=a^nb^n</script><script type="math/tex; mode=display">(\frac{a}{b})^m = \frac{a^m}{b^m}</script><script type="math/tex; mode=display">a^{-m}=\frac{1}{a^m}</script><h1 id="对数运算"><a href="#对数运算" class="headerlink" title="对数运算"></a>对数运算</h1><script type="math/tex; mode=display">N = a^{log_aN}</script><script type="math/tex; mode=display">log_a(MN) = log_aM + log_aN</script><script type="math/tex; mode=display">log_a(\frac{M}{N}) = log_aM - log_aN</script><script type="math/tex; mode=display">log_a(M^n) = nlog_aM</script><script type="math/tex; mode=display">log_a \sqrt[n]{M} = \frac{1}{n}log_a M</script><script type="math/tex; mode=display">log_aM = \frac{log_bM}{log_ba}</script><script type="math/tex; mode=display">log_a1 = 0,log_aa=1</script><h1 id="三角函数-1"><a href="#三角函数-1" class="headerlink" title="三角函数"></a>三角函数</h1><h2 id="特殊角的三角函数值"><a href="#特殊角的三角函数值" class="headerlink" title="特殊角的三角函数值"></a>特殊角的三角函数值</h2><p><img src="../../image/特殊三角函数值.jpg" alt="特殊角三角函数值"></p><h2 id="三角函数恒等式"><a href="#三角函数恒等式" class="headerlink" title="三角函数恒等式"></a>三角函数恒等式</h2><script type="math/tex; mode=display">\begin{align}sin^2x+cos^2x = 1,sec^2x - tan^2x = 1,csc^2x - cot^2x = 1 \\cotx = \frac{1}{tanx},secx = \frac{1}{cosx},cscx = \frac{1}{sinx} \\tanx = \frac{sinx}{cosx},cotx = \frac{cosx}{sinx}\end{align}</script><h2 id="倍角公式与半角公式"><a href="#倍角公式与半角公式" class="headerlink" title="倍角公式与半角公式"></a>倍角公式与半角公式</h2><script type="math/tex; mode=display">sin^2x = \frac{1-cos2x}{2}</script><script type="math/tex; mode=display">cos^2x = \frac{1+cos2x}{2}</script><script type="math/tex; mode=display">sinx \cdot cosx = \frac{1}{2}sin2x</script><script type="math/tex; mode=display">sin2x = 2sinxcosx</script><script type="math/tex; mode=display">cos2x = cos^2x - six^2x = 2cos^2-1 = 1 - 2sin^2x</script><script type="math/tex; mode=display">tan2a = \frac{2tana}{1-tan^2a}</script><script type="math/tex; mode=display">cot2a = \frac{cot^2a - 1}{2cota}</script><script type="math/tex; mode=display">cos^2 \frac{x}{2} = \frac{1+cosx}{2}</script><script type="math/tex; mode=display">sin^2\frac{x}{2} = \frac{1-cosx}{2}</script><script type="math/tex; mode=display">tan^2\frac{x}{2} = \frac{1-cosx}{1+cosx}</script><script type="math/tex; mode=display">sin3a = 3sina-4sin^3a</script><script type="math/tex; mode=display">tan\frac{x}{2} = \frac{1-cosx}{sinx} = \frac{sinx}{1+cosx}</script><script type="math/tex; mode=display">cos3a = 4cos^2a - 3cosa</script><script type="math/tex; mode=display">tan3a = \frac{3tana - tan^3a}{1-3tan^2a}</script><h2 id="两角和与差及和差化积、积化和差公式"><a href="#两角和与差及和差化积、积化和差公式" class="headerlink" title="两角和与差及和差化积、积化和差公式"></a>两角和与差及和差化积、积化和差公式</h2><p>和差化积：正加正，正在前。正减正，余在前。余加余，余并肩。余减余，余不见，负号很讨厌。</p><script type="math/tex; mode=display">sin(a \pm b) = sina \cdot cosb \pm cosa \cdot sinb</script><script type="math/tex; mode=display">cos(a \pm b) = cosa \cdot cosb \mp sina \cdot sinb</script><script type="math/tex; mode=display">tan(a \pm b) = \frac{tana \pm tanb}{1 \mp tana \cdot tanb}</script><script type="math/tex; mode=display">sina + sinb = 2sin\frac{a+b}{2}\cdot cos\frac{a-b}{2}</script><script type="math/tex; mode=display">sina - sinb = 2cos\frac{a+b}{2}\cdot sin\frac{a-b}{2}</script><script type="math/tex; mode=display">cosa + cosb = 2cos\frac{a+b}{2}\cdot cos\frac{a-b}{2}</script><script type="math/tex; mode=display">cosa - cosb = -2sin\frac{a+b}{2}\cdot sin\frac{a-b}{2}</script><script type="math/tex; mode=display">sina \cdot cosb = \frac{1}{2}[sin(a+b)+sin(a-b)]</script><script type="math/tex; mode=display">cosa \cdot sinb = \frac{1}{2}[sin(a+b)-sin(a-b)]</script><script type="math/tex; mode=display">cosa \cdot cosb = \frac{1}{2}[cos(a+b)+cos(a-b)]</script><script type="math/tex; mode=display">sina \cdot sinb = -\frac{1}{2}[cos(a+b)-cos(a-b)]</script><h2 id="转换规律"><a href="#转换规律" class="headerlink" title="转换规律"></a>转换规律</h2><h3 id="半角、倍角公式的转换"><a href="#半角、倍角公式的转换" class="headerlink" title="半角、倍角公式的转换"></a>半角、倍角公式的转换</h3><script type="math/tex; mode=display">\begin{align}sin(a \pm b) = sina \cdot cosb \pm cosa \cdot sinb \\cos(a \pm b) = cosa \cdot cosb \mp sina \cdot sinb \\tan(a \pm b) = \frac{tana \pm tanb}{1 \mp tana \cdot tanb} \\\end{align}</script><p>令$a = b = x$</p><script type="math/tex; mode=display">\begin{align}sin2x = 2sinxcosx \\cos2x = cos^2x - six^2x = 2cos^2-1 = 1 - 2sin^2x \\tan2a = \frac{2tana}{1-tan^2a} \\\end{align}</script><p>利用$cos2x = cos^2x - six^2x = 2cos^2-1 = 1 - 2sin^2x$逆推</p><script type="math/tex; mode=display">\begin{align}sin^2x = \frac{1-cos2x}{2} \\cos^2x = \frac{1+cos2x}{2} \\\end{align}</script><p>令$x {\div}  2$</p><script type="math/tex; mode=display">\begin{align}sin^2\frac{x}{2} = \frac{1-cosx}{2} \\cos^2 \frac{x}{2} = \frac{1+cosx}{2} \\\end{align}</script><p>令$sin^2\frac{x}{2} \div cos^2 \frac{x}{2}$</p><script type="math/tex; mode=display">tan^2\frac{x}{2} = \frac{1-cosx}{1+cosx}</script><p>推导：</p><script type="math/tex; mode=display">tan\frac{x}{2} = \frac{sin\frac{x}{2}}{cos\frac{x}{2}} = \frac{sin^2\frac{x}{2}}{sin\frac{x}{2}cos\frac{x}{2}} = \frac{\frac{1}{2}(1-cosx)}{\frac{1}{2}sinx} = \frac{1-cosx}{sinx} = \frac{sinx}{1+cosx}</script><h3 id="积化和差、和差化积公式转换"><a href="#积化和差、和差化积公式转换" class="headerlink" title="积化和差、和差化积公式转换"></a>积化和差、和差化积公式转换</h3><script type="math/tex; mode=display">\begin{align}sin(a \pm b) = sina \cdot cosb \pm cosa \cdot sinb \\cos(a \pm b) = cosa \cdot cosb \mp sina \cdot sinb \\\end{align}</script><p>令$sin(a + b) + sin(a - b)$</p><script type="math/tex; mode=display">2sina \cdot cosb = sin(a+b)+sin(a-b)</script><p>令$sin(a + b) - sin(a - b)$</p><script type="math/tex; mode=display">2cosa \cdot sinb = sin(a+b)-sin(a-b)</script><p>令$cos(a+b)+cos(a-b)$</p><script type="math/tex; mode=display">2cosa \cdot cosb = cos(a+b)+cos(a-b)</script><p>令$cos(a+b)-cos(a-b)$</p><script type="math/tex; mode=display">-2sina \cdot sinb = cos(a+b)-cos(a-b)</script><p>左右角替换，左边的角替换成右边的，右边也一样</p><script type="math/tex; mode=display">\begin{align}2sin\frac{a+b}{2}\cdot cos\frac{a-b}{2} = sina + sinb \\2cos\frac{a+b}{2}\cdot sin\frac{a-b}{2} = sina - sinb \\2cos\frac{a+b}{2}\cdot cos\frac{a-b}{2} = cosa + cosb \\-2sin\frac{a+b}{2}\cdot sin\frac{a-b}{2} = cosa - cosb\end{align}</script><h1 id="基本不等式"><a href="#基本不等式" class="headerlink" title="基本不等式"></a>基本不等式</h1><script type="math/tex; mode=display">|a \pm b| \le |a| + |b|</script><script type="math/tex; mode=display">||a| - |b|| \le |a - b|</script><script type="math/tex; mode=display">|\int_a^b f(x)dx| \le \int_a^b |f(x)|dx</script><script type="math/tex; mode=display">\sqrt{ab} \le \frac{a+b}{2} \le \sqrt{\frac{a^2+b^2}{2}}(a,b > 0)</script><script type="math/tex; mode=display">\sqrt[3]{abc} \le \frac{a+b+c}{3} \le \sqrt{\frac{a^2+b^2+c^2}{3}}(a,b,c > 0)</script><script type="math/tex; mode=display">\frac{a^2+b^2}{2} \ge |ab|</script><script type="math/tex; mode=display">设a>b>0\begin{cases}n > 0时,a^n > b^n \\n < 0时,a^n < b^n\end{cases}</script><script type="math/tex; mode=display">b > x > a > 0，d > y > c > 0，则\frac{c}{b} < \frac{y}{x} < \frac{d}{a}</script><script type="math/tex; mode=display">sinx < x < tanx(0 < x < \frac{\pi}{2})</script><script type="math/tex; mode=display">sinx < x(x > 0)</script><script type="math/tex; mode=display">arctanx \le x \le arcsinx(0 \le x \le 1)</script><script type="math/tex; mode=display">e^x \ge x+1</script><script type="math/tex; mode=display">x-1 \ge lnx(x > 0)</script><script type="math/tex; mode=display">\frac{1}{x} > ln(1 + \frac{1}{x}) > \frac{1}{1+x}(x>0)</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vulmap使用指南</title>
    <link href="/my_world/content/vulmap%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/my_world/content/vulmap%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1749f0f7c721826524e87961d26f8b3a543b920dcfc7d1602bfeddf7977af7e4">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc97900cf1c61670349f240eefd534c3e1c939865e22058e2c6489b027a7f5ea490e75275cd782c5228e384227b4f5796970402acabe3502d163f272b56afe87961c94d8d9bfac3a4cf469f46195781b85cfd2c171362001d95fcd26265634e55a60c2426ba45d025f61fb054b53bbe475b7b56362f00a996d092e8bad90ffa39082dc8840b32cd569792b090b6269006ec5518607709b854ae76a3ba7858dd9cb7f992222cc09d8d5b4a59aaf1dd9844970f9fd658be1dcfa9d37af33d41570af7906e7263076236329ab02d3c4483ab78030d7b523c478191a4365d98d4e1ff557c7a1db486adf7ff0c9e7ff2875b96bbb058996a393a9dd464f6f572db57a58ca124cdebbcb8f463065c54569c0df4369b642fa770c0b85984f2ec68c5563a294561776053aff6de82c63b6dd32df95772da7ed73e11a27e3f82a72ec1fd8141b1744abd7967e5c329a625030228192f94a3c8b065d3c9c6458db7de12add7166396bdb5ea81e171ddaef3a0e9c11fe0d2009fd6336091da14c310cb4faeacc9fabd5d5873e4911dc5b7136b6d4583839b92cd2467f8196b415df73b52981f9b658ecc8a0453a236c2407fdca6d261c4ebe75758420948adfd703156ebe9b95eaa1be38e49e8b7169f36b192d80dc49ebbda52799645171bf5e1abc360d4c8be345a1c866d5cde85c43d8b7dda7dc4985143d9197c1938bb61bdf4abe601d8f8fcc8128864813a8f126ce482536917e5fb240585a896efc9621d8ab09fd3fcf7850715e4b06cd8e03947159d9ca845ff69806eaf7300c2efefea5f5492df634071ed95588cb33f73ff065472a04e3a4731542c4782aae7dda41a2d35c89d0c734e2f3fbbbbbb01fb6096d85ddb763e884bde9ba560d5194baede3373877add4d570a579e9e32f17cd56ea5cdba2c71f40488d6140fc4d49b5f2be1664f2ba910c2214aecacae1b55108d5015bff5a0fa84047c4a66a9683328d3d4d4f12aec5b81ca846f3afd1f608543dec90d188774c24e96129f0291b655c4b63cb5109756b916a964d718059604d77d7975aa9b2f4d7b0c3d838e8f60c2f159a7176a4f02887b14ef5380cad3d2664d94256f91aee5229450f2895700b9052eea503bfb7e8a106c3fe69f765918ca5b1881da07ebba6b8ccd8b48c83023fdc8e1a91a82da92ff5629222dee498209a79f80bbc44a6b33aab23619d8c807195eb96e624e93c983aba56f98ddea3e1fe1aeb2ba2fcd12db01cb220b8da3dee902f0cba7c6730c43fb6fd86cdb8fb2f26fe70aa0b1357b99f5ef09e51c5e984c092d927d110174aeedf89a15b532b4765442aa28ebafc3d80a1256049e7ba2a2f9eed0412a2c246f51332670b65bf7cb23602ecfe6a95431f5d9bf0fc45f383feae74878d1288def3f1bbb6f795abf7f885930cc63ed9a97b36d26d04b045364eb3bad71e738c7e4d5c5f558d99fef478c253bae78eb9b40f0d46419a733e9ee3aeee26a42230cf07c262ebedd4584c2889d032a60c9a4db63570d81ea651285fdff9cf1891d1f1e347a0b08463921f5c83ab7f358141ac25dc053dd66a431abd6c1f62f0ec1946c425467cd252bcbe52c4d9f5ed2c91e83bff6c84444722de810e69feb1c53356071ffdb305f8fce02466d4b846efec244a8d59199f7103f9f01fd6de693981f60e05ee52206195e166e191246d1d81a4c5919d44aa80ef67b412e13692f8e16e3e465214991a6caa5d49c4fc3e431ed9c5ea82af2d7039fe368667496c2b631d9c5f6dd34dfb193bc48881555e40910c031459943c84c4e4f455b4732d98e1c52ab7108e865a47c21a93c3e7fae25f1c10188d099aa9d2cdf8de27b4552b5b40b7b67a8e0547919e677054d64d17c412ccfc84705ba18c902891c5e177c6860119e3e3c82aa19f4cfb0116d4c48d2e8514c10146f477fa4d4c208e80ee04241b78221d5cb06326fa27e943226f0d778e005757576bf4a616dd26d41e7cf195864e4cc5e274a473b5569dc5d2d5fa3fe5c7660cb42a5cfb9195a755e88d3000b3e7180d22ff94197da8fecfa767316b95837c430a646ed8593451a2b193751ddd9219735a9e4e88b0c25fd54c8225c88fbde06702dbe2d829cced78beb6312e7e037080e68566d52e095f19be290beb92c22d4d6dbf661d4968fbe5b0cbc4b4f5163e9bfc55f8460d30dd6b1a0b2009da8b4e830603af3eba3a262a552e4a88cabfb61955c74c0eeb51d0ff341a6b79e8a8921db2169d759bf1c35a4c06d6cd7187e040d78ccbfc916f70dd7d1abd38d29c35abf80323101ac36164a586ba5d7ee505d1530da343090c5ddd9a8a525cb735f9b1eac9bb4b31b4e95dd05037890f24cbc084ec19ac6a2943f6394b04fd42717beb88d6f63fdadaef9fd86041bf5bf34a19ef7ffae870b786592caa911c383da329f9467de56d6cf39060eaca7822494443626da6026e31cd2185c580b8d12ee558898d800f8106a3d51014c804ca601451bf8cd1225a18ac61ff57c197c0992ba82b02a10eb628701cfdbe906541311ca94e80396e8783d8b26eaaa372741dab7168068fd70faf19c3575afa523c22077eacf636ddcc8ce493b77ca65591001b25f8974fcd0ab2fa0a7075089bdc00011ffc73779f347424a54efaed64a0fa75f4543070c5078d1b19cf8960615e36bbe242fd7986b25ad15ad739148c5139936c7b82ed96d95a92fcbb17e07ebb8c1ece18734002cd2f2817ff79799f358fdf67156a7437e586bdd4cdf4c79ec86591e3007402e6f6cdff1aa11919d1db7d99c379137cd6b1f7d86eede638c9678c9ce3926dec11b80bdf2b9ac3f83349a3cd04e047ed4d8a2e7ab1f40a216a5d83ef06d61f876475b21b555dd3e3c770c28432f77259eda1f3dae640c51f003a396523f98641bea4c9ceb7de1717899029642e77e67370ddf6199f0dfe5619ded4fc808e500dd618a6d200d782643a479888ff97a626d07d4847f1ee50514c893f3d4e9bd276b75aab99c7349576d0ffafe3cdf8724be1e844eafc5bad72a147d14bace68d54210548ea74eced6f30d5c3446ed304a6d7218c836bff13af52c534bd968da6db849b3b43522a3c54cca6abda1deccea1a8ffb815c820a0a091c74b13c478491a531654ff9a43a9323c17ab9bdcab3678e1d085ae703d1e36a63ea2fec891962e97c8bcdc3890817d94cc06b302741623cf940a22c0da1e4471b5fe25dd531c7ee71b959bb818efaa3b23c9c0a472ac5825a1a6b788de666f89cac452e6bec6200b1fa13c8fdcce2ed8d253cce89b8449a05081713da35eec19a3d25de335f97fd85335ecda1c41e4f9979579636bd20a5c878a844c4979b0b83585061e3c2b42c743a48527d28ed68a59693b015a7f2741088fedf5b410999717fdc00dfc53e36706a289945ce6042505ee79937b23d6fb8f926d506533e041fcd15537fba2fac6539afa553232c6e6d180647b394b3a38fd6985b674b04903646af272b3b5cdd6aa56e90588ee6f40a0302add608d37e2a49e98566431d05c62771ab1d071a277e0c6a5df4ce15c99daa2a6400a60d9c736b101dc0f30a715601e29d5c65cf51d366dc39c4dbdbc7075186d4e349191dcc24b9a881406c0cbc809c4a62ec336e9ec0af5c662b8b0e1d16ca3abf7e7035684cf5ef3bf6e1bc2b4451174a4425338e8e560965a2d9ac47c9f9aa3346383aa7e62dbf05875369c2372a2dd713711a93388aa4bcf22e1079c0c93d33981098f10ec49f58131f479f1ef29c5d6897738d1b84e031be0e3eb7501ba2967952472f3c124cce86501180c6dc236e7fa72f8fe3352653ead0365a7beb621d478ee83728d80ab9f17d15ba14c963d33c8118f327e12d51af768e6f6395c37e9d2e02dec3d9ae03892c214619fa1391a21f38388b661cff773899ec2ccb4357303c18403bd654574ddaf873dab3f4fc7c658b40bade6f140d019f8daf54e9b7169b7111f41659bb81efc73af9256b9a12331b4191fb2b94320a5ab2e4783696e596473290151c6156b78b16f40f388ea949e6d695fa83b5db36eb021bf1c7486834565d9a2c6ea6600842b8a0b29e3fece8f17e3cd62311db6083d50eb7b3aa55adf9c361dd9997fd2a4505524a86123e53c3afcd6dcbd8835c08f08f9987ddc4b24e52c99b202542b62f69328c197ce76fa711573a7e358d3a22eecc324fa7f8df238c7f7ea8e4b7c543f51f6fea91f90e10d9cb701980c800e885ec1247518cd3bf06935613f108c0fc20978cb0d0b3ec5dc3276c3ac246e3e3e3711e83caeec6858a1a060276cef5343bff7b1d5c68479317a578abaa0c5197d595dbc87685fd25906dec6f7e8eb77b711ffbba6d7be9ce313c621e9b0bcc212b2921f225974f2b8a7d659b7df428f6710efaf06c2597682297679620c78ac0694ee241ee9a842ed352d5c8707a6da6228acac20d855b6e7359bf2bdd083c9081923a99584e7cc15dfe0227e9edbfd97f98dcddc6baf7b4c071fcb9b9a61d5a80930eb3a306ae84949db6371c161bbccc2151585d2873916c13a6893bba7511d9f5799fe14a173ba5558797a0e4c7660718a5966690fa0e858aec156ac6fe9015b4026e9d5fb3191144f9adb69f719297eb573ca9a008c24c635641beda0e9bc04d38b2f7d7d0462a5a17b25d081daee36e709d4381a3b08a9d1af8dd3bdce191566212a2e2c55fed0d298b168a75f2ea3aa00f5d7113c49efe282ba742e19345d7d22479dbdbf71fb05cd312be03d84a19e9475961bb26ef4a97e39d4d41a16cecba626ecfe444fb495fcf79f9eaf703d848fc5436add9e85f0deb560836d785b66e64fcec3b638473b2d41bd559626a14c9db45b4b6d8044f8a8da83ab4319a0fadfea3503c3846f393565a96d170e12b3a499b3c29a2c771382e9c2c308ea7cae52967fab4cb7a6afb7f67a0e45f4b68f164576a5a6883c56d528f6b883e6a445bc33880b38a4d92b97e119583f1a7ff1eaa3b2c4bd6f21271907c5d32f540ce2baba5908c2e562c6c27502daf8a2312d2cd23b95ff29b4bdc9fcc0da6dcef7c756b7b44d6b44032d6c60cd5d750df9da9cc8e4df624d43d2a4f608b62e8d701c5e66ffd0b0075dc243f51abf7e40e9fa8824ab387648e76f93173d43ed54a0149d5dd996799d87af9ba4a9279bb7e57bba9b560e1c9d1a24fb10e192e3a1ce577b1268783f00d070d57f9df94e1672a84333248df72fd45e82bc51d6ace264da9acf2faa285b201e4125c5ade81bb29fabfbba165f827f76aa6b46bfb4137dd2280c3a2eff8bbb435e56825bb470f93eac7eb89f12355c25d6d3655c38c0c85acbb2bcbcb1d1c125a5ce717e56da047807edbaae471c005a7fadd8ca0a3bcb09acebcfece385a9995c9d366b78bed8e46c1143a9289303fbeead287e593038867620f6d735f662ccaba3c791c98612b1a160a743ffadeee666b622dd14c6e067604e73618099dd5db638735ac3d2009436d93d06295a047892924d4c4de6fe8ab02de3d230485bcdb3ba1fe50a5b8328bf5a298f1676264e4d7272f93412f652e1bb0f201cb39f8ca502f3154e3020c173d7e61a67724ebc32c67a5ca259aa513698194707447dcc835effa96c0dd92997ad942819045e73ed2aca71b334ff0ad57efcfda4a704562506a3b4359c166d728da631b7a47cb5142732e15c3893d52dde9a6700e1c4db2ebba42c1563d2247befa3e52d898576bbd8de25c6394e4a86737ef63c9570f33727f737a814deb26afed366e13c1a6abfc157c076892e63a5278769ab0a1852aefd23cf6d133d6152b87650d709c3dd34e1c32e7dec69e0a68723b134bc10850b067ccf58011ce13156d461d2e2446f3116d2dfb585c84ddaf8842fb7db6aa5b76947edbe5d5c7f2051ed7692335fd6834d77042af07f0778067304ea19d96d121d57ac64321af135e71ce42d5c013536df0457d1ae2f29de2ab950d576c2ae1626e9b267efeb8403b77338aa8c46cc7593f5e71bbcfbeb0566ee93f0d216f6d0046061f2a1a1e29ca7c5552e0f069a53c26b5b319f20422cb591c1e93fa13abd646d2591ba7fefcfb7260722b9a3140c8b4854b45a1eef3e9de5aa6c71539749e6c07a9a85c151d347fa85d24bbc3cdfe5634be8a99c8172fa6c30a790d03dc5dc92d43f55d5e07000269751a1ac29f33818c4b761aae3b7acfbbd63badbe3a8a2d1ecf0cd07d2046c50bb5da8275d7c2ca41209feef7da2891e3f2cda969bdd724ee31b15a18f6bcad6b98af7053e686f28b666fca0ea8afba0ce8f934a1fc81e66010451b58490a5c160efd26f7e8aa4030ff9eefb5678de77113cd552094beb0b937586048b69dafd14d44ca9542933ef122cbb287abc99b945cfb042055821bc8d94a34af7a99cb097913e9495f58e95f7f35376edcc30ba565621e8c5e11284c660bf4ad5c5cbbeab074f57468d9841547395f7dd38130009b2149f53c197d96cdca866046ffee5a71a2aecf529230b4de94bded08fb739f6f9e3ad1e90d6b0aa635f1acfe0d265fb8d1edb8215679310ded8d6e10cb1eada499b97157018d36b77cca6ffe8047e3c8f7bd7ce858beadef03fb67ad36ba7475361884679513e03da2d54b9e090fd6f8d4bda1f55e5a2469137be42b6fe6f6ae36d30a1d299c5d480579d8aba6568d1863bb5162de6d536ec7baffac24d36017d53f79f4b3e1e8408994679a63c2c80e018f67625577ed93fc74b9f659d2bdee4da0e138eba2fee8229646d46e62ad5617b73cb4b2b22d52c4704470a279b04f0d91cfec63b70c37c95b2eab73a635f71c2c2d0e8685137669805ebf30d97667a2866eb274eef0a2cb1673337f2717c0a98f1c702dddf3dd492c193391c117efa51a924fee7efe05c558a01cd6f5e19411afd184d0f9d90df61d8ada071a5205d022116d7a3c3683d481d154dfe7f0ae03df13a92319caa76d8fc4238076cd3c580129068042e89eeecc5ecffa001514d781ca25887a82d5506268bff9e3fe4ee1ae3923c4715915697b549ee10ba82715a0201ba16e1c6d7d4432b64a8265131bbecef80242f1cbe75de1e26e5423ffa11ba83537879bc6759163206a0687a189ad24cffec71b93b22f0fdaa738a77547ae428ad4eae131a870cddf001a44895ccd794bc3d8424b15b738ecf7ebc2b220be13acfb1ef58de0d23850743efbf2caab0e469ff685c291e7741db8cee519a74daeb82f44b1b86b4ff71860c38f44b19926d5c0a437781bed6c5c2011c7d85685ef562e3c090e7d18b516afc82bdcdeb71b42c98a18a2f17709aa117c72689b234228baa35e0aa052b0a90d29c57d2691061d89943d365f0ccc921d1c81eb12a487dc2d4e7f19631b2224c6e96d2bf9bdf91577e96827fa5102adf0b9b839839f1f231fbc9cb219e93bd35c2587239cb9bbd2f408f92b97bb5ec3b473edd23c55847e463d892206fcfe723c68482a015705a3e2b5091746ff0bf5dcbf8fe8b86640ae1fcddaff2e567f1c052bef77b645ec36c98ebd644321120e0349a373a5ff28ce6a83e93f73f804f911026ad5db5afe4bf5b03c3d3c3d9407717a63c1244f281b60de8f0611f8f44e5efac2d11b1d88b8182e63d25ec1fb5790142e7a5f26e3fb22e0a108e2e5064110716d442bc8373297b7f295be207893277b05abda4c45bc277e0bb278f496a06cbdb9fb1581121c45efc0f7a37eb0f2b7ae4f43ffb86552bd44f9ed085dedab1cf6ee2eb289abd564b30b47bdd75234164872e43353f24b9be9136691de860a38c78417d13704f1e9a19d419ba92b7fb8483701824e16b5ef9ba51ea2a55d2a0052bf8ee2baec1aa4e88346c6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>私人笔记</tag>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化测试框架大总结（二）</title>
    <link href="/my_world/content/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/my_world/content/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Appium是一个开源的自动化测试工具，其支持iOS和安卓平台上的原生的，基于移动浏览器的，混合的应用。</p><p><strong>Appium 理念</strong></p><p>Appium是基于以下的四个理念设计来满足移动平台测试自动化的要求的：</p><ol><li>您不应该因为需要自动化测试您的应用而不得不以任何形式去重新编译或者修改你的app</li><li>您不应该把自己固定在一门特定的语言和一个特定的框架上去实现和运行你的测试</li><li>当说到测试自动化APIs的时候，一个移动测试框架不应该做“重新发明轮子”的事情，</li><li>一个移动测试自动化框架应该是开源的，无论是在精神上，实际上，还是名义上！</li></ol><p><strong>使用Appium进行自动化测试有两个好处</strong></p><p>Appium在不同平台中使用了标准的自动化APIs，所以在跨平台时，不需要重新编译或者修改自己的应用。</p><p>Appium支持Selenium WebDriver支持的所有语言，如java、Object-C、JavaScript、Php、Python、Ruby、C#、Clojure，或者Perl语言，更可以使用Selenium WebDriver的Api。Appium支持任何一种测试框架.Appium实现了真正的跨平台自动化测试。（本文主要介绍Python的用法）</p><p><strong>Appium架构</strong></p><p>Appium 是一个用Node.js编写的HTTP server，它创建、并管理多个 WebDriver sessions 来和不同平台交互，如 iOS ，Android等等. </p><p>Appium 开始一个测试后，就会在被测设备（手机）上启动一个 server ，监听来自 Appium server的指令. 每种平台像 iOS 和Android都有不同的运行、和交互方式。所以Appium会用某个桩程序“侵入”该平台，并接受指令，来完成测试用例的运行。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>appium下载地址：<a href="http://appium.io/">Appium: Mobile App Automation Made Awesome.</a></p><p>python安装库</p><div class="code-wrapper"><pre><code class="hljs shell">pip install Appium-Python-Client</code></pre></div><p>前置条件</p><ol><li>搭建java环境，这里不再赘述</li><li>搭建Android环境，sdk下载地址：<a href="http://developer.android.com/sdk/index.html，国内的sdk">http://developer.android.com/sdk/index.html，国内的sdk</a> tools下载地址：<a href="http://www.androiddevtools.cn/">http://www.androiddevtools.cn/</a></li><li>安装node.js：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li></ol><p>下载并安装完毕后，打开appium，点击Edit Configurations按钮，设置安卓根目录和java根目录。</p><p><img src="../../image/image-20220701093503281.png" alt="设置完毕后点击save and restart即可"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先在<strong>本机</strong>开启appium服务器，ip不变，端口号为4723</p><p>引入appium</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver</code></pre></div><p>输入启动参数，这里只是连接对应的安卓手机</p><div class="code-wrapper"><pre><code class="hljs python">desired_caps = &#123;&#125;desired_caps[<span class="hljs-string">&#x27;platformName&#x27;</span>] = <span class="hljs-string">&#x27;Android&#x27;</span>desired_caps[<span class="hljs-string">&#x27;deviceName&#x27;</span>] = <span class="hljs-string">&#x27;UUID&#x27;</span></code></pre></div><p>具体的参数，地址：<a href="https://blog.csdn.net/Chaqian/article/details/109447117">【appium】appium自动化入门之基本参数完整版（67个appium基本参数和关键字）_Chaqian的博客-CSDN博客_appium参数</a></p><p>开启appium的session连接</p><div class="code-wrapper"><pre><code class="hljs python">driver = webdriver.Remote(<span class="hljs-string">&quot;http://localhost:4723/wd/hub&quot;</span>,desired_caps)</code></pre></div><p>注意：<code>http://localhost:4723/wd/hub</code>这里的<code>wd/hub</code>不能多<code>/</code>，否则报错</p><p>测试连接，开启淘宝app</p><div class="code-wrapper"><pre><code class="hljs python">driver.activate_app(<span class="hljs-string">&quot;com.taobao.taobao&quot;</span>)</code></pre></div><h2 id="apk操作"><a href="#apk操作" class="headerlink" title="apk操作"></a>apk操作</h2><h3 id="打开app"><a href="#打开app" class="headerlink" title="打开app"></a>打开app</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打开淘宝</span>driver.activate_app(<span class="hljs-string">&quot;com.taobao.taobao&quot;</span>)</code></pre></div><p>查看打开的app的包名有3种办法</p><p><strong>第一种</strong></p><p>cmd中输入命令：<code>adb shell am monitor</code><br>然后启动需要获取包名的应用</p><p><strong>第二种</strong></p><p>cmd中输入命令：<code>adb shell pm list packages -3</code><br>查看自己安装的app包名</p><p><strong>第三种</strong></p><p>下载雷电模拟器的包名类名查看器，找到app后直接点击复制包名（方便快捷）</p><p>下载地址：<a href="https://www.ldmnq.com/app/210.html">包名类名查看器电脑版下载<em>包名类名查看器PC版下载</em>雷电安卓模拟器 (ldmnq.com)</a></p><h3 id="停止应用运行"><a href="#停止应用运行" class="headerlink" title="停止应用运行"></a>停止应用运行</h3><p>以网易云音乐为例</p><div class="code-wrapper"><pre><code class="hljs python">stop_app(<span class="hljs-string">&quot;com.netease.cloudmusic&quot;</span>)</code></pre></div><h3 id="安装-卸载应用"><a href="#安装-卸载应用" class="headerlink" title="安装/卸载应用"></a>安装/卸载应用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 安装应用</span>driver.install_app(<span class="hljs-string">&quot;D:\demo\tutorial-blackjack-release-signed.apk&quot;</span>)<span class="hljs-comment"># 卸载应用</span>driver.remove_app(<span class="hljs-string">&quot;com.netease.cloudmusic&quot;</span>)</code></pre></div><h2 id="元素获取"><a href="#元素获取" class="headerlink" title="元素获取"></a>元素获取</h2><p>首先引入<code>AppiumBy</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By</code></pre></div><p>这里用<code>find_element</code>接口，通过<code>by</code>和<code>value</code>寻找数值</p><div class="code-wrapper"><pre><code class="hljs python">driver.find_element(by=By.XPATH,value = <span class="hljs-string">&quot;//android.widget.FrameLayout[@content-desc=\&quot;消息\&quot;]/android.widget.ImageView&quot;</span>)</code></pre></div><p><code>by</code>的参数，可以通过<code>AppiumBy</code>去获取，常用的分别有：</p><ul><li><code>By.XPATH</code></li><li><code>By.NAME</code></li><li><code>By.ID</code></li><li><code>By.CLASS_NAME</code></li><li><code>By.LINK_TEXT</code></li></ul><h2 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h2><p>首先引入<code>TouchAction</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> appium.webdriver.common.touch_action <span class="hljs-keyword">import</span> TouchAction</code></pre></div><p> 普通的点击</p><div class="code-wrapper"><pre><code class="hljs python">driver.find_element(by=AppiumBy.XPATH,value = <span class="hljs-string">&quot;//android.widget.FrameLayout[@content-desc=\&quot;消息\&quot;]/android.widget.ImageView&quot;</span>).click()</code></pre></div><p>手指轻敲屏幕操作</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 通过元素定位方式敲击屏幕</span>el = driver.find_element(by=AppiumBy.XPATH,value = <span class="hljs-string">&quot;//*[contains(@text,&#x27;WLAN&#x27;)]&quot;</span>)TouchAction(driver).tap(el).perform()<span class="hljs-comment">#perform()方法发送命令到服务器执行操作</span><span class="hljs-comment"># 通过坐标方式敲击屏幕，元素坐标:x=149,y=324</span>TouchAction(driver).tap(x=<span class="hljs-number">149</span>,y=<span class="hljs-number">324</span>).perform()</code></pre></div><p>手指按下和释放操作</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 通过元素定位方式按下屏幕</span>el = driver.find_element(by=AppiumBy.XPATH,value = <span class="hljs-string">&quot;//*[contains(@text,&#x27;WLAN&#x27;)]&quot;</span>)TouchAction(driver).press(el).release().perform()<span class="hljs-comment">#通过坐标的方式，元素坐标x=149,y=324</span>TouchAction(driver).press(<span class="hljs-number">147</span>,<span class="hljs-number">324</span>).release().perform()</code></pre></div><p>手指长按操作</p><div class="code-wrapper"><pre><code class="hljs python">el =driver.find_element_by_id(<span class="hljs-string">&quot;android:id/title&quot;</span>)<span class="hljs-comment"># 通过元素定位方式长按元素</span>TouchAction(driver).long_press(el,duration=<span class="hljs-number">5000</span>).release().perform()<span class="hljs-comment"># 通过坐标方式长按元素，WiredSSID坐标:x=770,y=667</span><span class="hljs-comment"># wait(5000)等待五秒</span><span class="hljs-comment"># 添加等待(有长按X效果)／不添加等待(无长按效果)</span>TouchAction(driver).long_press(x=<span class="hljs-number">770</span>,y=<span class="hljs-number">667</span>,duration=<span class="hljs-number">5000</span>).release().perform()</code></pre></div><p>滑动</p><div class="code-wrapper"><pre><code class="hljs python">driver.swipe(start_x,start_y,end_x,end_y)</code></pre></div><h2 id="元素等待"><a href="#元素等待" class="headerlink" title="元素等待"></a>元素等待</h2><p>引入<code>WebDriverWait</code>和<code>expected_conditions</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC</code></pre></div><p>实例：</p><div class="code-wrapper"><pre><code class="hljs python">WebDriverWait(driver,timeout=<span class="hljs-number">10</span>).until(EC.element_to_be_clickable(el),message=<span class="hljs-string">&quot;找到元素啦&quot;</span>)</code></pre></div><p><code>WebDriverWait</code>与<code>until</code>、<code>expected_conditions</code>联合判别元素是否存在，API如下：</p><ul><li><code>title_is</code>: 判断当前页面的title是否精确等于预期</li><li><code>title_contains</code>: 判断当前页面的title是否包含预期字符串</li><li><code>presence_of_element_located</code>: 判断某个元素是否被加到了dom树里，并不代表该元素一定可见</li><li><code>visibility_of_element_located</code>: 判断某个元素是否可见.<strong>可见代表元素非隐藏，并且元素的宽和高都不等于0</strong></li><li><code>visibility_of</code>: 跟上面的方法做一样的事情，只是上面的方法要传入locator，这个方法直接传定位到的element就好了</li><li><code>presence_of_all_elements_located</code>: 判断是否至少有1个元素存在于dom树中。举个例子，如果页面上有n个元素的class都是’column-md-3’，那么只要有1个元素存在，这个方法就返回True</li><li><code>text_to_be_present_in_element</code>: 判断某个元素中的text是否<strong>包含</strong>了预期的字符串</li><li><code>text_to_be_present_in_element_value</code>: 判断某个元素中的value属性是否<strong>包含</strong>了预期的字符串</li><li><code>frame_to_be_available_and_switch_to_it</code>: 判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False</li><li><code>invisibility_of_element_located</code>: 判断某个元素中是否不存在于dom树或不可见</li><li><code>element_to_be_clickable</code>: 判断某个元素中是否可见并且是enable的，这样的话才叫clickable</li><li><code>staleness_of</code>: 等某个元素从dom树中移除，注意，这个方法也是返回True或False</li><li><code>element_to_be_selected</code>: 判断某个元素是否被选中了,一般用在下拉列表</li><li><code>element_selection_state_to_be</code>: 判断某个元素的选中状态是否符合预期</li><li><code>element_located_selection_state_to_be</code>: 跟上面的方法作用一样，只是上面的方法传入定位到的element，而这个方法传入locator</li><li><code>alert_is_present</code>: 判断页面上是否存在alert</li></ul><h1 id="uiautomator2"><a href="#uiautomator2" class="headerlink" title="uiautomator2"></a>uiautomator2</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>uiautomator2是一个可以使用 Python 对 Android 设备进行 UI 自动化的库。其底层基于Google uiautomator，Google 提供的uiautomator库可以获取屏幕上任意一个 APP 的任意一个控件属性，并对其进行任意操作，目前仅支持 android 平台的原生应用测试。</p><p>uiautomator2有如下特点：</p><p>功能丰富 ：设备和开发机可以脱离数据线，可通过 WiFi 互联；</p><p>得心应手 ：集成了 openstf/minicap 加快截图速度 , 集成了 openstf/minitouch 达到精确实时控制设备 , 修复了 xiaocong/uiautomator 经常性退出的问题；</p><p>深度整合 ：代码进行了重构和精简，方便维护；</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs ada">pip install <span class="hljs-comment">--pre -U uiautomator2</span></code></pre></div><h2 id="weditor安装"><a href="#weditor安装" class="headerlink" title="weditor安装"></a>weditor安装</h2><p>作者的python版本为3.8，安装最新的weditor会失败，所以需要指定weditor的版本</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install weditor==<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">4</span></code></pre></div><p>运行</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">python -m weditor</span></code></pre></div><p>使用参考：<a href="https://zhuanlan.zhihu.com/p/372294429">干货分享|APP自动化测试抓元素利器——weditor - 知乎 (zhihu.com)</a></p><h2 id="连接设备"><a href="#连接设备" class="headerlink" title="连接设备"></a>连接设备</h2><h3 id="设备环境调控"><a href="#设备环境调控" class="headerlink" title="设备环境调控"></a>设备环境调控</h3><p>手机链接pc，输入adb命令<code>adb devices</code>发现设备后表明设备已连接成功</p><p>pc终端输入命令，以安装atx-agent至手机，命令如下：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> -m uiautomator<span class="hljs-number">2</span> init</code></pre></div><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>通过<code>adb devices</code>获取设备的UUID，然后输进参数即可</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> uiautomator2 <span class="hljs-keyword">as</span> u2  //依赖包d = u2.connect(<span class="hljs-string">&#x27;9568940ECCBB&#x27;</span>)</code></pre></div><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h3><div class="code-wrapper"><pre><code class="hljs python">d.app_start(<span class="hljs-string">&quot;com.xueqiu.android&quot;</span>)</code></pre></div><h3 id="停止应用"><a href="#停止应用" class="headerlink" title="停止应用"></a>停止应用</h3><div class="code-wrapper"><pre><code class="hljs python">d.app_stop(<span class="hljs-string">&quot;com.xueqiu.android&quot;</span>)</code></pre></div><h3 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h3><p>分长按和点击两种，如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 通过text点击</span>d(text=<span class="hljs-string">&quot;Settings&quot;</span>).click()<span class="hljs-comment"># 长按有Settings文本的元素</span>d(text=<span class="hljs-string">&quot;Settings&quot;</span>).long_click()<span class="hljs-comment"># 点击坐标（相对坐标，适应不同分辨率）</span>w,h = d1.window_size()d.click(<span class="hljs-number">0.5</span>*w, <span class="hljs-number">0.5</span>*h)</code></pre></div><p>ui2支持 android 中 UiSelector 类中的所有定位方式（也就是d后面括号的形参）可以进该网站查询：<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiSelector">UiSelector  | Android Developers (google.cn)</a>，列举如下：</p><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>指定text文本的元素</td></tr><tr><td>textContains</td><td>text中包含有指定文本的元素</td></tr><tr><td>textMatches</td><td>text符合指定正则的元素</td></tr><tr><td>textStartsWith</td><td>text以指定文本开头的元素</td></tr><tr><td>className</td><td>指定类名的元素</td></tr><tr><td>classNameMatches</td><td>className类名符合指定正则的元素</td></tr><tr><td>description</td><td>指定description文本的元素</td></tr><tr><td>descriptionContains</td><td>description中包含有指定文本的元素</td></tr><tr><td>descriptionMatches</td><td>description符合指定正则的元素</td></tr><tr><td>descriptionStartsWith</td><td>description以指定文本开头的元素</td></tr><tr><td>checkable</td><td>可检查的元素，参数为True或False</td></tr><tr><td>checked</td><td>已选中的元素，通常用于复选框，参数为True或False</td></tr><tr><td>clickable</td><td>可点击的元素，参数为True或False</td></tr><tr><td>longClickable</td><td>可长按的元素，参数为True或False</td></tr><tr><td>scrollable</td><td>可滚动的元素，参数为True或False</td></tr><tr><td>enabled</td><td>已激活的元素，参数为True或False</td></tr><tr><td>focusable</td><td>可聚焦的元素，参数为True或False</td></tr><tr><td>focused</td><td>获得了焦点的元素，参数为True或False</td></tr><tr><td>selected</td><td>当前选中的元素，参数为True或False</td></tr><tr><td>packageName</td><td>指定包名的元素</td></tr><tr><td>packageNameMatches</td><td>packageName为符合正则的元素</td></tr><tr><td>resourceId</td><td>为指定resourceId的元素</td></tr><tr><td>resourceIdMatches</td><td>resourceId为符合指定正则的元素</td></tr><tr><td>index</td><td>元素索引</td></tr></tbody></table></div><h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><div class="code-wrapper"><pre><code class="hljs python">w,h = d.window_size()d.swipe(<span class="hljs-number">0.1</span>*w,<span class="hljs-number">0.5</span>*h,<span class="hljs-number">0.8</span>*w,<span class="hljs-number">0.5</span>*h) <span class="hljs-comment"># 从(0.1,0.5)滑动到(0.8,0.5)</span>d.swipe_ext(<span class="hljs-string">&quot;up&quot;</span>, <span class="hljs-number">0.5</span>) <span class="hljs-comment"># 向上滑动0.5，可以为up、down、left和right</span></code></pre></div><h3 id="元素等待-1"><a href="#元素等待-1" class="headerlink" title="元素等待"></a>元素等待</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 等待元素的出现</span>d(text=<span class="hljs-string">&quot;Settings&quot;</span>).wait(timeout=<span class="hljs-number">10.0</span>)<span class="hljs-comment"># 等待元素消失，返回True False,timout默认为全局设置的等待时间</span>d(text=<span class="hljs-string">&#x27;Settings&#x27;</span>).wait_gone(timeout=<span class="hljs-number">20</span>)</code></pre></div><h3 id="发送文本"><a href="#发送文本" class="headerlink" title="发送文本"></a>发送文本</h3><div class="code-wrapper"><pre><code class="hljs python">d(text=<span class="hljs-string">&quot;Settings&quot;</span>).set_text(<span class="hljs-string">&quot;你好&quot;</span>)</code></pre></div><h3 id="输入法切换"><a href="#输入法切换" class="headerlink" title="输入法切换"></a>输入法切换</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 切换成ui2的输入法，这里会隐藏掉系统原本的输入法,默认是使用系统输入法</span><span class="hljs-comment"># 当传入False时会使用系统默认输入法，默认为Fasle</span>d.set_fastinput_ime(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 查看当前输入法</span>d.current_ime()<span class="hljs-comment">#返回值</span>(<span class="hljs-string">&#x27;com.github.uiautomator/.FastInputIME&#x27;</span>, <span class="hljs-literal">True</span>)</code></pre></div><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><div class="code-wrapper"><pre><code class="hljs python">d.screenshot(<span class="hljs-string">&#x27;test.png&#x27;</span>)</code></pre></div><h3 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h3><p>进行录屏之前，需要安装如下库：</p><div class="code-wrapper"><pre><code class="hljs awk">pip install -U <span class="hljs-string">&quot;uiautomator2[image]&quot;</span> -i https:<span class="hljs-regexp">//</span>pypi.doubanio.com/simple</code></pre></div><p>开始录屏</p><div class="code-wrapper"><pre><code class="hljs python">d.screenrecord(<span class="hljs-string">&#x27;./test.mp4&#x27;</span>)</code></pre></div><p>结束录屏</p><div class="code-wrapper"><pre><code class="hljs python">d.screenrecord.stop()</code></pre></div><h3 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h3><div class="code-wrapper"><pre><code class="hljs python">d.shell(<span class="hljs-string">&quot;dumpsys wifi | grep mWifiInfo&quot;</span>) <span class="hljs-comment"># 检查wifi网络状态</span>d.shell(<span class="hljs-string">&quot;svc wifi disable&quot;</span>) <span class="hljs-comment"># 关闭wifi</span>d.shell(<span class="hljs-string">&quot;svc wifi enable&quot;</span>) <span class="hljs-comment"># 开启wifi</span>d.shell(<span class="hljs-string">&quot;svc data disable&quot;</span>) <span class="hljs-comment"># 关闭数据网络</span>d.shell(<span class="hljs-string">&quot;svc data enable&quot;</span>) <span class="hljs-comment"># 开启数据网络</span></code></pre></div><h2 id="与Airtest合作"><a href="#与Airtest合作" class="headerlink" title="与Airtest合作"></a>与Airtest合作</h2><p>因为uiautomator2的图像识别比Airtest差，可以用Airtest弥补这个缺陷，Airtest与uiautomator2并未冲突，这两个框架可以同时启动。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> uiautomator2 <span class="hljs-keyword">as</span> u2dev = connect_device(<span class="hljs-string">&quot;Android://127.0.0.1:5037/xxxxx&quot;</span>)d = u2.connect(<span class="hljs-string">&#x27;xxxxx&#x27;</span>)d.app_start(<span class="hljs-string">&quot;com.taobao.taobao&quot;</span>)touch(Template(<span class="hljs-string">r&quot;taobao.png&quot;</span>))</code></pre></div><h1 id="uiautomation"><a href="#uiautomation" class="headerlink" title="uiautomation"></a>uiautomation</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>uiautomation是<code>yinkaisheng</code>业余时间开发的供其自己使用的一个模块，uiautomation封装了微软UIAutomation API，支持自动化Win32，MFC，WPF，Modern UI(Metro UI), Qt, IE, Firefox等UI框架，最新版uiautomation2.0目前只支持Python 3版本，依赖comtypes和typing这两个包，但不要使用3.7.6和3.8.1这两个版本，comtypes在这两个版本中不能正常工作。</p><p>uiautomation支持在Windows XP SP3或更高版本的Windows桌面系统上运行。如果是Windows XP系统，请确保系统目录有这个文件：UIAutomationCore.dll。如果没有，需要安装补丁 KB971513 才能支持UIAutomtion.在Windows 7或更高版本Windows系统上使用uiautomation时，要以管理员权限运行Python,否则uiautomation运行时很多函数可能会执行失败或抛出异常。或者先以管理员权限运行cmd.exe，在cmd中再调用Python。</p><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> uiautomation</code></pre></div><h2 id="Windows端元素定位工具及控件类型（backend）的判断"><a href="#Windows端元素定位工具及控件类型（backend）的判断" class="headerlink" title="Windows端元素定位工具及控件类型（backend）的判断"></a>Windows端元素定位工具及控件类型（backend）的判断</h2><p>所有的工具下载链接：<a href="https://github.com/blackrosezy/gui-inspect-tool">GitHub - blackrosezy/gui-inspect-tool: Gui Inspect tool for Windows</a></p><h3 id="控件类型（backend）的判断"><a href="#控件类型（backend）的判断" class="headerlink" title="控件类型（backend）的判断"></a>控件类型（backend）的判断</h3><p>由于一个界面中有很多种控件类型，所以在automation中不同的控件类型对应着不同的控件类</p><p>可使用Inspect工具判断backend适合写哪种。首先根据上面的链接下载工具，然后打开Inspect.exe</p><p>点击inspect左上角的下拉列表中切换到UI Automation</p><p><img src="../../image/image-20220808143847697.png" alt="切换到UI Automation"></p><p>鼠标点一下需要测试的程序窗体，inspect就会显示相关信息。 </p><p><img src="../../image/image-20220808143949290.png" alt="点击测试窗体，inspect显示相关信息"></p><p>找到<code>ControlType</code>，若类型以<code>UIA</code>开头，则说明backend为uia。</p><p><img src="../../image/image-20220808144354889.png" alt="以uia开头"></p><h3 id="Windows端元素定位工具介绍"><a href="#Windows端元素定位工具介绍" class="headerlink" title="Windows端元素定位工具介绍"></a>Windows端元素定位工具介绍</h3><p>使用UISpy或SPY++（文件名为：SPYXX），<code>spy++</code>显示的很全，各种窗口都能够展示出来，看着十分多非常乱，相比来讲 <code>uispy</code>就比较简洁实用了，只展示主要的窗口，节目很整洁很清晰。</p><p><img src="../../image/image-20220808150359319.png" alt="UISpy窗口演示"></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>打开记事本，输入<code>test uiautomation</code>后全选删除，并关闭程序</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> uiautomation <span class="hljs-keyword">as</span> auto<span class="hljs-keyword">import</span> subprocess,os<span class="hljs-comment"># 打开程序</span>subprocess.Popen(<span class="hljs-string">&#x27;NotePad.exe&#x27;</span>)<span class="hljs-comment"># 找到文本框</span>editor = auto.EditControl(Name=<span class="hljs-string">&quot;文本编辑器&quot;</span>,ClassName=<span class="hljs-string">&quot;Edit&quot;</span>)editor.Click() <span class="hljs-comment"># 点击</span>editor.SendKeys(<span class="hljs-string">&quot;test uiautomation&quot;</span>) <span class="hljs-comment"># 发送test uiautomation</span>editor.SendKeys(<span class="hljs-string">&quot;&#123;Ctrl&#125;a&quot;</span>) <span class="hljs-comment"># 全选</span>editor.SendKeys(<span class="hljs-string">&quot;&#123;Delete&#125;&quot;</span>) <span class="hljs-comment"># 删除</span><span class="hljs-comment"># 杀死进程</span>os.system(<span class="hljs-string">&quot;taskkill /IM NotePad.exe /F&quot;</span>)</code></pre></div><h2 id="程序的打开与关闭"><a href="#程序的打开与关闭" class="headerlink" title="程序的打开与关闭"></a>程序的打开与关闭</h2><p>在进行自动化测试的时候，需要打开某项Windows程序，这个时候就用到了<code>subprocess</code>，方法如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<span class="hljs-comment"># 打开程序，filepath为程序所在文件路径</span>subprocess.Popen(<span class="hljs-string">&#x27;filepath&#x27;</span>)</code></pre></div><p>关闭某项程序，可以直接杀死进程</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-comment">#杀死程序进程</span>os.popen(<span class="hljs-string">&#x27;taskkill /IM xxx.exe /F&#x27;</span>)</code></pre></div><h2 id="引入uiautomation"><a href="#引入uiautomation" class="headerlink" title="引入uiautomation"></a>引入uiautomation</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> uiautomation <span class="hljs-keyword">as</span> auto</code></pre></div><h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>automation支持如下的控件类：</p><ul><li>Control: 控制类型父类</li><li>WindowControl: 窗口控件类</li><li>PaneControl: 窗格控件类型</li><li>ButtonControl: 按钮控制类型</li><li>CheckBoxControl: 复选框控件类型</li><li>ComboBoxControl: 组合框控件类型</li><li>EditControl: 编辑控件类型</li><li>ListControl: 列表控件类型</li><li>ListItemControl: ListItem 控件类型</li><li>MenuControl: 菜单控制类型</li><li>MenuBarControl: 菜单栏控件类型</li><li>MenuItemControl: 菜单项控件类型</li><li>ScrollBarControl: 滚动条控件类型</li><li>SliderControl: 滑块控制类型</li><li>TabControl: 选项卡控件类型</li><li>TabItemControl: TabItem 控件类型</li><li>TableControl: 表控件类型</li><li>TextControl: 文本控件类型</li><li>TitleBarControl: 标题栏控件类型</li><li>ToolBarControl: 工具栏控件类型</li><li>ToolTipControl: 工具提示控件类型</li><li>TreeControl: 树控件类型</li><li>TreeItemControl: 树项控件类型</li><li>AppBarControlAppBar: 控件类型</li><li>CalendarControl: 日历控件类型</li><li>DataGridControl: 数据网格控件类型</li><li>GroupControl: 群控类型</li><li>HeaderControl: 标题控件类型</li><li>HeaderItemControl: HeaderItem: 控件类型</li><li>HyperlinkControl: 超链接控制类型</li><li>ImageControl: 图像控制类型</li><li>DataItemControl: 数据项控件类型</li><li>DocumentControl: 文件控制类型</li><li>ProgressBarControl: ProgressBar: 控件类型</li><li>RadioButtonControl: 单选按钮控件类型</li><li>SemanticZoomControl: SemanticZoom控制类型</li><li>SeparatorControl: 分离器控制类型</li><li>SpinnerControl: 微调控制类型</li><li>SplitButtonControl: 拆分按钮控件类型</li><li>StatusBarControl: 状态栏控件类型</li><li>ThumbControl: 拇指控制类型</li></ul><p>控件类支持的参数（xxxControl内的形参）：</p><ul><li>searchFromControl: 从哪个控件开始查找，如果为None，从根节点Desktop开始查找</li><li>searchDepth: 搜索深度</li><li>searchInterval: 搜索间隔</li><li>foundIndex: 搜索到的满足搜索条件的控件索引，索引从1开始</li><li>Name: 控件名字</li><li>SubName: 控件部分名字</li><li>RegexName: 使用re.match匹配符合正则表达式的名字，Name,SubName,RegexName只能使用一个，不能同时使用</li><li>ClassName: 类名字</li><li>AutomationId: 控件AutomationId</li><li>ControlType: 控件类型</li><li>Depth: 控件相对于searchFromControl的精确深度</li><li>Compare: 自定义比较函数function(control: Control, depth: int)-&gt;bool</li></ul><p><strong>searchDepth和Depth的区别：</strong></p><blockquote><p><strong>searchDepth</strong>在指定的深度范围内（包括1~searchDepth层中的所有子孙控件）搜索第一个满足搜索条件的控件</p><p><strong>Depth</strong>只在Depth所在的深度（如果Depth&gt;1，排除1~searchDepth-1层中的所有子孙控件）搜索第一个满足搜索条件的控件</p></blockquote><p>在代码中是这样实现的：</p><div class="code-wrapper"><pre><code class="hljs python">editor = auto.EditControl(Name=<span class="hljs-string">&quot;文本编辑器&quot;</span>,ClassName=<span class="hljs-string">&quot;Edit&quot;</span>)editor.Click() <span class="hljs-comment"># 点击</span></code></pre></div><p>也不排除会有组合框的出现，组合框的用法为：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 查找下拉框</span>comboBox=ComboBoxControl(searchFromControl=<span class="hljs-string">&quot;xxx&quot;</span>,AutomationId=<span class="hljs-string">&quot;xxx&quot;</span>)<span class="hljs-comment"># 点击组合框</span>comboBox.click()<span class="hljs-comment"># 选择需要的选项；</span>comboBox.Select(“xxxx”)<span class="hljs-comment"># 展开</span>comboBox.Expand()<span class="hljs-comment"># 折叠</span>comboBox.Collapse()</code></pre></div><h2 id="窗口方法"><a href="#窗口方法" class="headerlink" title="窗口方法"></a>窗口方法</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 查找窗口中的程序;</span>window = WindowContrl(searchDepth=<span class="hljs-string">&quot;xxxx&quot;</span>,ClassName=<span class="hljs-string">&quot;xxxx&quot;</span>,SubName=<span class="hljs-string">&quot;xxxx&quot;</span>) <span class="hljs-comment"># 激活窗口;</span>window.SetActive()   <span class="hljs-comment"># 窗口置顶;</span>window.SetTopMost() <span class="hljs-comment"># 窗口居中</span>window.MoveToCenter()<span class="hljs-comment"># 判断此窗口是否存在;</span>window.Exists(maxSearchSeconds)<span class="hljs-comment"># 关闭窗口；</span>window.GetWindowPattern().Close()<span class="hljs-comment"># 窗口最大化；</span>window.ShowWindow(uiautomation.ShowWindow.Maximize)<span class="hljs-comment"># 窗口最大化；</span>window.Maximize()<span class="hljs-comment"># 截图；</span>window.CaptureToImage(‘Notepad.png’)  <span class="hljs-comment"># 切换窗口</span>window.SwitchToThisWindow()<span class="hljs-comment"># 打开控制台(调用的是automation类)</span>auto.GetConsoleWindow() <span class="hljs-comment"># 显示桌面(调用的是automation类)</span>auto.ShowDesktop()</code></pre></div><h2 id="滚动条滚动"><a href="#滚动条滚动" class="headerlink" title="滚动条滚动"></a>滚动条滚动</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#滚动滚动条，直到文本在窗口可见为止</span>ScrollIntoView()</code></pre></div><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 找到元素</span>x = auto.xxxxControl(Name=<span class="hljs-string">&quot;文本编辑器&quot;</span>,ClassName=<span class="hljs-string">&quot;Edit&quot;</span>)<span class="hljs-comment">#单击</span>x.Click()<span class="hljs-comment">#双击</span>x.DoubleClick()<span class="hljs-comment">#右键点击</span>x.RighClik() <span class="hljs-comment">#移动</span>x.MoveTo()<span class="hljs-comment"># 按压左鼠标</span>x.PressMouse()<span class="hljs-comment">#释放左鼠标</span>x.ReleaseMouse()<span class="hljs-comment">#按压右鼠标</span>x.RightPressMouse()<span class="hljs-comment">#释放右鼠标</span>x.RightReleaseMouse()</code></pre></div><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p><code>SendKeys</code>实际上是模拟用户在操作键盘，就是按下某个键盘上的按钮</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 找到元素</span>x = auto.xxxxControl(Name=<span class="hljs-string">&quot;文本编辑器&quot;</span>,ClassName=<span class="hljs-string">&quot;Edit&quot;</span>)x.SendKeys(<span class="hljs-string">&quot;text&quot;</span>) <span class="hljs-comment"># 输入text</span>x.SendKeys(<span class="hljs-string">&quot;&#123;Ctrl&#125;a&quot;</span>) <span class="hljs-comment"># 组合键ctrl+a</span></code></pre></div><p>关于组合键的使用，具体如下：</p><div class="table-container"><table><thead><tr><th>值</th><th>按键说明</th></tr></thead><tbody><tr><td>{Ctrl}a</td><td>Ctrl+a</td></tr><tr><td>{Delete}</td><td>Delete</td></tr><tr><td>{Ctrl}v</td><td>Ctrl+v</td></tr><tr><td>{Ctrl}s</td><td>Ctrl+s</td></tr><tr><td>{Ctrl}{Shift}s</td><td>Ctrl+Shift+s</td></tr><tr><td>{Win}e</td><td>Win+e</td></tr><tr><td>{PageDown}</td><td>PageDown</td></tr><tr><td>0-9、a-z、A-Z、’ ’ = [ ] / \ \ ，. 等</td><td>字符键</td></tr><tr><td>{Back}</td><td>删除</td></tr><tr><td>{Clear}</td><td>清除</td></tr><tr><td>{Enter}</td><td>回车</td></tr><tr><td>{Alt}</td><td>Alt</td></tr><tr><td>{Space}</td><td>空格</td></tr><tr><td>{F1}</td><td>F1</td></tr><tr><td>{BROWSER_BACK}</td><td>浏览器后退</td></tr><tr><td>{BROWSER_FORWARD}</td><td>浏览器前进</td></tr><tr><td>{BROWSER_REFRESH}</td><td>浏览器刷新</td></tr></tbody></table></div><h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 显示等待</span>window.SendKeys(<span class="hljs-string">&#x27;&#123;Ctrl&#125;c&#x27;</span>, waitTime = <span class="hljs-number">0.1</span>) <span class="hljs-comment">#隐式等待</span>uiautomation.uiautomation.TIME_OUT_SECOND = <span class="hljs-number">10</span></code></pre></div><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><div class="code-wrapper"><pre><code class="hljs python">uiautomation.Logger.ColorfullyWrite(<span class="hljs-string">&#x27;运行&quot;&lt;Color=Cyan&gt;automation.py -h&lt;/Color&gt;&quot;显示帮助\n\n&#x27;</span>)</code></pre></div><h2 id="获取剪切板的文本"><a href="#获取剪切板的文本" class="headerlink" title="获取剪切板的文本"></a>获取剪切板的文本</h2><div class="code-wrapper"><pre><code class="hljs python">GetClipboardText()</code></pre></div><p>复制或者剪切用<code>SendKeys()</code>解决</p><h2 id="控件判断"><a href="#控件判断" class="headerlink" title="控件判断"></a>控件判断</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#判断控件存在</span>auto.Exists()<span class="hljs-comment">#设置一个时间内查找到控件</span>auto.WaitForExist()<span class="hljs-comment">#重新查找控件</span>auto.Refind()<span class="hljs-comment">#判断控件是否消失</span>auto.Disappears()<span class="hljs-comment">#判断控件是否可用</span>element.IsEnabled</code></pre></div><h2 id="控件矩形坐标"><a href="#控件矩形坐标" class="headerlink" title="控件矩形坐标"></a>控件矩形坐标</h2><div class="code-wrapper"><pre><code class="hljs python">rect = control.BoundingRectangleBoundingRectangle<span class="hljs-comment">#return rect.left, rect.top, rect.right, rect.bottom</span>rect.width() <span class="hljs-comment">#宽度</span>rect.height()<span class="hljs-comment">#高度</span></code></pre></div><h2 id="截图-1"><a href="#截图-1" class="headerlink" title="截图"></a>截图</h2><div class="code-wrapper"><pre><code class="hljs python">CaptureToImage()</code></pre></div><h1 id="Pytest"><a href="#Pytest" class="headerlink" title="Pytest"></a>Pytest</h1><p>Pytest是python的一种单元测试框架，主要有如下特点：</p><ul><li>简单灵活，容易上手</li><li>支持参数化</li><li>能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试、接口自动化测试（pytest+requests）</li><li>pytest具有很多第三方插件，并且可以自定义扩展，比较好用的如pytest-selenium（集成selenium）、pytest-html（完美html测试报告生成）、pytest-rerunfailures（失败case重复执行）、pytest-xdist（多CPU分发）等</li><li>测试用例的skip和xfail处理</li><li>可以很好的和jenkins集成</li><li>report框架——allure 也支持了pytest</li></ul><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs shell">pip install pytest</code></pre></div><p>验证安装是否成功，并查看pytest版本</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">pytest -V</span></code></pre></div><h2 id="第一个pytest程序"><a href="#第一个pytest程序" class="headerlink" title="第一个pytest程序"></a>第一个pytest程序</h2><p>首先了解pytest的运行规则：</p><ol><li>查找当前目录及其子目录下<strong>以test开头或者结尾的py文件</strong></li><li>找到文件后，在文件中找到<strong>以test_开头方法并执行</strong>。</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPytest</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    测试类</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_print</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        测试方法</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;helloworld&quot;</span>)</code></pre></div><p>使用IDE运行（python tests for xxx）后返回：</p><div class="code-wrapper"><pre><code class="hljs shell">Launching pytest with arguments TestPytest.py --no-header --no-summary -q in xxxxxx============================= test session starts =============================collecting ... collected 1 itemTestPytest.py::TestPytest::test_print PASSED                             [100%]helloworld============================== 1 passed in 0.01s ==============================</code></pre></div><p>注意，若代码中出现异常，则不会执行测试</p><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>pytest的运行是使用命令行运行的</p><p>直接运行py文件中所有test_方法，默认从上到下运行程序，使用mark标记更改运行的程序<code>@pytest.mark.run(order=3)</code></p><div class="code-wrapper"><pre><code class="hljs shell">pytest test.py</code></pre></div><p>当某个py文件中存在多个类时，想要运行其中某个类</p><div class="code-wrapper"><pre><code class="hljs shell">pytest test.py::TestOne</code></pre></div><p>运行py文件中某个类的某个方法</p><div class="code-wrapper"><pre><code class="hljs shell">pytest test.py::TestOne::test_one</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>appnium</tag>
      
      <tag>UIautomator2</tag>
      
      <tag>PyAutoGUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架整合大全</title>
    <link href="/my_world/content/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%A4%A7%E5%85%A8/"/>
    <url>/my_world/content/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇篇幅较长，建议读者找准阅读本篇文章的着重点</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SSM（Spring+SpringMVC+MyBatis）框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容），常作为数据源较简单的web项目的框架。</p><p><strong>Spring</strong></p><p>Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。</p><p>Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。</p><p><strong>SpringMVC</strong></p><p>SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。</p><p><strong>mybatis</strong></p><p>mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</p><p>页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。</p><h1 id="为什么要学SSM"><a href="#为什么要学SSM" class="headerlink" title="为什么要学SSM"></a>为什么要学SSM</h1><p>springboot的框架现在越来越成熟，SSM论开发时间、配置复杂度都比springboot复杂。但是springboot中的基础都是从SSM来的，springboot只是在此基础上进行了封装（包括SSH（spring，struts2，hibernate）），从Mybatis，变成了springboot-mybatis-starter，从而实现开箱即用。本篇着重理解框架原理，从原理下手理解SSM框架。</p><h1 id="框架分析"><a href="#框架分析" class="headerlink" title="框架分析"></a>框架分析</h1><p>首先了解框架的主要文件以及用途</p><ul><li>spring：bean的管家，负责管理bean对象<ul><li>applicationContext.xml：spring配置文件，mybatis、springmvc等都在这里面引入</li><li>db.properties：数据库配置文件，密码账号等</li></ul></li><li>springMVC：后端发送数据的接口<ul><li>controller：后端逻辑，一般有<code>@Controller</code>、<code>@RequestMapping(value=&quot;&quot;)</code>等</li><li>springmvc.xml：springmvc的配置参数</li><li>web.xml：web的重要配置，可以配置过滤等</li></ul></li><li>mybatis：数据库框架<ul><li>sqlMapConfig.xml：指定扫描所有的mapper文件或者bean的位置</li><li>mapping.xml：数据库sql配置，mybatis通过该xml执行sql语句</li><li>mapping.java：数据库接口类</li><li>bean：数据库对象</li></ul></li></ul><p>SSM引用的设计模式有：</p><ul><li><strong>单例（Singleton）模式</strong>：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li><strong>工厂方法（FactoryMethod）模式</strong>：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li><strong>适配器（Adapter）模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li><strong>代理（Proxy）模式</strong>：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li><strong>策略（Strategy）模式</strong>：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li><strong>装饰（Decorator）模式</strong>：动态地给对象增加一些职责，即增加其额外的功能。</li><li><strong>模板方法（Template Method）模式</strong>：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li><strong>观察者（Observer）模式</strong>：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><blockquote><p>以下引用：<a href="http://c.biancheng.net/spring/">Spring框架教程（非常详细） (biancheng.net)</a></p></blockquote><p>Spring 是一款目前主流的 Java EE 轻量级开源框架 ，是 Java 世界最为成功的框架之一。Spring 由“Spring 之父” Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。</p><p>自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 5 个大版本，也就是我们常说的 Spring 5。本教程使用版本为 Spring 5.3.13。</p><p>Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。</p><p>Spring 框架不局限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何 Java 应用都可以从 Spring 中受益。Spring 框架还是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力。</p><h3 id="Spring内部模块"><a href="#Spring内部模块" class="headerlink" title="Spring内部模块"></a>Spring内部模块</h3><p>Spring 框架基本涵盖了企业级应用开发的各个方面，它包含了 20 多个不同的模块。</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-keyword">spring</span>-aop      <span class="hljs-keyword">spring</span>-context-indexer  <span class="hljs-keyword">spring</span>-instrument  <span class="hljs-keyword">spring</span>-orm    <span class="hljs-keyword">spring</span>-web<span class="hljs-keyword">spring</span>-aspects  <span class="hljs-keyword">spring</span>-context-support  <span class="hljs-keyword">spring</span>-jcl         <span class="hljs-keyword">spring</span>-oxm    <span class="hljs-keyword">spring</span>-webflux<span class="hljs-keyword">spring</span>-beans    <span class="hljs-keyword">spring</span>-core             <span class="hljs-keyword">spring</span>-jdbc        <span class="hljs-keyword">spring</span>-r2dbc  <span class="hljs-keyword">spring</span>-webmvc<span class="hljs-keyword">spring</span>-context  <span class="hljs-keyword">spring</span>-<span class="hljs-keyword">expression</span>       <span class="hljs-keyword">spring</span>-jms         <span class="hljs-keyword">spring</span>-test   <span class="hljs-keyword">spring</span>-websocket<span class="hljs-keyword">spring</span>-messaging   <span class="hljs-keyword">spring</span>-tx</code></pre></div><p>其中有4个核心：</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-keyword">spring</span>-beans<span class="hljs-keyword">spring</span>-<span class="hljs-keyword">expression</span><span class="hljs-keyword">spring</span>-core<span class="hljs-keyword">spring</span>-context/<span class="hljs-keyword">spring</span>-context-support</code></pre></div><p>1个依赖：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">commons-loggins</span></code></pre></div><p><img src="../../image/163550G63-0.png" alt="spring框架图"></p><p>上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。</p><h4 id="Data-Access-Integration（数据访问／集成）"><a href="#Data-Access-Integration（数据访问／集成）" class="headerlink" title="Data Access/Integration（数据访问／集成）"></a>Data Access/Integration（数据访问／集成）</h4><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。</p><ul><li>JDBC 模块：提供了一个 JBDC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li><li>ORM 模块：提供与流行的“对象-关系”映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。</li><li>OXM 模块：提供了一个支持 Object /XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java 对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。</li><li>JMS 模块：指 Java 消息服务，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li><li>Transactions 事务模块：支持编程和声明式事务管理。</li></ul><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Portlet 组件，具体介绍如下。</p><ul><li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC 容器初始化以及 Web 应用上下文。</li><li>Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li><li>WebSocket 模块：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建 WebSocket Server，从而实现双向通讯。</li><li>Portlet 模块：提供了在 Portlet 环境中使用 MVC 实现，类似 Web-Servlet 模块的功能。</li></ul><h4 id="Core-Container（Spring-的核心容器）"><a href="#Core-Container（Spring-的核心容器）" class="headerlink" title="Core Container（Spring 的核心容器）"></a>Core Container（Spring 的核心容器）</h4><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。具体介绍如下。</p><ul><li>Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。</li><li>Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li><li>Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li><li>SpEL 模块：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li></ul><h4 id="AOP、Aspects、Instrumentation-和-Messaging"><a href="#AOP、Aspects、Instrumentation-和-Messaging" class="headerlink" title="AOP、Aspects、Instrumentation 和 Messaging"></a>AOP、Aspects、Instrumentation 和 Messaging</h4><p>在 Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p><ul><li>AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li><li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li>messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li></ul><h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><p>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><blockquote><p>引用 <a href="https://blog.csdn.net/q982151756/article/details/80513340">细说Spring——AOP详解（AOP概览）_Jivan2233的博客-CSDN博客_aop</a></p></blockquote><p>要理解切面编程，就需要先理解什么是切面。用刀把一个西瓜分成两瓣，切开的切口就是切面；炒菜，锅与炉子共同来完成炒菜，锅与炉子就是切面。<strong>编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面。</strong></p><p>一般做活动的时候，一般对每一个接口都会做活动的有效性校验（是否开始、是否结束等等）、以及这个接口是不是需要用户登录。</p><p>按照正常的逻辑可以这么做。</p><p><img src="../../image/70-165182641632610.png" alt=""></p><p>这有个问题就是，有多少接口，就要多少次代码copy。这里可以提出一个公共方法，每个接口都来调用这个接口。这里有点切面的味道了。</p><p><img src="../../image/70-16518264134208.png" alt=""></p><p>虽然不用每次都copy代码了，但是每个接口都要调用这个方法。于是就有了切面的概念，将方法注入到接口调用的某个地方（切点）。这样接口只需要关心具体的业务，而不需要关注其他非该接口关注的逻辑或处理。</p><p><img src="../../image/70-16518264103306.png" alt=""></p><p><strong>红框处，就是面向切面编程。</strong></p><h4 id="AOP中的相关概念"><a href="#AOP中的相关概念" class="headerlink" title="AOP中的相关概念"></a>AOP中的相关概念</h4><blockquote><p>引用 <a href="https://blog.csdn.net/q982151756/article/details/80513340">细说Spring——AOP详解（AOP概览）_Jivan2233的博客-CSDN博客_aop</a></p></blockquote><ul><li><strong>Aspect</strong>（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li><li><strong>Joint point</strong>（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li><li><strong>Pointcut</strong>（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li><strong>Advice</strong>（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li><li><strong>Target</strong>（目标对象）：织入 Advice 的目标对象.。</li><li><strong>Weaving</strong>（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li></ul><p><img src="../../image/70.png" alt="AOP概念关系图"></p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><blockquote><p>来源：<a href="http://m.biancheng.net/spring/inversion-control.html">Spring IoC（控制反转） (biancheng.net)</a></p></blockquote><p>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p><p>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</p><p>IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。</p><p>在传统的 Java 应用中，一个类想要调用另一个类中的属性或方法，通常会先在其代码中通过 new Object() 的方式将后者的对象创建出来，然后才能实现属性或方法的调用。为了方便理解和描述，我们可以将前者称为“调用者”，将后者称为“被调用者”。也就是说，调用者掌握着被调用者对象创建的控制权。</p><p>但在 Spring 应用中，Java 对象创建的控制权是掌握在 IoC 容器手里的，其大致步骤如下。</p><ol><li>开发人员通过 XML 配置文件、注解、Java 配置类等方式，对 Java 对象进行定义，例如在 XML 配置文件中使用 \<bean\> 标签、在 Java 类上使用 @Component 注解等。</li><li>Spring 启动时，IoC 容器会自动根据对象定义，将这些对象创建并管理起来。这些被 IoC 容器创建并管理的对象被称为 Spring Bean。</li><li>当我们想要使用某个 Bean 时，可以直接从 IoC 容器中获取（例如通过 ApplicationContext 的 getBean() 方法），而不需要手动通过代码（例如 new Obejct() 的方式）创建。</li></ol><p>IoC 带来的最大改变不是代码层面的，而是从思想层面上发生了“主从换位”的改变。原本调用者是主动的一方，它想要使用什么资源就会主动出击，自己创建；但在 Spring 应用中，IoC 容器掌握着主动权，调用者则变成了被动的一方，被动的等待 IoC 容器创建它所需要的对象（Bean）。</p><p>这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给 IoC 容器来帮忙实现，因此我们将这个过程称为 Spring 的“控制反转”。</p><p><img src="../../image/SouthEast.png" alt=""></p><p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。应用程序，框架，IoC容器（感觉容器是个抽象概念，也可以指服务或子程序一类的东西）。这三者可以类比为：</p><ul><li>应用程序 — 买汉堡的顾客</li><li>框架 — 厨子</li><li>IoC容器 — 汉堡</li></ul><p>如果没有控制反转，厨子不存在，顾客想吃什么得自己现做汉堡。顾客责任重大，因为什么都要自己弄，万一做出个黑暗料理需要检查自己的菜谱是不是有问题。</p><p>此为控制正序。</p><p>有了控制反转，顾客就不用进厨房了，相反地，他只要乖巧地坐好就行，他只是一个饥饿的家伙，上什么汉堡他也不在乎，厨师会搞定一切的，厨师做好汉堡交给他，done</p><p>这就是控制反转。</p><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004 年在对“控制反转”进行解释时提出的。Martin Fowler 认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”。</p><p>在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。</p><p>控制反转核心思想就是由 Spring 负责对象的创建。在对象创建过程中，Spring 会自动根据依赖关系，将它依赖的对象注入到当前对象中，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。这就是所谓的“依赖注入”。</p><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><blockquote><p>源自：<a href="http://c.biancheng.net/spring_mvc/profile.html">Spring MVC是什么 (biancheng.net)</a></p></blockquote><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。</p><p>Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现，是一个典型的教科书式的 MVC 构架，不像 Struts 等其它框架都是变种或者不是完全基于 MVC 系统的框架。</p><p>Spring MVC 角色划分清晰，分工明细，并且和 Spring 框架无缝结合。Spring MVC 是当今业界最主流的 Web 开发框架，以及最热门的开发技能。</p><p>在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。</p><p>Spring MVC 框架采用松耦合可插拔的组件结构，具有高度可配置性，比起其它 MVC 框架更具有扩展性和灵活性。</p><p>此外，Spring MVC 的注解驱动和对 REST 风格的支持，也是它最具特色的功能。无论是在框架设计，还是扩展性、灵活性等方面都全面超越了 Struts2 等 MVC 框架。并且由于 Spring MVC 本身就是 Spring 框架的一部分，所以可以说与 Spring 框架是无缝集成，性能方面具有先天的优越性，对于开发者来说，开发效率也高于其它的 Web 框架，在企业中的应用越来越广泛，成为主流的 MVC 框架。</p><p><strong>Spring MVC优点</strong></p><ul><li>清晰地角色划分，Spring MVC 在 Model、View 和 Controller 方面提供了一个非常清晰的角色划分，这 3 个方面真正是各司其职，各负其责。</li><li>灵活的配置功能，可以把类当作 Bean 通过 XML 进行配置。</li><li>提供了大量的控制器接口和实现类，开发者可以使用 Spring 提供的控制器实现类，也可以自己实现控制器接口。</li><li>真正做到与 View 层的实现无关。它不会强制开发者使用 JSP，可以根据项目需求使用 Velocity、FreeMarker 等技术。</li><li>国际化支持</li><li>面向接口编程</li><li>与 Spring 框架无缝集成</li></ul><p>一个好的框架要减轻开发者处理复杂问题的负担，内部有良好的扩展，并且有一个支持它的强大用户群体，恰恰 Spring MVC 都做到了。</p><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p>MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。</p><p>在 Web 项目的开发中，能够及时、正确地响应用户的请求是非常重要的。用户在网页上单击一个 URL 路径，这对 Web 服务器来说，相当于用户发送了一个请求。而获取请求后如何解析用户的输入，并执行相关处理逻辑，最终跳转至正确的页面显示反馈结果，这些工作往往是控制层（Controller）来完成的。</p><p>在请求的过程中，用户的信息被封装在 User 实体类中，该实体类在 Web 项目中属于数据模型层（Model）。</p><p>在请求显示阶段，跳转的结果网页就属于视图层（View）。</p><p>像这样，控制层负责前台与后台的交互，数据模型层封装用户的输入/输出数据，视图层选择恰当的视图来显示最终的执行结果，这样的层次分明的软件开发和处理流程被称为 MVC 模式。</p><p>在学习 Servlet 及 JSP 开发时，JavaBean 相当于 Model，Servlet 相当于 Controller，JSP 相当于 View。</p><p>总结如下：</p><ul><li>视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。</li><li>控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。</li><li>数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。</li></ul><p>SUN 公司推出 JSP 技术的同时，也推出了两种 Web 应用程序的开发模式。即 JSP+JavaBean 和 Servlet+JSP+JavaBean。</p><h4 id="JSP-JavaBean"><a href="#JSP-JavaBean" class="headerlink" title="JSP+JavaBean"></a>JSP+JavaBean</h4><p>JSP+JavaBean 中 JSP 用于处理用户请求，JavaBean 用于封装和处理数据。该模式只有视图和模型，一般把控制器的功能交给视图来实现，适合业务流程比较简单的 Web 程序。</p><p><img src="../../image/1130463606-0.png" alt="JSP+JavaBean"></p><p>通过上图可以发现 JSP 从 HTTP Request（请求）中获得所需的数据，并进行业务逻辑的处理，然后将结果通过 HTTP Response（响应）返回给浏览器。从中可见，JSP+JavaBean 模式在一定程度上实现了 MVC，即 JSP 将控制层和视图合二为一，JavaBean 为模型层。</p><p>JSP+JavaBean 模式中 JSP 身兼数职，既要负责视图层的数据显示，又要负责业务流程的控制，结构较为混乱，并且也不是我们所希望的松耦合架构模式，所以当业务流程复杂的时候并不推荐使用。</p><h4 id="Servlet-JSP-JavaBean"><a href="#Servlet-JSP-JavaBean" class="headerlink" title="Servlet+JSP+JavaBean"></a>Servlet+JSP+JavaBean</h4><p>Servlet+JSP+JavaBean 中 Servlet 用于处理用户请求，JSP 用于数据显示，JavaBean 用于数据封装，适合复杂的 Web 程序。</p><p><img src="../../image/1130462557-1.png" alt="Servlet+JSP+JavaBean"></p><p>相比 JSP+JavaBean 模式来说，Servlet+JSP+JavaBean 模式将控制层单独划分出来负责业务流程的控制，接收请求，创建所需的 JavaBean 实例，并将处理后的数据返回视图层（JSP）进行界面数据展示。</p><p>Servlet+JSP+JavaBean 模式的结构清晰，是一个松耦合架构模式，一般情况下，建议使用该模式。</p><h4 id="MVC优缺点"><a href="#MVC优缺点" class="headerlink" title="MVC优缺点"></a>MVC优缺点</h4><p>任何一件事都有利有弊，下面来了解一下 MVC 的优缺点。</p><p><strong>优点</strong></p><ul><li>多视图共享一个模型，大大提高了代码的可重用性</li><li>MVC 三个模块相互独立，松耦合架构</li><li>控制器提高了应用程序的灵活性和可配置性</li><li>有利于软件工程化管理</li></ul><p>总之，我们通过 MVC 设计模式最终可以打造出一个松耦合+高可重用性+高可适用性的完美架构。</p><p><strong>缺点</strong></p><ul><li>原理复杂</li><li>增加了系统结构和实现的复杂性</li><li>视图对模型数据的低效率访问</li></ul><p>MVC 并不适合小型甚至中型规模的项目，花费大量时间将 MVC 应用到规模并不是很大的应用程序，通常得不偿失，所以对于 MVC 设计模式的使用要根据具体的应用场景来决定。</p><h3 id="SpringMVC与Struts2的区别"><a href="#SpringMVC与Struts2的区别" class="headerlink" title="SpringMVC与Struts2的区别"></a>SpringMVC与Struts2的区别</h3><p>Spring MVC 和 Struts2 类似，是一款基于传统 MVC 设计模式的 Java EE 框架。它的核心是一个弹性的控制层，能够很好地发挥 MVC 模式的“分离显示逻辑和业务逻辑”的能力。</p><p><strong>1. Spring MVC 基于方法开发，Struts2 基于类开发。</strong></p><p>在使用 Spring MVC 框架进行开发时，会将 URL 请求路径与 Controller 类的某个方法进行绑定，请求参数作为该方法的形参。当用户请求该 URL 路径时， Spring MVC 会将 URL 信息与 Controller 类的某个方法进行映射，生成 Handler 对象，该对象中只包含了一个 method 方法。方法执行结束之后，形参数据也会被销毁。</p><p>而在使用 Struts2 框架进行开发时，Action 类中所有方法使用的请求参数都是 Action 类中的成员变量，随着方法变得越来越多，就很难分清楚 Action 中那么多的成员变量到底是给哪一个方法使用的，整个 Action 类会变得十分混乱。</p><p>相比较而言，Spring MVC 优点是其所有请求参数都会被定义为相应方法的形参，用户在网页上的请求路径会被映射到 Controller 类对应的方法上，此时请求参数会注入到对应方法的形参上。Spring MVC 的这种开发方式类似于 Service 开发。</p><p><strong>2. Spring MVC 可以进行单例开发，Struts2 无法使用单例</strong></p><p>Spring MVC 支持单例开发模式，而 Struts2 由于只能通过类的成员变量接受参数，所以无法使用单例模式，只能使用多例。</p><p><strong>3. 经过专业人员的大量测试，Struts2 的处理速度要比 SpringMVC 慢，原因是 Struts2 使用了 Struts 标签，Struts 标签由于设计原因，会出现加载数据慢的情况</strong></p><p>这里仅仅比较了 Spring MVC 在某些方面相比 Struts2 的优势，但这并不能说明 Spring MVC 比 Struts2 优秀，仅仅因为早期 Struts2 使用广泛，所以出现的漏洞也比较多，但是在新版本的 Struts2 中也修复了许多漏洞。Spring MVC 自诞生以来，几乎没有什么致命的漏洞 。且 Spring MVC 基于方法开发，这一点较接近 Service 开发，这也是 Spring MVC 近年来备受关注的原因之一。</p><h3 id="springMVC组件"><a href="#springMVC组件" class="headerlink" title="springMVC组件"></a>springMVC组件</h3><p>springMVC五大核心组件：</p><ul><li><strong>DispatcherServlet：前端控制器</strong><ul><li>前端控制器，主要负责是接受所有请求（根据配置文件来决定），并将请求转发给对应的控制器，接收控制器的处理结果，确定最终由哪个视图完成响应</li></ul></li><li><strong>HandlerMapping：映射处理器</strong><ul><li>处理请求路径与控制器的映射关系</li></ul></li><li><strong>Controller：处理器</strong><ul><li>实际处理请求的组件，例如接收请求参数，决定最终是转发或重定向的方式来响应</li></ul></li><li><strong>ModelAndView：处理结果和视图名</strong><ul><li>控制器的处理结果，其中的Model表示转发的数据（如果是重定向，则Model没有意义），而View表示最终负责响应的视图组件的名称</li></ul></li><li><strong>ViewResolver：视图解析器</strong><ul><li>根据视图组件的名称，确定具体使用的是哪个视图组件</li></ul></li></ul><p><img src="../../image/v2-affc785a9a11a1f37ab8939ffbc1304e_720w.jpg" alt="springmvc组件工作流程"></p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><blockquote><p>摘自<a href="https://zhuanlan.zhihu.com/p/351830443">什么是Mybatis？最全Mybatis学习笔记 - 知乎 (zhihu.com)</a></p></blockquote><ul><li>Mybatis是一款优秀的<strong>持久层框架</strong>。</li><li>它支持定制化SQL、存储过程以及高级映射。</li><li>Mybatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</li><li>Mybatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO(Plain Old Java Object，普通老式Java对象)为数据库中的记录。</li><li>Mybatis本是Apache的一个开源项目Ibatis，2010年这个项目由Apache software foundation迁移到了Google Code，并改名为Mybatis。</li><li>2013年11月迁移到<strong>Github</strong>。</li></ul><h3 id="MyBatis的功能架构："><a href="#MyBatis的功能架构：" class="headerlink" title="MyBatis的功能架构："></a>MyBatis的功能架构：</h3><blockquote><p>摘自<a href="https://www.w3cschool.cn/mybatis/">MyBatis 教程_w3cschool</a></p></blockquote><p>我们把Mybatis的功能架构分为三层：</p><ol><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ol><h3 id="为什么需要Mybatis"><a href="#为什么需要Mybatis" class="headerlink" title="为什么需要Mybatis"></a>为什么需要Mybatis</h3><ul><li><p>Mybatis就是帮助开发人员将数据存入数据库中 , 和从数据库中取数据。</p></li><li><p>传统的jdbc操作 , 有很多重复代码块。比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率。</p></li><li><p>MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) —&gt;对象关系映射。</p></li><li><p>MyBatis的优点</p></li><li><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</p><ul><li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li><li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li><li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li></ul><p>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</p><ul><li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li><li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li></ul><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><ul><li>完成持久化工作的代码块 . ——&gt; dao层 【DAO (Data Access Object) 数据访问对象】</li><li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li><li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li><li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li></ul><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h2><p>在idea中创建maven工程，选择骨架maven-archetype-webapp（一个简单的Java Web应用程序），这是Web比较常用的骨架，同样的常用的骨架还有maven-archetype-quickstart（一个快速的基础Java应用程序）</p><p>Maven骨架简单的来说就是一种模型 (结构)，Maven根据不同的项目和需求，提供了不同的模型，这样就不需要自己建模型了。假设用户要做一套普通的楼房，用户使用Maven就不需要用户自己打地基，直接使用Maven打好的地基就可以了。同时种类的楼房(写字楼，商场，套房，别墅) 就有不同的地基，因此，Maven就有很多种模型。</p><p><img src="../../image/image_20220509143037.png" alt="创建Maven工程顺序"></p><p>点击下一步后，修改Name，这是项目名称，点击Artifact Coordinates，可修改Groupid，GroupID 是项目组织唯一的标识符，一般来说可以设置的与包结构一致，也就是 main 目录里java 的目录结构，可以设置为域名的倒序，当然这不是强制的。ArtifactID 就是项目的唯一的标识符，一般设置为项目的名称。正是通过这两个值，形成了一个 “坐标” ，能保证项目的唯一性。</p><p><img src="../../image/image-20220509143714046.png" alt="项目创建第二步"></p><p>继续下一步后，会出现maven的properties的配置，为了加快项目搭建速度，需要添加这样的一组键值对。</p><ul><li>DarchetypeCatalog</li><li>internal</li></ul><p>命令中参数 -DarchetypeCatalog 的值有三种：</p><ul><li>remote：从Maven远程中央仓库获取 archetypeCatalog（默认）</li><li>internal：从 maven-archetype-plugin 内置的 archetypeCatalog 文件获取</li><li>local：本地的 archetypeCatalog 文件</li></ul><p><img src="../../image/image-20220509144209954.png" alt="项目创建第三步"></p><p>完毕后直接Finish，等待项目创建完毕即可（即src文件夹生成完毕）。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>在main文件夹下创建java、resources文件夹</p><ul><li>java：存放主要的java文件<ul><li>controller：前端控制器</li><li>service：数据库逻辑接口</li><li>impl：service的对应实现类（可在service包下面）</li><li>mapping：Mybatis的Mapping映射</li><li>bean：数据库对象，对应数据库的每一个表</li><li>utils：自定义工具类</li></ul></li><li>resources：存放properties等配置文件</li><li>webapp：存放jsp等前端页面</li></ul><h2 id="搭建步骤与前置条件"><a href="#搭建步骤与前置条件" class="headerlink" title="搭建步骤与前置条件"></a>搭建步骤与前置条件</h2><p>步骤如下（个人理解）：</p><ol><li>搭建Mybatis环境</li><li>搭建SpringMVC环境</li><li>搭建Spring环境并整合springmvc和mybatis</li></ol><p>在resources文件夹中创建文件如下（附带解释）：</p><div class="code-wrapper"><pre><code class="hljs crmsh">applicationContext.<span class="hljs-keyword">xml</span> <span class="hljs-title"># spring</span>配置db.properties <span class="hljs-comment"># 数据库配置</span>log4j.properties <span class="hljs-comment"># log4j配置文件</span>springmvc.<span class="hljs-keyword">xml</span> <span class="hljs-title"># springmvc</span>配置文件</code></pre></div><p>pom.xml可指定jdk版本</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- maven管理插件，jdk默认为1.8 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">compilerVersion</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><h2 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h2><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>这里使用的是Mysql数据库，Mybatis的使用是和数据库驱动是分不开的，依赖如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mysql数据库 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.38<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- c3p0连接池 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- mybatis --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>如果需要redis则需要引入依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis，Redis官方推荐的Java连接开发工具 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="新建数据库对象（bean）"><a href="#新建数据库对象（bean）" class="headerlink" title="新建数据库对象（bean）"></a>新建数据库对象（bean）</h3><p>这里用城市做实例，数据表中，城市有id，name（城市名称），countryCode（城市代码）字段。用这些字段作为类变量，私有化并做getter和setter即可。这些都可以在idea中自动生成。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ssmtem.bean;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">city</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ID;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> String countryCode;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ID;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iD)</span> </span>&#123;ID = iD;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCountryCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> countryCode;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCountryCode</span><span class="hljs-params">(String countryCode)</span> </span>&#123;<span class="hljs-keyword">this</span>.countryCode = countryCode;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;city [ID=&quot;</span> + ID + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, countryCode=&quot;</span> + countryCode + <span class="hljs-string">&quot;]&quot;</span>;&#125;&#125;</code></pre></div><h3 id="sql映射配置文件编写（mapper）"><a href="#sql映射配置文件编写（mapper）" class="headerlink" title="sql映射配置文件编写（mapper）"></a>sql映射配置文件编写（mapper）</h3><p>在mapping包中创建cityMapping.java，作为被映射的接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ssmtem.mapping;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> com.ssmtem.springmvc.bean.city;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">cityMapping</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;city&gt; <span class="hljs-title">showallcity</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(city info)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> city <span class="hljs-title">showcityByid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;&#125;</code></pre></div><p>在mapping包中创建cityMapping.xml，作为映射文件，编写sql语句后映射到mapper接口中，调用接口即可运行sql语句。</p><p>关于mapper映射文件中，参数如下：</p><ul><li>mapper：映射文件的根节点，只有 namescape 一个属性<ul><li>namescape 作用如下：<ul><li>用于区分不同的 mapper，全局唯一</li><li>绑定DAO接口，即面向接口编程。当 namescape 绑定某一接口后，可以不用写该接口的实现类，MyBatis 会通过接口的完整限定名查找到对应的 mapper 配置来执行 SQL 语句。因此 namescape 的命名必须要跟接口同名。</li></ul></li></ul></li><li>select： 查询语句，最常用、最复杂的元素之一。可以自定义参数，返回结果集等<ul><li>id：xml的id，和mapping的映射接口中的方法命名一样</li><li>parameterType：传入的参数类型，可以是对象（bean）、数据类型等</li><li>resultType：输出参数的类型，可以是对象（bean）、数据类型等</li></ul></li><li>insert：插入语句，执行后返回一个整数，代表插入的条数</li><li>update：更新语句，执行后返回一个整数，代表更新的条数</li><li>delete：删除语句，执行后返回一个整数，代表删除的条数</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta"><span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta"><span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- namespace：命名空间，用于隔离sql，用于动态代理 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.ssmtem.mapping.cityMapping&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;showallcity&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.ssmtem.bean.city&quot;</span>&gt;</span>Select * from city<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;showcityByid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.ssmtem.bean.city&quot;</span>&gt;</span>Select * from city where id = #&#123;ID&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addItem&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.ssmtem.bean.city&quot;</span>&gt;</span>INSERT INTO city(NAME,countryCode)VALUES(#&#123;name&#125;,#&#123;countryCode&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>mapper的更详细的其他配置，可参考：<a href="https://www.jianshu.com/p/7e84f0fff0cb">mybatis mapper详解 - 简书 (jianshu.com)</a>和<a href="http://c.biancheng.net/mybatis/mapper.html">MyBatis Mapper（映射器） (biancheng.net)</a></p><h2 id="SpringMVC环境搭建"><a href="#SpringMVC环境搭建" class="headerlink" title="SpringMVC环境搭建"></a>SpringMVC环境搭建</h2><h3 id="依赖引入-1"><a href="#依赖引入-1" class="headerlink" title="依赖引入"></a>依赖引入</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- springMVC --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--json-lib，对象和json格式转换工具类 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>jdk15<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="springmvc-xml配置"><a href="#springmvc-xml配置" class="headerlink" title="springmvc.xml配置"></a>springmvc.xml配置</h3><p>springmvc主要有如下四个配置：</p><ol><li>配置组件扫描，必配，组件扫描会扫描包下的所有的Controller类</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置组件扫描 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.controller&quot;</span> /&gt;</span></code></pre></div><ol><li>配置MVC注解扫描，必配，和组件扫描搭配，相当于同时配置了HandlerMapping和Controller</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注解驱动 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre></div><ol><li>配置视图解析器，选配，视图解析器是为了当html，jsp等前端文件放到WEB-INF/的路径下时，浏览器不能直接访问，就需要使用视图解析器来访问相应的前端文件</li></ol><div class="code-wrapper"><pre><code class="hljs xml">   <span class="hljs-comment">&lt;!-- 配置视图解析器， --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 前缀 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 后缀 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><ol><li>配置拦截器，选配，拦截器是拦截tomcat容器和spring容器之间的交互信息，主要是用于验证用户在访问该网页时是否登陆</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置拦截器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/*&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;interceptors.SomeInterceptor&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre></div><p>总体如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:mybatis-spring</span>=<span class="hljs-string">&quot;http://mybatis.org/schema/mybatis-spring&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:util</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/util&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.1.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置组件扫描，必配，组件扫描会扫描包下的所有的Controller类 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span></span><span class="hljs-tag"><span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.ssmtem&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><span class="hljs-comment">&lt;!-- 注解驱动 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 为了预防引用js和css的时候出现错误，必须配这个 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 这些配置不是必备的 --&gt;</span><span class="hljs-comment">&lt;!-- 上传配置实现类 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 上传图片的大小 B 5M 1*1024*1024*5 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5000000&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- springmvc的异常捕捉器 --&gt;</span><span class="hljs-comment">&lt;!-- &lt;bean class=&quot;com.ssmtem.exception.CustomExceptionResolver&quot;&gt;&lt;/bean&gt; --&gt;</span><span class="hljs-comment">&lt;!-- 视图解释器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h2 id="Spring环境搭建"><a href="#Spring环境搭建" class="headerlink" title="Spring环境搭建"></a>Spring环境搭建</h2><h3 id="依赖引入-2"><a href="#依赖引入-2" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>首先在pom.xml中引入依赖（有点多，需要慢慢看，上面有每个依赖所代表的功能）：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring --&gt;</span>      <span class="hljs-comment">&lt;!-- 四大核心 --&gt;</span>      <span class="hljs-comment">&lt;!-- 模块提供了一个强大的表达式语言，用于在运行时查询和处理对象图。</span><span class="hljs-comment">      该语言支持设置和获取属性值；属性赋值，方法调用，访问数组的内容，收集和索引器，逻辑和算术运算，命名变量，</span><span class="hljs-comment">      并从Spring的IOC容器的名字对象检索，它也支持列表选择和投影以及常见的列表聚合。 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">      这个jar 文件是所有应用都要用到的，</span><span class="hljs-comment">      它包含访问配置文件、创建和管理bean 以及进行Inversion ofControl / Dependency Injection（IoC/DI）操作相关的所有类。</span><span class="hljs-comment">      如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。外部依赖spring-core，(CGLIB)。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 这个jar 文件包含Spring 框架基本的核心工具类。</span><span class="hljs-comment">      Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，</span><span class="hljs-comment">      当然你也可以在自己的应用系统中使用这些工具类。外部依赖Commons Logging， (Log4J)。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 包含支持缓存Cache（ehcache）、JCA、JMX、 邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类。</span><span class="hljs-comment">      以前的版本中应该是这个：spring-support.jar这个jar</span><span class="hljs-comment">      文件包含支持UI模版（Velocity，FreeMarker，JasperReports），邮件服务，脚本服务(JRuby)，缓存Cache（EHCache），任务计划Scheduling（uartz）方面的类。</span><span class="hljs-comment">      外部依赖spring-context, (spring-jdbc, Velocity,FreeMarker, JasperReports, BSH, Groovy,JRuby, Quartz, EHCache) --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">      这个jar 文件为Spring 核心提供了大量扩展。</span><span class="hljs-comment">      可以找到使用Spring ApplicationContext特性时所需的全部类，</span><span class="hljs-comment">      JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。</span><span class="hljs-comment">      外部依赖spring-beans, (spring-aop)。 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 其余模块(AOP,aspects,Spring-aspects,spring-tx,spring-jdbc,spring-test,spring-web) --&gt;</span>      <span class="hljs-comment">&lt;!-- 这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。</span><span class="hljs-comment">      使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。</span><span class="hljs-comment">      外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes) --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- Spring-aspects</span><span class="hljs-comment">      提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中，比如Eclipse AJDT。</span><span class="hljs-comment">      外部依赖。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- aspectjweaver是aspectj的织入包 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 为JDBC、Hibernate、JDO、JPA、Beans等提供的一致的声明式和编程式事务管理支持。 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。</span><span class="hljs-comment">      外部依赖spring-beans，spring-dao。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- Spring-test支持spring组建junit或TestNG的集成测试和单元测试。</span><span class="hljs-comment">      它提供了一致spring ApplicationContext的加载和上下文的缓存。他还提供了可以用来测试代码隔离的模拟对象。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心类，</span><span class="hljs-comment">      包括自动载入Web ApplicationContext 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。</span><span class="hljs-comment">      外部依赖spring-context, Servlet API, (JSP API, JSTL,Commons FileUpload, COS)。--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!-- SpringORM框架依赖 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>除了以上spring核心依赖，还可以引入：</p><p><strong>log4j</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--log4j，生成日志 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>commons工具类，选用</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- commons-lang3，书写优雅代码必备工具类 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--commons-fileupload，文件上传工具类 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>lombok，选用</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--lombok，getter,setter注解开发工具类 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>junit，选用</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--junit，单元测试 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="配置文件整合"><a href="#配置文件整合" class="headerlink" title="配置文件整合"></a>配置文件整合</h3><h4 id="db-properties配置"><a href="#db-properties配置" class="headerlink" title="db.properties配置"></a>db.properties配置</h4><p>用于连接数据库</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/world?characterEncoding=utf-8</span><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">xxxx</span></code></pre></div><h4 id="applicationContext-xml配置"><a href="#applicationContext-xml配置" class="headerlink" title="applicationContext.xml配置"></a>applicationContext.xml配置</h4><p>这是spring的核心配置文件，把数据源，sqlSessionFactory交给了spring IOC容器管理，以及开启了注解式事务。</p><p>配置applicationContext.xml的思路为：</p><ul><li>载入db.properties</li><li>将db.properties的参数传入c3p0中</li><li>开启Mybaties的工厂</li><li>设置Mybaties的扫描包</li><li>注解事务并开启注解</li><li>配置核心事务管理器</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:mybatis-spring</span>=<span class="hljs-string">&quot;http://mybatis.org/schema/mybatis-spring&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:util</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/util&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.1.xsd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 将db.propreties连接到spring中 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span></span><span class="hljs-tag"><span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- c3p0连接池 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- Mybatis的工厂,sqlSessionFactoryBean --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- Mapper动态代理开发 扫描 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 基本包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.ssmtem.mapping&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 注解事务 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 开启注解 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span></span><span class="hljs-tag"><span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 配置核心事务管理器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h4 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h4><p>打开webapp/WEB-INF/web.xml，该配置文件为核心，当启动一个WEB项目时，容器包括（JBoss、Tomcat等）首先会读取项目web.xml配置文件里的配置，当这一步骤没有出错并且完成之后，项目才能正常地被启动起来。具体功能参考：<a href="https://www.cnblogs.com/linhuaming/p/9464356.html">web.xml 配置文件 超详细说明！！！ - 吴川华仔博客 - 博客园 (cnblogs.com)</a></p><p>spring的核心配置文件和springmvc的核心配置文件在这里被引用，所以具体的配置思路如下：</p><ul><li>引入Spring的核心配置文件</li><li>开启Spring监听器</li><li>引入Springmvc的核心配置文件至前端控制器</li><li>springmvc设置拦截</li><li>处理其他的问题（如Post乱码问题）</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;WebApp_ID&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.5&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>spring-springmvc-struts2-mybatis-hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.htm<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>default.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>default.htm<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>default.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 引入Spring的核心配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Spring监听器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 前端控制器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 默认找 /WEB-INF/[servlet的名称]-servlet.xml --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">              1. /*  拦截所有   jsp  js png .css  真的全拦截   建议不使用</span><span class="hljs-comment">              2. *.action *.do 拦截以do action 结尾的请求     肯定能使用   ERP</span><span class="hljs-comment">              3. /  拦截所有 （不包括jsp) (包含.js .png.css)  强烈建议使用     前台 面向消费者  www.jd.com/search   /对静态资源放行</span><span class="hljs-comment">           --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 处理POST提交乱码问题   --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div><h4 id="log4j-properties配置"><a href="#log4j-properties配置" class="headerlink" title="log4j.properties配置"></a>log4j.properties配置</h4><p>基本固定，只需要改参数即可</p><div class="code-wrapper"><pre><code class="hljs xml">### 设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppender#log4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</code></pre></div><h3 id="代码逻辑编写"><a href="#代码逻辑编写" class="headerlink" title="代码逻辑编写"></a>代码逻辑编写</h3><h4 id="servce代理mapping"><a href="#servce代理mapping" class="headerlink" title="servce代理mapping"></a>servce代理mapping</h4><p>新建cityService.java，并编写接口（方法名与mapping一致）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ssmtem.service;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> com.ssmtem.springmvc.bean.city;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">cityService</span> </span>&#123;<span class="hljs-comment">/* 找到所有的city */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;city&gt; <span class="hljs-title">findAllcity</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* 根据id找到city */</span><span class="hljs-function"><span class="hljs-keyword">public</span> city <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> *  根据分页查询</span><span class="hljs-comment"> *  <span class="hljs-doctag">@param</span> page 第几页</span><span class="hljs-comment"> *  <span class="hljs-doctag">@param</span> show 一页展示多少个</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;city&gt; <span class="hljs-title">findlimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page , <span class="hljs-keyword">int</span> show)</span></span>;&#125;</code></pre></div><p>将mapping文件织入impl中（@Autowired），调用接口即可，在类中注释<code>@Service(&quot;cityServiceImpl&quot;)</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ssmtem.impl;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> com.ssmtem.springmvc.bean.city;<span class="hljs-keyword">import</span> com.ssmtem.springmvc.mapping.cityMapping;<span class="hljs-keyword">import</span> com.ssmtem.springmvc.service.cityService;<span class="hljs-meta">@Service(&quot;cityServiceImpl&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cityServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cityService</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> cityMapping cityMapping;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;city&gt; <span class="hljs-title">findAllcity</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> cityMapping.showallcity();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> city <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">return</span> cityMapping.showcityByid(id);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;city&gt; <span class="hljs-title">findlimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> show)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</code></pre></div><h4 id="controller编写"><a href="#controller编写" class="headerlink" title="controller编写"></a>controller编写</h4><p>所有的springmvc的控制器模块都需要在类前加@Controller</p><p>在方法前注解<code>@RequestMapping(value = &quot;/index&quot;)</code>，在浏览器中浏览该地址，会调用该地址下的方法，方法的返回值有三种类型：</p><ul><li>ModelAndView：该类可以封装后台处理的数据，并返回视图，不建议使用</li><li>String：输入返回视图的路径，后台处理完毕后会返回到该视图路径，在方法的形参中加入model，然后将数据装在model里面，会一并发送到前端视图中</li><li>void：适合发送json数据，通常与AJAX交互，返回类型必须添加<code>@ResponseBody</code>，形参中用<code>@RequestBody</code>注释</li></ul><p>方法形参可以为数据类型，可以为model，可以为对象。取决于调用该方法的用户发送的数据是怎么样的，若为数据对象，则和bean一样，将数据写成私有变量，生成getter和setter即可。详情看Mybatis中的环境搭建中的新建数据库对象这一章节。</p><p>需要调用service时，需要具体化实现类（<code>@Qualifier(&quot;cityServiceImpl&quot;)</code>）并织入（<code>@Autowired</code>），这样就可以不用实例化也可以使用方法了</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">showitems</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qualifier(&quot;cityServiceImpl&quot;)</span><span class="hljs-keyword">private</span> cityService service;<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">showitemtest01</span><span class="hljs-params">()</span> </span>&#123;List&lt;city&gt; list = service.findAllcity();System.out.println(list.size());ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();mav.addObject(<span class="hljs-string">&quot;list&quot;</span>, list);mav.setViewName(<span class="hljs-string">&quot;index.jsp&quot;</span>);<span class="hljs-keyword">return</span> mav;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 1.ModelAndView 无敌的 带着数据 返回视图路径 不建议使用</span><span class="hljs-comment"> *  2.String 返回视图路径 model带数据 官方推荐此种方式 解耦 数据 视图 分离 MVC 建议使用 </span><span class="hljs-comment"> * 3.void ajax 请求 合适 json格式数据 （response 异步请求使用</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showitem</span><span class="hljs-params">(Model model)</span> </span>&#123;List&lt;city&gt; list = service.findAllcity();System.out.println(list.size());model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 不能用形参传List的值</span><span class="hljs-comment"> * 要用对象包装</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> vo</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@RequestMapping(value = &quot;/updates&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateItem</span><span class="hljs-params">(QueryVo vo)</span> </span>&#123;Integer[] ids = vo.getIds();List&lt;city&gt; list = vo.getList();System.out.println(ids.length);System.out.println(list.size());<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;        <span class="hljs-comment">/**</span><span class="hljs-comment"> * json解析(后台)</span><span class="hljs-comment"> * 必须添加<span class="hljs-doctag">@ResponseBody</span></span><span class="hljs-comment"> * 传过来的数据用对象封装</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RequestMapping(value = &quot;/json&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-function">String <span class="hljs-title">json</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> QueryVo vo)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;这是我从AJAX传过来的数据&quot;</span>+vo.getText());JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;斗地主&quot;</span>);jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<span class="hljs-keyword">return</span> jsonObject.toString();&#125;&#125;</code></pre></div><p>更详细的内容参考：<a href="https://segmentfault.com/a/1190000005670764#:~:text=一、简介 在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet,分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。">SpringMVC之Controller常用注解功能全解析 - SegmentFault 思否</a></p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring整合</tag>
      
      <tag>框架应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sqlmap使用指南</title>
    <link href="/my_world/content/SQLMAP%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/my_world/content/SQLMAP%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="adcb831ad3904e5041a12a830ad23b69b2cc664cbb0de42d07b30b6cd62e9119">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc97900cf1c61670349f240eefd534c3e1c939865e22058e2c6489b027a7f5ea490e75275cd782c5228e384227b4f5796970402acabe3502d163f272b56afe87961c94d8d9bfac3a4cf469f46195781b85cf332293b4c8a431fe5a5d9c792704d69519334502ee9f43238311f31baa04d88f73fa0cf466c8e41ef82a53084f427002e2a2ac64868568510fcac92982b94ca92dd0a9f3dc8a0ff5e96cf2f67c82e0fa4017d83362da9ac7c99a637dbb33abd578243109a9d0a74afee7078b9023250d3e3924d22c2511b123767653f4f31af5cc9aabad857103b3c238f9696cf3ced11dbe103a9b5d3bac4ca9e87bb04c6415cdba8e8a7217653c9d773db9a03210b18833b65ccd4fe5c5918ea00285905c1740350da17c3c132768f344f538542f72c914dbfa8a345260cc1519d27a3e181abfb876ef625dae1712efe91a9df8e0bdbf417b47be0270ded51b0b1c06e9d4d24383740b1fc2df4970f3ec7a33ad655a85d4502e6fca999d3a87c8af399aa2b8ceb7bed52f10528e2d25a924df751c651298bc47b4d8a1d9a2aabc0021160b8a8e763425676c0755dd37414944d259727f0bc6bc93fa24c5fbe1cb329193f41845ae631d79580c6f82d0c76b048722d258f8e8bfe923a9080c1658f59fc2b6968faf45591447ee8b818a99e519f2d47044245d261c17926b7f229f8c98d3f5ecfbf43ca36b649d62adf0e64ee73054ee1d8c3acf566d9491340871a59f610f23b86363ecf57ae22fe8602dbc7bb035a3280974af5d2660f6daf6e77708de690b6990333bb17990d0f06fba038aa17db4d76477b4fa310bb77449df94c949a52a6e94f7c1d2f76e2b72b23aad9ceac2a2f6cee6f8ba43b93cee7df98762997dc4529918b429a5c17326015245a4c73d914e08fe7b87a4bc885929637e3cc2637e04d7705083b63c582833c6dfd4aff2afc204e0da8dfe7976bff9e1c8354b5d53637aac64b3e49752941348e21ca41bccd456889ed08986286995a1c1c3eb9356a61dd4850653b98bc7cf7fdaa391ba669f676d591c33efc9ec1c766ecdc3b4f9c28445675c2f3b01cd6f7c57035af0e47f0def80c0976ec133caaaa9436305dc2571fb08596f0e9feec2072c6849d58888cbb25115517681381dcf78995cdca042534bf2f203555d1bc5330a011aaa2a8ae35f888a202bd6c7344a1f4bcb1ed98a93d43a4c8976ca4134914b08ceea5ef954256b4b4e4cee6791fb5a2d142ba6361c979fe2db47e572ca17485f6bca86dec25c634fc6f5d95d6a4285f48e74d669302be755470613c68a6557fee88a179d0d3ff810cfd563cb4b24db8bdee5b9d849e5bea345709afd11a1bc6200db76379984d406601fe8e47fc4d5ae4ec928397e09eca2a39890cf1931c539de96ffb24cf36cfbde503a61581a51360c64d1c749a717e05ab322f20565a1b7288b79f21908f27d73753b3f280af75a19ae99751a04db3dd1aed454b4b7edd0b9f2088a3a62c54e69570541a923915c8593321d85c8590f1736977282a13ad755dcd7add58e3623fbba9a6922d0aff62c8c45cf766ca67f092044af493ffc1a69699aabfc4645651acecd8a37e1040d9e3f268af65647f31dd1cf944e87ab2483d7be9d116cca14a4c89b84b0e9d83562fe8818867c2da09e51b51e993685c4cb129ce12dd041beca8ae94faee21a5d62dd71122ba7bb7a6feed7a960bc3e19f2f0d1468abfde9f77578eecbd2dfbe1a28694ce00eb5e87a4dcaf7033b543b2a484a567e82c62466b81d30b141b6ce133d76254124f3ac7860646f7846d4f08ff86ee9152b89903ee6838b5d1e722c69971657109d1d217caf9f06ce4783e881636588b464a08c0bef27f9c85b395f8a7f3a1200e0fcbb06b7ec33a4d079bc8023af280ff3a7aac919b2bcc1a306aa4e985907f0842d11ff721adca0c1ded9b26378130c0d4451dc9aa51046f780d18714deab5ce01ab923734dce5dbe8c287740f07b153b524d3ce1a32fe27a29dfd5e98447cd9ca54acedd283195df9557dc533fbfb291db8ed6c0aa2b456af0556360da7a023a04594e1c911a608cedb2a916de4528574db221577e6a61401ee2988beff1bbc43a34bd34981304223c9ce6501b572f824842ddf7008d8465b6e640bddbca6d5b4691ccc66ba73eb93014d0b863c4885ac907b29e8654e1fce2425a3475963be8b663e207f5b69ad44971f8c8fbf5620e98a2ca95ee105e7e3a8f1f03f8af6f875ce073149f5c21ac04585a8deba658ef465b09e728186db81f97162dfb69d8f7f4f1decb175eb9fa385a64d269605133e78ee1d2d6ec02eb4ae0bfcbae89dc50d525cddabf31681079c555a10038e04b70553bef6d2bf0d8565f42958e36b83a31af1f002f6876a4d29c20681a0649355d4bdd888c87d8183cad12e789305b959333010b473066a2c49478814b802e9de50a7a6cfdc5cb158bec37fd4366df6378dafeb7274af0123da120e42d448cdc4599413f034c5033d1845a325ee025cd2718facf0722fc04bdb94f2de19ab2cbf6ee4343aaa6c1d8b46714b715dc75bd1cc4b5dd016c349675ba6cc5b7486b5508987ea74a9c4b88890cf16df92d79a68cb08fc61f3961c9454ef77dc97d731046cd05ec79d84b958d7a815bec02529ff546387856b48c57e158831188982e94c7aa6c1813e1a0bafc4bd1e9d79d6d01dc4d97ce4861c062a96cb113df8547accf99a9e29101da2bbf2b9e8dafe93f1f80a2261ea92e6099bc0eb903f1e284b2f3c6551fc41f671fd7d78e62e875508825f0f50bb1053d92c8632289f273f6175deb4054687f6d50e6abbe70b9cc6cb894ac2314ee8939676037900ea4ec4cf0f24fee5a7dcd7945b7cfadb8fd233308b7c930136cec81583923169b47248cfc53f4107b62fcd276783afa1a4fe28db83248fbb9a48a3ffbc7cbb0f09f69a0a979a62c0a64f8b82e331443c52427b07433471c5590ae01d95d617046bb85cb0faaebedd4f036f6fb4547fdbcab00c533adf9e6c7296322ef54ee424fc61846911d3b84eaf26b95dd6b0b8dedb6aaf84a29b3b4dbeac4dae06c890fb84a9fb72f7fddd9c680684773c736abb8272c1417b28a0a12fe0dde708c3774188e700e1d0f79aebbdd6ee9f77bc88dbf28fcdb8b6fad9d3f40c49e22c97b85cf5d22061365cdb51a4b20b22e7e298449fcc45822524352f5b02122fe156005e984e1cc60be746e222184d6fadfd3594d0fa0bce74bc1ae493a23546cf8bddb32bdfaba5c3a8f1f4d677f7402a06b6f1301710e1ff8f2437deff08ef57036f26b15400a1c4c9d6ae4679134e84786a2f444c9a164f5c231162ace07d6f0dc89d05a86a2ceaf7eb260c133b13a146112169e8ad9d065a851e56f0cf2df50972c2cc5aaea3729200d84813f7e46bc7ee495023d8488d64ac1ef8d8c016fdb320a99840039c5c87288268df279d725419de29278c3b58afddeddcac336675cf34c1817374c20c42dee50c4f2f897418f5354a35ddc8aca37e42545320a06391c51c6807b297f691bf556cc43921792fdf695c0c5fc9c8991f5f3d561ec24dd97e710fe21d97369d4cf7fbbeb40d8ae330fdfff46b333ef69d2a5b5bfa82c0328792e57cbdbc910a233112d1869f86833b2f674da3bd8141cb82a98ecc4a1c0f08dbcaf2c429f533998e416271010b2d3fef188f4ab5430131556f9a85aa4e1180d962f7539923cc3c9c22121fdbb65596ecf6f97b4111e6bdb75e5276d9e469ad4f1ceba7f39e91b12767852de7733b323e0dfe0dd847e4234d8f77178e499a8d5d2fe0c036a676371b6a9c03dc850bcc4dbead590e51f6fd401f8e869b5c0f0294d7467a22984b8cbb438c73f47f040eaa8fc62714715778d5d389c09ee732e3ba9c12f8e3dc128d2dfd8c568bf80fa76138c77d50a4a6a5be8edb89650f4e162dd51a091614dd9287cb55e7c084dcc1e7bb5981e69ffb6d68a7ffdc3aeb24b18b6e7c60c4cc202ddfb11e63875c0caa567a3b7f6be27ec73f89447e7cdf28d2620b391717da1e82124bf682cb8b1ecc008713a2692b17c79cafa5d45924f1c93af81747564ea967b5ed243c85183a8bfdb061e966c717b32c1d67c345e6f17f030506afa39f71a1e79f6f43ac195726f54ab1a456e60055cc26987240dc01962eb70c115e9110407bd97571a9222359ad49b95a19b127c37931d4e01fcd156216df2c124482692a51699d94a7d5e3bd24171ac9a17ec42082639fc06555efdfa73985ed64605f9ae2acb5fc209ea063241825d67b53b72c98b252f85ebe77fa40cc5b2e49cff0ebe9f581443aca7a99cf193268b379f5b95c735734049830e946defed9b240db366d628758e1a91da0f2276fb2978cd71f0217168305c61e5eca97beb35a03f2d2edf229e21caaf331f83216ec8aee7f73c2f8e77804a78fd126285edc3e39cd3248201f7e1e1db64c34f8563853b3b7b0646e7c28dcf4b64b9204d7bf2c848bebbeee49e1d807f25c5a4d4952cd1b5c9f2175962b556f37309ba6397adcd3a5f0549d8c4ceb5d48827c7195362c6e2b9c2fcd555a3c2a85e8ff732aa9a30890fe62fdd5b82c16bfa82c2d348a6b82087332090773908fa6f6b6be994636c5ba269695cbd25048fb3b73892910ee7adc87177102f3e84eef7aae49385cc64847d2714009912ab86d46d709623517b54ce8a59f80da9506b0f49b36778af4cfb0b75fcd02dda9b47c91a8da6319300e029cc1bd23246206597f12bb84bd4c9b3149d60e3490ef8505ad2c43dc3039f1229e8c68286de3ed335eee02e88613da658df9390c12bb016e607ed68d6c6223456c8a043dcaf3b22a751c5e0dbd08ff0ac0c7dd3ce9682d2a98708a08680e8b6508d447118ea48d8161b733aa1bf73553d1b8f426953ccb9549b28170deae0cd76a483e9535f22b443f011899d4f77a117f85cc8c5e5637d135a33492b041c8d42af353956e368ddea717741031e528b8f6567afac48e5449b3128c91c1f7d094bff58a3c03c3581c2bf478b0cd763221734ca4f5d4648f1b3556f39d9f886c36fcb74c53b8f2d84435494fd92262f8fee9537312de73876e982e2e82eb14259d4f8104f9265a0a4e2bdd31538eb751fbde014f04e45a93004f4c6514eb11c1039a7a037a9d25ada0cf607dbf612d3633cc703bb8510cf60521bc9622ade2c26d9ebe49ae9a30021c0288baa761942c7eda889d44dcf8fa549caedd5230862782b14b3c5a91e96caf177c4ea151e65ba2c4cc2b199a1905250f97bba82760c154e2ea0bba145a510289180fd53cfaa0eb108344a1685acd6b002bcbb987c603e93a2d5c9e2f7a3b051b2b44db07a5b184b3fb75763a6f78da8ab0bd3e821f0ce32055975d858c55d9a0984230f67d769f3c920c603f4ff2971ddc1a1b545dc14a72b9c42f3ba9ee4428d1e07f496a5f03333ad06bcf7bb958e5a11193baef36171bbcdb55c36789cc995d7eb662c2efdc1dd4e2aaf08030d8c213dd394c714ddb12d385f44aa0465aae2257e13a2d0a33fa8b7c87313ac7e9d023ea59dd86fac21fd9105024e4dbf6dd44300162709e1355ff89f1b1a03616349eb89962a68130269236c07186757e4300f93866cc1639d3f66e767f2e7a0ccd0080ce805f51a07fbff07f58f5a2261ee345862e4450203f5138bc0a63eef86e5196149f4d21026e8a6eeb1c9d46d93e82c1fe3215c056a7eb729b0aff4fec8a449bf2985de5013c7ab7a03da55d17d461d6aab8371b335ddb632333362e8a8bdf77d7ba40649735c4a48fa7947c922f253b21f7706d586486e32641aca3bae32870ab8eb73f790fb2c5e0efcb252683b7464472a1909017ccd8cc6e97dc5cfbdc2d65c53e80f47640a9bca130875b2b6d86b4febebca8610065426296281a877461ba1d000245fd701ef6b3205aff2ba9127aefb8b69cedc37eabf7c06dbe904e2d346da27779d5d5e2ee2e8271d6aec43edc6598c8762986dc420fa7ebd91378c86b9cdb290680f38351e2add3280505410b5fee27cc317d2ef6333d1b998bf5ff3851d3b81640150484c56c19fe194660e8e0ac4a8342be47385dc2ed059e97a93cd78811ea4504dc41eb45c8e53eaebba4ef680afd7d0a33d3d183f4b99ca1997e9b44f3cd32acae718656c4ad1ab7be5f1b14b2656a8640d2f94cdfeadd7797a8a53970e00c210a3bd74dc943a52956e4c8246081a8102e913b8a94cefb4e1ae76feb1f518a42c452479d86cda23d2893aaa42e9fb524ecb0f1ae4e26bbf1a383be3723b7e88bd33ddc6f6badd5db011177a43973aa648a957309b5ff4985d3ba180417cf8dde5996568f65e4fbbcf4cbf0d313563747ba86dac7314974e85f2b1df0b93b36eebde94cad2fac56afe21b6bf844e4107c0e074f65a9244f9daaa72b9009c2a09961081ac69542b06a31114874bb38e848eeb6325346a4c09047ccbcadb50863d0f064ec48c829560c1ffde1b4f6ed215bf7493512e261d67d3f04a4ab9949e2111723d57a037461a2a643ee835f7e8c6ab1418b68b8236f153bdcd06599839fc6bfa7ed258e176c426b1b8792a4a94375e904c7d4585acdc3ff2cd205824bdd986aa5327202c96b1b932e02959de00bb76aff9aad96d8de314ab89e7008a80e83568cfe972c572806bf75c000212a6252ff864c1b99403a42486c3e7640f6625f46398c8c927d7c66bdeab88ff297105427cc5ddfb9f77312002f33f0558b745d9bc1df28c792b1197976eb6558eafbb30ff7cc7d3a3a8fb16b7b913dcb3e0439e5495e92a91a0de44fd3a26c0a57b9f054d700c38200d9a127705af4053cb164c40284f0e7d3a52371665ea83af15f2a005a2d30e49a523278dad1edace37f3935aa50fed2a1e02bf760ef2d25da1e440f019618dc4c05fcd4dfe11a0a20844d0bc3f487337de871069f1af9faabcd499deb131ecae6b2be59bbf0f56b4134e617dfcb0d3abd02e899a8ca399e852950e0797cfec9375f5615cefb0b5b243db384e1b6f98719d1634cc7f7ada4b516abb30f0e8a163d1ef49086f958fb7b79e2e982e4963bbe62032c30bd15bf23955cfd85d414c6b5572c75c2129c264181487ea6f96246d4fcdcee3baa0723428d0f2d77127e3e45b8c79a5c080afa8499feae18e7f51097f0dc430a802f90fcdeefef2bdd16e3a078e439b9be41bfdc3ce0ea099110ebc8579392445195b58cb46b7e8a8eaf0a3bbb6a585b58a369d0bad237be4b6acf66193c57d09d4846525fe2381115292c3ce826b2651c6801467ac83d246448af8125123873190b11eb5d9e468cecc39254fbf5a2558254986fb5d41fd03d365aba831ea38fc3cacf6fdd3b940654a26eb6c5657138a92ffafce263aca0fdbb12b04263edfbbd8ccebf82b7234bef3497c3e401c7c3fb1daf9ce60cc38776dd7bd22743ce38793e70e8d341912f3d56d7a85be84928818f472609d3fb0a6dec7e80523cc99d0170d9863efed290c2d743671ca2ddeb1ef38790567ab9b3289be3a4a6254afcec2947162ba764b844fd5183d5fbce237f8fd5a6d5170078f512e456e14176c84777d146ce1d84965f65b52e247f6bf05a04230ad8d99487988ec83e8c5542d423c26c2ae3679b296f1189d4ebf9cf3a4d34b8d08304b0aefc3377cba619b7bb1751dedc645abd3bcd767befba52522710e3388134230608d7e72062d31aa3bfe72efa2faf401cd6e6aae971fce187e60e34a4fa1641b6867a367dd6ad881ec088f6786d89a8a9e6da782c10a90036afed4e594f4185ce0b8e8cb0af89ad09dfc81ea6c8d0ae76a42384dbe5355016a9a23b2321ded6731b02305fb6973dd832816fe933b344bd4bcc6efa6be3cc76d712248b50f6345c989a559c19501e3b99b33dd666239cef8dbbca4f0d61ddb098ccd7c8e19c3c8fe9414936726de4d5702917da10bfc2c30f02a8eeaebc7268f7f10fb5504bc4b6e4847009dd0bcfd24a52e20a88d306d8c932c431fa2bbbaa4f003a726fee83145a29cb78f5369403566ae52767298645af3f1865fcff7b150dc3754d071ea951ada03ce48b1e0f27218116b74088627dc6696a6254164344c23fa5561516a62ee4755bd7a5348591058b462af0c5e6fbbaa000b0567ce7cb8ae62a828c7da78046fade99e856968049a51872e0e29bcf50a84c63a15b7e414e4ed66de8b449b388fced83a64557cecf26e0f6ded1584a14a1a542dac6197988662d69a2b0991c755c5f74c11a9351e1349da879c838a62f3dcdb8f6f0d4ab6019116516a232d7446305b4c236f8a53490bbcbc3c2b967cf7eed22b91b627fa96a764857d64e43206cbf8ba5cb72ffcbea01e03b9b80eef7943e964a822147e4e2142762fe5e097d5d0a05985d5d7bd3e2e05f8eb32f6a928ca0d01495586fcc6645540ff4a1981a9963848c8bb96d94359d878e0f827c26387bfff4e5722c9d1e4383a8bb1310a12d241b37914869f17860ae9d14e6d014d89e069bff1d515ed481b23004e07268f08a9e88b7c1f79c6dd819abf3d4fca33b0835b46adbc87d568d52e323b4bbd782e9b9fafcf5748c728fb85628b6708577c0e91e01ae8eb31e82516e977f98b1629100c3f7d7a6f6094b03428215f87a38b85941fec013568694fe365c9bda4705eb02efad9142936776342f847af07000f74ce62198d36c9c5d70a25319a2f6f3126cb6c45183ec5d160a2b1b2e18142c8ce722455c0cff040b75ba86c4c9cffc1f9288d7dd2f376d233e5807b730c377a46f74763555f79e4989db8561f4a7cb67c4e673b559baad8df3b0d89918502d24ffaadbef7e4f31b5464f268a50d113538ace4a208c37f8cd582568641996bff10b652c09e6bb71b8b4015ab27e4efe21c12ebeb4f328cc6ccd523d6d0b5d2bd3baf5a2a68b2b117d032441bab1e8109e49c5ad6d10ab73c1b64b19f58867146dc65a82c556936a87d5e5922a19b9ea147e37612dec48f72628c1d3e7bcc0100a984ae52d3394354b6d91ff9b3120194172d949e539d3f74fcd8219f49946f0bd2b68e30f56c3172d1fcb6ff7d079f7e852d40695b0310bb96b392aa83ec30a0569535f9f906db97f0c74fff663eac45ccfa7f172b1cd36db1a900699963382b8e5f25c97c7463f5ffe59898b75912bcf30dc578d823d56e2840415398a7174ef18cbf441613ee847009bf9197d65ad44adc7d8ba2ec804dc92641012a4a2013ebc75ce2545c60138de0548bd634fe7c49a2cf8eebc938069e556b460ab2ceb33b19e6f8a5d00e759355fa3818c26d695443574f20776f08f48a6125b474af2eb296ea5c5f83f2d532a731a77fc88da07e812119aaa3e8a7f0c2c2a2cbd950ccdc24e77d33d704d708b2d273ed35cebd4f57a807a9d2a870cb30c60d31d8a030eaca6c05231d877266e2e66c9d702da5da460f5e120bb06747e8c8718e12ce3227d68d84a88dfe8575ff0c6c7f54fc652a40f28865b31b229215e7093d7dba682fc16cfec4c0ff51b3447010ab21cf380a8d937bd15d4f8bb2f900e3195accb13c0337aa3b1bf618c6e7fa4d8ad434a62b4a28bb95fd6759d57488d78cda9c41de2832210a3a6d3e711fd7ce652d6329b93d6742ce77059657da6d458f2ac9fe7b986705e585f6a13e06930b809279ee97338b0ddf50eae5428fc4adb1863a257fe0d0645713089a9b7d76e07c4cc7ad35d5cf7cc98d2db9d5a784c7133d88baca392f987cc7fa85459c327edd3e20c5d25608d3e8851175ec08c57cb71dd19473b14932a0097e287f7143ac209acb5a56579feee97a0ff5f05ad70d9dfc4b19376d7a4a76fae042bc29536f3c16075fa1cabb9baba67225f093b3e7b9e1206974eb80223ea805cd2199ef31fc9ebc1ba2203dd7abcd7ae1f0f336f959b2d84244dc87d80fb08095d86a030091f1ccdb97715fd9b549dbab23218fb81240a6063548d85a0f282a50bdcbdc8f5de5e56f2deacb87d24fbc093d65e54745e558f091511a7fed4bb3e03aa1de0b965592d2435fb18e7a498c3db5e7d75fa6fa46e626aebc0201a30cd631086cd1d932fda9e919a2c7c4ac652d01aab63e872ecdb64bbb665a9859dbd7723a6f9fed2935ac63b1b977d4e503c14c8f699a2b4fd5b2f6ceb5b0cc045630edd0d399c7ea95a515caadaa3a173de0e907f40e9f54221cd0f41e082ff8284f4303686563ef4457f9ebe5aaa18c5e830198b0e36e5af8bfae53d94d78a263a83e73745b7024332cb8986add87ca30de0429c3ce4e9390ab100203bda530f0fe348912b57a6cd1bfa53fb34afb2ee9f09e5ee1db6c328360187b4f96fd7ca470e0129bd35ec025df44092f0ee55472bb3c89767d1119e9ee5821affa42a7a03798bfaf8dfefc9ee3cc923b7694939bc55e59a2bcf1117a54c9f7a967f721d7a9ea066489207d66dad4c74699ec96a581dd02a3d2519cf45758c6a1826b306c8768e206e6910031990249e19153b9196b1259f61590c92efab55929e0df230eedc20d48aebc3ab343f697aa7f0ceb4f112bdfbe6ab009cb132e197141ab4f6c583f66e80bdf9d4321f748523f76dfb1029795b4b39c2f17f9ddd6dd5c577877428280d95cfc18c2f8a6efb623ed33fed58e5cb2f398d762af92d1b5da335058ecb4c20f4dbf401df2b9e9194b95385dc7e74a4555297f1bc666e0b6e11e5cff6341fbdac64b575d06e573e6d93917ba22af95b494eba51d5445e61e776d3c2e9082dad449ccfbcefcf7140a453810ce4ac194b3653e0f6570d840cae23afe57b1d16171c11e85d46ed0368122cbc98f52a443de7ab0c1ee01b5d367ea110d90177bdedbf0139e2f6c9f758742430dea8a2b1f641f009ecc8a486906532004bb7c30e345fe948d3d3357e987945dc42e104d29770291bf8c9ef134fd3274263d7b69bfaad6f6db1d345e14a85bf06ee81d3ac0eaada08c0b1516d027c405e52100c8e26ac73d121080b92ec617bcdf26346e9c0233d523add9de5c6115ecd668ef3b5fe867eeee16851560e3df8e8c9ae48b2aa09ac51d3a36256f999cc26ad85f74cb2353808631655abe09fe9c751a14066c2b12a603ab0e902b9a5ebb98e9e4aafc3be6babcfed859213987086ee19a501b5cc15f89816144813e3a236b1f269b09bc2bdc101a9660ccab522df9d40d791a5d798523fed33b6941443c5fd551f7408e477c58fbf31ccbb6b66efb97b6ea8c71de03930ca870b6cbbf921ba042df97cf7322cb47777e9bb09fb650d954bd237fc3456219365b8404a24b9dff3b38bfb76ee40bb074fb85ce748bb7d51c8f2e5099b4416b5279b41ee1dceb6fc6388e82308d26d00c8316034696a3eebb75f550d59815ab3968fb0069c35e7244bfb0a3a2d1245578575054a27f958d3042fa802680d29947a5bb2859c5f557db6277447eb14bd6e338e05ebb97c8dbf4efb954cc12136c4e6e5f56c54441c71a1d48b9b06157ff5f14fe155a7cb46bd50491afd7d1b625caf621f759207025467635f3302fdf402c4af443050f736aae3a2c6a34d2e0658a914af672dfce9c173e94b6c5d426937465963bb7db88</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>私人笔记</tag>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploit使用指南</title>
    <link href="/my_world/content/Metasploit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/my_world/content/Metasploit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="34f75a31b231661e0acb3d52dd2db53fe5ee37db13fc727dc1d0f81e62cccdb7">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc94af5c0e8664665233559a1feb822dad9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>私人笔记</tag>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BurpSuite使用指南</title>
    <link href="/my_world/content/BurpSuite%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/my_world/content/BurpSuite%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b84a7983d25ff5ec4659f26a7766b241e3ef2a9e20d3098a046de7dd81cae352">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc90616960127c725cd7a0ac171906ac2b8c68ba66f149fe2f81495013946281475743599e89291cac0a8b47a1367b840f86db76214b80c25fef992fac696ef44410c41f79fd85304d712b6c51e478796da01a91047b0fad971401f2d0287ba0a0edd728abf20303f8b2c3d58022b78dff65daf48543bd8e97a98d8bc03c8ccacae6c705d2a1d89a9a346cf42fd2b26fa2ad34bb91f3cf5a913a1412985c2e74001ff1682d5d19e78a6854954e6ece0ad687034f32aebae98210d53f830ac9a9b6b09a20340d2670aa5fefd6a74af6c67964759d2823220c955a13aab1b279d5a5ff016341ae1e1583503dc7a4bdac593cd436df12432dafd04746e1f91afbaaf58fa6c7db6b9eb7bc8d7dafa3f0eb33b999d21b945c2b44f84cbf24adb38b71391b3d125bc1b191660d917dba016d9720be04bd426a73fd8c5a7c0444ca7ff941872acffb659b428f4b7720f000eadbddf34339ef4243f7fa4f68b119006517028080c088b91b7105214a7ec108e93372db7e7dd54a98a4c4203f52d0f09fe8fc078d77d015bc63875a5384c14e3f26f65abf06dabdafa01d5c9c8ae75a10b40c77514bed4ae83925a55a0f2ddffba6926873e22dcef2d8b5c85309d9718417d1741630b67dcd93456415c2a90ff912ba3003129e291163b502874f0864ecc4b9a7dfdbabcc19730c5c753d8866a9f9275f41dba64e8b688c09d09c1301efe843ecc35e592ccc784984eb6e4f42ded11738b83aee36b41b8d92cf48597ad0afe1227045653d8860fc850f30b1684675c2d95a8c202f7741a5787823c17ce4af3f42b1fd48c8a1733a9a5bdff0191b4a7a5d660687e8f49c08ab288c343949197141a7efa124bec3f768c3abb353f519c307f0133164357cdbebbff1d6cbf7681210e82c08165b85e6e4f29fa4c02fa814fcc5a83f1f91490537ce266034ff63b635bf9c4662d2fc803347d9f248487830bbd209a4be7e6153f8e134f6465fdc865dafa4bf966d2dd194c10024e3485b3c80bc9d2a6631a9734515cbc20d0d6580d282ec6bb91e58ba846a02a4ba9ff53a4a02834c63be8dd42821a8f361945f1546ed3c3125f6b401977dd9e7d125a8cd757f468138ea0ad97ae437fe4c8402691938208f402c9e696f9f5f884cf0bbd91f36beae2f464d319cbe0a76ff1a21d7b043a37a5982fca784f1988e8691031f6c321fa129c30db69ae7a431c3c85a3f94e47306013a9eb0fcc0383735b9e295d96b973d00a6d14815aacdf11d71eeb7a58974dd798e94b4a576604e6897edd7aa8a8f916f37e88ab2bb1116675ac36a8478840cb3ca61bf70de8147ff5bbfab7631a44e10e7dcde096821f34284307a638aa2514a55150b2799d1374dd305873c2693df603c17ee4765f2c6ab6a3728370fc1b056ce2b9a9832ce401572bf408497adb597e3fed225cf798ade14d7961d55fabc059b0417a5c475100b067e13c32f587b430e9e9f76e09151adc7ebdb099e9cf6ecab583e0cc733f0bd8887368cf8d2e01c5ef102443aeb22e1d6fe99783d2bff5f8a4717f5e0a90473d5b448b77511337e95867dcfe09b3ed170b6d5ee77b4aba71968926126e9fceb761bc3d59f320764efb508e0b242b6f92c0338f44fceb9636e4b795b01cf09dc7f3d9bfdad754ffd760349fb42c686a952ac937cea954dd473b155711156ea6115026435954e17e4581e7a99b1bdd3edc158e997543c6d5ad9304d2b9cf20bc4582f9e3da08a06177c15dd6e1394be809e31153bbf12f342d832ba94e680f33485d81dbc87cf3036bad74eaf6da0fdf495a9062b859bc74e2ddc2358e2dad4cfdac02131864e02a21f7cb2ac36c51fb4a55afd090f76a432eb12bbad59de68ad16b0af386ad69bf2f1b107050d498ce0439ec045cd795094730fba6ee32fe83ee2dd607ec326234fa804e1de89aa1299a450e30a5a19a9abcaa6be9728ddd7946d888e9c4198339925653dd25af344af8386d6e569ada85b287bdc507fb1b3fdbb7a9879d1d8a86d427facba29c275338cc2f653b1c3108d7fbb69008ea6ea67e514984e4173dd7382ac6463ddcc81349fdef3bdba808ec05a72c556de9f47c41bfcc9be147e776dde022c43285e7dd409d74299c34886e09958a73fb555be188f8c32619cf49e340f6082248ffa9ab87d6ff683d3900d6172d58f0a9bb7afbbb0604f6b125a3dac223a41e83463a739a3b8364a2e655f722a0be0829dc3e8fbd4d90d6817d41c76253efe0c27f4b02c7f17c882ed281bed1cf6165f510b800978cebb6368b71db9286a4cbd31d5e93f355b6830047b18a6fcb7019579c693c81f780778a975d596d94eaa439c5730826039b37600324de0f723ca611c5d29ff26fb2a3a036251779a15c8af76f761bf48d2b9b04702fd94360d7384a876479e40e1908c038fac7239b859fd3703b519a5d7705a5e8b3bf4671b3d9593ab06791f4390bed99ef6c83bd6ca49028fe08443cc6a8a31a4fe8635a7acaa424e71f5b7421f6e7ef748a8fb8488fa973649b9e00ba84b8559fa7153eb50784365b46c4d883112a1edf8e197ad365afae797df6843259c75d1f3ce21784606853e477c3d44b3e7dc3ebc3915c091885dcbd5b93130aefc2f081dac1140eb1810e4f4643e15e5a8e664afe73b00363160840584a10dabd0d95aa0f8a98b23b0de573069f893062ce9cb97cac7d2a6ce86fd640729d3c64b57f077e4e0096c5d8099a3654d90b714e168adcc27e74da9c8326a756d86a648bd7a816b0a7262c93f9637caa78e12a3a4ec41e660e13ad52efda78df3fb5d568ad70b1d40894df9d4132473d67856138991a1bbb0e42f29e1e3f5f5c80ef74b523ef2d41e54b81c18c15a3da4b5463aec9849d652a8fe8debbfd09780d0d09f60b932e92919bfe4aefa2bc9bee420ad164bdb3c58278b7219290f1f983dc8a4e117285a2e3b512d77791344f195c9ed784ea0e5306ec871f5de1c3919cb1a21dbb90fcb424dd86049945700938a5f8716ca7177e840678479a753d5c4b5a4c6af6e1f77290d78c44493cb3e7a75473552ebd33d7cc4b083206a110c135d19d264e20c22025beb6866ab317993458d847f05a114749b95830221f2e0c118a6dd34b27144a8338c5defc810bf7cad6ee74c61c9e2d7c3a714ae17fd9df648ac5a705a2c2180751ed41b430bb58ed4444edf968a241e8f9290070785927eaffac5828017992b235269b6a220f2ff1738f95b1d5b7961e8683a6e61dcf5ee55a525bb19213224e485f26f3a9364249b86197294a4bd03a041b393184c314771f4244eee0c7f647652910a969fbccbd39d2a14a074f93cf27001397430a010dfbf620a38a0851a6a1cc81cc077da6d128538ccec3134233e14c6aaf15792c0f967313b8ff665acbc22342fe0a0e68cb6aa353dec6e380e0971fc6fcaa7cf7e056feebae05663d741298371b7cd68dabaec3472a798d752629fafe80a03213c08465dfc0ab5f874fd9fef3f0d8d4302ba1853c0ae3c5ae9461532c2c0d6419075eb70cf79d2a8487c56089b945d48d52564cdde3754eb3b5edb117ee293fdec05e079b67891b2a7454ef28eae49382e5f49754178a30c06329dbb1286c156451cfae5d32fa5e8a06b092b013618884ae1b5053cd6312a4871caa5b3199959f3253bae4ee574bee9e507b0cffbf4363c047c314b70058202c9dbfb6dad578bdf2fcb0ba1b2905c0dc45f2e9912dcfe524dcc6de241f16726782788bd668289428ceb64b380b0e8a9e8490f6dd60d8b5b921e1c31b29da4a946e51b94c3a1d620c8b23fdd46989a5a2bb9e18b47c88b375d7c2cc34f42ce99d1f5f0bdcc09df5eb896e243553b2766e5c85921d6db16bd921bc0a24ded5ba8683ba234561da12740379c86188a7f7f0d5c0a072bdb7593876d6404fabf7a9f31d21b35c91729f30900b978b58a08a64a3b520184f30c3522088cd2607fd1064a845943f56a9c7d735b5e81041760fd6b0e847d91bbb7589ee951798c230c8a91db38868d386d82e34b027631bdcc548c18fc3bd0a836b5c60e2eacc439889095c8f69a091cd03705ab03b4366bdbc32192367fa7dd69dc02b8632e4509f865c345578dc35cb969af21e6711fceee1add75a13deaba8eea645ab910d4431653eba673df6edef854d512d8d902d1b5371e94d6163427ca4bd4a42cfabbf8059eaa8a91e6b1bb59f10900a27637fec871eca5f6425d4e2508237bd9561fc109ea9ed0685b0d9227604912b163d653438ce01e643af2c7051ff47051ee4638ff79b3bfc8053741223fc438e42132b47139c66fa7769a09d6e02de6188b2f69016e94354c14f937ffd1fa7483c475615e9f8c550b8fa57c8ca8f85d5cceff9fa0630241de53b830ee0bf03eaebc8a9e7e189a4223d9837db56108adeedd82c5513aaf7a68232694b2c3a5e5cbd100c2cdc63922c24d20d7bb210e9e1783756461f1b1c62236b3d62bbcf5fd6376cb46b6975b0a84b66939ebbcdf0a35a0d1494445328ffd0886ae5445b9a692e266e3288437ef6dcf02453f905333c220f6b2aac0916a493209a5e535c38dba37b8ba522588a0f504354be85c896cb95b45f5e22587661c2b17d160e10d1a63fd346cd4f24396824765997490f248cc5e577c417c931b13cfe2294d0eb006f71ac157f4ad33cdc9c15b30cf2e85205ba344684d9c34d2f7c17c83ea168a7f391e1bfdeac9c61124da4d1fb70ed540c735d39a1b470e000586380d4843316409b4076b239508150a8225861b856fd27575a9b83c7637cfc7ab50b2c278c8f257f880695e133c8d1974541101c94b23b8764d17208386bece45146be10ada4dc41a209d3330102efae9bd6fe88dacf6d70a0bf4d8fc94c305ef1b8a954b5aa422efc73b7b0832bdee7877e1450a6b8caba851bc7b31f0b5279f3a1e10b891571439ed3ffa190382f2ce7e7ef318c55892164d72befeca1af24f125cbf4e334d7f5abcde63a36288128f965af9de57a4c5b58e3b88c13b9a5c14b6448269891792e9a3d088dd31541372075266b76d1394ac7695677dd8f83ba69f7802676a638b9a586d92193212ca9acc78ec9e3c3f5ad9ffb5d37442c21fce1c4c6d7cf82f6dda2953c3767a2f77acdede9412e33b49cf048cb3e045cefc75fb1f60701aca7a92b1e8a7e549af77f304c31614c939165d5a20253529a313451f85bce1caf1565aa86abd63fd3de14b2e781cb21785f940b7649224638b7041e09b668e1de0084e3c07c89ceb2ffde830901a442e9b7c6d0a6ab9ce8bd5fcca4a89f12528e32ba9ade7c935263732ce638c2d237999f0c89400f57f57abf747c2fceb5666944945f66d9633d92f609760232476084f9c53d4874162bf39ff2bccadcc8a13c15de4455ed8d9ca4666aa6534c501574331114e903760c9ec0d3610b5400107a219f927a0a6dbdbfc162fd001fec9433bb62b1912031536f9b41f71b2c48e2d2f51a0f814ffd51326ccdb3d4c396aea729d6d8d862734b38838fd1f946564a3645d1f873db475e23d6b0beda09141afdfdf81d609e6f5b5442043d942a9ecb2c2215d77165d24bc9942c2c5347c03b4d718a307f4e351c6b543c4c1dca3682646fca68ed0b3c162bebe4a76c95753d25923030da039e54382243d2d44a5f0a955133e6aaa699810fa50191331eec8fefed3adbc5c81c663eb9aa76a11515d40f871060486eb24e09f911407201ad26893543009e50830adfa6729a5f6fc7d9655c1b693785f53d85463b3759b0536ea10505dd008d1e7bd4f6c1fcd0c8489779848e2f21d1b61646105629c129d6b08aad3ed5ce157a61703f8cfc6707d04b29f5e1a6846a19c013fbd0e85dad3138fdffdf200468afabf7cd873e9152fbed40bd521fa9234a9cbd1a7ac27df11619f6b92cd13824f9e3cb69db102bd9cbfcc1f9ca20bfaa2ffe90c2aba7a0fbb98f2ed949eb7e671b802e938aa772938aa228097d27611bf3b26a22b8769990c9f2673590c972cf9d0837008cd5ba2fda830518191414d2858a1e5884159c8bb7d70839ebe4d354825e7e34cae380b37f345e2962698e0cec4747256496096fb7af9b50cfce44f8d839e03574e6805a2985690272c90045afa9c1ba47270396d9f0e5f01211fc421287e40baffd3ce2b4077cad34df6a56f8b66a8b56534fa903ff4a26830e597d9eea8398c80a07e4616bfbf15ce0db2c0e002d5cd9f1bc6e9bc382b940ac275fbd8f9689e200883ee58c73a3186b7f8c255f21d51ffc06beb4e5c2c3d4a89895464212caba44756b584a960ea9e09b197e52585fb501e3108c6b400166ad7d0bd616235efc8ded620979e7b22fe9db8acbc72d5fd5e739adff7517c2c5db09e9ac5a080cb1c0bd31304703cd115e99da7e35224a20b917738597c20b98738086de9745103fbe2d348ee25768318b06a5d835f48d3850d122c719d07ceacf20f2e79c86b395d86915eeb2a126e13d756e5fee4cc2da429638190efc76d418affa3ba57ec7ff83785a34d290feab740c23932c5d95e8be39b07f9c4499cdca4e05511e4854077f92b94a307a25ae9209f1a783964de8ab624b3ce489811ca1a3cca26515cc161e930e417e15637bf92c923ff30ad4ebcbfd68f11e33fcb4a4e1943596a35acc2d9521fe9df732a050c7e8ae47088fdbe2192bfc613d4802672b55ad9bb08aa0bb0af7112ddae5ee42de8d5787077c19c106468ce7058b666a81c6ca6c692f59787b563b3e3dde179bb2e16dc741bad8e48eba839be454144421458b2307d59d6aa21124f7475a0dc3289c0dd688e13ff81b69d07c3b53db7c6fd5f7e41163f915260e8c4b0907157e793565c29824238eae89e9c3fd43e792ff880527889c0780e3475d96af3be3ffc15570d565e90ef34bc067dd513fc88e40696f30e098aed939efb749eabdfaf08143cf8ef50d7fe60a337aea1274cc305c274422db498e698679283f7689cb7b9e39d26cbdb26612f1ac55bb84076459a1a38e3f62cf5120fb7485d4e73d8050a374a1d9b500196b6aeed24a49e9d191c22650962fcb56cc000f0c0fc29ac7ec565624400df73403cd6f837c78c53ed6e59d312a7e73e67cba7276244d6056e6f26ce5d9264e787841e92899a4b1359cf099fe0a9318394e7b979c62fdd2d3d8fdc5576a21d39472f9a2c9cc993af12d014508a3bfbbfb78dadae5ebcd6c694a62f968e0c97f70da39e6a0fbbee2fd5573671db1734ff4e23f8e861fb8e77d839edcac26f1775c965c3d07056f2de0356b3d7094f4dcff81bd1ed34628d6fe807649729b358ecc8cf0d1ef58155473723cd2a24a9d523801782c38c433f092e4707980be00dbc4ac004a8bae2ebfc06d2b53a841ce56691099bfeaa2e83238b1a19baf7a560fc314ed22243864a4a94b96c63f4aa1e0052e9a3d7cff150b4c6103f54f62cdfa06219196c7c478ea41ac4b6f22eadda03773ac0b52433aedd069f14f9c1424e471d1813c67fa6f418e8ec1bc6bbe2c81ae57325ebb06783bac4a83d9e12da91e3866be5bc47f3d2685c8191e2931567dbe8c43c5f4781267dddb9479b4d999231f9fc8848aa07b2669d9b1bc2ce59717079aded778efe6f8465791bdc7aca2eeae9aa3cd78d4188e25dade5fedc661f71a6ca43cf6a8b0845af6e77c5fd4ce217a36574e7fe5c343f0c08877bd5cc153c5d237f993baa0440bc4a5700598087e7b9c8b220c223d9ba0549abb6326d0efa900e72fd1fce4002a78ab0bae0118cbab30bafc85ddb3b05e9a891706b71b7cefc5d370ac47da8c3c9737ae9f33aab5979b922cbe7162b5ab77aeca18ae5c2b5c766ccd6f4469ad19ea67552a687d15f98983b366ed22e1d4f85ab3d57d01fb489b2e74330f2fab4a142658698696b76c680ba31ac3ad23af9ad0a81131822ff2c539fb00073361914a021ab8ec64b266895babb71725a2bf734b071646052c637304ab6364e5cefb4aed8c37277fade3d45457c9a5b6a5f89ea28f0688e83e10aaa9d1e3c592841f3ea37fb29356de60251d7fa5ea6e09079b8c960ed3ef42609291e159f3f30e4b1f91d5af765d27b2358b3f16e39c465ea8788a5af1b792b4b62aa84a1d69bfa9e51983524642fb9381d8322b08343d1b83f896bc74693d52786eb3f88bcee50f4591a2c70191dabb09235803077ca8df26c9d88c7b875cf3e0069196ac81fb845b6838201c2cd0ad9d4b0b42aff7ea4c1174a1f85718b1b60a7a90d09522891d8ae2c98939775df59ad6c77ca2b46e33552597e681c633ff60da850fcb0adf224430e51035c2eb4495a965192f0f98401a3864bc04f68927488dcb06deb4ec26f3a80034d072ddd994d58726fe5033ef08c18299648d6b995efbbb16ee9dbd48d6ded52c87e91329c05524f3d548f3d362af0202c575018dfdf884af709acbea9289b4615d108ce76480f8f06badeca35791f2077c08b554bd401ed7e5f2f19dc6ec2ebdbbcf88a896c8f53f333f0b6cd51c6f7c593290705dd5e90aecdb3ab8873bd667cadaee80100d2d6b4706017d0e41164bc04582a1d5786a720168766d5380e8c50d0f2f532f562ccecf3f0ab1d1499b484a7bff390424e8f5b993ef53a9e46d56e364f263fcdb67ec1e5b85765368f7b749ee152523f512eef3ab14d5544641ef0c71086802e8f4dd1a0104e2b9fb001fb5a8f9bf7fc75359e3693beb87816a948fcace812e26193bf4aa6ec72d14160c75a9e39dcca5c8c417c302ed3ecbbb18720dc8af826a087549a6210b38d5f2cc9eb9d9580847fea35a862da63deacb5f08d4a6484fc13d730e58eae4ce73802b3aa46d1e1167d566819ef63eec09b0609b67e2d7a6372d6d250fa3770cba245f2722aa4e4b2540da82cec21c4b15a3d7ed8bc40dc142c5c0375bd69522f515ee37d4a9dc746d5beccbcbf2e247efebd6b87f8c0ebd9f8c379ee49acd6c50889f85e86142e0ea2f248df9b6f4e90502959a363666494475ac74b95b9b7af1b9e741843cd0a59b9d5d02d4ef372e0ab97cfdc681b39d52c3a227c0a1b04abd76da8584d14c0c8ea51ea928b8fab9d889fe95feca3228e109ae46767ddd47975a8dca83c222d253e920e4516effb7e487aa030375a0cc86fbe9ff8fc0ad759102890b4ce2754a554ef3001cc0627d62c297f508a65aa279d9b3168a6f0aba7d886feb297313dcfc1bc35775c7044f8f1a95790d2c798aff6b4aa6b4a3244dfc3d0e1adfad63b8f74713146f85c7defa8ad0ce2aeaffa3808457ba1adcb2f2afdbf7dff631aece633476965b3f3c8376010f8f4fe472408cf667bceaac50c9e87b5173f276b6333c85f4ec8b9df8adfb1ef41da80b59b02dde6d72a420c57b9a6338a46a52e846bba04e4e3f8f12d2ee4886905d2b6c05b3004da3ec3624c6d450da1b08b94e00a99b61776d72f7847437dbdf8c3cd3783bdab87390b6ee4f2ec20aa9700390701932171ea3d4b1715f29d2fb78448f0b406392c9148aacdc84471ecb5eda6c9bbd8510b61b089e7594a3ea381bfc23e1e298aee3ca513d527d86242a8107f0aabdfa655f4647290765fd4121af40928e579375ee62cf2697dad032e5304d686c225e3ede6df6deb9de366a9b89bc421a6542a35dfa51c3abad47c2e6bc4648b29f6c4d8cd89dc36cd607c95ad48180acaa23c0f2da40d53efb13932ed37571087228fa97f37ba182db6ce7d89a80edcc451530a2d04127fdad309006dd1d87480ed7eab570d94658a13fb0bdbd5583cba357a1ab7a3188b583cca0872bfaf26e6b3fb7f18ae5b80180a89440a60edf08695047596c3c7613eba7c1ef9686c3c70c045a9ac760ee5d78a5083eff070dd218ad23a9c0042693a51374e7b1a5ee691369be0ad87d10bd7a88704d113b706c521c0b1a4b5f8babb041ead94efd91c630d73999ddc7ada70a5315c144c1cdc258d7a9994a4463ba4b999e628b0c8cca01cf9c3ae1495c1590eea37d70533567e15ed97960f8b0911bb2a460095eabdcc7e626b53a3db08e16fd450177d0a0378a5190355f11f9f360157f2b742bc0fbf05be0bd9786fee453b29f9aeba723d5b55784fd308379b2795561221a4c134e9041307eb0f75efe8ff126127afdda24e8199fcc9030c16abf11091a809423d69ec901f8db2070474bcf1199c1bc16422074d9ad6fd6f5bdcad2bbd857bbf32abc01a122fca94eabb773097f360131a3165b965d539d27b2dc029382dce0e3ecd3c24a6e827eafa1d3e67d8a1d55991907655d3e7b44f9143066e13cef117a237f236af3fb71eac341f3598aadb50824537f37d67af1ffbaac7a025b912aa40f89add04ffc47224498a58dce58a7df835115e196fef271bbc77da96a5f74c1e97b63c5bdc188f13f29e2643b919f3bb84c9c3ed788ce06349f3e35d4ee18e21d5b6f4ca3cae53fda93b752dc60095ac566dac9931d14ca26932484cc3cf5d47c97ed6dd56f20c78f6900e8f856f55fc5d7f95d056f0320094a0fc3d5955f64846b63471eff9e7dbeefbe425961fd59b51700b1982b76aa6521eac16b795a7efe8a8f595a17515e3e5c8a5eba86210e6fc8a1bf0eea4d891f74d51b58798897019976a6d5522fc8ed3f9862811d9fbcc28a6f4290cb8506b98c39cf68ad9807439ff5334e9380c5f96c0e72812b3b017d132293db96df8c56b1a7a130805d329241a4bb94b5e228e19baf91f2a60705bb9e82989671873589357daf7c8884cc98c036ab5e326c9b8b91d55f6f066c0eb7d25fc63aff028cb16b32a98fc32fe9b3009d9b870b38324588c3599c8b91dfd2caee0249a51a8a4c4d3e56127e1f5a7308fc639c6ab579401d90c387a0b00b2fb0c4c8fb1a06563ef66e667830427974b4363d1c291abf8b926085107c47cf3346adfda19433050ba174540bfad551fb36513f3e3ea30bd2ae616a57dd2433b154e3317e1a2f51b57f71d34fd227035654c866ce20759b8d8f281b07d340810472df5411488d77488aaff2816a8b23cb6a7e2d3bc8295dd13c65a527fe1e2aee04aca0d6d6f4eb0fddb56411f494421fcc3f347cdb4c72be602312da9b2aa47016216eda99b2b1a25356476d2f985344019e530d122de4d18b703e323ed9b7de30140f4e74d5b7568c70ca4dd77302e2f50e31e538100ff9c4a2da6394c2915275ca11adc8911dc00544de525a31206ad90b99dce3ba18d7751b3903a57eb71d217dffa4233816b62048deace3afed4609daa17953628cccebfbbd76c831b5a3620762d8eae20bfec4a3f827df8c464f19386d00e2b77080bca029241738d46cf6ca3af401dfa9edf78361d2f1caa4701f8a7554e1557b3e1329616dd09fe5738e5b753714c42de2b23a18aba3399ad2550adaeef924f8bce4091b234167fb102517c9e21f3e12c0f97d44964571322a9cd5de468504c0b253178881538a41c76554c20fe44fefa2ce2d46eaf867cdac07761dc5cb68c5eb534898aae1318b5a01421266a58a7e07d18573723dabc6d87588858663c0d7dd81f832d3545c9aaab93cc2da71cc8d9712cb38de239c1a612d4d4c350cae06eb9e0fd79404832edee5cefa02bfbc00b89cecaae54fbcf0505aa83e2a0c6a0c463073dda0f150384eff6a3643a40ded5274eb657ff0e17f062a09a1656039ea4530f578e673d16d7082332795e9b94025e89828fdad884fb2a60db6185dc077128255599c1419181e25dc93bbda89758692ec26b263dd2253e85f3370128d130a6d4a58ce65f0ce4d1f263189fdffe24573f4c8822874814297e81fb2ef484f938e10169c4c737d6bde30dcb40768eecfc4cbe57dbaa423b17012663e2512407d8d1629b481803de82382a71314635aec8320458199416618963b643f196d3677d4ef3e2c8329e355c13aa9360914a8a032fd74b177fd3cd51742176e7b1cee8dd470e754c9d6fa07924d39ba118ded2eef9eeb91ff2a568e8c7e65420f0b7fdca25b61eeba840031990ca1d6b55233b3f1ebd47f385bb3db8320be0c06ef9ffe97f0b41547a457e46963780dc4f701c674939ec65e3cdcde9fa977a8d638fba51d3ef6cdeddc1013d21549d5508701d58ba3dea194e141a89ec6df7e5f9f425d79930a77c6d6cd5ea55e93288f56883725fd8ee7e9ba9ada4a592aa01358408e94be38c47fedbd68a92e8ac50d3fa82bcb5b771de40a5e9586e85dd33f6f1fe1772a555286208b5c041e68f8aed33b9d2c552c00cb5ecc822d9e585ad515</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>私人笔记</tag>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nmap应用大全</title>
    <link href="/my_world/content/nmap%E5%BA%94%E7%94%A8%E5%A4%A7%E5%85%A8/"/>
    <url>/my_world/content/nmap%E5%BA%94%E7%94%A8%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4cf325c754bc5da03980579eed84bd927fccc4621baa21dae7f739850439219b">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc9afd5a628343fa4fed0ec5447d920b24c089c24d49fa889c20d3737dedec8bb922d581019a8312e97c11bd5658a5b6b5a5c157adf205bdde33d53a02305f4bef308f60fafd3d6c24c5d43bd6f15a9005cae3070a9b618cdfe6d3b326ba39528681f35a271148eca8c24d5e6108c65fa3dbc3a2dd73bfcb67b1af4ea9fe955b73b0e9954ca409940c14172af55442ad6ea1f9d30bb581acfc0d891dbded1aa07738b16cbbdb4408fb7c467b8a2ad0486cc8b0c1657fe6606ae42a016cca0f5ca4c555029cbd1953b5f55686ac916868a24007f21d779f36530794567a781b0be659ab57a8b90c0e2de04b4221cb6151ac8137a4362eb787ce0c2c56a9f90401fa2b64e12362a403f34040450e3b3e3222ccd29c078012ae2f31f432205113da4e02fdb3152d3facbbf7564fd0f67e319adac4e7886ba1fca88a0d4237c760d85c1ce680798b245463e07fdf26fb8cbed6f1f010167d6ddc9c93977e6e8f10995ee52c4dce5f3940516cad04b2ff86e0b3af5a482f7d6d36cd88a1e3f356d38055b3b7b64361551fc519c1c55263a171fdde20f136fa3a9bef039bdd4b2028b95efb39d953e457a586767a9becdda9200a3afff58d9d7a84cd1d1cc91dbf050b8ccd5421cd571e1242ab77eac8150c16f902e9250d50ff76b6d3cae44998bb59b8f3bc75175c388c449de8e33fb6b70072da47831c7349c245d60564feba90176e3f64c9fa06f18e5d8efbf63040f68b6dffafa98ee332f708463be0594e743c9d28bd5fe98cafcb087ab4b29af22206d08bed9159f1fe3efd0272b40e35aef39ba16f20c41abacaf057c991bf4807107e5980fcec356e0c8776b0bf93152b3920dbbca9266e87af98468d4b7c587e1be025c63bdaeecdb18742dd4a648ca9df65ee7496d4a0d1242a8fde3f7045a056e6eb78cddb620f182fa7d16326dcf94d6ecee9d95b4fb2bd8ef10ca1fe675a2acede8e27a8e1b6c56ccb21fe9b1894c088c63a87a8ddb72062fff45b1fd53be018b24a142c2419f5775c66a6aead35af439c08b83e7dd7937303f7a5716cdb7c5391f1a7dffb016ae54b332cedb25a924e4fbcc8cd63fbee360c43736b9e830da37cd63bd8dc4ddcb4e58cc0f552898ab6d586ac42c753a5ef42b07d4b3d1691180a73e7276b22f7c4d0d9a8ed89e3e584882db072789187838f00bfb11768e181a65e7428641611962a599f39c24a7f6f654d053272de18e282e0cb91938f9fff64d734ef69deab6001dc1f02b57a43028324fc36a9829e6dc40e1a34c9fba9abf12743db6c8a868f78d7aadd7829c4ad7a7c1267f35cbc0b59cf3e74d61afe614df03c905aca098648033cb7c0aab2d93772367f8cea7356b3b984ad4afd1a2ab2b5dfe8490789fb8ddad22b52ded7164fb54055307ccecdbe1c5339f114584e2ea70a9c90ed8c06f10aaebb73042a1188a34e4044aa597651917e91bd8684bcf6951f7683ff0f0fda7e3259b77fc96ac245efdea38ac1ee795a6cdd268acea2a04ab72120d453c5d2e4fe258710feae99f06b4f080c5a5f230510c6d06f3c3a41a6c47b132b6c6a7e7d5f57d5ac60d37933d2502b3fd6fefd3158a283268ecf719740e1527f3ab76803ac891ee6ded2aa8af45e77684013a427477bb91086f051ff8baa1c0d5a330f93e93916f1c8e3b338c17bd991588f90765a0c20289cee01cab555d24e8d41a344991f39c08eb0f985fae7ecff0409b4a47c460efcd733514d56df810af7a968e18a020fed43f706ef4111eb12575cd7967526434dac8e1cff9645f1e9ae14e431739a5c2dab5880449c9ebf36f1990864ee77e92ac05d28118b755fecbe97d69a402c655b43d864ba6249eaccf6fc012733074d325eb4fd8889ac444fd2c7861a5fe4f658229ca419f74d6d03157f2a687d28166b63ca905c646b4592c549aed84ef61d7ad1c19f74f5b7c4aecc3097b8ffce0f42bc367d33051ed6f602864a3a326f882422c1cd87b34d042eea718c7eea48a7123ac60e0b1c6747004fdf55ba3481f8f0113f3865096d048b2cd7201145d0bc2249dea74d137ba80a1483f322a59370f55060496e8219b1943d3022f98f999fbeb754fcbd00344e11344749b75d67a5116fff329a0147911e6d9f97b41d8f47a72309a41a28f5d9fe6c305985a9d447f610452b4fac82150d50171da05efcbf8f0ff40c454c235882096cbfa9bf051a8c4379f18da8c6845856a49d2782856361583c675d11dbf1e73443a4804cb34450ec67dd455c3663c263512f5bf73d9cad9e9743da1e3edaea6a332872266c8d13735b1f99326da9053bde5d122a2d63264de7606c2cf4cddf600f2b77756bf87eaeaa42906036c74d21fdbc000125bbcf11214e4fcf463502fc8d624e8d869beb634d85b671ceec805c839a70d0fe16167b663d2d5c54e630df95eb67d672c4acc940e7475d86640724536a1c842136c1f5bfdd96351528e3400ca521364d981a9a9d4b6be9f7879d01f0c486fc7f2a716e3920dbb1154a4a8dceae610c7d47be2c16733430e3e957b798cee5196676e5cad047ffa5bacf27dc19579cdafb35500f26eafaaa2609dfed0c35e737a9d52705d7ebdcd10f99268a37253af3616b7f9633f5b2746e753f3c6d6c1b453cc8498cdd915fa9b08c49d266ec25ea787c6b59263232d8503e2a2708951caff69817d5c94cbb6c16521f60321f2189e72212f57e9f6343c9aa7d8acca4f3161f3396c9d933850fe041a787437c5f89db9bd4e66983440dcba64d861709221311319dfb19fe2bf0c85560c67acb8e0eeb9bc870ca13d05394b50364741cd6a4eff616cb396c811b83f720a77429e545a4d9da6df6364aa3758a9bbb2bd9a7848b43994c8ab3e35255c33ce047b197bb7308cbe95609f59bebde69aff06adde1e4d1e5c91eafbc00647bdab214aeb9b7e4aebfb3b1d8b911cfb629f85693478aabf8eafb084864404d6357bd41b5abb14d910c3eb27ed84772e54cb3b493ac71b4d4be65e9436bded1eb6858c545983b8d36999f6cbc56b9fc536b85c6ef0f922358bb65f48f55bbd55bf4477c5056ded1727bffe567a5e3e6db8681043dfcb5f2e7fe6499ddbecd6344af71764e37b189838b984c888babeab1e2eb7f48fc79e24be763b5d9fe18764849982f19393a22408fa446b910e3dc63952b9039b50ac4dfa3bd0bf5362879b01a543d3c268373de8cd57ccf0d7eefd79ef18e341501a6c0391a0f2b953d3f1cf9d6003340299fbd74a646276353ef9b4123bea43774fcbe3239b22e5f085914c7b6183a9ebf29806e68da5b0b029d1782706dd3a739ec5e6ef4a2a27a2998330702b48fd83f8c85d8beb071750a5431c4e2da7558f63ebbc024e35fa06e610f5d2f0d33cb71d390eff84f41fff529fe22222ac0abdda78ee1f41f870dd5a078a66fd7f4f340778b73bb592c00da4396b459a7bbc19978407413b00b473b031c2aa458057fd0e795740823c3d10e866408b402e8ee1146fb062102967fff1a81bce61610e7208d5162f10d9ecb6215ae49425dd1c63f55b0a3a9d39acf5f875a20a1e230f69f648ef91339465c729842d4745462d1117cc43f39d32bc28176433b1fffe35358b78b5eceea0c80ef87a3c386b9c28b38960f9eda1141651a332ed21f4ea154df43deaf7d827acb22c59096e43cca42d99326ad25dcde504de71c039c2fc066500f2af8be0609bc394861179d3041a04b7545f5de7f085b2eab4da201a734679fbeafb6a245293d9a3b5a03b92ce478f9bb73a120d3b52793ec61475d7f90a62f34a3a4de808a473213eaee873b9bed51908d07966d0c0a6df4bd340d1a4924a5ff9a1b7fd643323bc6f265d87f966c953681b679d858dc7335f0154c7f7a192ace7b0aa4d5ebfb010f1266bbce75230409e1d26048da0a7bc910f92712c6bb641bac4e060354e13bd281a01b3c97681b827160860955742c339df53a62770375b01d6437403ba49b1170ba1232a2f0e14881909a16fda9bf27c455834753beebe4af67b4067fcdbe1a22d5abe8f5e2cd4fde1520fb0bcf0ced96e61a143f687c048261e209402bfb3e9451648514baf1279b0ea110563aa6b719f907cd06e344c8db89d27239dfa22793b99109f99a44d757cb5bb964cdc0f9dd93fc65f2d3d9d91228eee3ab7f0c88ac671eb27d85106c191db620cea175efb96cd8d24b6fba14d698d7dcdbdbae84760bcad9151beba532c16cb18702a3cd7f43281844af74be4203d0cd70e325e03a022692c3f930547805b446bd67aeb9adfb2f4a8d800404e87286bec2fd88a7ea7861213cceca2aa76401756e2daed2eaa32b98c5c306ad2b0f5c535d14175eeedf69a89dee1f842f7198a648cbba30279831fb0c35d062c7f6a315cfeceae722626709d94a3e7a279a457690e6b564aa594d16865c995ce511fe9af8371f64bae4f963c5d53a4a6593967e43959b6e8d675eb058427c6e1fe823133993b1b30f62617c5ef956c39afb4d9659a50785490f9867d0b694573d4a1cb342b5d312edee5988e1888545ebb0ef38b20387743513c0e4240933989836babdbbbac86d4e73ea53de4b741d20859877d50d875aba51bbf9be80dac84920138b1e03d1b1a04935509dc7c553c204bf19eebdf61eddc11ed1960cd2af8b680775ed40785355dec2cfccae2dea135357d850bdb81492d3d065c4e73ea9b7282e1ffd898b562cfb2647871c0abd38ab4fa4dcde51afbc995a6b2e9a0f742e2c85312b44acb671e6d83bda81795b6750571a1e1b0cff40a78ab699b0b17e8b6851f67716d5b62ca2728b862053b476e2f6c48bc2aa92a19ea52d440c5506d287b021feecb8f1bbbb3172563a96c3f345b9c30d45eec92493a3a557b0b8624221e97a1b7042f5955fecc55454d7190a5cfd7dfc64cd081fe89e913c84178a567c0b86f8d9077264654880cac4bef6abe2916db776f331bee3027acc81a3dfe65fd10ceaaea463147088c8f54e374b1f72caaca750e4f881bb487177f0e234685dfef7b5c91464a981fd96de3a16d9be5104ecf4d00054c014be9e9ebef801a92ff17e832d05f695869921ea302f2dbf2863e163dfc6795e7509fd5e079baf6dec732ff81fe1c52af058b1d7e64ceee76b79cfe98f7302d3144e9057f8654b20b9b2567fda8076a866d97ce756f966226f925da1b9ce713e94bddd187695b417834709eda0cd5d1467ec3eb8f50a018753d2392816b174108e1f4d074dd230fb3abe386b7997baa6bcccdb6bf02f12982d4dc4d89999ef56dc8367a1aac2e6fb596e6ac5bf3d13e0018558da35d620b95a11cef3c18031052f9f55ca212cd503d203fcee958d6d23192987e5573e1779c9b8a592e14aa746226370463204879d4e1b6e52af25cd280016ad4f2e756347c862ecf3ee48fb1a970a5d319b83f074a21ed2666ead80bdc7731758aa32865aac129bdb6bdf23b10fb8c6b4ef19e43de9e3faa223ed74625a4a22e6a7acd963c0a6527b785f8e4dd49481f6176c6701dc5d8bc84d98ff1f9ab92b5b6b15f42a8910c330f5087fa23eae839652da136d2db2df28ac576f1fd1159d777c471d797d187886d8d657cda5d96579cf0e902ce5051aecdee909b32ba84e74d99d0cd689dce8e04abdbb1e33b433631f68c40b09ec23ace101463b8f8c03ae2264b8011705ef5fcbbdf34ae052062de4e9491ca9028225ebb3984fbfa7058f2f65b2cc5d36e6ac140234d60221a925b24e09e557d07f7e10f622a90c61b4b626551174b9a2acd4d6dbcf7add348489d2e57c99e04f0099204d4d5ed94df6932a1f370bb515b765b9892acc20988e55acf6b9c82877953cb2f212ea59302133e5e026902bb0b46fef9d60bc630d1df8a6f3c949ee9505d0174973b5ff320d91fde1ca2a8f401cae8ab4495df79fa495cbdd90efa32039f207204d06f6ab39dd372f5be58629d8353c120806ac45642c2b6d31e637d58e0a9eca3ee0b3d8303cc5f8a28708a08128d2bf209cd5d35735e1cf457119b53747170c3e93789c9653484afabdad896b118f43926747e2b34c837039c7b7568fc1893a6856f72ebb82e07bd232b96a4d348572bfbde20268228aacd1f68e5dc785aabadc3496798ea1935ecc9b5681f490e7a1b4ebaf756e80c925222792cd014410a5e0a90154fe3d0a132de945c39932af5f59466bd00ecd0cc6212e23461181bd0b49ea5ad47e14b7ff111a4e5268625d3d1c2c34372f41c9074a75db9a60458bd099f0a9c325bbd5c98d108582b91496396a3c17419d4e6ca07e9427b336bdc7df3352c01eb385849570fa71174e0a399cb986c7cdb5fcfa3517c7b749a55f61ae325f04fdfebb7bc0c779df1a412de6cab12ab94989ae28727237ddecdb73cd3de31615eb99fb194679b8167447fb96f2387f0be3bf2e87263a239a447dbb1405cb01aac58761b4edbde350ee104551f230c304fca577ae83a064d05d790daad01d019e0055846877648fa4ecc1e51aeef438bcf41160dfe4996c75cde8558b6b0f6ee2455b53eb162446989f65f125cc41ae49f1955ad1e067b57095d4848382065166b428d09b12d55f2a6eb3da670e7e35c5d00d70d08daf2921ac862d5b9ff3451880385d0a7de5599792699c198ac00e57b4613c156b329d85f20c287a9a3bbeeb7d7f0682fba3059ffe8ee51916e23d4d90111de0d745466ed50b3bf635158476cb8a58659c8780c678107a2fbd93b663bac3250755e63cd2db2988a3dfd3a3c63d721ea4a1076c5e70c15d33c2618c5b2c2348c06ddde06c570c1a2ab1c079c5227d9798c33857ce0b6bd82e190fd398e927221ea1e436b0d376971e9c1be0025af5f2e71ac77963c4283ee75ac3c57dec7bb72fd20d84cbf548f7736454fc2d2b2d05e269296de9c648674e714b41d7eb9c50b7dc5b0dd000066c83b8df8fb1975a47d7fa9dd99e4f210211c2f3c8c32f61aee9765b450fcf4d5281baead8b0b18c207bb2332d7050bb3159cea43a01f77fa73d25ea707e92f2e8b387e9981fa763a5a17e350bce6693bbcf19751c0e69124e8bdd54d4fa53c7a26c5d019f0e15de1fb0d67912a8077e5ffd794ccb7489a37475bbf04de806f42700af98a61ab4000e57b3512337d16b343826f5a40229a55770b612910a01a2b75e97612fad9058460086b727bb647f35c5e3cc801c4d604f34eca6baef91cc42fcbd3f42776337f52ef6aa66318ddf6d5b275b604c93f65a2d757ce711eff98a21f386657f1ef7230b281d6b39233d33a5573db8c179259c0781f813af7506e31f0de3edafbe13d1bb85dcf29a7f7d57f1db67e0c9aa30863af29920f770a981118dafcc30707b092c8593f57264587b78b1767f8633b898a53f8d09c0946cf93f082a71501d11b1fae81f795ec807b3c7830fffde0864d75e548b7b1174ca08d235c9cde075fe2273022ab559b10698053b6e122c7edf89ccfc98fd086e3a6c6e83a466f52213324bd940155ca5a6f63368a37af3da24eb763b461c9ce898504818f8b2fd38179eecb27fc79868f6516515458949026558ac7b217978c0a8fd7b1c345222f2a5c574dd674f32a2d597b64c6441d935bab60dd5734aaf7110c6e045545452715192fa346c25c0970b562766d3fc9cbc4b2c9828dd65d0f921886d5c0bad752158a20f5e7bace3e2d2c552730672884dfff2bb16e464d0b1d59cad22611097044be4c956cdfe50eafc9ec23211fb141ac06de3d079541e219020eb55d5ba0c7b94251e0cba92331ceb9a6c6ef6681c222d844580a9b72cc5db4878016b6ea26931d6d02f9d2eba2a61acab62de3a389212252626b134f70c6e593298dcdba7cc5dc160fd9c894c8b034e6ccd714fb7a40d2715db0de1fbd5d2edc5a34dcee10c525894b7dac42e4d803e782dd7f79d8ee1bddeb570dbeb218932edbf230bd27c8ca95ff78826aec3b02783b3c15aa6a27b6c157bca5baf8f69365173e07d46d86b645b2ceead01a546c546bd4501c53d1c8a3a9c513fec3620433b57763b7aabc7ef449f35fcd20dac7282587d011519208617daecc60356c1392f83af50f98e6495c24083fb8c869e12860b45c7b0042c1c8164ddaa41106b578fb4f62458e97b09d4c91d9a15248255e8df77a3d0b8164a5fbd57c6e09e2e2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>私人笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机语言注释规范</title>
    <link href="/my_world/content/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"/>
    <url>/my_world/content/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>程序中的注释能够帮助理解程序。</p><p>注释编写注意事项：</p><ul><li>为了提高可读性, 注释应该至少离开代码2个空格.</li><li>不要描述代码. 阅读代码的人只是不知道你的代码要做什么.</li><li>注释不能太多，注释会影响程序的可读性。 通常一两句话能把情况说清楚即可</li><li>在代码的关键部分(或比较复杂的地方)，能写注释的要尽量写注释。</li><li>比较重要的注释段, 使用多个等号隔开, 可以更加醒目, 突出重要性</li></ul><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>描述某个变量的作用</p><p>第一种写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注释</span><span class="hljs-keyword">int</span> ui = <span class="hljs-number">1</span>;</code></pre></div><p>第二种写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> ui = <span class="hljs-number">1</span>; <span class="hljs-comment">// 注释</span></code></pre></div><p>突出某段代码的重要性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ==============</span><span class="hljs-comment">// 请勿删除该代码</span><span class="hljs-comment">// ==============</span><span class="hljs-keyword">int</span> ui = <span class="hljs-number">1</span>;</code></pre></div><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>标准格式如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 类的用途</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 作者</span><span class="hljs-comment"> */</span></code></pre></div><p>使用实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 类的用途</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 作者</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span>()</span>&#123;    &#125;</code></pre></div><h2 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h2><p>标准格式如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 方法的用处</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> parm01 形参的用处01</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> parm02 形参的用处02</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span> return01 返回的数据1.</span><span class="hljs-comment">*/</span></code></pre></div><p>使用实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 方法的用处</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> parm01 形参的用处01</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span> double 返回的数据1.</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">test1</span><span class="hljs-params">(string parm01)</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">double</span>;&#125;</code></pre></div><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="单行注释-1"><a href="#单行注释-1" class="headerlink" title="单行注释"></a>单行注释</h2><p>描述某个变量的作用</p><p>第一种写法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 注释</span>ui = <span class="hljs-number">1</span></code></pre></div><p>第二种写法：</p><div class="code-wrapper"><pre><code class="hljs python">ui = <span class="hljs-number">1</span> <span class="hljs-comment"># 注释</span></code></pre></div><p>突出某段代码的重要性</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># ==================</span><span class="hljs-comment"># 请勿删除该变量！！！！</span><span class="hljs-comment"># ==================</span>ui = <span class="hljs-number">1</span></code></pre></div><h2 id="类注释-1"><a href="#类注释-1" class="headerlink" title="类注释"></a>类注释</h2><p>标准格式如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">类用处</span><span class="hljs-string"></span><span class="hljs-string">@author: 作者</span><span class="hljs-string">@time: 编写时间</span><span class="hljs-string">&quot;&quot;&quot;</span></code></pre></div><p>使用实例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    类用处</span><span class="hljs-string">    </span><span class="hljs-string">    :author: 作者</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span></code></pre></div><h2 id="方法注释-1"><a href="#方法注释-1" class="headerlink" title="方法注释"></a>方法注释</h2><p>标准格式如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">方法的用处</span><span class="hljs-string"></span><span class="hljs-string">:param parm: 形参的用处</span><span class="hljs-string">:return: 返回的数据</span><span class="hljs-string">&quot;&quot;&quot;</span></code></pre></div><p>使用实例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self,parm01,parm02</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    方法的用处</span><span class="hljs-string">    </span><span class="hljs-string">    :param parm01: 形参的用处01</span><span class="hljs-string">    :param parm02: 形参的用处02</span><span class="hljs-string">    :return: 返回的数据</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注释规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot框架整合大全（一）</title>
    <link href="/my_world/content/springboot%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/my_world/content/springboot%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring翻译为中文是“春天”，的确，在某段时间内，它给Java开发人员带来过春天，但是随着项目规模的扩大，Spring需要配置的地方就越来越多，夸张点说，“配置两小时，Coding五分钟”。这种纷繁复杂的xml配置随着软件行业一步步地发展，必将逐步退出历史舞台。此时，springboot的出现改变了java的开发，从此变得便利。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><p>SpringBoot所具备的特征有：</p><ul><li><strong>可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；</strong></li><li><strong>内嵌Tomcat或Jetty等Servlet容器；</strong></li><li><strong>提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置；</strong></li><li><strong>尽可能自动配置Spring容器；</strong></li><li><strong>提供准备好的特性，如指标、健康检查和外部化配置；</strong></li><li><strong>绝对没有代码生成，不需要XML配置。</strong></li></ul><p>在过去，开发者要让一个Spring项目启动，往往需要配置很多的xml配置文件，但是在使用SpringBoot之后，开发人员无需写一行xml，就可以直接将整个项目启动，这种“零配置”的做法减轻了开发人员很多的工作量，可以让开发人员一心扑在业务逻辑的设计上，使项目的逻辑更加完善。</p><p>除此之外，其采用了JavaConfig的配置风格，导入组件的方式也由原来的直接配置改为@EnableXXXX，这种纯Java代码的配置和导入组件的方式，使代码看上去更加的优雅，所以SpringBoot如今受到大小公司和大多数程序员的青睐，不是没有原因的。</p><p>SpringBoot之所以可以做到简化配置文件直接启动，无外乎是其内部的两种设计策略：<strong>开箱即用和约定大于配置</strong>。</p><ul><li><p>开箱即用：<strong>在开发过程中，通过maven项目的pom文件中添加相关依赖包，然后通过相应的注解来代替繁琐的XML配置以管理对象的生命周期。</strong></p></li><li><p>约定大于配置：<strong>由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。</strong></p></li></ul><p>说明，以下操作都会在idea中运行</p><h1 id="springboot启动原理"><a href="#springboot启动原理" class="headerlink" title="springboot启动原理"></a>springboot启动原理</h1><blockquote><p>详细原理：<a href="https://www.jianshu.com/p/bbb2cbe2c49a">springboot原理(核心原理、启动流程、执行流程) - 简书 (jianshu.com)</a></p></blockquote><p>springboot是基于springmvc、spring容器和Mybatis的整合容器。</p><ol><li>初始化监听器，以及添加到SpringApplication的自定义监听器。</li><li>发布ApplicationStartedEvent事件，如果想监听ApplicationStartedEvent事件，你可以这样定义：public class ApplicationStartedListener implements ApplicationListener，然后通过SpringApplication.addListener(..)添加进去即可。</li><li>装配参数和环境，确定是web环境还是非web环境。</li><li>装配完环境后，就触发ApplicationEnvironmentPreparedEvent事件。</li><li>如果SpringApplication的showBanner属性被设置为true，则打印启动的Banner。</li><li>创建ApplicationContext，会根据是否是web环境，来决定创建什么类型的ApplicationContext。</li><li>装配Context的环境变量，注册Initializers、beanNameGenerator等。</li><li>发布ApplicationPreparedEvent事件。</li><li>注册springApplicationArguments、springBootBanner，加载资源等</li><li>遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</li><li>调用ApplicationContext的refresh()方法,装配context beanfactory等非常重要的核心组件。</li><li>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</li><li>发布ApplicationReadyEvent事件，启动完毕，表示服务已经可以开始正常提供服务了。通常我们这里会监听这个事件来打印一些监控性质的日志，表示应用正常启动了。</li></ol><p>SpringBoot会触发其他的一些事件，这些事件按下列顺序触发：</p><ul><li>ApplicationStartingEvent：项目刚启动时触发，此时除了注册监听器和初始器之外，其他所有处理都没有开始；</li><li>ApplicationEnvironmentPreparedEvent：上下文得到环境信息之后触发，此时上下文创建还没有创建；</li><li>ApplicationPreparedEvent：bean的定义信息加载完成之后触发，此时bean还没有初始化；</li><li>ApplicationReadyEvent：在所有bean初始化完毕，所有回调处理完成，系统准备处理服务请求时触发；</li><li>ApplicationFailedEvent：启动过程出现异常时候触发。</li></ul><p><img src="../../image/image-20220824110402477.png" alt="springboot容器启动流程"></p><h1 id="开箱即用-springboot项目搭建"><a href="#开箱即用-springboot项目搭建" class="headerlink" title="开箱即用-springboot项目搭建"></a>开箱即用-springboot项目搭建</h1><p>前面介绍了springboot的两种内部设计策略，想要真正体验到springboot的开箱即用，还在springboot的项目搭建上。</p><p>首先说明Springboot的各种版本：</p><ul><li><strong>CURRENT</strong>：最新版本（但不一定稳定）</li><li><strong>GA</strong>：General Availability,正式发布的版本，官方推荐使用该版本，国外很多项目都是使用GA来表示正式发布版本的</li><li><strong>SNAPSHOT</strong>：快照版，可以稳定使用，且该版本会一直进行小量的优化和改进</li><li><strong>PRE</strong>：预览版，主要是用来内部开发人员和测试人员测试使用，因此不建议使用</li><li><strong>RC</strong>：Release，该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。</li></ul><p>日常使用中通常选择<strong>GA</strong>版 ，版本稳定性排序为：<strong>PRE</strong> &lt; <strong>SNAPSHOT</strong> &lt; <strong>RC</strong> &lt; <strong>GA</strong></p><h2 id="start-spring-io"><a href="#start-spring-io" class="headerlink" title="start.spring.io"></a>start.spring.io</h2><p>进入快速创建SpringBoot项目的网址<a href="https://start.spring.io/">Spring Initializr</a>，选择项目的各大选项：</p><ul><li>Project：说明是什么类型的项目<ul><li>Maven Project：Maven项目（默认）</li><li>Gradle Project：Gradle项目</li></ul></li><li><p>Language：使用什么计算机语言开发</p><ul><li>Java（默认）</li><li>Kotlin</li><li>Groovy</li></ul></li><li><p>Spring Boot：选择Springboot版本（版本不一一列举出来）</p><ul><li>2.6.7（SNAPSHOT）（笔者选择这个）</li></ul></li><li><p>Project Metadata：项目的大致情况</p><ul><li>Group：开发团队，一般为com.xxxx</li><li>Artifact：项目名称</li><li>Name：项目名</li><li>Description：项目描述</li><li>Package name：项目的包名</li><li>Packaging：打包的类型<ul><li>Jar：普通的Jar包（默认）</li><li>War：网络War包</li></ul></li><li>Java：java版本（版本不一一列举出来）<ul><li>8（笔者选择）</li></ul></li></ul></li></ul><p>在完成项目填写后，点击GENERATE即可生成项目，浏览器会自动下载保存到本地</p><h2 id="Intellij-IDEA-Spring-Initializr"><a href="#Intellij-IDEA-Spring-Initializr" class="headerlink" title="Intellij IDEA Spring Initializr"></a>Intellij IDEA Spring Initializr</h2><p>日常使用idea的时候，使用Spring Initializr去创建项目会十分麻烦，这个时候可以在idea里面的Spring Initializr去创建springboot项目，idea会通过调用start.spring.io创建springboot的项目，十分方便。</p><p>打开File -&gt; New -&gt; Project，在New Project窗口中点击Spring Initializr，之后点击Next（若没有设置SDK，请设置IDEA的SDK，Choose starter service URL中选择Default即可）。</p><p>在Spring Initializr Project Settings的窗口的设置和在Spring Initializr网页中的设置是一模一样的，参数详情查看上一节即可。输入参数完毕后，点击Next，之后选择Web -&gt; springboot web即可。输入项目名称后，即可开始使用springboot项目。</p><p><img src="../../image/image-20220413102938600.png" alt="springboot web设置"></p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>在进行项目搭建后，文件大致结构如下：</p><ul><li>src：项目的主要文件<ul><li>main：放置java包的文件夹<ul><li>com.xxx：java包</li><li><strong>xxxxApplication.java</strong>：springboot启动类</li></ul></li><li>resources：资源文件<ul><li>static：存放静态文件（css、js等）</li><li>templates：存放html文件等</li><li><strong>application.properties</strong>：springboot的配置文件，可修改为yml</li></ul></li></ul></li><li>.gitignore：上传git需要忽略的文件</li><li><strong>pom.xml</strong>：maven的pom配置文件，用于加入新的第三方依赖</li></ul><p>值得注意的是，在html引入css、js文件夹时，只需要按照同级目录的方式引入即可，以bootstrap为例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span>/&gt;</span></code></pre></div><h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>首先删除一些无关紧要的文件，分别为.mvn、HELP.md、mvnw、mvnw.cmd，使项目保持整洁。该操作为可选操作。</p><p>打开src -&gt; main -&gt; java -&gt; com -&gt; 包名 -&gt; xxxApplication.java，可看到：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;</code></pre></div><p>这就是springboot的运行程序，点击run，可以看到整个项目开始运行，若看到<code>Started DemoApplication in 1.488 seconds (JVM running for 2.522)</code>为项目运行成功。查看<code>Tomcat started on port(s): 8080 (http) wih context path &#39;&#39;</code>为项目运行的端口号。至此，springboot搭建完成。</p><p><img src="../../image/image-20220413110227972.png" alt="运行console"></p><h1 id="spring-boot-starter"><a href="#spring-boot-starter" class="headerlink" title="spring-boot-starter"></a>spring-boot-starter</h1><p>SpringBoot的一大优势就是Starter，由于SpringBoot有很多开箱即用的Starter依赖，使得开发变得简单，不需要过多的关注框架的配置。</p><p>在日常开发中，我们也会自定义一些Starter，特别是现在微服务框架，我们一个项目分成了多个单体项目，而这些单体项目中会引用公司的一些组件，这个时候我们定义Starter，可以使这些单体项目快速搭起，我们只需要关注业务开发。</p><p>例如spring-boot中集成redis，只需要pom.xml中引入<code>spring-boot-starter-data-redis</code>，配置文件中加入<code>spring.redis.database</code>等几个关键配置项即可</p><p>常用的starter还有<code>spring-boot-starter-web</code>、<code>spring-boot-starter-test</code>、<code>spring-boot-starter-jdbc</code>。</p><h2 id="spring-boot-starter-web"><a href="#spring-boot-starter-web" class="headerlink" title="spring-boot-starter-web"></a>spring-boot-starter-web</h2><p>详细的pom.xml配置如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>点进去，可以看到：</p><p>spring-boot-starter，里面封装了：</p><ul><li>springboot（spring容器）</li><li>spring-boot-autoconfigure（springboot的自动装配）</li><li>spring-boot-starter-logging（springboot的日志）</li><li>jakarta.annotation-api</li><li>spring-core</li><li>snakeyaml（yml配置）</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>spring-boot-starter-json，封装了json相关的包</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>spring-boot-starter-tomcat，封装了tomcat相关的包</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>spring-web，封装了spring的bean相关内容</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>spring-webmvc，封装了springmvc的内容</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h1><p>修改application.properties为application.yml，理由如下：</p><ul><li>如果工程中同时存在application.properties文件和application.yml文件，yml文件会先加载</li><li><p>yml文件通过<code>：</code>来分层，结构上有比较明显的层次感</p></li><li><p>yml配置文件上比properties简洁</p></li></ul><h2 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h2><p>resources文件夹</p><h2 id="配置细节"><a href="#配置细节" class="headerlink" title="配置细节"></a>配置细节</h2><p>yml采用树状结构，结构如下</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span></code></pre></div><p>改配置将整个项目的端口改为了8081，以下是springboot的jdbc的yml配置</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-comment"># UTC： Coordinated Universal Time, 国际协调时间，也称世界标准时间。</span>    <span class="hljs-comment"># 设置国际标准时间能够保证mysql连接不会出现时区错误，并且保证编号为UTF-8</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&amp;serverTimezone=UTC</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">****</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">****</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>  <span class="hljs-attr">security:</span> <span class="hljs-comment"># 简单配置springboot-Security的验证登录密码和账号</span>    <span class="hljs-attr">user:</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">admin</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:/mapper/*Mapper.xml</span> <span class="hljs-comment"># mapper文件存放位置</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">smg.****.dao</span> <span class="hljs-comment"># mapper配置类存放包</span></code></pre></div><p>里面的参数详细会在以下章节有解释，只是展示Yml是如何配置的</p><h1 id="Controller-控制器-的使用"><a href="#Controller-控制器-的使用" class="headerlink" title="Controller(控制器)的使用"></a>Controller(控制器)的使用</h1><p>在使用controller前，必须要引入<code>spring-boot-starter-web</code>这个包</p><h2 id="新建Controller"><a href="#新建Controller" class="headerlink" title="新建Controller"></a>新建Controller</h2><p>首先新建类<code>FirstController</code>，并且在类前加注解<code>@RestController</code>表示该类为一个控制器</p><p>新建方法，书写如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/helloworld&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloworld</span><span class="hljs-params">(String name)</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;从页面返回了&quot;</span>+name);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello  &quot;</span> + name;&#125;</code></pre></div><p><code>@RequestMapping(&quot;/helloworld&quot;)</code>中的地址，在浏览器中浏览它会调用该地址下的方法<code>helloworld</code>，从而执行方法中的逻辑，可以是数据库操作，计算等等</p><p>在浏览器中输入<code>localhost:8081/helloworld?name=李明</code>，可以看到返回成功</p><p><img src="../../image/image-20220824150255756.png" alt="浏览器效果"></p><p>在进行更加详细的操作之前，说一下作者理解的【接口】。</p><p>接口，这里特指软件的接口，作者认为是对某些请求进行出的一个生产者。对某个网站进行抓包的时候，可以看到不仅仅有网站本身的url，还有其他的一些奇奇怪怪的url，这些url就是所说的接口，编辑controller这个过程也是编辑接口的过程</p><p>接口有返回和请求的资源，接下来是说明pringboot中的controller可以接收、返回什么类型</p><h2 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h2><p>顾名思义，该类可以封装后台处理的数据，并返回视图，不建议使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/modelandview&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">modelandviewTest</span><span class="hljs-params">()</span> </span>&#123;    String text = <span class="hljs-string">&quot;helloworld&quot;</span>;    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();    mav.addObject(<span class="hljs-string">&quot;text&quot;</span>, text);    mav.setViewName(<span class="hljs-string">&quot;index.html&quot;</span>);    <span class="hljs-keyword">return</span> mav;&#125;</code></pre></div><h2 id="Model-和-String"><a href="#Model-和-String" class="headerlink" title="Model 和 String"></a>Model 和 String</h2><p>在控制器中返回视图（前端页面）的路径，后台处理完毕后会返回到该视图（前端页面）路径，在方法的形参中加入model，然后将数据装在model里面，会一并发送到前端视图中，该方法为官方推荐方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;    String text = <span class="hljs-string">&quot;helloworld&quot;</span>;    model.addAttribute(<span class="hljs-string">&quot;text&quot;</span>, text);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></div><h2 id="带有数据资源的对象"><a href="#带有数据资源的对象" class="headerlink" title="带有数据资源的对象"></a>带有数据资源的对象</h2><p>有多个数据的时候，可以用对象封装并传入后端。注意不能用List作为形参。</p><p>新建一个名字叫QueryBean的类即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/bean&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">bean</span><span class="hljs-params">(QueryBean qb)</span> </span>&#123;    <span class="hljs-keyword">int</span> id = qb.getId();    System.out.println(id);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></div><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>该方法应该是最常用的方法之一</p><p>前后端交互的时候，数据格式用json，就可以用到该方法</p><p>返回值使用<code>@ResponseBody</code>作为响应体输出资源，形参中使用<code>@RequestBody</code>作请求体请求资源</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/json&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-function">String <span class="hljs-title">json</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> QueryBean qb)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;这是我从AJAX传过来的数据&quot;</span>+qb.getId());    JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();    jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;斗地主&quot;</span>);    jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);    <span class="hljs-keyword">return</span> jsonObject.toString();&#125;</code></pre></div><p><code>JSONObject</code>类是<code>org.json</code>包里面的，引入依赖即可</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.json<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>20220320<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>实例中用的对象包装json中的键值对，该方式传入的形参还可以有如下：</p><p>String。该方法可以将json中的某个键值对进行拆分拿值，方法中参数名称必须和data指定的json格式对应</p><p>比如说请求的json格式为：<code>&#123;name:&quot;1234&quot;,password:&quot;1234&quot;&#125;</code>，接收的方法如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;这是我从AJAX传过来的数据&quot;</span>+name+<span class="hljs-string">&quot; &quot;</span>+password);    JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();    jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);    jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);    <span class="hljs-keyword">return</span> jsonObject.toString();&#125;</code></pre></div><h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><h2 id="什么是thymeleaf"><a href="#什么是thymeleaf" class="headerlink" title="什么是thymeleaf"></a>什么是thymeleaf</h2><p>稍微摘自官网的内容</p><ul><li><em>Thymeleaf is a modern server-side Java template engine for both web and standalone environments.</em></li><li><em>Thymeleaf’s main goal is to bring elegant natural templates to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams.</em></li><li><em>With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do.</em></li></ul><p>机翻后，就是（作者稍作修改）：</p><ol><li>Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎。</li><li>Thymeleaf的主要目标是为您的开发工作流程带来优雅的模板，HTML可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作。 </li><li>Thymeleaf拥有用于Spring Framework的模块，与您喜欢的工具（例如springboot）的大量集成以及嵌入您自己的功能的能力，对于现代HTML5 JVM Web开发而言，Thymeleaf是理想的选择-尽管它还有很多工作要做。</li></ol><p>不得不说Thymeleaf和JSP十分得像，但是他们之间的区别在于，不运行项目之前，Thymeleaf也是纯HTML（<strong>不需要服务端的支持</strong>）而JSP需要进行一定的转换，这样就方便前端人员进行独立的设计、调试。它有如下三个吸引人的特点：</p><ol><li>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li></ol><blockquote><p>摘自：<a href="https://www.cnblogs.com/ityouknow/p/5833560.html">spring boot(四):thymeleaf使用详解-纯洁的微笑</a></p></blockquote><h2 id="pom依赖引入"><a href="#pom依赖引入" class="headerlink" title="pom依赖引入"></a>pom依赖引入</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- springboot thymeleaf starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="html引入"><a href="#html引入" class="headerlink" title="html引入"></a>html引入</h2><p>在html页面中引入：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">“http://www.thymeleaf.org”</span>&gt;</span>    ...<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>准备工作基本完毕，注意：<strong>xmlns:th中th，个人认为是一个命名空间，在使用时需要引用，强烈建议不改，笔者查阅了大量的资料，几乎都是用的th</strong></p><h2 id="thymeleaf使用"><a href="#thymeleaf使用" class="headerlink" title="thymeleaf使用"></a>thymeleaf使用</h2><p>这里列举最常用的，若有不足以后会慢慢添加</p><h3 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h3><p>后端首先发送一个对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-meta">@RequestMapping(&quot;/pageAction&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pageAction</span><span class="hljs-params">(Model model)</span></span>&#123;    List&lt;user&gt; list = Service.queryList();    model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;page&quot;</span>;&#125;</code></pre></div><p>user对象按照如下方式建立，注意生成getter和setter方法。Serializable是将对象序列化，建议搞上去。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">user</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre></div><p>前端循环遍历对象：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;list : $&#123;list&#125;&quot;</span>&gt;</span></code></pre></div><p>展示，注意要在遍历对象的盒子里边：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;list : $&#123;list&#125;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;list.name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- 展示在页面上使用text --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;list.name&#125;&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 嵌套在input或其他用value --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>可以使用<code>#numbers.sequence()</code>限制展示的数量</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;index:$&#123;#numbers.sequence(1,10)&#125;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;index&#125;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 这里会展示1-&gt;10 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre></div><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/pageAction(id = $&#123;list.id&#125;,name = $&#123;list.name&#125;)&#125;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>若点击1,url上会显示</p><div class="code-wrapper"><pre><code class="hljs applescript">localhost:<span class="hljs-number">8080</span>/pageAction?<span class="hljs-built_in">id</span>=xxx&amp;<span class="hljs-built_in">name</span>=xxx</code></pre></div><h1 id="数据库资源管理"><a href="#数据库资源管理" class="headerlink" title="数据库资源管理"></a>数据库资源管理</h1><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>springboot 内置默认支持HikariCP数据库连接池，这里使用Druid作为线程池，Druid是阿里巴巴的一个开源项目，是一个数据库连接池的实现，结合了C3P0、DBCP、PROXOOL等DB池的优点。Druid不但提供连接池的功能，还提供监控功能，可以实时查看数据库连接池和SQL查询的工作情况。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>可以看到，即使使用druid，也是需要引入spring-boot-starter-jdbc，否则就会报<code>.....ClassNotFoundException: org....jdbc....embedded.EmbeddedDatabaseType。</code></p><p>原因是Spring Boot底层都是采用Spring Data的方式进行统一处理。EmbeddedDatabaseType类在spring-boot-starter-jdbc依赖中。</p><p>SpringBoot属于Spring“全家桶”组件，Druid属于阿里巴巴旗下开发产品，所以SpringBoot整合Druid并不是由Spring组件提供依赖，而是由阿里巴巴提供。</p><p>注意，引入依赖之后，必须要对其进行配置，否则会报错</p><h3 id="配置编写"><a href="#配置编写" class="headerlink" title="配置编写"></a>配置编写</h3><p>以下配置是比较简单的配置，包含了druid监控平台的开启</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-comment"># 数据库访问配置, 使用druid数据源(默认数据源是HikariDataSource)</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="hljs-attr">druid:</span>      <span class="hljs-comment"># 连接线程池</span>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">xxxxx</span>      <span class="hljs-attr">url:</span> <span class="hljs-string">xxxxx</span>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>      <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span>      <span class="hljs-comment"># 访问druid监控</span>      <span class="hljs-attr">stat-view-servlet:</span>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>        <span class="hljs-comment"># 配置Servlet的访问路径：访问路径为/druid/**时，跳转到StatViewServlet，会自动转到Druid监控后台</span>        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/druid/*</span>        <span class="hljs-comment"># 是否能够重置数据</span>        <span class="hljs-attr">reset-enable:</span> <span class="hljs-literal">false</span>        <span class="hljs-comment"># 设置监控后台的访问账户及密码</span>        <span class="hljs-attr">login-username:</span> <span class="hljs-string">root</span>        <span class="hljs-attr">login-password:</span> <span class="hljs-number">1234</span></code></pre></div><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>有了连接池，我们还需要进行数据库的增删查改的操作，这个时候就可以引入Mybatis了，Mybatis是一款优秀的<strong>持久层框架</strong>。它支持定制化SQL、存储过程以及高级映射。学习过ssm框架的都不会陌生，这里就不介绍它的作用了。</p><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span>  <span class="hljs-comment"># 指定 mapper.xml 的位置</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span>  <span class="hljs-comment"># 扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.example.bean</span></code></pre></div><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>连接mysql时，首先引入mysql的驱动包</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>配置文件中的<code>url</code>添加为<code>jdbc:mysql://127.0.0.1:3306/database</code>，driver-class-name添加为<code>com.mysql.cj.jdbc.Driver</code></p><p>配置完毕，开始编写数据库交互</p><h3 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h3><p>在Mysql中添加名叫Test01的表，属性为<code>id</code>和<code>name</code>，添加包<code>TableBean</code>，里面加入实体类<code>Test01</code>，对应表添加属性和<code>getter</code>和<code>setter</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre></div><h3 id="Mybatis映射编写"><a href="#Mybatis映射编写" class="headerlink" title="Mybatis映射编写"></a>Mybatis映射编写</h3><p>首先添加Mapper接口，加<code>@Mapper</code>标明该接口为映射类，也可以在启动类中添加<code>@MapperScan</code>注解扫描指定包下的 mapper 接口，这样就不用在每个 mapper 接口上都标注 @Mapper 注解了。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test01Mapper</span> </span>&#123;    <span class="hljs-function">List&lt;Test01&gt; <span class="hljs-title">selectall</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>紧接着编写mapper.xml映射sql，在<code>resources</code>中添加<code>mapper</code>文件夹，并添加<code>Test01.xml</code>。该位置和配置文件中的<code>mapper-locations: classpath:mapper/*.xml</code>一致，添加如下文本：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- namespace：命名空间，用于隔离sql，用于动态代理 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.Mapper.Test01Mapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectall&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Test01&quot;</span>&gt;</span>        Select * from test01    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>注意，<code>namespace</code>中的值为mapper接口的路径（参考如上代码），里面的<code>id</code>对应mapper接口中的每个方法，<code>resultType</code>就是返回的类型，虽然是写<code>Test01</code>，但是返回的也会用List装进去。这里不用写路径是因为配置中<code>type-aliases-package: com.example.bean</code>扫描了实体类的包，所以不用写</p><p>这样，mapper接口的工作准备完成</p><h3 id="Service编写"><a href="#Service编写" class="headerlink" title="Service编写"></a>Service编写</h3><p>首先编写service接口，新建<code>Service</code>包，添加<code>Test01Service.java</code>，方法与mapper接口一致</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test01Service</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Test01&gt; <span class="hljs-title">selectall</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>其次编写实现类，添加<code>Implement</code>包，添加<code>Test01Impl.java</code>并<code>implements Test01Service</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;Test01Service&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01Impl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Test01Service</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    Test01Mapper mapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Test01&gt; <span class="hljs-title">selectall</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mapper.selectall();    &#125;&#125;</code></pre></div><h3 id="controller调用"><a href="#controller调用" class="headerlink" title="controller调用"></a>controller调用</h3><p>首先在controller里面织入mapper类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> Test01Service service;</code></pre></div><p>然后编写controller后直接调用即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/mybatisTest&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mybatisTest</span><span class="hljs-params">()</span></span>&#123;        List&lt;Test01&gt; list = service.selectall();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;            System.out.println(<span class="hljs-string">&quot;id: &quot;</span>+list.get(i).getId()+<span class="hljs-string">&quot;name: &quot;</span>+list.get(i).getName());        &#125;        <span class="hljs-keyword">return</span> list.toString();    &#125;</code></pre></div><p>开启项目，在浏览器中输入<code>localhost:8081/mybatisTest</code>，就可以看到调用了数据库并返回资源</p><p>实际上，controller也可以直接调用mapper接口来对数据库进行操作，但是<strong>不推荐</strong>，像</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> Test01Mapper mapper;</code></pre></div><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。它的性能极高，Redis能读的速度是110000次/s，写的速度是81000次/s，具有丰富的特性。springboot中当然也可以整合redis，这里已经默认读者安装了redis，并且懂得了如何操作redis。</p><h3 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-comment"># Redis服务器地址</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    <span class="hljs-comment">#Redis服务器连接端口</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>    <span class="hljs-comment"># Redis服务器连接密码（默认为空）</span>    <span class="hljs-comment">#password:</span>    <span class="hljs-comment"># Redis数据库索引（默认为0）</span>    <span class="hljs-attr">database:</span> <span class="hljs-number">1</span>    <span class="hljs-comment"># 连接超时时间（毫秒）</span>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span></code></pre></div><h3 id="工具类编写"><a href="#工具类编写" class="headerlink" title="工具类编写"></a>工具类编写</h3><blockquote><p>来源：<a href="https://cloud.tencent.com/developer/article/1607647">Spring Boot整合Redis代码详解，四步搞定！ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote><p>可以自行更改，使用时直接调用即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.springbootredisdemo.Utils;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-comment">/**</span><span class="hljs-comment"> * redis工具类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisOperator</span> </span>&#123;<span class="hljs-comment">//    @Autowired</span><span class="hljs-comment">//    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;    <span class="hljs-comment">// Key（键），简单的key-value操作</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：TTL key，以秒为单位，返回给定 key的剩余生存时间(TTL, time to live)。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ttl</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.getExpire(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：expire 设置过期时间，单位秒</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> timeout)</span> </span>&#123;        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：INCR key，增加key一次</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">incr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, delta);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：KEYS pattern，查找所有符合给定模式 pattern的 key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">keys</span><span class="hljs-params">(String pattern)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.keys(pattern);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：DEL key，删除一个key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String key)</span> </span>&#123;        redisTemplate.delete(key);    &#125;    <span class="hljs-comment">// String（字符串）</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：SET key value，设置一个key-value（将字符串值 value关联到 key）</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        redisTemplate.opsForValue().set(key, value);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：SET key value EX seconds，设置key-value和超时时间（秒）</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout</span><span class="hljs-comment">     *            （以秒为单位）</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">long</span> timeout)</span> </span>&#123;        redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：GET key，返回 key所关联的字符串值。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> (String)redisTemplate.opsForValue().get(key);    &#125;    <span class="hljs-comment">// Hash（哈希表）</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：HSET key field value，将哈希表 key中的域 field的值设为 value</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> field</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String field, Object value)</span> </span>&#123;        redisTemplate.opsForHash().put(key, field, value);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：HGET key field，返回哈希表 key中给定域 field的值</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> field</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hget</span><span class="hljs-params">(String key, String field)</span> </span>&#123;        <span class="hljs-keyword">return</span> (String) redisTemplate.opsForHash().get(key, field);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：HDEL key field [field ...]，删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fields</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hdel</span><span class="hljs-params">(String key, Object... fields)</span> </span>&#123;        redisTemplate.opsForHash().delete(key, fields);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：HGETALL key，返回哈希表 key中，所有的域和值。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Object, Object&gt; <span class="hljs-title">hgetall</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().entries(key);    &#125;    <span class="hljs-comment">// List（列表）</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：LPUSH key value，将一个值 value插入到列表 key的表头</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行 LPUSH命令后，列表的长度。</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lpush</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForList().leftPush(key, value);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：LPOP key，移除并返回列表 key的头元素。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 列表key的头元素。</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lpop</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> (String)redisTemplate.opsForList().leftPop(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现命令：RPUSH key value，将一个值 value插入到列表 key的表尾(最右边)。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行 LPUSH命令后，列表的长度。</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">rpush</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForList().rightPush(key, value);    &#125;&#125;</code></pre></div><h3 id="Controller调用"><a href="#Controller调用" class="headerlink" title="Controller调用"></a>Controller调用</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisOperator redisOperator;<span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">redisTest</span><span class="hljs-params">(String value)</span></span>&#123;    redisOperator.set(<span class="hljs-string">&quot;test&quot;</span>,value);    String redis_key = redisOperator.get(<span class="hljs-string">&quot;test&quot;</span>);    System.out.println(<span class="hljs-string">&quot;redis_key: &quot;</span>+redis_key+<span class="hljs-string">&quot; 删除&quot;</span>);    redisOperator.del(<span class="hljs-string">&quot;test&quot;</span>);    <span class="hljs-keyword">return</span> redis_key;&#125;</code></pre></div><h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API可以快速、轻松地获得任何应用程序，不论是从最小的移动应用程序到最大的网络和企业应用程序。</p><p><img src="../../image/image-20220825210001361.png" alt="简略图"></p><p>shiro有三个核心的组件，分别是：Subject, SecurityManager 和 Realms.</p><ul><li><p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着”当前跟软件交互的东西”。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。</p></li><li><p>SecurityManager：它是Shiro框架的核心，典型的<a href="https://baike.baidu.com/item/Facade模式/7557140">Facade模式</a>，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。</p></li><li><p>Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。</p></li></ul><p><img src="../../image/image-20220825210054637.png" alt="顺序图"></p><p>shiro的大体框架为：</p><p><img src="../../image/image-20220825210129458.png" alt="框架图"></p><p>使用springboot也可以将其整合在里面，让自己的系统更加安全强大</p><h2 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- shiro的核心包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>在进入学习之前，官方给出了一个快速开始的项目demo，详情如下</p><blockquote><p><a href="http://shiro.apache.org/10-minute-tutorial.html">10分钟入门shiro</a></p></blockquote><p>以下是QuickStart的全部代码，这里笔者自己注释了一下，分解可以看到有6个部分，大致是<code>SecurityManagerFactory</code>（安全管理的工厂，属于工厂模式）、<code>SecurityManager</code>（安全管理，三大核心之一）、<code>Subject</code>（对象，三大核心之一）、<code>Authenticated</code>（认证）、<code>Role</code>（角色）、<code>Permitted</code>（授权）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.quickstart;<span class="hljs-keyword">import</span> org.apache.log4j.Logger;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;<span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<span class="hljs-keyword">import</span> org.apache.shiro.session.Session;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.apache.shiro.util.Factory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickStart</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger log = Logger.getLogger(QuickStart.class);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1.创建shiro工厂</span>        Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>);        <span class="hljs-comment">//2.创建SecurityManager</span>        SecurityManager securityManager = factory.getInstance();        <span class="hljs-comment">//3.SecurityUtils设置SecurityManager</span>        SecurityUtils.setSecurityManager(securityManager);        <span class="hljs-comment">//4.获取Subject对象 *</span>        Subject currentUser = SecurityUtils.getSubject();        <span class="hljs-comment">//5.创建shiro的session</span>        Session session = currentUser.getSession();        session.setAttribute(<span class="hljs-string">&quot;someKey&quot;</span>, <span class="hljs-string">&quot;aValue&quot;</span>);<span class="hljs-comment">//设置session属性</span>        String value = (String) session.getAttribute(<span class="hljs-string">&quot;someKey&quot;</span>);        <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;aValue&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;Retrieved the correct value! [&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>);        &#125;        <span class="hljs-comment">//判断该用户是否被认证</span>        <span class="hljs-keyword">if</span> (!currentUser.isAuthenticated()) &#123;            UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;lonestarr&quot;</span>, <span class="hljs-string">&quot;vespa&quot;</span>);            token.setRememberMe(<span class="hljs-keyword">true</span>);            <span class="hljs-keyword">try</span> &#123;                currentUser.login(token);            &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;                log.info(<span class="hljs-string">&quot;There is no user with username of &quot;</span> + token.getPrincipal());            &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;                log.info(<span class="hljs-string">&quot;Password for account &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; was incorrect!&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;                log.info(<span class="hljs-string">&quot;The account for username &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; is locked.  &quot;</span> +                        <span class="hljs-string">&quot;Please contact your administrator to unlock it.&quot;</span>);            &#125;            <span class="hljs-comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span>            <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;                <span class="hljs-comment">//unexpected condition?  error?</span>            &#125;        &#125;        <span class="hljs-comment">//say who they are:</span>        <span class="hljs-comment">//print their identifying principal (in this case, a username):</span>        log.info(<span class="hljs-string">&quot;User [&quot;</span> + currentUser.getPrincipal() + <span class="hljs-string">&quot;] logged in successfully.&quot;</span>);        <span class="hljs-comment">//test a role:角色</span>        <span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">&quot;schwartz&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;May the Schwartz be with you!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">&quot;Hello, mere mortal.&quot;</span>);        &#125;        <span class="hljs-comment">//test a typed permission (not instance-level)粗粒度</span>        <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;lightsaber:wield&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;You may use a lightsaber ring.  Use it wisely.&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;</span>);        &#125;        <span class="hljs-comment">//a (very powerful) Instance Level permission:细粒度</span>        <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;winnebago:drive:eagle5&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot;</span> +                    <span class="hljs-string">&quot;Here are the keys - have fun!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;</span>);        &#125;        <span class="hljs-comment">//all done - log out!</span>        currentUser.logout();    &#125;&#125;</code></pre></div><h3 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h3><p>shiro.ini：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># =============================================================================</span><span class="hljs-comment"># Tutorial INI configuration</span><span class="hljs-comment">#</span><span class="hljs-comment"># Usernames/passwords are based on the classic Mel Brooks&#x27; film &quot;Spaceballs&quot; :)</span><span class="hljs-comment"># =============================================================================</span><span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-comment"># Users and their (optional) assigned roles</span><span class="hljs-comment"># username = password, role1, role2, ..., roleN</span><span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-section">[users]</span><span class="hljs-attr">root</span> = secret, admin<span class="hljs-attr">guest</span> = guest, guest<span class="hljs-attr">presidentskroob</span> = <span class="hljs-number">12345</span>, president<span class="hljs-attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz<span class="hljs-attr">lonestarr</span> = vespa, goodguy, schwartz<span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-comment"># Roles with assigned permissions</span><span class="hljs-comment"># roleName = perm1, perm2, ..., permN</span><span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-section">[roles]</span><span class="hljs-attr">admin</span> = *<span class="hljs-attr">schwartz</span> = lightsaber:*<span class="hljs-attr">goodguy</span> = winnebago:drive:eagle5</code></pre></div><p>log4j.properties：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">### 设置###</span><span class="hljs-meta">log4j.rootLogger</span> = <span class="hljs-string">debug,stdout,D,E</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出信息到控制抬 ###</span><span class="hljs-meta">log4j.appender.stdout</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.stdout.Target</span> = <span class="hljs-string">System.out</span><span class="hljs-meta">log4j.appender.stdout.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span> = <span class="hljs-string">[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><span class="hljs-meta">log4j.appender.D</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-comment">#log4j.appender.D.File = E://logs/log.log</span><span class="hljs-meta">log4j.appender.D.Append</span> = <span class="hljs-string">true</span><span class="hljs-meta">log4j.appender.D.Threshold</span> = <span class="hljs-string">DEBUG </span><span class="hljs-meta">log4j.appender.D.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.D.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><span class="hljs-meta">log4j.appender.E</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-comment">#log4j.appender.E.File =E://logs/error.log</span><span class="hljs-meta">log4j.appender.E.Append</span> = <span class="hljs-string">true</span><span class="hljs-meta">log4j.appender.E.Threshold</span> = <span class="hljs-string">ERROR </span><span class="hljs-meta">log4j.appender.E.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.E.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span></code></pre></div><h2 id="配置类和realm"><a href="#配置类和realm" class="headerlink" title="配置类和realm"></a>配置类和realm</h2><p>在springboot中自定义shiro的配置类<code>ShiroConfig</code>，并在方法前添加<code>@Configuration</code>（标准的springboot配置类注解），<strong>config类中所有的方法前都应该加上@Bean，让spring托管方法</strong></p><p>首先引入<code>realm</code>，这里的自定义<code>realm</code>命名为<code>UserRealm</code>，创建一个<code>UserRealm</code>类，并继承<code>AuthorizingRealm</code>类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;    <span class="hljs-comment">//授权</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 授权方法doGetAuthorizationInfo&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//认证</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 认证方法doGetAuthenticationInfo&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>在<code>ShiroConfig</code>类添加方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建realm对象，需要自定义</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserRealm <span class="hljs-title">getUserRealm</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRealm();&#125;</code></pre></div><p>其次引入<code>SecurityManager</code>，这里使用<code>DefaultWebSecurityManager</code>，形参中用<code>@Qualifier</code>指定<code>realm</code>方法引入<code>UserRealm</code>：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//DefaultWebSecurityManager--&gt;获取UserRealm</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getUserRealm&quot;)</span> UserRealm userRealm)</span></span>&#123;    DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();    securityManager.setRealm(userRealm);<span class="hljs-comment">//关联realm</span>    <span class="hljs-keyword">return</span> securityManager;&#125;</code></pre></div><p>最后加入<code>Factory</code>，这里用<code>ShiroFilterFactoryBean</code>，获取<code>DefaultWebSecurityManager</code>的方法同上：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ShiroFilterFactoryBean--&gt;获取DefaultWebSecurityManager</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getDefaultWebSecurityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;    ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();    <span class="hljs-comment">// 设置安全管理器</span>    bean.setSecurityManager(defaultWebSecurityManager);    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div><p>三个方法在config类中是串起来的，顺序是<code>UserRealm</code>—&gt;<code>DefaultWebSecurityManager</code>—&gt;<code>ShiroFilterFactoryBean</code></p><h2 id="添加测试页面"><a href="#添加测试页面" class="headerlink" title="添加测试页面"></a>添加测试页面</h2><p>添加主页index，两个页面add，update和登录页面login.html</p><p>index.html</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Index<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/user/add&#125;&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> | <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/user/update&#125;&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>login.html</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/loginCheck&quot;</span>&gt;</span>    请输入账号: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>    请输入密码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>add.html和update.html添加1级标题即可</p><h2 id="Controller编写"><a href="#Controller编写" class="headerlink" title="Controller编写"></a>Controller编写</h2><p>编写controller对其进行测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span></span>&#123;    model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello shiro&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(&quot;/user/update&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(&quot;/user/add&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;&#125;</code></pre></div><h2 id="登录拦截配置"><a href="#登录拦截配置" class="headerlink" title="登录拦截配置"></a>登录拦截配置</h2><p>该操作由shiro的内置过滤器完成，有5大选项：</p><ul><li>anon:无需认证可以访问</li><li>authc: 必须认证了才能访问</li><li>user:必须拥有【记住我】功能才能用</li><li>perms: 拥有对某个资源的权限才能访问</li><li>role: 拥有某个角色权限才能访问</li></ul><p>在<code>ShiroConfig</code>类的<code>ShiroFilterFactoryBean</code>操作方法中引入过滤器，完整的方法如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ShiroFilterFactoryBean--&gt;获取DefaultWebSecurityManager</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getDefaultWebSecurityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;    ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();    <span class="hljs-comment">// 设置安全管理器</span>    bean.setSecurityManager(defaultWebSecurityManager);    <span class="hljs-comment">// 添加shiro的内置过滤器</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">        anon:无需认证可以访问</span><span class="hljs-comment">        authc: 必须认证了才能访问</span><span class="hljs-comment">        user:必须拥有 记住我 功能才能用</span><span class="hljs-comment">        perms: 拥有对某个资源的权限才能访问</span><span class="hljs-comment">        role: 拥有某个角色权限才能访问</span><span class="hljs-comment">     */</span>    Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();    filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>);    bean.setFilterChainDefinitionMap(filterChainDefinitionMap);    <span class="hljs-comment">//设置登录请求</span>    bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div><p>可以看到，/user/下面的请求全部被拦截，必须认证了才能访问。在没有认证的时候，会跳转至/login。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>登录其实就是一个认证的过程，在controller中添加/loginCheck的操作逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/loginCheck&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginCheck</span><span class="hljs-params">(String username,String password)</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;获取账号密码:username: &quot;</span>+username+<span class="hljs-string">&quot;,password: &quot;</span>+password);    Subject subject = SecurityUtils.getSubject();<span class="hljs-comment">//获取当前用户</span>    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username,password);<span class="hljs-comment">//封装登录数据</span>    System.out.println(<span class="hljs-string">&quot;验证登录&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        subject.login(token);<span class="hljs-comment">//验证登录</span>    &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;        System.out.println(<span class="hljs-string">&quot;用户名错误&quot;</span>);    &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;        System.out.println(<span class="hljs-string">&quot;密码错误&quot;</span>);    &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;        System.out.println(<span class="hljs-string">&quot;账号被锁定&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></div><p>在执行<code>subject.login(token);</code>方法时，会将token输送到<code>UserRealm</code>中的<code>doGetAuthenticationInfo()</code>方法，验证是否正确，这里需要用户自行配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//认证</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;     System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 认证方法doGetAuthenticationInfo&quot;</span>);     <span class="hljs-comment">//从数据库获取账号密码</span>     User user = <span class="hljs-keyword">new</span> User();     String username = <span class="hljs-string">&quot;root&quot;</span>;     user.setUsername(username);     String password = <span class="hljs-string">&quot;1234&quot;</span>;     user.setPassword(password);     String perms = <span class="hljs-string">&quot;user:add&quot;</span>;     user.setPerms(perms);     UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;     <span class="hljs-keyword">if</span>(!token.getUsername().equals(username))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//返回错误 UnknownAccountException</span>     &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user,user.getPassword(),<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//principal放存放着账户对象:USER</span> &#125;</code></pre></div><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>每个账户都有相应的权限，某些功能不能给某些没有该权限的人使用。首先限制url的权限，在过滤器中添加即可</p><div class="code-wrapper"><pre><code class="hljs java">ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();<span class="hljs-comment">// 设置安全管理器</span>bean.setSecurityManager(defaultWebSecurityManager);<span class="hljs-comment">// 添加shiro的内置过滤器</span><span class="hljs-comment">/*</span><span class="hljs-comment">    anon:无需认证可以访问</span><span class="hljs-comment">    authc: 必须认证了才能访问</span><span class="hljs-comment">    user:必须拥有 记住我 功能才能用</span><span class="hljs-comment">    perms: 拥有对某个资源的权限才能访问</span><span class="hljs-comment">    role: 拥有某个角色权限才能访问</span><span class="hljs-comment">*/</span>Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<span class="hljs-comment">/* 先检测授权后检测拦截，越在上面的优先度越大,未经授权跳转到指定页面 */</span>filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;perms[user:add]&quot;</span>);filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/update&quot;</span>,<span class="hljs-string">&quot;perms[user:update]&quot;</span>);filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>);bean.setFilterChainDefinitionMap(filterChainDefinitionMap);<span class="hljs-comment">//设置登录请求</span>bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);<span class="hljs-comment">//未授权页面</span>bean.setUnauthorizedUrl(<span class="hljs-string">&quot;/unau&quot;</span>);<span class="hljs-keyword">return</span> bean;</code></pre></div><p>一定要注意授权和拦截的顺序，并且授权是有优先度的。可以看到未授权也会跳转到相应的url，在controller添加即可：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/unau&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unauthorized</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;未经授权无法访问&quot;</span>;&#125;</code></pre></div><p>最后在UserRealm中添加授权逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//授权</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 授权方法doGetAuthorizationInfo&quot;</span>);    SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();    <span class="hljs-comment">//        info.addStringPermission(&quot;user:add&quot;);//为账户添加user:add权限</span>    System.out.println(<span class="hljs-string">&quot;开始授权&quot;</span>);    <span class="hljs-comment">//拿到登录对象</span>    Subject subject = SecurityUtils.getSubject();    User currentUser = (User) subject.getPrincipal();<span class="hljs-comment">//拿到User对象</span>    <span class="hljs-comment">//设置当前用户的权限</span>    info.addStringPermission(currentUser.getPerms());    <span class="hljs-keyword">return</span> info;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里会列举上诉所有代码，仅供参考</p><p>ShiroConfig.java</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<span class="hljs-keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;<span class="hljs-keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        三大核心</span><span class="hljs-comment">        realm</span><span class="hljs-comment">        subject</span><span class="hljs-comment">        SecurityManager</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">//创建realm对象，需要自定义</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserRealm <span class="hljs-title">getUserRealm</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRealm();    &#125;    <span class="hljs-comment">//DefaultWebSecurityManager--&gt;获取UserRealm</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getUserRealm&quot;)</span> UserRealm userRealm)</span></span>&#123;        DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();        securityManager.setRealm(userRealm);<span class="hljs-comment">//关联realm</span>        <span class="hljs-keyword">return</span> securityManager;    &#125;    <span class="hljs-comment">//ShiroFilterFactoryBean--&gt;获取DefaultWebSecurityManager</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getDefaultWebSecurityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;        ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();        <span class="hljs-comment">// 设置安全管理器</span>        bean.setSecurityManager(defaultWebSecurityManager);        <span class="hljs-comment">// 添加shiro的内置过滤器</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">            anon:无需认证可以访问</span><span class="hljs-comment">            authc: 必须认证了才能访问</span><span class="hljs-comment">            user:必须拥有 记住我 功能才能用</span><span class="hljs-comment">            perms: 拥有对某个资源的权限才能访问</span><span class="hljs-comment">            role: 拥有某个角色权限才能访问</span><span class="hljs-comment">         */</span>        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-comment">/* 先检测授权后检测拦截，越在上面的优先度越大,未经授权跳转到指定页面 */</span>        filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;perms[user:add]&quot;</span>);        filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/update&quot;</span>,<span class="hljs-string">&quot;perms[user:update]&quot;</span>);        filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>);        bean.setFilterChainDefinitionMap(filterChainDefinitionMap);        <span class="hljs-comment">//设置登录请求</span>        bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);        <span class="hljs-comment">//未授权页面</span>        bean.setUnauthorizedUrl(<span class="hljs-string">&quot;/unau&quot;</span>);        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><p>UserRealm.java</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<span class="hljs-keyword">import</span> com.example.pojo.User;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;<span class="hljs-keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;<span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;<span class="hljs-keyword">import</span> org.apache.shiro.subject.PrincipalCollection;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;    <span class="hljs-comment">//授权</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 授权方法doGetAuthorizationInfo&quot;</span>);        SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<span class="hljs-comment">//        info.addStringPermission(&quot;user:add&quot;);//为账户添加user:add权限</span>        System.out.println(<span class="hljs-string">&quot;开始授权&quot;</span>);        <span class="hljs-comment">//拿到登录对象</span>        Subject subject = SecurityUtils.getSubject();        User currentUser = (User) subject.getPrincipal();<span class="hljs-comment">//拿到User对象</span>        <span class="hljs-comment">//设置当前用户的权限</span>        info.addStringPermission(currentUser.getPerms());        <span class="hljs-keyword">return</span> info;    &#125;    <span class="hljs-comment">//认证</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 认证方法doGetAuthenticationInfo&quot;</span>);        <span class="hljs-comment">//从数据库获取账号密码</span>        User user = <span class="hljs-keyword">new</span> User();        String username = <span class="hljs-string">&quot;root&quot;</span>;        user.setUsername(username);        String password = <span class="hljs-string">&quot;1234&quot;</span>;        user.setPassword(password);        String perms = <span class="hljs-string">&quot;user:add&quot;</span>;        user.setPerms(perms);        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;        <span class="hljs-keyword">if</span>(!token.getUsername().equals(username))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//返回错误 UnknownAccountException</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user,user.getPassword(),<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//principal放存放着账户对象:USER</span>    &#125;&#125;</code></pre></div><p>exampleController.java</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.controller;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.ui.Model;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exampleController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span></span>&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello shiro&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/user/update&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/user/add&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;    &#125;&#125;</code></pre></div><h1 id="Dubbo与Zookeeper"><a href="#Dubbo与Zookeeper" class="headerlink" title="Dubbo与Zookeeper"></a>Dubbo与Zookeeper</h1><blockquote><p> dubbo文档：<a href="https://dubbo.apache.org/zh/docs/v2.7/">Dubbo 2.7 | Apache Dubbo</a></p><p>zookeeper文档：<a href="https://zookeeper.readthedocs.io/zh/latest/intro.html">ZooKeeper 介绍 — zookeeper入门 文档</a></p></blockquote><p>在进入学习之前，首先要了解一个理论</p><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；</p><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。</p><p>分布式系统（distributed system）是建立在网络之上的软件系统。</p><p>分布式系统对于用户而言，他们面对的就是一个服务器，提供用户需要的服务而已，而实际上这些服务是通过背后的众多服务器组成的一个分布式系统，因此分布式系统看起来像是一个超级计算机一样。</p><p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。</p><p><img src="../../image/image-20220826171055565.png" alt="分布式服务框架图"></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。RPC它假定某些协议的存在，例如TPC/UDP等，为通信程序之间携带信息数据。在OSI网络七层模型中，RPC跨越了传输层和应用层，RPC使得开发，包括网络分布式多程序在内的应用程序更加容易。</p><p>过程是什么？ 过程就是业务处理、计算任务，更直白的说，就是程序，就是想调用本地方法一样调用远程的过程</p><p><img src="../../image/image-20220826170936911.png" alt="dubbo框架大致运作过程"></p><h2 id="如何理解Dubbo与Zookeeper"><a href="#如何理解Dubbo与Zookeeper" class="headerlink" title="如何理解Dubbo与Zookeeper"></a>如何理解Dubbo与Zookeeper</h2><p>淘宝每天有超过100万的用户（当然笔者不知道完整的数字），每天都能产生百亿级别的数据，用一个服务器是绝对处理不过来的，真的很难想象如果用一个服务器来处理淘宝用户产生的这些数据，一个用户请求一次需要多长时间，这个时候就需要多个服务器对这些数据进行处理。就好比做作业，如果有一、两份作业，一个人可以做得过来，但是有十份、一百份甚至一千份，就需要更多的人一起做这些作业才能在短时间内完成作业。</p><p>但是做作业，如果一个人只做一份，另外一个人做十份，这显然也不合理。</p><p>上面的这些思考，属于<strong>负载均衡</strong>，不同的人做作业，属于<strong>分布式</strong></p><p>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间<strong>解耦合</strong>（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是<strong>提供方提供服务</strong>，要么是<strong>消费方消费服务</strong>，<strong>所以基于这一点可以抽象出生产者（Provider）和消费者（Consumer）两个角色</strong></p><p>生产者（Provider），通俗理解来说就是从数据库拿出数据的那个服务，产生数据的一方</p><p>消费者（Consumer），通俗理解来说就是拿到数据后，用这些数据搞事情的那个服务，消费数据的一方</p><p>zookeeper用来<strong>注册服务</strong>和进行<strong>负载均衡</strong>，哪一个服务由哪一个机器来提供必需让调用者知道。</p><p>所以dubbo作为接口的RPC服务框架。而zookeeper就作为将这些服务管理起来，进行科学分配作业的框架，也叫zookeeper集群。</p><h2 id="Zookeeper的安装"><a href="#Zookeeper的安装" class="headerlink" title="Zookeeper的安装"></a>Zookeeper的安装</h2><p>zookeeper下载地址为：<a href="https://zookeeper.apache.org/releases.html">Apache ZooKeeper</a></p><p>首先进入页面，点击一个稳定的版本，进入后下载压缩包</p><p><img src="../../image/image-20220826213520189.png" alt="点击https下面的链接"></p><p>注意，一定要<strong>下载带<code>-bin</code>这个后缀的版本</strong>，这个是编译后的压缩包，否则会报<code>Could not find or load main class org.apache.zookeeper.server.quorum.QuorumPeerMain</code>的错误</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>下载完毕后，解压下来</p><p>将<code>conf</code>目录下的<code>zoo_sample.cfg</code>文件，复制一份，重命名为<code>zoo.cfg</code></p><p><img src="../../image/image-20220826213929602.png" alt="复制文件"></p><p>在安装目录下面新建一个空的<code>data</code>文件夹和<code>log</code>文件夹</p><p><img src="../../image/image-20220826214108791.png" alt="创建文件夹"></p><p>修改<code>zoo.cfg</code>配置文件，将<code>dataDir=/tmp/zookeeper</code>修改成 zookeeper 安装目录所在的 data 文件夹，再添加一条添加数据日志的配置（可以根据自己的目录进行修改），以下为作者的配置：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:/apache-zookeeper-3.7.1-bin/data</span><span class="hljs-attr">dataLogDir</span>=<span class="hljs-string">D:/apache-zookeeper-3.7.1-bin/log</span></code></pre></div><p><img src="../../image/image-20220826214418.png" alt="zookeeper的配置"></p><p>从<code>clientPort=2181</code>可看到zookeeper的默认端口为<strong>2181</strong>，当然也可以修改</p><p>配置完毕后，双击<code>/bin/zkServer.cmd</code>启动zookeeper服务端的服务（或者以管理员身份运行）</p><p><img src="../../image/image-20220826214655214.png" alt="zookeeper服务的Windows命令脚本"></p><p>控制台显示 <strong>bind to port 0.0.0.0/0.0.0.0:2181</strong>，表示服务端启动成功</p><p><img src="../../image/image-20220826221657367.png" alt="服务端启动成功"></p><p>双击<code>/bin/zkCli.cmd</code>启动zookeeper客户端的服务（或者以管理员身份运行），出现 Welcome to Zookeeper！，表示成功启动客户端。</p><p><img src="../../image/image-20220826221919087.png" alt="客户端启动成功"></p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>参照windows，客户端为<code>zkCli.sh</code>和服务端<code>zkServer.sh</code></p><h2 id="Dubbo-admin的安装与使用"><a href="#Dubbo-admin的安装与使用" class="headerlink" title="Dubbo-admin的安装与使用"></a>Dubbo-admin的安装与使用</h2><p>下载地址：<a href="https://github.com/apache/dubbo-admin">GitHub - apache/dubbo-admin: The ops and reference implementation for Apache Dubbo</a></p><p>下载后，解压得到如下文件夹</p><p><img src="../../image/image-20220827074908680.png" alt="dubbo-admin文件夹"></p><p>进入<code>dubbo-admin-server</code>，按路径<code>src</code>、<code>main</code>、<code>resources</code>找到<code>application.properties</code>，编辑该文件。推荐用idea或者eclipse这些ide软件打开这些项目</p><p><img src="../../image/image-20220827081127767.png" alt=""></p><p>添加<code>server.port=7001</code>，为这个项目修改端口，否则默认8080端口启动。注意<code>admin.registry.address</code>、<code>admin.root.user.name=root</code>和<code>admin.root.user.password=root</code>，它们分别是注册地址（zookeeper）、dubbo-admin的账号密码，配置后结果如下：</p><p><img src="../../image/image-20220827081932400.png" alt="配置"></p><p>使用<code>mvn clean</code>清理整个项目</p><p><img src="../../image/image-20220827082405654.png" alt=""></p><p><img src="../../image/image-20220827082321600.png" alt="清理项目"></p><p>上述步骤完毕后，<strong>启动zookeeper服务</strong>，然后找到<code>DubboAdminApplication.java</code>，启动它</p><p><img src="../../image/image-20220827222441425.png" alt="dubbo-admin-server启动成功"></p><p>由于笔者下载的是最新版的dubbo-admin，它是个前后端分离项目（所谓前后端分离，实际上就是前端的项目和后端的项目独立开来，物理上，前端要开一个服务，后端也要开一个服务），后端用springboot，前端用的是vue，所以需要下载一个npm。具体的教程后面会出，或者直接百度吧。</p><p>进入<code>dubbo-admin-ui</code>，编辑<code>vue.config.js</code>，将第33行中的<code>target: &#39;http://localhost:8080/&#39;</code>修改成<code>dubbo-admin-server</code>中设置的<code>server.port</code>也就是7001，当然这个也是可以自由修改的</p><p><img src="../../image/image-20220827223210675.png" alt="设置代理窗口"></p><p>打开终端，进入到<code>dubbo-admin-ui</code>后，进行<code>npm install</code>安装相应的包，安装完毕后，使用<code>npm run dev</code>打开dubbo-admin前端</p><p><img src="../../image/image-20220827223352867.png" alt="dubbo-admin-ui启动成功"></p><p>打开浏览器，输入<code>localhost:8082</code>进入登录页面（这个也可以修改，在<code>vue.config.js</code>的第24行），根据上面<code>dubbo-admin-server</code>中<code>application.properties</code>的<code>admin.root.user.name</code>和<code>admin.root.user.password</code>设置输入登录账号和密码（笔者方便测试默认都是root），输入完毕后点击登录</p><p><img src="../../image/image-20220827223848696.png" alt="输入账号密码并登录"></p><p>见到如下页面，dubbo-admin准备完成</p><p><img src="../../image/image-20220827223944672.png" alt="dubbo-admin主页面"></p><h2 id="生产者（provider）的搭建"><a href="#生产者（provider）的搭建" class="headerlink" title="生产者（provider）的搭建"></a>生产者（provider）的搭建</h2><p>搭建之前，首先打开zookeeper服务端、dubbo-admin，并创建好数据库</p><h3 id="引入依赖—dubbo"><a href="#引入依赖—dubbo" class="headerlink" title="引入依赖—dubbo"></a>引入依赖—dubbo</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="引入依赖—zookeeper"><a href="#引入依赖—zookeeper" class="headerlink" title="引入依赖—zookeeper"></a>引入依赖—zookeeper</h3><p>引入<code>zkclient</code>，zookeeper客户端</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--zkclient--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.sgroschupf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>引入<code>zookeeper</code>，但是需要解决日志冲突问题（新版zookeeper的坑）</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入zookeeper并解决日志冲突--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>解决<code>java.lang.NoClassDefFoundError: org/apache/curator/framework/recipes/cache/TreeCacheListener</code>问题</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--解决 java.lang.NoClassDefFoundError: org/apache/curator/framework/recipes/cache/TreeCacheListener--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="引入依赖—其他"><a href="#引入依赖—其他" class="headerlink" title="引入依赖—其他"></a>引入依赖—其他</h3><ol><li>spring-boot-starter-web</li><li>spring-boot-starter-jdbc</li><li>Druid</li><li>Mybatis</li><li>mysql-connector-java</li></ol><p>具体的引入参考数据库资源管理这一节</p><h3 id="搭建Service"><a href="#搭建Service" class="headerlink" title="搭建Service"></a>搭建Service</h3><p>该章节的操作步骤和数据库资源管理这一节一样，但是注意一个点，实现类中，<code>@Service</code>的包为<code>import org.apache.dubbo.config.annotation.Service;</code>开了这个，才能让dubbo服务被发现</p><p><img src="../../image/image-20220828093723834.png" alt="搭建成功，dubbo-admin发现了服务"></p><p>注意在bean类<code>implements</code> <code>Serializable</code>，让bean序列化</p><p>搭建完毕后，该服务放在后台即可</p><h3 id="配置编写-1"><a href="#配置编写-1" class="headerlink" title="配置编写"></a>配置编写</h3><p>参考如下配置</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">dubbo:</span>  <span class="hljs-comment"># 注册服务应用名字</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">provider-server</span>  <span class="hljs-comment"># 注册中心地址</span>  <span class="hljs-attr">registry:</span>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://127.0.0.1:2181</span>  <span class="hljs-comment"># 哪些服务需要被注册，扫描的包为注释了@Service的类</span>  <span class="hljs-attr">scan:</span>    <span class="hljs-attr">base-packages:</span> <span class="hljs-string">com.example.providerserver.implement</span>  <span class="hljs-comment"># 随机dubbo端口号，否则可能存在端口冲突的问题</span>  <span class="hljs-attr">protocol:</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span></code></pre></div><h2 id="消费者（consumer）的搭建"><a href="#消费者（consumer）的搭建" class="headerlink" title="消费者（consumer）的搭建"></a>消费者（consumer）的搭建</h2><h3 id="引入依赖-4"><a href="#引入依赖-4" class="headerlink" title="引入依赖"></a>引入依赖</h3><ol><li>dubbo+zookeeper：与生产者的搭建一样</li><li>其他：spring-boot-starter-web</li></ol><h3 id="Service地址映射"><a href="#Service地址映射" class="headerlink" title="Service地址映射"></a>Service地址映射</h3><p>provider中的Service的包是<code>com.example.providerserver.service.BigdatatestService</code>，bean的包是<code>com.example.providerserver.pojo.bigdatatest</code></p><p>在consumer中也要新建一个相同包名，相同类名的service和pojo，用于映射生产者的service。bean类同样也要<code>implements</code> <code>Serializable</code>，让bean序列化</p><p>这就是为什么consumer在引入依赖不需要mybatis这些数据库操作框架的原因，完成后消费者结构如下：</p><p><img src="../../image/image-20220828104118301.png" alt=""></p><p>新建controller，映射service，注意看包名</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.example.providerserver.pojo.bigdatatest;<span class="hljs-keyword">import</span> com.example.providerserver.service.BigdatatestService;<span class="hljs-keyword">import</span> org.apache.dubbo.config.annotation.Reference;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumController</span> </span>&#123;    <span class="hljs-meta">@Reference</span>    <span class="hljs-keyword">private</span> BigdatatestService service;    <span class="hljs-meta">@RequestMapping(&quot;/rpcTest&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">rpcTest</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">for</span> (bigdatatest bd:service.selectall()) &#123;            System.out.println(<span class="hljs-string">&quot;===================&quot;</span>);            System.out.println(bd.getId());            System.out.println(bd.getAge());            System.out.println(bd.getName());            System.out.println(<span class="hljs-string">&quot;===================&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> service.selectall().toString();    &#125;&#125;</code></pre></div><h3 id="配置编写-2"><a href="#配置编写-2" class="headerlink" title="配置编写"></a>配置编写</h3><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8122</span><span class="hljs-attr">dubbo:</span>  <span class="hljs-comment"># 注册服务应用名字</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">consumer-server</span>  <span class="hljs-comment"># 注册中心地址</span>  <span class="hljs-attr">registry:</span>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://127.0.0.1:2181</span>  <span class="hljs-comment"># 随机dubbo端口号，否则可能存在端口冲突的问题</span>  <span class="hljs-attr">protocol:</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span></code></pre></div><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>进入浏览器，输入<code>localhost:8122</code>，可看到返回成功</p><p><img src="../../image/image-20220828110235265.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架应用</tag>
      
      <tag>springboot整合</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的基本应用</title>
    <link href="/my_world/content/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <url>/my_world/content/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：<a href="https://www.test.com/redis/redis-tutorial.html">Redis 教程 | 菜鸟教程 (test.com)</a></p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h2 id="与其他的key-value存储不同点"><a href="#与其他的key-value存储不同点" class="headerlink" title="与其他的key-value存储不同点"></a>与其他的key-value存储不同点</h2><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>下载地址</p><div class="code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/tporadowski/</span>redis/releases</code></pre></div><p>Redis 支持 32 位和 64 位，需要根据系统平台的实际情况选择，这里使用msi文件直接安装，安装的时候记得勾选path相关的选项即可。这就可以直接在终端中直接打开redis。</p><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>使用如下指令：</p><div class="code-wrapper"><pre><code class="hljs axapta">sudo apt update <span class="hljs-meta"># 更新apt</span>sudo apt install redis-<span class="hljs-keyword">server</span> <span class="hljs-meta"># 安装redis</span></code></pre></div><p>测试是否成功，启动：</p><div class="code-wrapper"><pre><code class="hljs avrasm">redis-serverredis-<span class="hljs-keyword">cli</span> <span class="hljs-meta"># 查看是否启动成功</span></code></pre></div><h1 id="Redis基本命令"><a href="#Redis基本命令" class="headerlink" title="Redis基本命令"></a>Redis基本命令</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>基本命令为：</p><div class="code-wrapper"><pre><code class="hljs shell">redis-cli</code></pre></div><p>测试是否连接成功：</p><div class="code-wrapper"><pre><code class="hljs shell">redis 127.0.0.1:6379&gt; PINGPONG</code></pre></div><p>如果需要在远程 redis 服务上执行命令，同样使用的也是 <strong>redis-cli</strong> 命令。</p><div class="code-wrapper"><pre><code class="hljs shell">redis-cli -h (host) -p (port) -a (password)</code></pre></div><p>实例：</p><p>连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 -a <span class="hljs-string">&quot;mypass&quot;</span></span>redis 127.0.0.1:6379&gt; PINGPONG</code></pre></div><h2 id="键-key"><a href="#键-key" class="headerlink" title="键(key)"></a>键(key)</h2><p>获取key对应的value值：</p><div class="code-wrapper"><pre><code class="hljs shell">Get key</code></pre></div><p>设置key对应的value值：</p><div class="code-wrapper"><pre><code class="hljs shell">SET key value</code></pre></div><p>删除key：</p><div class="code-wrapper"><pre><code class="hljs shell">DEL key</code></pre></div><p>判断key是否存在</p><div class="code-wrapper"><pre><code class="hljs shell">EXISTS key</code></pre></div><p>key设置过期时间，以秒计</p><div class="code-wrapper"><pre><code class="hljs shell">EXPIRE key seconds</code></pre></div><p>key设置过期时间，以UNIX 时间戳设置</p><div class="code-wrapper"><pre><code class="hljs shell">EXPIREAT key timestamp</code></pre></div><p>移除 key 的过期时间</p><div class="code-wrapper"><pre><code class="hljs shell">PERSIST key</code></pre></div><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</p><div class="code-wrapper"><pre><code class="hljs shell">TTL key</code></pre></div><p>以毫秒为单位返回 key 的剩余的过期时间。</p><div class="code-wrapper"><pre><code class="hljs shell">PTTL key</code></pre></div><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>string 是 redis 最基本的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs shell">redis 127.0.0.1:6379&gt; SET test &quot;1&quot;OKredis 127.0.0.1:6379&gt; GET test&quot;1&quot;</code></pre></div><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs shell">redis 127.0.0.1:6379&gt; DEL testredis 127.0.0.1:6379&gt; HMSET test field1 &quot;Hello&quot; field2 &quot;World&quot;&quot;OK&quot;redis 127.0.0.1:6379&gt; HGET test field1&quot;Hello&quot;redis 127.0.0.1:6379&gt; HGET test field2&quot;World&quot;</code></pre></div><p>使用<code>DEL test</code>删除前面测试用过的 key，不然会报错</p><p><strong>HMSET</strong> 设置了两个 <strong>field=&gt;value</strong> 对, HGET 获取对应 <strong>field</strong> 对应的 <strong>value</strong>。</p><p>每个 hash 可以存储 232 -1 键值对（40多亿）。</p><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。用户可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><div class="code-wrapper"><pre><code class="hljs shell">redis 127.0.0.1:6379&gt; DEL testredis 127.0.0.1:6379&gt; lpush test redis(integer) 1redis 127.0.0.1:6379&gt; lpush test mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush test rabbitmq(integer) 3redis 127.0.0.1:6379&gt; lrange test 0 101) &quot;rabbitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;</code></pre></div><p><strong>lpush</strong>用于存储元素，<strong>lrange</strong>用于查看元素</p><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>实例：</p><p>添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。</p><div class="code-wrapper"><pre><code class="hljs shell">sadd key member</code></pre></div><p>在终端中实操：</p><div class="code-wrapper"><pre><code class="hljs shell">redis 127.0.0.1:6379&gt; DEL testredis 127.0.0.1:6379&gt; sadd test redis(integer) 1redis 127.0.0.1:6379&gt; sadd test mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd test rabbitmq(integer) 1redis 127.0.0.1:6379&gt; sadd test rabbitmq(integer) 0redis 127.0.0.1:6379&gt; smembers test1) &quot;redis&quot;2) &quot;rabbitmq&quot;3) &quot;mongodb&quot;</code></pre></div><p>注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p><p>集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p><h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><p>实例：</p><p>添加元素到集合，元素在集合中存在则更新对应score</p><div class="code-wrapper"><pre><code class="hljs shell">zadd key score member</code></pre></div><p>终端中实操如下：</p><div class="code-wrapper"><pre><code class="hljs shell">redis 127.0.0.1:6379&gt; DEL testredis 127.0.0.1:6379&gt; zadd test 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd test 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd test 0 rabbitmq(integer) 1redis 127.0.0.1:6379&gt; zadd test 0 rabbitmq(integer) 0redis 127.0.0.1:6379&gt; ZRANGEBYSCORE test 0 10001) &quot;mongodb&quot;2) &quot;rabbitmq&quot;3) &quot;redis&quot;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化办公类包大合集</title>
    <link href="/my_world/content/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E7%B1%BB%E5%8C%85%E5%A4%A7%E5%90%88%E9%9B%86/"/>
    <url>/my_world/content/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E7%B1%BB%E5%8C%85%E5%A4%A7%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>办公自动化（Office Automation，简称OA）是将现代化办公和计算机技术结合起来的一种新型的办公方式。办公自动化没有统一的定义，凡是在传统的办公室中采用各种新技术、新机器、新设备从事办公业务，都属于办公自动化的领域。 通过实现办公自动化，或者说实现数字化办公，可以优化现有的管理组织结构，调整管理体制，在提高效率的基础上，增加协同办公能力，强化决策的一致性 。</p><p>该文章主要讲解能够实现自动化办公的一些类和包，并且是如何使用它们的</p><h1 id="Xlwings"><a href="#Xlwings" class="headerlink" title="Xlwings"></a>Xlwings</h1><p>xlwings是 Python 的一个第三方库并且开源免费。它能够非常方便的读写Excel文件中的数据，并且能够进行单元格格式的修改。它还可以和matplotlib、numpy以及pandas无缝连接，支持读写numpy、pandas的数据类型，将matplotlib可视化图表导入到excel中。最重要的是xlwings可以调用Excel文件中VBA写好的程序，也可以让VBA调用用Python写的程序。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs python">pip install xlwings</code></pre></div><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwings <span class="hljs-keyword">as</span> xw</code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先了解excel大致操作，首先打开excel，打开excel中选择其中的一个sheet，在sheet中操作单元格。</p><h3 id="表相关"><a href="#表相关" class="headerlink" title="表相关"></a>表相关</h3><p>新建xlwings app</p><div class="code-wrapper"><pre><code class="hljs python">app = xw.App(visible=<span class="hljs-literal">False</span>,add_book=<span class="hljs-literal">False</span>) <span class="hljs-comment"># 在打开app时，后台打开</span></code></pre></div><p>打开excel表格</p><div class="code-wrapper"><pre><code class="hljs python">book = app.books.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./test.xlsx&quot;</span>)</code></pre></div><p>保存表格</p><div class="code-wrapper"><pre><code class="hljs python">book.save()</code></pre></div><p>实例化sheet表对象</p><div class="code-wrapper"><pre><code class="hljs python">sheet = book.sheets[<span class="hljs-string">&quot;sheet1&quot;</span>]</code></pre></div><p>查看excel绝对路径</p><div class="code-wrapper"><pre><code class="hljs python">book.fullname</code></pre></div><p>查看sheet表的名字</p><div class="code-wrapper"><pre><code class="hljs python">sheet.name</code></pre></div><h3 id="单元格相关"><a href="#单元格相关" class="headerlink" title="单元格相关"></a>单元格相关</h3><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p>在单元格中写入数据</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).value = <span class="hljs-string">&quot;xlwings&quot;</span></code></pre></div><p>读取单元格内容</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).value</code></pre></div><p>清除单元格内容和格式</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).clear()</code></pre></div><p>获取单元格的列标</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).column</code></pre></div><p>获取单元格的行标</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).row</code></pre></div><p>在单元格中写入批量数据，只需要指定其单元格位置即可</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A2&#x27;</span>).value = [[<span class="hljs-string">&#x27;Foo 1&#x27;</span>, <span class="hljs-string">&#x27;Foo 2&#x27;</span>, <span class="hljs-string">&#x27;Foo 3&#x27;</span>], [<span class="hljs-number">10.0</span>, <span class="hljs-number">20.0</span>, <span class="hljs-number">30.0</span>]]</code></pre></div><p>读取表中批量数据</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).expand().valuesheet[<span class="hljs-string">&#x27;A1&#x27;</span>].expand().value</code></pre></div><p>直接与电脑里的活动表格进行交互</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 写入</span>xw.Range(<span class="hljs-string">&quot;E1&quot;</span>).value = <span class="hljs-string">&quot;xlwings&quot;</span><span class="hljs-comment"># 读取</span>xw.Range(<span class="hljs-string">&quot;E1&quot;</span>).value</code></pre></div><h4 id="格式相关"><a href="#格式相关" class="headerlink" title="格式相关"></a>格式相关</h4><p>获取单元格的行高</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).row_heightsheet[<span class="hljs-string">&#x27;A1&#x27;</span>].row_height</code></pre></div><p>获取单元格的列宽</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).column_widthsheet[<span class="hljs-string">&#x27;A1&#x27;</span>].column_width</code></pre></div><p>整一列的列宽自适应</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).columns.autofit()sheet[<span class="hljs-string">&#x27;A1&#x27;</span>].columns.autofit()</code></pre></div><p>整一行的行高自适应</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).rows.autofit()sheet[<span class="hljs-string">&#x27;A1&#x27;</span>].rows.autofit()</code></pre></div><p>给单元格上背景色，传入RGB值</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).color = (<span class="hljs-number">34</span>,<span class="hljs-number">139</span>,<span class="hljs-number">34</span>)sheet[<span class="hljs-string">&#x27;A1&#x27;</span>].color = (<span class="hljs-number">34</span>,<span class="hljs-number">139</span>,<span class="hljs-number">34</span>)</code></pre></div><p>获取单元格颜色，RGB值</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).colorsheet[<span class="hljs-string">&#x27;A1&#x27;</span>].color</code></pre></div><p>清除单元格颜色</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).color = <span class="hljs-literal">None</span>sheet[<span class="hljs-string">&#x27;A1&#x27;</span>].color = <span class="hljs-literal">None</span></code></pre></div><h4 id="公式相关"><a href="#公式相关" class="headerlink" title="公式相关"></a>公式相关</h4><p>输入公式，相应单元格会出现计算结果</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).formula = <span class="hljs-string">&#x27;=SUM(B6:B7)&#x27;</span>sheet[<span class="hljs-string">&#x27;A1&#x27;</span>].formula = <span class="hljs-string">&#x27;=SUM(B6:B7)&#x27;</span></code></pre></div><p>获取单元格公式</p><div class="code-wrapper"><pre><code class="hljs python">sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A1&#x27;</span>).formula_arraysheet[<span class="hljs-string">&#x27;A1&#x27;</span>].formula_array</code></pre></div><h2 id="工具类整合"><a href="#工具类整合" class="headerlink" title="工具类整合"></a>工具类整合</h2><p>直接复制粘贴即可，调用方法即可运行</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwings <span class="hljs-keyword">as</span> xw<span class="hljs-keyword">import</span> os<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelUtils</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;excel操作类&quot;&quot;&quot;</span>    COLUMN_DICTIONALRY = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;K&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;N&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;P&#x27;</span>,<span class="hljs-string">&#x27;Q&#x27;</span>,<span class="hljs-string">&#x27;R&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;T&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-string">&#x27;W&#x27;</span>,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;Z&#x27;</span>]    book = <span class="hljs-literal">None</span>    sheet = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">openExcel</span>(<span class="hljs-params">self,excel_path,visible=<span class="hljs-literal">False</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        开启excel</span><span class="hljs-string"></span><span class="hljs-string">        :param excel_path: excel表路径</span><span class="hljs-string">        :param visible: 开启excel是否可视化，默认False</span><span class="hljs-string">        :return: 是否开启成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        app = xw.App(visible=visible, add_book=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 在打开app时，后台打开</span>        self.book = app.books.<span class="hljs-built_in">open</span>(excel_path)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startSheet</span>(<span class="hljs-params">self,sheet_name,excel_path=<span class="hljs-literal">None</span>,visible=<span class="hljs-literal">False</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        开启sheet</span><span class="hljs-string"></span><span class="hljs-string">        :param sheet_name: 工作表名称</span><span class="hljs-string">        :param excel_path: excel表路径，默认None，若不调用startExcel()方法，可以传入值自动调用startExcel()方法</span><span class="hljs-string">        :param visible: 开启excel是否可视化，默认False</span><span class="hljs-string">        :return: 是否开启成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span>(self.book == <span class="hljs-literal">None</span>):            self.openExcel(excel_path,visible)        self.sheet = self.book.sheets[sheet_name]        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        关闭execl</span><span class="hljs-string"></span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.book.save() <span class="hljs-comment"># 先保存excel后关闭，防止数据暴毙</span>        self.book.close()        self.book = <span class="hljs-literal">None</span>        self.sheet = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        保存excel</span><span class="hljs-string"></span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.book.save()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertValue</span>(<span class="hljs-params">self,column,row,value</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        插入数据，也可以更新某一单元格的数据</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :param value: 要插入的数据</span><span class="hljs-string">        :return: 是否插入成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].value = value        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertValueByColumn</span>(<span class="hljs-params">self,column,value,row=<span class="hljs-number">1</span>,max_search_row=<span class="hljs-number">1000</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        插入数据，插入时会检测该列的某一行是否存在数据，不存在才插入数据</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param value: 要插入的数据</span><span class="hljs-string">        :param row: 从第几行开始检测，用1、2、3等表示，默认第一行</span><span class="hljs-string">        :param max_search_row: 最大搜索几行，默认1000</span><span class="hljs-string">        :return: 是否插入成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">while</span>(row&lt;max_search_row):            col_value = self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].value            <span class="hljs-keyword">if</span>(col_value == <span class="hljs-literal">None</span>):                self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].value = value                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                row+=<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertValuesByColumn</span>(<span class="hljs-params">self,column,values,row=<span class="hljs-number">1</span>,max_search_row=<span class="hljs-number">1000</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        批量插入数据，插入时会检测该列的某一行是否存在数据，不存在才插入数据</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param values: 要插入的数据集，用数组封装，例[1,2,3]</span><span class="hljs-string">        :param row: 从第几行开始检测，用1、2、3等表示，默认第一行</span><span class="hljs-string">        :param max_search_row: 最大搜索几行，默认1000</span><span class="hljs-string">        :return: 是否插入成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        save_row = row        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:            <span class="hljs-keyword">while</span> (save_row &lt; max_search_row):                col_value = self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;save_row&#125;</span>&quot;</span>].value                <span class="hljs-keyword">if</span> (col_value == <span class="hljs-literal">None</span>):                    self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;save_row&#125;</span>&quot;</span>].value = value                    save_row += <span class="hljs-number">1</span>                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">else</span>:                    save_row += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteValue</span>(<span class="hljs-params">self,column,row</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        删除数据</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :return: 是否删除成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].value = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clearValue</span>(<span class="hljs-params">self,vector</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        清除某矩阵内单元格的数据</span><span class="hljs-string"></span><span class="hljs-string">        :param vector: 矩阵，列表表示，第一个数为行，第二个数为列，列最大不能大于26，例[20,20]为删除20行、20列的数据</span><span class="hljs-string">        :return: 是否清除成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        row_num = vector[<span class="hljs-number">0</span>]        col_num = vector[<span class="hljs-number">1</span>]        i = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span>(i &lt; col_num):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,row_num):                self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.COLUMN_DICTIONALRY[i]&#125;</span><span class="hljs-subst">&#123;j&#125;</span>&quot;</span>].value = <span class="hljs-literal">None</span>            i=+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRowHeight</span>(<span class="hljs-params">self,column,row</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取单元格高度</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :return: 单元格高度</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].row_height    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getColumnWidth</span>(<span class="hljs-params">self,column,row</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取单元格宽度</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :return: 单元格宽度</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].column_width    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">autoFit</span>(<span class="hljs-params">self,column,row</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        自适应单元格</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示，默认为A</span><span class="hljs-string">        :param row: 行，用1、2、3等表示，默认为1</span><span class="hljs-string">        :return: 是否自适应完毕</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].autofit()        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">autoFitColumn</span>(<span class="hljs-params">self,column</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        自适应某一列</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :return: 是否自适应完毕</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span>1&quot;</span>].columns.autofit()        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">autoFitRow</span>(<span class="hljs-params">self,row</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        自适应某一行</span><span class="hljs-string"></span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :return: 是否自适应完毕</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sheet[<span class="hljs-string">f&quot;A<span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].rows.autofit()        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getColor</span>(<span class="hljs-params">self,column,row</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取单元格颜色</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :return: 单元格颜色，RGB值</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].color    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setColor</span>(<span class="hljs-params">self,column,row,R,G,B</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        填充单元格背景色</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :param R: R值</span><span class="hljs-string">        :param G: G值</span><span class="hljs-string">        :param B: B值</span><span class="hljs-string">        :return: 是否填充成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].color = (R,G,B)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setFormula</span>(<span class="hljs-params">self,column,row,Formula</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        设置某单元格的公式</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :param Formula: excel公式</span><span class="hljs-string">        :return: 是否设置成功</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].formula = Formula        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFormula</span>(<span class="hljs-params">self,column,row</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取某单元格的公式</span><span class="hljs-string"></span><span class="hljs-string">        :param column: 列，用A、B、C等表示</span><span class="hljs-string">        :param row: 行，用1、2、3等表示</span><span class="hljs-string">        :return: 单元格的公式</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> self.sheet[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;column&#125;</span><span class="hljs-subst">&#123;row&#125;</span>&quot;</span>].formula    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">killExcelProcess</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        杀死excel表格的进程</span><span class="hljs-string"></span><span class="hljs-string">        :return: 是否执行完毕</span><span class="hljs-string">        &quot;&quot;&quot;</span>        os.system(<span class="hljs-string">&quot;taskkill /f /im et.exe&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>办公</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对考研的反思以及战略</title>
    <link href="/my_world/content/%E5%AF%B9%E8%80%83%E7%A0%94%E7%9A%84%E5%8F%8D%E6%80%9D%E4%BB%A5%E5%8F%8A%E6%88%98%E7%95%A5/"/>
    <url>/my_world/content/%E5%AF%B9%E8%80%83%E7%A0%94%E7%9A%84%E5%8F%8D%E6%80%9D%E4%BB%A5%E5%8F%8A%E6%88%98%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c1b4f08aed1aa54eb7deb97f39f37807599b862f5c0a262a0b4cefedbe2da567">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc9d1aeb62b709e2f6b6282f9e532bf0c78b0542529a1fe400a03a6d1e5573e9a329c54793f65b20ea18ac3c492e1dfa755afcf53ef6ceb344da0cc790473b59a37f438d320b1d2bb4d586762d14c68e9c1b66d5d05d1f6ccbddd8cebe0627fda9b0da3c5dddedd72f288eb9cc5fc5a40c1c4c4b6cc41cfdfb00895a9b3088b51cc852e9ef060b84750b38b1d4dfc7a98ddcca4d7b8cafd1218f51ccf4ba6d1208fdb759dcd0c6fe78c843014b80eacaf382906f02471937de61337ae54eb1ecbc4e01d2f6abef5c7c3393220cee679257e8de215574b21859330b96b6e00909dcfdd329172b58ed2e1d0d1a1139dc47281f977accf3430f4f317f05e0afcdbc3443bfb7d0278f13f5b1284365403ae75f46a1aa82a23a7f4d0f2b92075820fd8bba1b132793b1a55a40c647e78399d79b14ab6b474de677904366889d298937af63ff2632cb4492663e38672141a25e4a7edd4e206f605e79afe04fa0af6e6188249a6de094f029fea816ac98066242e47b151e1f09cefa1b036ab1fd21dd01da24e948ff60e3291875ef3e050fb79d7b79964da52c29fd778a9f1b776fe6483d2033d240dca3ed73bd7e0ac6defb0397cacd297d9faff2540d20d91bed07311987f298593d17f792bca6fd4e8d55c01f4685484e37225757155c228e11031865caeffae66def346b0e3aa3d5f3d8a9074bdd4153670ba0a915594ca5d807de70f73cfd99397a17f8b88b7f019896858dbc57c9e777e4da3092578830881c87d462fc65ac515e04e9ff8059848dfb6f8f6d9483a6f43346c93930fe6466f54a1e170e228888946086b02be19040cc7a5a9d53418f3f3d57a3c6c9418513503de3edb076fe78a9cd4539c7581c4e954788cbe7b2e4128008b8a594c7e17ed52e5aaf279e8864c6e2e83cc34fb7d7481161b9b2144deb7f7d6ff289319910d350487cdc165876023a7357f9f925ad65f5e9d8459f52c59cd27df8a4ef6f217a893d4c1edee09f63a13aaedcbb829c00d5228d0477b85315a3537c432494838babcc308bee3071649b4f72ba827f6bdcb0c96ff4c29ae04a6b205d72f63749b4c82ae93aa495e82c023bca124d9c8cf54325377b707a197bbabae9c43089ff200fa6d0116ec987cadfe15f30b6a519102520ba2291f70c26067972afea53952dce1862503f931d245bd48a16ab30a4409ed3fe0b166df61059195936d029de4993e0638ad65bd5bdcb12490fde027c616b73bbf7c6bebc3829bbe6f05b11c1363d6291ab93c08be776353af5f16165230cbd4ead649bdc113098ed851007f8a496bc50d6ded106ebd95716f8368b2d32b5b61454b1678c6a9d6f1cbbfcf041495f146145fa290812f84654108aaca2ff55c4b126a2f73af383851e45ec25a9d88306d176357d05308e58d3da1598f251cfa8b6513aefeffd718d3ac9b5cf0ffefaf8d789e8501cf2c69f0dc1acc083615612692b2ef5542e4f1f75b0d1aceefea2ce735e4ccf1dc71f0c9190b26b63a051c50173f2f43c8095e33f7db20de067a5a028c7de7343ed90a026bda0edf8fd8e5d1fb38f58803229d643142cd5e7efd06795dd2e0b0f599f7b6a501fdea9bcbb0317085f5ba545ba2b7cb170f339c29b4b8074744ce1181c6c8c168d2bb197fee71943a543e947dbc1671823f0252a1db03069e026357057e32214bd4e75cb0a4bd58f22d2510093baafeee13a4de165e037e6c5ceb83b7e7492b23fad304bf2cca938a70adbb98f6c69490024219a7dbb5605573b19390a5a7315ba1aa9d4d45439461a82285ee2494b3aa6d3eb445a6869304132412ead26348e8dc358611e31d3872f94ac3b8301084fe911d899cb22930d09f6b8703b2dbf1b3e7adedb241ce4f78be8bc43b3a4d12b270976f246c4d9b811de52e34d7ec21211d2d10cf58cd767199ec776ba289a1b8fdfbc5c9b4c3f61e969fc0d05af4523f9b9834026ee93d54f7ee0f7e2ab02c066f7ca2aa944d5d6c4719c67649b3d8c49e6c8335b2f610543fdee9946440ad0b57fdf133d8c1ad2a52a4fd42791577bee3bc0d7e3a01cd37fc780b9cdbda15af1b4fe4d277b1d2a9d641c76757c4f17da07dca0932c3ed2ace414e6814c41bfd9067cd2e5b471ae9842041c0409888619a9a2df012b03405f0c14f6f2f8d1f4e2a69d1be8459beb4859591b8cf957d61b2661fb53d7b4a48630f366eb27ecc2fbb1b406f638b130abf199aeea79bdad52b88c7c8791179047b8593bd0265ff518ffc9f02138113db0a4d1cc67f6cc3bba4d1d83a07264b09e81c8ede16af32fe306a39be9167165188c67fe039fbca54dcf89180d813342ea4f86bcb486c7638658384d9a9eb5d9e15970c5e0ed07850e33af619db03a0eef2080264b8bf8e8a5efcbc204285b7714c0ce4c8478a0602b8265be3a3adb8aeaeec455b8976cf2ca18bfc706b6286b944bf0527002b76c4ebfd0bf29585565ebf5e87a3a0a4707c71fd93bfa97ba4a24ca0475fcb293f5a1a46aba0968b64ca3d9c325222e5ff75d259743aaa1fc083ff19eab9866e41d6b840bd0688f0a9526a69950dbb8bf14ca61ad996722f14d84738b54bce90cd0ded0eab19b873d8ebdc4d2979309095d2c854162b35d2aa007b7976fac12b1c58276320b5cc1309eebdf2cc872499c9b9404e2bbfd4d5e6f49a709fec15635472f31b26af24761e5fbcbb7eb55dac41562fcdcd60e9255e0b6353519cc4e5fc41befab919e13632b6126458b0e8eaf34e0d66acc400b46966f701228c4bfe3d6b46d2934ae418c6f85a0526f0ec7c733510a527a9880a94dcb302c595a44925d5b21701d5f31d9484402d3e41a1497f8a53d24eac856214ed6e12bf7c64dfc83e0bf1074da185a4fad309358f6b8bdf07223678934bc4b8d6a1570776f2623f68913c4b9cf3bc4c68c428a0584cca7c16f9bedea2c0e85b1b35aad8437850af262d6a6ce95d38574946d6912f4aa6c6b79c01f02f1d744ad68cf32614b8deb2abc1a761388c03c3c2086e8690bdbf664d0b1814b10604080f5c883e609f70122b09f45400898bdc73f716cd7ad9e89d24c5928dd5ac1822b5c89206390b0a80f556394abb13b498d8924ec77e7a3a7e79c55580a2a1045af405e1e745cbe253693e89bd08f7b0b8c4194dc9b3bd316e69cbd870f1e8795890c6c19b062bc42ef2994e138512f20dc6a754f6480d07a3487bf840d03cb958ac0e9dbb0fe56617105dc708ef00da31dbade2ad96b650caa4ed81afc033afbe7a6d3cb7e378fcf0fd5d69f36a7045891b177526f7385511fe83d9d34936be52247916f197c9bd9b88a493bae5c2be2287a2a38aab89343fce08f0c35ca17d4a0c26f2838c9d23d9e3935c659ad2fab0aa94da46695f81a471c309dae0540ea5822af6d6585565dc391747d5a0d2b2b54f660dd546d0b87e9556b1060827160810f7eacbf536fd961e594a5ef309ab79170ee98124b54b8b9a08f02d65e1ce61585a62494cc9351a95dcc00332f413d64b465e4f2f05618bd80fa84fc964015b02e0af7c78afd2a1aaba5cc67aab62c8f85060031edea2109c74fcccea9920dc26e18127661cc28da4215a9c636c90edfeb220918d0e78cd2e11437faf5208f53077b5316a929dcf8878132bb40b6351d787fe16c08fb79369546854bcc5e884882cc1e51c15f2aab904cbf421ed98d288ebd74c3484358ebf5f25918c3a65aefe7caa84566bcdafaeb5fa9f94a11f63661f33d3b7d773258d18865daed992f49c3a729ad7914f4b81c98d70ca5cdec69596133f33c8365ab97f0699285ebb3f0c52b94ea4a0e95d90d9927467b064db757bd6538a8a3344e3ea716b3e392d30bebfa7183c2965c6a370f9ddf4982a250bc1e7e5bf4dcc58ddfad01809d086a03f66e8023c3653de2e7d53a7e8bd8e2e875bcef772bbdf6ba47c5a6b1719fe1da94bdfa006dfc0efa6b17fc0083a7216efb081230cad46375e5c9c9f80406df14dd602d757a40810a2bd0a431517825aaa3020526f91f02d925f3656a9e6ee4ed3e83ccef218743a635760c862462b74b676345a6002b2fc458eb5c3f3f0ad4db5a8e3f10bae2954cec4024282efe21e42f8ff60f6abcf08536be3475e295c936bb557554078b32dd87edceca6808c0cfafb9421ba128af042b2775c123e35093f047f48d971acb127f4276416228a99fb9be3646b62998982fedf608358a61d5fef63a8401f3af89d7d0e582083c42dd9dd8db20f99fc10eaf796e6d4bf5f5d33ada9cfd949abdc03715c1cd1b81bed431c727d6334b0fa434560678acff35f00bb7be22d78bba891a9352ad3b45f26d94510a89aabe87d52fdcd5abc46974fd3b4638dd1b490223f6135bf8738ab2b6adda1a7fcc9296ad719f904709a5ad3392f41156d7d8b677e604967ff3fd16f4448668825538479507fc9e3023b9505a2e6f93e166352d192f45b2983c1772689e7b67010c54bd05ae5e4c55be96cd64058b671f8deca2e62e92433400f6425c931d553b2262dcf2674380a8d517ba76bb9e06b30f0912163b32fce7fd6a42bbf6233f945cf0a91fe079ab3f4b011e3c1315ff6084c36999634ac20183925fbb91c27e4a49910682f1eb833bfaba6e020ebea194b20da5e9312a8474292336854b64b85256fa3916c9247ea586c52613250ec81858438f3de0dcdd72bceee2c94b912dffe1a50a5c310ec0fbe7d237a0afd6893b145fea58abbf44211948868c15c198030b492010ce4a99a7d25e0c2f8ecfdd87be124ed17680f072e76163e5cc4c6a1e95410e6d45cf359d51f2e5a16c292fa2f402f375616504a43e099c4f5e8c07723d63fd5043b7789a96e812502c5f2ff0d949b6aa656b83b74e069bfc5029a0062a45f539c030200e6b5eaf53ad7e0466d57d0a175bcbccf8ad7c1a750fc7ccadc31ff473281ea42469f9197869e03426de569a560053265e8c4d7e4016dd7a0f3366afba287760713aa8b61136da4ed3f95bde986415483cffd734e6a2a046159a7ecc9bfd3ecad04f3b3030cce7ddc904d125e36e338b5efb566eb2216e3665d724e28e4f6130f754c830cbcd74b00cb3712eb18ff1f870f8d627492685ccc188a6dc9286cd265f66bf96cfd2c012d36bafd78d840fb7935e3a6e00f180d21411d89b08a6069ba44d5bceaacce3d91b5c269a81c7d7c772929fdf83f3d40471277df50c080c8d66d2d8c5d60b8dd7cf4b1ff8e163682491240c00883e244deda953d9eb8a863d23fa17bae556bbe62a46c6c1c81b4c277cb2916c0edc56ead3a559671889bc54338d863424ef594a4ef83ac08a8e6d38f3e617eaea552749f73cd989c28bdd88f62abc0bf2fdaf61d16d8f9645ab7e02dfb53fb0eb72d5691c1981cd000148421e8ee5d9a492f56b20a898da46646776661bbd97c005166f51a59db9f63e3630e54cb4a4943af03768d45cbb01216c7f559a428eb7f60ae995c78aa3d1471fa2afc3d8f4a73f29ccc8505fadf1b5ab865453103e4efa1232f764a6e1469a6e8c11ad5a68eb2a72e60c64b63d4898db07fec492cf293df90afb67ea473405c7fa0aa4a7c1411c56048cfefa4de8102d040c412ebd0cef06751b0d2e7dc05b5b733638d75e3841654e551a8ef18183527721876ff793746ef3c868065e8bb587ea8b7098c1092c64ae2d9bfdc7125011de2a38f0e2576ca364e433bad9eaa989deecd9127efbe41f3617c9c37f603faab9f0625f2d38066eef891b82c1099f3cc0e81350c08337d0aa34ddd87ce3fb5043f4108e74cdcb3dc3263bd648431708135799ed50a0732b5321c6b3b658dfb60d5a2844d049cc51f84cf880a18b145f1f7d0cf8d17830e7bfe2600bf0bc187a3c802a08f3e158c64d15bdec15111597f15fb3d887f405680d3d61f33b1dff2fb9f05743ed5be2cc7d90e9e1430c89915c66ef2d8a8f6f8e3d578aaa7e7ff15576591b0312ddf05a55072658997023379318cc511ac3c842c2b02b71d43741a4711dab2cd2f891e5ace66f5ec540f53ae9376c62080fe3df87bdb3acc69ee89ddffa4910ff241f0d1c8450ee074b19ad1612ee9ab0e3458ad45adea452ca19d2f1b1cc69c6b096526e9c32b8b06802a84c520ce6fc19bc3c358eea3686cd7aeff3a96e0f189c6d930da27d0f146fb0caaa3ea118b22b5924026dc59df7a4a892f31b46500896051ee4643b7e565524d999221dc1c437fb03545239ec67ca01b284b299a30d024c0026a5f92f4760ef62f494e2b9a9b4060d002e8c184259a4aadf66b698009e2bec9bb8b9d16c032dcdb115e80b6191d12233b57812e07313100f9cee790c10287cecf3e55f7cd3b862a496d2fa55cfcb7ec0e3acc53195b2e10092dce97b8acc211d4f860bd00b1769520358c8ff1a6a306b7f74af08e1b2fc697e92fead1cddacb7fc7ce61235b411f2f482309fc6dc3487e69a37ff97f5bf7ba34c8ec4fd0d1f8653dffa00aca54116d0d3a5ba1a1d014dc83217865e29f7a19f0de6bb177c391fb44890839fc11c4e2fa54b3b6dce8a2f77ae27c9ea1083f263801a735ff6a69e2f086e8cae337584fca81c37120e866fcc4fd3bf53fac09f545212bb406ac66afd406ef4c6b15b0457a1cfc53b7cc0f7378545ab46f115147472d89327a35f3738d5d3e5efe8f504e8e67d7d1a079ee5c56de4fd6d1aa4111b50c08f3d5cabe5fb9e72ca5ea86056c3d88f93b2f1f9ca06e0669099f60a7f789a671b7868deb421b14d42d616af01d51c374aeae3d7bfa29db820f02732715ec32b65d4bc695ddf170a83e8b001c7c3ab68ed199743b91dd484c099fd818ba380bef4be13f9cfcf36fc4b56f4662e507f1d170ba1f3cae45aa85c7ccc63740a5f5849691041502cb1de04f34eaf55e02af93f4a18bbb1921ccc41fa114160116d3b0ec1f67674aed6cca4ae3eeb990a943a88cc7d3b06d5497e1c27897d7a0efd9c1e7f2d1d4b252b07c373b79aac01b27e705fb215552843317e562a79cb2da3f372a711126206a0b0554d2329fb1c2520822fdba48e14bea02c13a82f87670b2eb110a57cd8319787c30b1e7cda6ea46927f6e48d7a7dcc0f0c96d8eecd818462f6941316c6ca6bdbd0c2efd73a2b50a41af5611697e44d75e4be94c4b63ab80ef30f22976a81c0efd3f6fad4fb75d99dc5602a96ccb44765b97ed8865b8aee79ed2e83a25a093798ed506858e1a662c398a352ec6f4c48af6c838c03350ddee7e8fb041c4a8c279ec1657e99dd12ff1bdb65c781b4d818382c779fe813cb0f39c59cf37153def6321d953cb3e19da5adf6db7ba57902fecfe35e36841bbc3696f01d94bfa37b1239ad2dce7e069de2a3231e8c531c482005b871cbb77c43303f533a51e3aa6c6cda656b222318c3ccded79eaaf5f47df74c7bcbad6799e130515ddd036acf49b81fb71ac70ef0980984f4f299151af47ba1d5b3da1456c02e24cd27b66e19f608c44f4de129724650e082cb1c873c403da0f40e8f89d689f4d8ab942e4c0c70e4a05acbced1cc1b9139e2f04834fdf5b2210e5ddc32f331897cb4af5af23bbbf53cdbd97a123a00c345078e84f073d82f0bed1e3d1522b229d01c31e1d869778e0d0847d5767e6224eae53bbdb998cb173aa5a0914e9ad4c66538065005b800062de2c2a16525542618a25b7ae467cc6dfd5f0aa6e0cba227027dc25cb8ede4750f12ce53329a8f2ced00ec11ded6afe6dbd0ed258b939e159d4dafef6bcdfe8848aed3a4120ca43dd8025db86a0a51175c0fdcc9e9551a6dbfa857249be2b3e7a06720c61a0dd23f575e211607e79da5d661cb863c13a722ce7d815a799094943e7a93d0367cfc6b60b5cb96de9c5f37fecc3b9d1d76d98aa856adc941e2ef5bac2b43619a708994d40c1492d2eb973571c5e9f7d711d9aa7825cba24cfe50944cd3e139f74ee44b53985a75ff46e487178fc15658fa34023824f0c0aec9abe2893dc0476b44d89e26eea06fbf884320dba1db6d0ea3f40c49fa793f44a87e7304b7e66f409a1d13b482cbf63433f97a56c0844bfd416b81037b1e983c06c752ea3c261a8c8cd268a1bb3179cffb6bfa2f352e0f17ba237992a9049a75a959b25b726d65ec8395186b839c96e6b51b3bbef8d17c0315c6c3306dfde524392c92c1f5991d484178db9048e556c6ffd9bf0b368afd8a23f099dbc1a1b7186a88e164942ebf518728edb462605e1fdef6e449a52cfa1ee04adc90478f604ad2b198909cf5ee43d50558ef92c073d0a0957c5f9f9c1914bc23898e4b958ac57374b316f3a5a29e2f7b82353000d6b6adc52189ed4c05b2e6aeab8f461b24be61e4fb9597d814f54a42566e9bf62ad2fc24433742fdcd6a22e56b5e19db75fef106f8779513fccc7ea8ae34ee777635f0cb9054c15f24efccd2d4e5298ee83322a92b420d2736c0f9e3f289639bb1c705dda561fc5c3aa1d185af51c82c4c09451f8287fd19bcf48f5621bd3a7b29382b937ad1c1aaef7d8e01339b1d1c56ad79974c426552a74f636b89f288b821f1442a00307c1e19e70ff99d60180d1dc4a3a7ebe3081d00413a9acebb515e47db5cea227836aba14b9f4c121509fb65ec32a9595b7afab7aedf1e831a289482253076694556821a5ffa0b016d778dada016aceaad8b124d1fa8d14dc48ff48d2b9d2ea196dc4746afcf0f71f0b6a400764d2e3686006443ba9d910c6b3c6b1118ba2c5d5e1637d76194fc2e89ea1ada2b2baaef18309fd76e2a5d0fa10de59c38969bcc27cf6f1faa4dd0d8f6ea914f573f48ca19d3a113fcd102ab37f60646f18d7972f597f49eba0bccc3119dace371ce4532969e819a86bcf6ef930f182a0fc4dc64b9d9586d24afecd5931c781c367c6b2e159ccf37189e48014b5d989dbe59fe4ca37b22eff2d7513d4b4fe3770051e8319d7d53a25e444fc708eab3ad1cd8beb3b64b98995178195c61651fb487905854acee7eb8b1e9565f1ebc65e4134134c19432f9f9a661203f20d15a041b54ff5b194f0579205763d01c7f4b744f3f970490296539795364319ccff594fdf196cb45ee110695c7fdec063e844bf617716ba3d4eff6473e98158d307c07a3ec24dc195bfd3ea28b3dbb5495b29b4d5bc0f99396906e956d15b129afbd99abd6f7b8cf11657b68d8edc5a1b944eda8455bb87a6eca02cad73b925038bd757bb0d9f98f046ea526c6a4603107452bbce877a82c6f71c4f1b582233c505e558b9b93eff49ea215ae5b729b7fd1e2b29c2985047cc2892cf0f40234dd69bfa90615ad1259eb7702e6ca9249df09f695b2bbad2b9ae4199d1f895bfee693a6f47767a608f3062549b7baf38dddabadd0ea21ac4d1037a56dcf4bde0785e60eaba991f6e389430c0bf6033a6444e51a5d9b4cf9e9cde7539d2012f5e0d73e83257f84d04e4ca1a5e42561af5d84c7dbc7033f695fa032b8288bf6e47d5ef5823e841b0addcd590a63d8aabc31a151aca07b476343a54fc11bb77a46c5db0a22c587f984a5bfcde7bb21258d8a0397fcd97683543a68e6a0fd389d61c1129cd7ea759565c95e4a09f41cbae6ee51447224a79b7187963cbb39396cddd2b261f3af81d962751301c50ed93fb5506ff19f3842580dac7c7e6639e84a5b9530b9c034e53b47a477c9e71b74033f59860a2dd84b7da6e9b4c9aad69c4761549696d71de0d996ba8387ed642ed586ebaff5d41e9c513233abba478b5e8a41fc7e86e2754121e239489aecc430fb88fc9792e22d98db6ed38edaa2004cc256240cd097782728146b8f2d2364904472be48845b68cfd4d33d31b2af0ac156d4b3384e4e3225879c2d62dc652a074b5cbe98f69578a4ee135043ea4297bd0fae30fe6ed2734279ada22c333254ed8fe537f9242822453c617a0a1531675c25c4b74c8255f108c35238e1927b33a7e363bec427767663acbaf40d370d9d88eca2c63730440d0af07bc634a62062df6a2c873913efd25e236a7504cecfcf5a6fe9293f8e2401a893705f6835e510f46b0d855bc785a9c8dd5316281cf44a7cdbebd20ea87aaec097aab11dea5c3faa701ceb4409cf391dac272d1e9daab1afd84a93b91ce71338269872d49f74fd234781fb13b77f4f325415b8af7e66f9a4137c9ca7539db888e484b22067993aa65aaa72f24564f50df55f20d8083873f0f9e189e2c0023ccaa43f6b6951ff82e05917877cd0df784531fc5aa5e45cf7db8e05dce9ca928694e02994a50dad22ddac5013371abe0b0a9010af723ea64ea1c10e0cc6b5e809c0bf33aa93b18ef9ab12962373250714065a68d010d216467c3d881d3eb82e404c4f20ef4d7b3ced8ba0b24c8c7f54da92e2e3e11066f2b19602355bca1339eac77b565aea0993678ad18a1536f7ca829e256178869e4fe5ff75f294f2a131b9c1ed133e6f404fb55ad717776b09637f3e958993a55e57e15d0191ec054751917870ba5c75039733da9b51c88727bb93ced2785ea5c31a82f29cbd7e147b1ce5464c4f7d9abe95bb8eda70e58a332b9f5e6290a3c4a3fedc011ef71a0fc52b5f863b5744b4881c69934048c4c534a3a2e095b7318b307663de9f1f01038c9571c606efd9a9f38d2feeada6d3bb95f47ec223afc114aff3200b15b765d6ccbde90ab49d80c4ea41997e0a8fb4beedb5cdccfa9a4f445ad74260ddb4fc35648f1afcfa8a1a0ec17d310d833e1b33e8442b73b609ce50936fe326f821cedf7622a2534ff82fb45c37bb341ca0a3aa7d243ad29312788d34504e4a3378daa5be7656c1fe4ffaddf8420eb3a3b17c4fecb880ecd2aa76cc07e8e0d93fca35c361d0fd6a1da077eeef81f41e0d48ab5c53835a0c3e7fe30436717d0f3ba5d8fc97bd4726d9e29746605e5dcb49824d1bc34ff5a23e6dcf9882e3f4ce669e7e6377180f027732b73335f6165119e2184e9c17e9897d8243672f9880dedab6aba8f7959762f5b4faea6792be5dd78431269c4fbc2ad41f6a09b564dfaeb3c46f773ced57f465551584e8afdb3eb617bcc59435240a0c2f7259849c7b88992de754264981d206fc9de7e75dcb0339d72397dac0e590c28b816d2a33006d6c1fe46c5b4fd6e83a396a31c3787a9e60b9185993c737d109d604afcac9f11c1612dabec06e1565fae74430d712e0f6d77b809da9182d9a1bdeded64808abfa3702cfb93fd22db79d1ddcd01671701eb69a5543f71634da9b115612ee5276ca9dbd6dab6a29931cd6528805cdc740e51f4e83eec829c99ee59d356a17dc6f8cd15c1cce2335a2c81ba3d95195bc4b92ee8081de0a5ff7c304f0d8835be181677ca455a2079bbb68ca5e14e4f7467cbb6c0bbbc0283274bbdc4d231ba5844158829274590922fea580e65b993ba0bcee05ad504f08ce15e4476b2a3347434454ccfa7913a09d64590e4dfef5bb6b0f3c1d94436cdbd29a7cb8a0f4ee5ed74325fbeb53b2b3efde28aedf36d01e72dbbfa6f548a474ee71dcce3bbb62d9fee04e0fd873580b47e42ea3644f61bc3367e939e78dc4a9a4237063a60dba74113bff76ffc0b1ea82b5c41f333951e0484fbf9ca8ef40241e258e6b1ea94c56de1bdbbea4b09c071c50196ee551644c3c5f20336d3fcbfa93eef2322edf004cbfa690b91e7982322974116da0974c07c71d995bfd177a08c7823952c900d12a1fcf660baebb3a16aa6eca04c299281e4517884bca6d5e87971438d74858b6d0bb64802da48730697cc9b8d1fb560af274c62795141fbc8001ac401102720e25e56c577eccab02c8af787d44c6290c6a940216e4cfb21b6c2a74f4b9e2f09a7021b3079763b223e6c3a42654593de3d53dbd818b1011b05a7b02dca73be399a16d6a784de7f04e69a0ad9fdfa499bad4a24f4dbcc564aec73d127cf1b27e6c9f6de66820cb27773f1c4f8fc26659a429770acd7345d3f7dfad34238e53bfd71f8eaac6571d2f4002779006fa724cef19f5263c28a3b1a3b822d21caab511df5c9a6de683da87d4bdaf84b20a3bd91bf94db75d19a0cb0d53b645c63175bb748e89b4f6c8dbdaa7bf4864c7e8cde5afb413e6c5c61575ec6d6ffb373d249609b21936242c85e2174c1aa19dee520034ee8e305feb1875018493bb4056c7c012756e36597372704eab4ed64dd512bb3e9737fa7f8f20b46b7b3bbaf64726cabdf6ad910c692e02a29ea10cc4c8037fa12361a658b283193e4423e39e556d7d16207d7f3c3f33549f509f56deb9ef1d3a29cd49472e2bea3f03d758f4b62e3803758c9ac41f06c33fa5873436483f8b62b92eee30ee15f03464ddbfdd8b34c5525794742c0629587f744fe04bdd3c1889a51f29bd746a6531dee2a050d868f96dc2dd528a5e5814ca4f781f75b8cbb5cb4c00b4506af47d8d392273b8d1b505438fde5604c700c42bd536527aeff4fe48b95a4bba3671aadb13f35c640ec42b9186387d540311867f4c173ca3ebf4b08f487aab44b230859a87f759fa9874f3854fd609c8fb9ea58f1d2cce694944068bf13a50b6d5226838a1c2fdf1be716324e056816aa67093b44634e8cc75fc7052467aac46a71769b1b1c34bc300ad6692bc2dc8a3efeafe9540269814042e810fed2c5770962308e3113765a2c5d552de73072287514cee59978ab3865417b292041a760e98712a6af282ec491212a231234fabea5e8b8d943673b747d19241ae38dee9558b7e93862231648b82e9157d35b3fac3c2f593a0f4cdbc74d4c3fdb30f15ff63208014f8db16107cb3a4171a3107e25d940e28df5004efbc5f2e26a433a9417ba913a9d1a1ae17e1f9925bc0f93d806162cb104d88338ef8b7cf8483a23235d2cb859c81aecb429515b0efebd930930ffc8bfb51059c10cd4fdcf52a02083e28230b6a97e13e109d317a6dc80610926bc369b40831d243e95b28e35ff0b5437e9a821840bd1c36803f7bdf30ae86d9e99b6ce58c45656fc2aa15dac0ad2baea472135bb21c8f591cb2616c9782f169d2bd4978456db246dd9446b43b49e531d6091c01974d68f161bca4fa67ab3d22b74d2f8fab3584d4e6d7760e9c4fb8eaadca4d312b26714475f5b7b397d68a37fd0c15b43ce971a7a8b5c24b828cc80f32e144d20847edb5395ff34e14630fdb87060ba438be5e495e24173e771d72d2c57065e1114481efc0b81e324d6d8f69c068d8adc5c4f38053420bb9473b70cb3b917ffd55aef79f64834009226c78f6a86ca492aa5a272435728c7af05514a8d4aaf49aedb95edefaa5fa0e404b40a3e005b74a6f66f0fdfb7e099dd68bdc297dd43d032f6798e00971aa6fe6e9359dd85df32e8c8d9765f75ec737d4694ae400004c8eab63ac6fc9bc963e7e645f8d2d1827fa3345e7ff957ba2c59b7c43c13a2182a8fbd8e24f3b3145e39776460c01dfc9a8ecf37c3eddc437333b1cd18ae4e1776754dbff167a7785b0a83883535378dfb01a068580b9e4e4bd6d64eeace45df80b684b98910952865290c6330d8f70f3c187d04ef4606d6229d6f2ae53128a74653585c649367cce7cbe833001eb2a640f215c85e3e5263dafc3d119505a31e4180262cffffa8b8f38c604852fe184ad73917942989b019728dae915c76146947c648487bc71aafa2dd277c2459751654fe8f32c4313360ae4970200b7f0c3b38789e8c9b0c75be7154fbfa7114f059dbab186b96bda1f6be5338e422336a3ce50af08d4da2eed5582b83bf011b332c952f1396c9932b1c990f31d495b8bab57841168b5f0e44cbc487b4a294ee725a5809218b6215f72625c2cfa62fd9f6a8c89f61f9142f33a3a8d849754108f7b234bc47719a4b830423e1f616cff350b5e80eff07e6afac7c2a06b3b515e0acaf10e247e53b6bcf628d505d73c470b42061321eaded9b563bfbc30953ea024b23cec6e67da7528e036a1eb9f32b9cf118c420891ed20b2d4aaea8f8871588382f5c9b7a33676fee3a551c0e4d84af11b77a543cc10ec1a7fdd616628f5d1704d7a7b9a276e77d93bd6266a602d44b90b07d85ee04c81f6e1e03b44be0fddcb384724671b575fc4bfb94bb4927cc40a7b1ac18bd9d107bd2e1359ac392b769be4997ce8ec3cc230a1564269914561ffafac3ab7fad0a30846253ec18dc68830e56ebaf3ee78469b6e083f7d5ef6a8b85b415257839f97050653caaa646d8d303db5efc7c79fc5ae86c3dac97a17034013e84ba65ca023ac037e386a64a2cb2b9efd81973f2a68063c69cdebce00441e713a79f14c932cec926607737f26bcc54e5ed240a74092facdef3755a87b83e212daa24f42b7a9f6ef9e11983fbdbf45d5730e8abf3f5ff54728b464a69111184e81b564a499a7ae7fa5e703bde477c8b24e87c7e7ed7653e3a5a08fe6dd95dcab36e8f3728c4b85b85b6884747bda1c5c307b321e43f226b54602b7684fb8d572f1c913031d4301ef8feb52acfb48f92abdc66e97a4b993973356b36de7753573202eaea5ca9486c074b431ab715fa1938c0a2d0b4ffd809ca2cea2fd48034a3df01c60bac002dd5fdc62c6a8cf9522cef452d731c8da0297152ee5e0da3724ea5417697d799ce13ce0acb966cf4d2f4c05f7a5801b4ddb2e76f3e4f4fe82d0ff27fc0b42402bbb3c313191490d262108a96200170c6a63e457f9f6371bbe9e0a309b7859f4f46bfd18767a201ed25649321901a5eee15698e0d2ce538f43ea15a54c6254169ff8426edf533dc012519dd2d68bd660243f97fdd4294091cf65bf8a89e37d38bb700c568f12663c1fe0570d835d31de7618db9fc2db2c5014e915b4ccde6deb130b50ca82432cea9b45df1fd5ebad6b2fc22d488bffd26e4c10ec2272dfeda6437c0071d2df250f5fcdb58b9c2af7bd146a235d4c1c0aff9834c52167ac1b27e7c85617bdf29ae7d6b97613c53f2d9999b7c94a9a67271523a0ae1a864aa116eaed4bc05bb832ba475c5eb5661de93afc31e1d9e651ed02be8185026ed353ffa6c473aac22de3c9606c69a9c56d93e18fc631c275fc60f69b48c899f48f43c022c975f6a58d4d3d600fb9dab6b56b8de2b2483ce703b21cbe65d2dca28f47df82c83768c2ff8fb88b0e9f4469d0754f6ab2f8cd074ac0178c7d954c25b657dd7fb0cd3d0d1661d7fca506cd9c5f3f6173c642ebf3d074c491ecbca50cc887e5d8cd1261fd7401693f3713a492d64cc430a1f85138f529a2e8b278f7b94bfe0cc9ae54ab7ab8568d23665c061f9991764b60b4d2b42f547afda9516231dd565ae17acd35d4a1932d1204b59470fcd0afa429698e208665655f6b95dc088f9f16f14d673c2fcf2a0c0a0209274a729841947f3affeb120a1ad623c87e17d1afe52ddf849467b18625249a9c35e0c0f1ff0386d79bfe6dd5fee2c4a89af5bb1e27f2d7228d59a4fb64921e6cfce238fe7fb5aed481d7396e23fd98a408393f38d0323ba0df5efec5efeac1a913ae59f21899382bc28382c44e7b94bdb22cfcf57e467cd8fa9263ea429b1fc50ad56d83b1adfbe2b3cfadbaf07673acd70dd3bf3ccd717439b9db0d31dd2aabbb18f35e552e51d976c912ba14a615980f3e05730c1efb509ff4c63cf52135214e2d9a737127256398925be1b85fab64d58bf4c35be18f843543ef9f594c12952a5c4b5ce9cbb76bb71678508196dee6558c7f6ac95443021cbd89cb045726218f10f75bc12e82ff8b3520a3364843fb924240753f40ab1ffea2295ebf3f7abd73af91d05edfa768783d45ced89fe0a53ec46268905cc2b3bed3633691d4e73775cfc7d2ed686c9bfc37eebd784249e19fd33e44f1c7e4ddfc326159734aff28ed5032cf788f7efb12440b2eb20b1aec8b9d42d4e3c2280602e96de30dd0c7d45ec1dae7dce9afec9b704943b1906ac187220ab94a85db4f015d45b5eb0297d81a5773ff692d160a1cc9187612e7d2ebc3600fde8867b8fb019b98c38038b39745870c9339fb28f68baab85498eb698ab6cb68c92d711a7a03106af13e9fc5a9a805f0de1a80e4178f682cd3511b6622541d990cb171609fd97f10698b2a4dd9de92978</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>私人笔记</tag>
      
      <tag>研究生考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python加密解密</title>
    <link href="/my_world/content/python%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <url>/my_world/content/python%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AES的全称是Advanced Encryption Standard，意思是高级加密标准。它的出现主要是为了取代DES加密算法的，因为我们都知道DES算法的密钥长度是56Bit，因此算法的理论安全强度是2的56次方。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得计算机的处理能力越来越强，虽然出现了3DES的加密方法，但由于它的加密时间是DES算法的3倍多，64Bit的分组大小相对较小，所以还是不能满足人们对安全性的要求。于是1997年1月2号，美国国家标准技术研究所宣布希望征集高级加密标准，用以取代DES。AES也得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜。</p><p>在密码标准征集中，所有AES候选提交方案都必须满足以下标准：</p><ul><li>分组大小为128位的分组密码。</li><li>必须支持三种密码标准：128位、192位和256位。</li><li>比提交的其他算法更安全。</li><li>在软件和硬件实现上都很高效。</li></ul><p>AES密码与分组密码Rijndael基本上完全一致，Rijndael分组大小和密钥大小都可以为128位、192位和256位。然而AES只要求分组大小为128位，因此只有分组长度为128Bit的Rijndael才称为AES算法。本文只对分组大小128位，密钥长度也为128位的Rijndael算法进行分析。密钥长度为192位和256位的处理方式和128位的处理方式类似，只不过密钥长度每增加64位，算法的循环次数就增加2轮，128位循环10轮、192位循环12轮、256位循环14轮。</p><p>注意：</p><p>CBC加密需要一个十六位的key(密钥)和一个十六位iv(偏移量)</p><p>ECB加密不需要iv</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs shell">pip install pycryptodome</code></pre></div><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad<span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> unpad<span class="hljs-keyword">import</span> base64</code></pre></div><h2 id="加密解密流程（ECB模式，pkcs7填充模式）"><a href="#加密解密流程（ECB模式，pkcs7填充模式）" class="headerlink" title="加密解密流程（ECB模式，pkcs7填充模式）"></a>加密解密流程（ECB模式，pkcs7填充模式）</h2><p>初始化构造函数，此时的Mod为ECB</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">@use: 构造函数</span><span class="hljs-string">@parameter: 密钥</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,key</span>):</span>    self.__key = key.encode(<span class="hljs-string">&quot;UTF-8&quot;</span>) <span class="hljs-comment"># 将字符串转换成UTF-8的字节流</span>    self.__mode = AES.MODE_ECB</code></pre></div><p>AES加密</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;  </span><span class="hljs-string">@use: AES加密</span><span class="hljs-string">@parameter: </span><span class="hljs-string">data 需要加密的明文</span><span class="hljs-string">@return: </span><span class="hljs-string">加密后的密文(ECB模式，pkcs7填充)</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">self, data</span>):</span>    cipher = AES.new(self.__key, self.__mode) <span class="hljs-comment"># 传输key和mode进入AES类</span>    <span class="hljs-comment"># 将数据转换成UTF-8字节流后，用pksc7填充模式进行16位填充并加密</span>    encrData = cipher.encrypt(pad(data.encode(<span class="hljs-string">&quot;UTF-8&quot;</span>), <span class="hljs-number">16</span>, <span class="hljs-string">&quot;pkcs7&quot;</span>))    <span class="hljs-comment"># 将加密过后的密文进行base64编码，之后转换成字符串类型得到密文</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(base64.b64encode(encrData),encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)</code></pre></div><p>AES解密</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;  </span><span class="hljs-string">@use: AES解密</span><span class="hljs-string">@parameter: </span><span class="hljs-string">encrData 加密后的密文(ECB模式，pkcs7填充)</span><span class="hljs-string">@return: </span><span class="hljs-string">解密后的明文</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">self, encrData</span>):</span>    cipher = AES.new(self.__key, self.__mode) <span class="hljs-comment"># 传输key和mode进入AES类</span>    encrData = <span class="hljs-built_in">bytes</span>(encrData,<span class="hljs-string">&quot;UTF-8&quot;</span>) <span class="hljs-comment"># 将密文字符串转换成UTF-8字节流</span>    encrData = base64.b64decode(encrData) <span class="hljs-comment"># 将密文字节流用base64编码</span>    decr_code = cipher.decrypt(encrData) <span class="hljs-comment"># 解密</span>    <span class="hljs-comment"># 用pksc7填充模式进行16位填充对解密数据进行转换，后转换成字符串形式得到明文</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(unpad(decr_code,<span class="hljs-number">16</span>,<span class="hljs-string">&quot;pkcs7&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漏洞靶场大全</title>
    <link href="/my_world/content/%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E5%A4%A7%E5%85%A8/"/>
    <url>/my_world/content/%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7a44aa208e821610723dafcf3c096458bf76e8ff24aa4d1c8f7dac79b9960fb1">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc9418370cb03e91601d7edd4ea583524a7e6f3116e975818582202ddd02cd892ce9cd6e4a8d6bf6383d3095c9a346afc88a7ecdd48653fa34fa2bc34233f4f4c4956ec33a51431e6726bfad63d82686badb7a8b8961704c3910b0e2ae44450fb9930cfde9254d4f1e3ea2846a9a91950bb2f5ea4893c2b1e5bd475a7eb544347a9f6fed2542f5b71015a8a448ccf14f6dfa396d8b6fb14ddbc4a4d93aa23d42c509d6338c912f11be5bd385fbf891e910c0cc368ff1068992778b7605349277bdda2f3a480ba3191c968fc1e00ed60de4a885aad90cbdcf3f8cc55a8f7fb33a3a9dd6a17867b596ebac5adad33184d7fd9ba820fbe47df00c1bdb179368dad274fcbc5f86832350f1f060b6015b10d5e451eb4e66aabc76e70b69d87d407a7b21a96f664fb83f4f9f480674a0d91aef1de474782232363841be3230a8d8de6c1f0827fdfd766760bfafdc01bdeb056978cbbab613cb6ce1c0239e0b36b188ceb0d6163effeeadce17725f4bf6e4a70658e2752bd0014a3036a97e774138f405980972cd8878fdba6d6af69e113e6f9d4b79660275367706f7f0677196540e5611387456e8f98a1a296a33a20f10bff12c16e2753fbd65f210798b116d780d80f5c358f56fc3cfe613a4cce268a6c970364e8fcb8caee734812b249c5fb7291e3be465a0edb78ccfe272222b55bb9758c478fbc1c47ce6fa2e7ffd2ae71af470243887aa3b341d0762671e6d41a0a0b960345f499f260c3ada07398053bd6206db96facb8cfde9f400a048cf11128f57f9906797137664b749ee24913146cd6faed062cd42d59281a1b95e0246cdfdb9134eeaa6135a37024d82e28099bac24ef4e4ad064fb46b1a684e85ee3a5711f103a3f0f072636ddceaf87ec424b2192d2de22072d50811a288cc51877d1a2a2629d1a461d464b53871bedf5da47785aeda3742d42910d1db559612be02c2fd515d5947e33fa9ce1b310ba565b13267b6e036a143cc24d13e459195725ebc25bcdc292bd884c29c06be0e2841850e5884c0c662d4afe2e0467df3e544c4f9d6940e4533a0db74cd22eecd28d16ce0f0626125d50efe891f432d61d1002ad9b7d955a0e32b2b1e302aedb8301a1c447beb0a349bd8d491636b4a8188adbac47fe1ab4d2bb5b5c6f1f4c82256f4ccf115021236fafeb0ae08064ed8ffb792c9d6cbbef9ae74b76d33828384120887ec7d88c67d62897bb91537878cbf4dc2b982227c0dfeb43e5a1ba23e440324158611901d01b9bb64a03142c6aed4996e1f2ae93341b34dfe13b475048eeb5b2975b5c1ab7a122df1509a354ea359cb447577265d46ccf867faf1e85ad1c9e4d920575a17ccd0cac22dee16c1f823ffbadbb7f8b11c4c14e5766477f3d0fddcce739aabe57f01aa38f573d3da207ce03ebe5d18d36db3d8f4c1c758cf7e7ab4ff07e03f1b5d72e42c3779aed397a41b34d57a90f90aa0ca5db02c25a4ea905f263410845eab0caeafe079395d10e4848dbaa7cdc05b1de639af385e0aead0f39d7b2e1f5aff0413e2c22bbbf2a72d86564430a7bb066b22fb6d3856b07a65b0e3334677a89d1c787c153aaaf72a039c2942658810252dfd29fb1acf54958ad2b12593c6bb5c9527d9d35dbaadff045bcfd83ca702ec2da8a4bd50cb739ad097a0db2a177618bfb0898ea2d8bcb45ad19cdc9307f10515d854121f86b688f5cb98daabe51f813aab72b03c7afd54fd1539191509d4311813fe04f2e36c43bb5bfa9a147840003f3649181af48a15b2093e70f1db8e796af5c239507cc1dcccc090db9bdeb3cd9e314378b5f53575205a4b9e763430e879e0105ff2da91eb1e20f56e8968ed9da3d55e63217c4341d23d7820593807a2d7765d8b5badba14d184d28912fb99628e8f48451843e1e9bf05dcd5eb3d8a5f29541303cad4597343bca9e8edd6a319ab8f18aa83dcb4cfc68e8d7ca6b079e915256f850280a897b2de912dea19098e2be8769add375ab6c6365c1b37b744f5ad7ade6354d04151c70dccc54dca6e721227534afcfb444660454c020a77f8cfd4197e394adf7fbae54b331177b39458bcbb96bcf7047edd800fe5fc12abc97d92e694301d2d4af76a0fa56f240878411bca308be2d72a2f03b30eb6ab1e0f5734908244dff79ad1e582c45b45f4786e14819dad77a1bf028504c821513055d564cb39e740c1ff26896e313b78b2573098c937490b24a0dcafd3699be848b25aae953890f9f81ca309c9583a09c5ae2bb4a09da1f5359bca96b38aaa2cf1a55eb4f3bd744154704497a53f047fdd1b56bea0079752fb0176e8b77535265bc8362e6be49360686c6220b3787ffba0cd63bf8a72b02dea5b4b2a4ef4a2a3cff929aa97336009a43b14ba653e84ec6b0bcf0550f612a128c0e9a3e06ec8a583478c18c82e1a0f50660fc5e6921602a8f75f4a9bc2f4b6ed6127fbe6b453884cef3ba4ef0624c9bee285e336769cd872e9d94db0f1a444b5b9f2864af18bebb6b7d1eb5dd7fb52d92670ee68ccd039a75006f62dbccf105759d36da0d3411e9b2bb70c2dce4f713463442b3522050c067e33819dfb9104b33accbe1415966ba798c790abc3f9e9884166b9e2a8ddfc93c475b021daaf88188890ad05a7634861cb2a2cd5025006564a0348f0bc3cf03a101a5db440bcf3f9ac8d8375ea5b7713fd96b59e6cdd3b09264e88f63fed2d33a419efe89593f655f6a26c682c9c8460c34519d62d693bf30c7d3bd746b2dec80fab31ca30f6df531ec43bb8d43123cea4fb33a72323e61efc61b4c801a01a550a2e5435e1d149053e7006eaf293d93d7be6482fb1135919ae49966f7dc09eb08d44a808c9ae4cdab4001f8baaebbf314675bcb83ca5cceaf5792acd78a05f87c0ad77acc80564525d34f6064135c353b37095dd8daff70242154185fd9cbbf14ba98ec675c7c65bffcb874417498ce41799d218a3beece8fa60bd6cda7f519b7380e67795e4d872d51868f7dc2f449b5bc8e0f13a2e66670cd2211a69872fcd4bfe38082cccc5710f364bfeb789294087c9c6947bf7dd01cc4c57a955c1673a6d735d6761baa2348558f9749c8f0c1b37d7ede6fad18e474030c75e35f195cb0583c2149d27b6592bb51de0fb5eab408304083eb9aec225bc9c0ce02b33c743ecf8e2035d071a83dfd8113f6dfd209fb6b7b648fa72217e11384cab321aa413b30b1680f47eef464389f11c48cdd94233944a6159099de1d2c947813bb0c4a73919b85dc0b619402f1de25eb88c7dad109c3065af3909a63db162b8ccb38c60f5b1f53ef7027ac0305e950ce00b9936eb7cad054165052eb52a110ebd2d1d2cb964864523a9d4add8013fd8cf2946903ff81c3cfda3f8d301624b8f178b4cddf58fe0d037a816281baea24feec9fbb374973fa8a5ce6a45c133fe24317a825994576e532d11eb54ba48bd31ec34f694b3d00bc459d8d8f99d2954f7c3b749130c1987557a9bad2c9f746561b6207a19b9ee85d6e1b58ac6a0a81f5daa54f828a29d94f7ec7c3ca550d3e26aa01dd17ba3935d11e7e8e198b0fe8b746d33ca6dcae07cd91cb6cbabb8a2fa58ecd72ac9a96029cdac495a55de6a047fa15e062876873154c43e75e17ca67da40ea7897d3e97a3f556ad5585f9506ed8f483f74cecb07c127b0228d3b1152cc85cf414443187d6867629c3604f39dffb4e43bba386a2326ee8e9531a5bb10e13a74c499fb03e8b27bc5ac5a6ec91d12c1388b072e7d0187c0465edc57496b3cb37be2cb2ba5277d0476d24762e27b409299e24ae69b933e52453081ff288a03de3dd04a29c51d4b2cf211f0f4d5ba66870a00d9afb77525c6c7002a2d407878dec1df0a7916a7adb3927fd16342a50981bd0dfa769138bd9507478a51990ae91e87438832a97652bb63f0fe12c4d77c2521ebfcf21bb6223f68dd2305e810b7200e470e434b67ed33b3ae9d88cbe5d8c7c0f3ea4bf2d8432c6b16f8bc846b786b87c42b604de86c4ba4a497b12ac3a945dcbcf7353617b24b19e00905062edc3fa390ef1e9d1ebd8e211e2d47cbce2dc8d2652061532a46b43d992278a6dc0925cd9e2dc4bc9bf1ca6ab95b818310fc4d3b80f86557dc47f52d776030f080b76ff154638d46ec856de0b0a528c96cc157acfa5dc58f8a1e993bdbd5c9cff2c13d83f88dce081655e181d522a79ccd9312867965e61d82b546a28e00ac14b2108133689f298112049d027b759acaf3d076d95124e18b8cce90e17c0bf17c1c08c7b7106185b568d1c67019034522166101a7af897bf28ef8e42f34a0088a5d41d5124a95ddff45c7e351986b0b33f40eba651894f7712bf525c563424cf7056114c74e62900503643f90a7b5ae508a0b0a98e7ddc8d0acbe565d8e6e0307c4dbecd8ae3c1e608b9b9c56007c317dea0cc17fd12496a6dfb54a3ddb435678a34aab4f4df00bac8584783621e9916148e0a52b94628ca1a74924a656eef923eddc2f32f28e7bfcf5e5447c9f2676412a51012aa7364337d60526c5e9c90fc055b6a667fce82bccd22e5b05881eb332a6249b1de1286b3a5354c7a909fde28ef887645e81df0182a2c56fa6d02ba73c28532028b0eafb7ebb2a32bdab7277416a0866569f07832907559e6c18af0fc27345917c2af3e2e017f414a258b44a833ef579681d758aafc6db931a4254c03ac95a8bcaff605aecc354b09426d7a6f90d65109bb23c055dfd4f0fea133d72b0b29f37a58f1fc4746356bf7a106beea51db306395728742a76a77cbc8d0629843a6c1837215463a92d1d773991c570c2d27320e621ac5bc15811108ee2b369de12f27eae6afbe1ebcb91bb69ab3d14887dfc1251c2368824f3dded9fd7a47924d0d56724e9ad54f1f6105fb47344f6626e33d13f940e83cd26526d2b0292f831f6ccdce4a5dc46cb089b9b2de73d3d78a2b6255f6197da44ee0914a2c0a40a74780212db217e1dadd021733c43265f95c3896a4f6fe24d4fdc4111bef3246a93826000992c81e52eb00208ea6aa89efbe33de4bdc1c75ed8060b536a23adbf6e010e2d548919be37bcdfa584963279138ed39cae1f56dc11151116b952fe0a231d54697b939bfb2ecb09acc968de1ee63c18307e6151150e4ba2aa47ec32b679e76080a24520008d5db1c471f11e3e95ef30e5de4712bf8e16ee80006a05c32f8337332c52f17b5b59bd4609a5481ad54bd48d6df07fa3e696c2b5f81f7a31134e2d54b7393c0d6f7e7aee29497576e7a7208506bdab14f65b29683bbd15ecc2ee4e671b79dee141ee13e8db6efbccff00c8eaac00c0d100e745867cdd466923391d2857a8c7c3ec4ae40545ef4668380be7a24b7071b9a8a67bae16bed005839f6f7cfd893551fbe11a02c4ea32b2229e11ec1f6451a3dffcbf6dccd5da8faf98fcd32c0f778748979aba33838e9d67faa1773e57cd39ee31fddde86b54ef94928ef5680e410a3b79829e2647c2d078081dbc3e5481e17207f103323145bd40c37fc4d4b385ec4c49cd56ec88c83ce8787fa30a1da70af434985a2ceb07ba67eb1410e9322e6a1d2cd32226d321939d54d6317e325cd42acb79723a0ec5b61afa6d5d9b3ba110f27c7a3f266770319a1724b89a49fb66c12f15987dbd5d541db6e1dd7292d7a6e7b6409e21281893804103be2af67a775386ea4fe8d87b49728d4fec051ba5fa629c7099e1b2bf125afa79cdeef2a488ef178e972128c5af70e16b2e12e0d2c3ed25c5cec8b5dfd3a457d22ccb1cd596c331d004305c6e91767fdb8e7ca2d496e0c9de70bd84abf9941e9f8e90fa9fa55d4b67bd233005095b92c8a16a9bd375da3394239a3ccda50831efbbc7d478fe8eaee56dabc641ae1bdce43b7e47bf99122e5508b5d728010a1f6358a5d0a5d6ef972c0f79738f65040ef585fcb4f4282aed0d3685f231206a626996c933457598181bb36d279778bbe45277223e30eb57d7370cfc9fe51fb73d3d1bb39018972f04537e8d398fc601a66c0e63a1effdae3f6f595cef86921c2f1c9fb91fbd5ee08e9cacc9c7d56a9239dbbb9cf99a067362d98289e2f2937e7641b318ca3e3668ae011f1e0c380b692232d482eed2e1cfc5ffb9c94620a356dfd7ca7aac228cc8b363f41576d3ad249b3feeecb4709a1ed4700b78de8327af3a20f51745a73f9196274af52b7a2f3dd18f64bd73bb2435997a4f41a3170aa99205a6e27fed16d0b9c687b71ec541ce77f5f6b3fea5e15aee58acaaf2b57e6a82583182c9aa6aa079bd2ff1fad16fbd7f793e28bd1540695d619325320ce510de9fb6c00f28d3f53b9809fa9ccbe3eb1ad452af8de2afb5f24bae96ba93f6008c5bdbc7f60ab7304f8d9aac600166dee329c2b653a5c01c90ba093c40b402ce1e0616cac616ffc97e4a0b246aa4f69dda8585bbb3ad4819f4f9cc00c7e7c52fc041b7b1f2183031fa442fc2e055f1aa966d9a7daf697270fa3f254d3370fd22fab63d8c72c4911e94d09451292e2ba2835e70f0206013967b4a3397127d899a25d4793d4575b7ec1f64f5e6b6e4b4ee2a332627066bd01f7ab47ba1927bc20c2b4e2d14af76c75f351a6382a095e9648f0fc2d2da5212c0328b86dd1f8d20fb0829b63ca4fac6e8165c16c86f727657eb0bda1562f98b7c3b6b0cf935d642663d0d278ecf8024b69e65c2e13b45106160c66765bc88a144e15fa827102e48ca88018683e2c3a9b914001e865513f124ae7f709b446e7352c79465bf016ad3680a107577d9bf09b7deb9db287efa7393ddc7c0f20814b5bde3ec5568f7a3388d01fe576ced15c27ce4adb79a6b503006fb24283aca6ef8d43961662d31f84c53ab3d7363c1a78cc95f67355cd046745a02dede343a1501c0814c17002e8f341c212add9f69e64fb8dfa074582abc256a71bb5d34e5a26d8f7b91f15fe225a2f89c7ad92a9a1db9bf9e605ac971c783fb052d4ee9dc81e53eec606f9081665efef6b3d8f427019d4c0aafbc4626644312c20860fc62626650405bab0089dab0c4e2b1faa8d77c0c8ee6a60e098ce7a629052b06b7d7111b6af7a0d55b3cb06d750dd4205179b276280e8de5725d008ffacb9f141ae6b155879351fa3a5c1cbad8227d4d2dbb90ece9ad55be6bc8567bfc314972cc1bd3a32f838ad330864658e2b8d464fa20434c4b331087dd03ac74cfc236681f674f51fc14a8a7e0eba55978dbd93b13cc00f0f8b10a41268e360679034af8c5b7af5000dc00e25872a41ddd62584a0a3553f725307d64aa3cd67131ced8d88f0d562069bcf87669c0a8191832e5ed872845016d00a32e32583fc37cb3b238c4dc4b63d4d0eb02eb985f985f100b2cb52cd03b44f06490e249981ef263a94115fdf0b5f08803cf96c9f3f9c4b14c4ad94a13812a34f66d10370acc9cef9c42a32392366c8913384f09b7eb76262b7a0da312417d05403b7df74a29909e9079b98b1395365785aeef1788f2bad2fbe21e85eb38ff0170f72441baf6e5a40fede284a4f6152daca8e4aa8c4bb2bb1496cc8668f06b106c5f03713256d46f14df1cc797b4d487ff3c791240db17b8ddaab8a00f9a4a7b8e20b1d38c2469e9cdd46b6aa3b3b7ca8e486ee091865aa2f76e2aec3086660fc4d8208be13f685f5b291c6fb5b3141e6ae69343a3838046f2787091b55af7efa3ae6c2f5ab3d937d9d3478cb6ad92105057781d11a8e7112c16038fe4e9cebee17652cc22e07e87938184473698c7fb9c48c684bc4e7c5a576dca123fea0e29acee824d86150d8ecaef03ed9d73b34b49f76da1a02f02f5503c07f5b5c828df6965faabc30455f7d6f0970b3150b8b16d4bceb2f31e89585f6f0cfcf2da18d51b0f1357558b7116f0530fb074436c1a6b8303f8c4b4aa4a9a62bcb65b774d76f39cd3aecfcc42ccb1ee2c6101d3022038c5f22a19d6825d7502aeea73f8d56a263e8dea6435673d6eb0141d164ab01a927ad11268f898a9b1bc62c6c980c5c929a33a4044b2a5ccb105fc2f88dae9f0ef43d8f5ee1e3e443b5c32ca7dfd215bd571553a1904eb016142435471729d865490769db37ee1ee303432916539be92d411e22818fda512767bd9a7051bd11f80e7689fc9562d91381860873ea5f061debece09a585e54db4fc2a85c5f7b03825673c9a164405f62b3f6a9dd9eceed2185c693fb362ded51a5d9cf893dfbbfa6074369e46b400ccfdbb7467585b3d2d7bcacb1281a678cd0dc4806ad1c4c4fb4a6c11131e51e0aaab60a77335acee498981505cb62105d070b157b82470291db825313620fd7bb02c63d6392f050a49c81984b8e1710503eb358fdf7fe4c558590d948c88260f6261b2d641a312c42a0ae48fffd1586c0f61a71547c5f12739220b96b4f8dfeab4c248d85858fa4b4d9714605aeb89a5cd1c2453172d61d737acf92cd48176fc0d00f099ae7cab7c525dc1ad98f3d009c8e8e96328025c95ed73aa4f29185dec6cc0276145183872bb3db1d50ae7ba865252414b3ad6d5abebedff33ad81b0494f13a1ce668c0028ee6fca8a6dc70d3b2a62bb8a063dc35cea0527cb17f46e8b3921174b3ca6a1ad0b90cd02dd0676e80f2b39e11d3e571c2beffda1f1ce41bc591c4c3b75281d7098a9fe6eb3b662a7482d53424a88036d8781f6700b78310e3e6ca663a4635e6006184ffaecf798e104b503f86b9afcc5def1a8317e946c291122af55298ddf2552ce86b4bdc86ae325b309131912733acb40dab6299502ca95ff57e51fdcb138a26df633364fb482a87c762a567c6eb9f912e3840c4966fc506bf0a969d4af102103ce7f0d381a0bfd2aa6662a8d2854e777f74057badeca7e3942364fb32ea0b48db4cfd6a22f882b83c823c677916197da8f315a58a95efa97357257686faa6c253a4d6b95d6d67c7b6f75149e1bd3ff3db8044c6ea7a7e7e561f0fd6a2bfe5d3a9305ee4bf9cecd197d80a650e4b0e8e18b190f8b3873491f3b47f3bac1023800272079f54616b151a4fec8f804afc3cb6f5ad3df46ad342cb0a89dd9433ba12ffb74dbcd5eb5e17861f0dc7663b495938116efdc400f273e151c469190fc2bb25ef1014411ebb37f1f77a8add79a4b6478a4a9d0b1f2d2a812044320571cecd9860411ec12d0f72b6c1f0a235c044c44c523741228f56683695247085c2108cc67e844f3bb1491ede5ffdcddc8793cb3fabccb829cb8df21266316cb38a0239d338a82e9c1899bad389f12ef7863d50c347ac067d0cec0249e80dec03e7956546757642507e86b9137546effc68100f3b488dd96839ecdda2be168f68889561f374c805a5cbee7cf3490536503d55e8f30248ebad9e1ef7fb358dc571a66266c0b65f131c474c22399864678325eaa3ba115f4f2a0be83d270da351b2db32c188438ba339be575a906fc01eb79c7ff7144810022c3e7b58ec069551268a0c669a2cd47a058e6e0ecb3eb62a74e7516f9aaf5c41e1a1b955d8acedf1719a6412cb08ac192d0a204505e304dde3068ae8e6a2bdb96cc2475e9856b8befa86f048418ec23630237aae48ce942fa7662be3fb038ffa1d8334e0c2925f0879f446d58ab4f0356c822cf9ffad1965fd9b53fa20473b6804e7ae56d1241a939a1fdad624133650bc3fb810d738925a4ec310412fdfc07d19004058beff66b6ef27eea031b15db06f2ce5df6bf98e8bdbceba95f3be3df61319e9de576842470a629cac842613b9e20f0eb4555131e2a147e72463baac7f07f53e23b6281cee50afb1f4374b8e52d82e23289299257638c2fb8ca4120b068de66ff1317cbf51d0a660ef879be2a8c4cb78ba15c935d600a9ca5cb16d2cc6e2ac60b18a5299711821e0cb2550ff84867942d050473f346a2c31395cfca4cedaf96354028f7c88e54e303c9227bd6b7572d3c34b43c6f7979fef784c2dc6be4bc234420b8315c92998948565be203dff04576a4dab8ad4b363e1ada4b07249ab7d6e6465c6dd68110a991f4a627e3114109afec5354e4cbfcbcb5dda163852578533b321238beac541789356f53e5f32a4fc7ad39e9675241cbf83a40e4f1c48a7e43b89c282917452033d2c1208980908c2e087928e1ec72ff771440a8cd87b72f35334cd2da36b9b1aed377e9c9569524afe0218d04a1a4c60335c73bf01ae0a5eae99cd63a223a8b7e6e11360c6b79bfe37f9653ff986c0192134b67fdb61adc07ddb71dd238c1e05759200ca713b0d284cafa77001cfdea2918c630ce03cac91a2bc5e01e6b708726819cd019e25755bc3414b7ac65af961f564d332940255d5b21951608674f34000bae181076f96b4eb78074b9b5e57595fa35a7def3c56adfa5f93a41ddd191de4e690c7b7814e7ecc3c7860d6a6af528d829e4745cb2735b7865e033f950ad68fd96a1fa30c9728b1e621ba7c3c857a7919149b210e00c317753ce276111c1d2d81bbe1b89d582a5118fa63ed2acaf7188ef99359893b75a0358887d58caa462af1499e604843581195616b0fbda772ad401c08d7b516312687ca2b4f3acc4f49220f809d174147fc30a609139c8ea8d0db8a237df1473d9ff51495dac6475889d7edd2c469c7f53be65646664fb324571ac504b46969f564da23993092f2fd7d6cd2c7fae99bf60a0f787a2a8136b81f6d35f0c721cb6ab524a6b4b22d1e54750df2fdca1655c213e19f7c2e6375bf4bf2aacc9401d7494ae6637212cce98e5b0ba3bdd389aaee1a7cd178e990f3e3258e057cd5df8a2b65043768206807aa1b035f57d02d1a5365985d615807d716a16bf3fbf534081163b93025c40d669e88131d37daa5876a710bdb24b83defd29575dbd21e1fc30101bce7d5368092eb843c15693434098850e9c146920d68e712a6504efe25041e6aab012610c1833e49397350697f01937b25038c386cf5eb95d1738c9a9e1f37b118d26abdc8de5a39386564f29d42657af4706007cf7ff7462e48760f980ecb3f29e910085d44e643b781e61950fff008f8122141d715f6135954aeda9dfbcf3eeb60a630f351cb1c6b48e34dc7e630252c0d651c1e6b30f0aeb26e487844ed787ee73fe8da0bda5292b8c415c88758b3abeb9860a873b4d1d0f399229a239d10633087d58b0efbbd271fa6326d1d5205f227854842d84c90dd0d904721b706dc06f88768e79b190f914e642fdb97048a7758c88f5d4f31605f8555a5f616a7c4ce5f8dcd2d8f38f689820b24130d2e3a821b5c7d1796e6e749d09b84c8668304e30aafa0a6879634bfb2856f7552412a10b7c7448c9d462c56591974930d7f2c2ad75f854a2a0f6f9e326af650fda1ceef748da51483671d58bf4fab38cdb17e988ccc65aa2ec0e402063f859e7f64046afb5b5d2d8a0430c1d3c99c253173b9dc6e5c43cc1d3ee5efb82f0a4d998074e814e87a476933fa5397dbbd5b7b651dc7ea55fe20b5885a49e83d6dda7efac102921b063976778ca6c682ea393266636c23b49a80de40c416142fd461a2f3fb62e2e2f50037423e6a81788ff4ab21bebc9176007f51c917743580968c0aeb7c4513bab36c3fc9b0c319a0a64965529eef96aa50f568bd8f7287c46669ad6ca05dc86aab9de1991177473c313f2d65102be35d396790e800f578c437594a4a68a8fe6e7cca9569f336843c09bf88786c7ab290830f327e4c4194aa1d65e2f31b1d8f9dcf4993914f11491e95648235bf57f84df31329d570e5559dca8083926acdd52faca4388105829fd451ec76099ec71a50109b88e0e384af00beba41237720bd5bb9e4872c3973774903d6d320594c3cdc16440d5717f0d4902ab43cfd2c5cedd2fb5373ef97c93c66f0798df4e644eaa84de29daf33a599c7fd4df474e840219e59eef92da2650a38afaa1f4ce46a274d909548cf0074a69d811e5e661cc3d7d37c0bd5d3c718c44343ab9a2adfd3d48a78533ee192bd83a822ef97bfc90c445b7ef20ca638cb941b84ab04c4446e9c54119efe411fc6088a358e34bd82b815134dc04495ad210658e31e796bac49e2ca9bcc8af53abab4319c8b08a0059eee7d872e752f940cd8099709b844ae9a111576db248ee2cefc3d941e2bf8714b98fe357673923484b2ec84718d3fc4cdbaae575bea31cb3646bea3539f8a4e13958d15f5b6a3992129d0c064644aaedeb15c7d2f9bdffdc98c7ed418ddfa40448adee737bdc499cebd75be4433b8e26b7f9d5485a7ba025001a4075f397e240a46c2fda7124f88906ffbd9cc7b4d8423708b44bb0fc4563c8f2fc66d8b1a5c3ccfdec7109c8caea6c52f424fadc97b138327077a003a004bd24357262a30afb7de7401ad485a91551653b910ead7fd98d332f521375f613c9798110fa7bfdfb28e6f1942abeab0977498e7eecb8907497d2718a63958a694362e9cbc65eb891a509ddc2ba757cf7525e13b4a3484fe52ebcf91935fb5919c8c0290f8e3b96fce8801dc5dd6591b580589be45c3a1f17cc9f6abc7d226c72e5ee75701b6979a4a0652b49c0e37c27183e563a1e8876d2e574a2fb309a29691dad1edefb52d16d827574c717a681cb820b63faf3c065f2ab2553f98afec9a2b56097bb8f22d825fb4f06c80835ab23dd15826f7205605a0d4faf7a18db2a6ac3202bd99f6937ca59d4e394f99eb9fedf50b624da516820e322c71af2dbf5fa36fba3e6ad4411858f3788c4f14662c55f65e18a4c1c43f08eda45b6279ec81730e424b0e49e8196a1a8a973dad144974fd2574c814c8050142e3a59434a1b30112905ffb02f0a97a3d889e70a0c4e880c3a1c0d9a1fbffe3fc2cb427a16115d2a46de8b575be7c5d2f978561a449a5c969c1fa5aa5b5a0ca1afa64036d0d1179ca32c1c33437b0dd25113524aacd051d1b70e89ae2d372b76d5a2b163ee6120c04fd9fbbf9192ad5f708de6b5e9d7f6be462329070ce5d5ebaf7c75727876efa98708494f0b97ebe2564cb06100101d273713d1bc31b2d670eff49001f06ef385faba7d73d90475dba16ef5cb37699619d465ddaece88db555eae48089f300c865fb78082ab4da453ce8c9e3e262c8a1261448d49e7258d025b5c2cda125b56e1c036bc6afef4465fb68902de50f191ebab600bb7cf9b6c04b4f11fbfb0e312c5001a4730a4d197c4d93b91f9093df52c4f99850d45f5316d636913cb2bb91ba0747d29adb54cc80e27fd4b6d0d372e23a54d318005483a611c5c1576ccb23b156c418949fabf692641928cb6984429a4ae4d79ba3eeba6723081ce1400bb50e5f2731d80083a7aa074657028a352b55db21f0c2d6026a7f621624792c1f9cfdd8c2dd91595803754aeaf1ffce3e4ce2af20a129d0c3341ac8cca16862e80cfbb4a73f5bebe83853adab0f90a7d531b722be0135b801ff2640d9b43dc7c08dbb5d003165d5aae90b1192e740948f90895906a8d9d26d82c638c849ee100368eb6f7820835368968017a569775d857a161dfde1dd7d6760114fe7968570b299fad9f057dfba39c17c02e92b0a302bde17bcfdaa545219d448801a60c847ea3ef64003e09e138f25ff38d178c6c662ad5b1c112a9751d500a2a79916ff3c887085964903c914c074e174c3ea6efd4b8e756d8989382e4aebcb46fc274cce1a10066d7f48fb5d61da8c35e527347e8861c6f9d72ce95706e356a85bf2c1b27487f2bec8938620e602ccdc64ed1a73e1fe81d232a650f979762e41e16ba5a01de51ae2788d44ca4269aaa8aad96fe22c92390dd6909689f0372c7c646f1047841ca5564bf550a9d310cd5c2eda41a3e31f87e992adc526f7f458d8e40e910bbec19ec19cd2da9178e41b17d6880d59af569077991b91504e02018a499adf3775d400c6e91a4a0d4eaf780a637766c2eff48c3feb56a3cf79a16dd540cc7b58aaae4efdc3ec802b2277ca454a86d795fd0b5a76210625e07e7e740677e3ae28b1a3ed08849c9c73a1178556e0270e7078d83fc1b9da3b5ee7b2fa484c4fb892c059d5d8187ea0f59b9acb064e741ae69211f057295d2efcb2827f7e41a1e28382551a2ce2180618a9fba1cf6e0e754abafdfa6c391987a218c79fc8c5ee315c0bb73c63eaeef9e2a3ce3b33cd94f5d18fc778feb52cab50a9b17b5d25d85fb305d004c672784b3836b501b9d9866a472674e0953b4c6b44817756b0bb28ae4e2e0d49bc817ceb1c1f1566f05a847f05e03ca9f8929ca7b76b41665aa84d37c2c908bfede38f6459d2c61f674e923ece273a8dce07fc57ac8111ca267a966cb9ae8d218c767ca4a017c8836d740f60fbb42cf0eac858c69aa125d60fc3338764cce26ec1c5ab147c64522b1073373db39180ed9cba5caee3eea0efd25c0e238bc0d785bb660fac8ce766c55b244f4a2f216b820fe15f0dbef93f01ab0ec2ca2c34434519dd87e7a8fb96fd572dbd300ceba30cd0fc6b627127273583491c835815164d4cfd784b7ef7cb1ff14778917ab8f7b5a1354a386f9274fde1ceedad635e224a83638ba273323d20345b9e3fc5c4290db3983f4218a846d74def831281989ad1589d97b3c5dfe092fdf84dd2713d293525b5230d6e6ad5e63bbf112cf4d029b0bf5a104bc8b1b390e71e3695be2e3eb29934761ad1e12e239da52d0c2d9119e59bf6f027ab4f0672c8568e39da2d19efafacf7c08026e83d7e29b33b0524e5be46ae485c0d821048ef2ebcd99c206870d519fd6fe22dffe3fc38a0d10c1de73018e305ca63d75703c61b1a340e76514c6a84e1e4d2e35a99d6e482507680bacd33787961a5a759d5a66538533d28b4c01d10ca2cd1906578dbd660f42aa19078ae659eff276c842a60fc461568d4c09f9c45d540ecf6efd2e2feced59881aefea364e3840e8b541ed4de9e692030f144866616453d328a22a0d38e79b1e599409036da2755dfbf9bdc2e5dd3266abf0f2ed0d6f374e0c9ca5675d7dfe7a4b3b2e79e807871121d926bb00ad9371d5ec3fe98a0f57e8a21c0c06069c243d00d479fd270e1d2cef083c65e580ce338f0316aa506cbe4efb7482f9e41df12ef504a227ee7557138dc97dcf7c0cdb938f254f2fde36831f1ad921be3738b07ff10ceae9ebc833eafa032d70975917b2a455de52aeac847e162dd1ac6412adcd4be83f235cdb412e7d48f933e1181a623a24e594c884cac427ac2cafff75453f020621f8bf2559440d43bfa663a52edb5504802a70d1e65db0191eb1da6e8604986daeaf843394a3fc50b73f5ee187c5b8dc2fde27fa987494e643016d3b5cec1903763246cd9dd8050a14b91febddcf90a591f807784ae8ecc8f193d9d9f8a903bccf7b2e0cf2253f4b8b27ba44edb4974e2d1037b337b7b5845267cbbe329041552c65bdfde3832a34f79a3f254627649ad8424a44a54fb01ee7e7869de46adf258c9dc837dffb471b8bbbf97f9486a61b069fbb466cc2ed8a9b4f4b34839b26e6a113718bb8abbd69f5f660b0cbf34ce04848a8f1cd4532232528410c45f1f203d15f94e9706fb89230afa1782de913e785d05ea85b5931c8f0cb86b5a46019445d07533649a3d1d9495b16c88daae1ecb5c71c7a506fa1be37ffaff6221a5d64a72567919356cab339378a1a2f687b1d98fc3bb6f310aa1ebbd356f4219a654b76a89025b91a24fc23362831dc77a8ca79955dc0414424a7798e02126418493141df253e6d40d6eb99d8b819326a24c743beacd4c624a6ad6b0d7f009c411d6eaf7811a00e788a26c0a5b21f721a98dfa6a8076dd09b9b355beffa0fb24c66073308f169dcb9c1cc1641626d668f107eaee0df3d0f420185bfa19979ccb0bdbe6e9a98e142ce2db031b85db72421f2979de00c62e1485d188308aaed7c443237ec1ae7ace4a39a7216c8cbeeb56476d01d77ec58d215f866381b4afc344144f304760eb5c96e4258a9c5853bb26d73ef1e4cb52c8ddcc2e0b41d2b0e2f4bd4276ad50f2b6781535f1b3478430f854aa0f8b3677de1445741cd38e9e0df46bf9fb08ecc1e654adf36b3a25c7b1e2dec36b23938df0bb045ccb12be173fcc18ca243b9cb96673497c09e8464b2fc13348a2315703fb1a90f51f5c50b7a048693779a229396e447976d9389435caa8a6e9313e45c29a05bfcbc80e0cecead916c186a773ada511ebe57ac053eade59e96ed1c703fb1bd8b63b2b35b805dea9206dfc92ef664f288d059e292921513fbf3e64e805db94cf6a563f9edeb29484293324e03112691615118212fa145d9746c357f6dce05d31b24ffbd5ba750ee6d7f4ad6a8fe5544577a69b5d738f95641473798296be877cc01b1e53d5471f6911cefea7ddbcd75c9e954e77a4ddc5ea17f246415dbbac12d60bcef930f6753c719ad31472ae7f81fad5bdf19cff44562cc9378d8e8052fe74a91fbd83bd6c819e8f78c53cee6a0a1bf98ab1185eba877c5851418334f8c20710f6b12d96ac018c529a1ce85b2de7043f5285a7e1f9c5df0aeae4296ef5fd5a8bc60073cd5b4a3e97e58d2cbe3dead760be819a825f8849da931448f244bd63aedd001d4500cde0d675277b447a1f936537eb98b221d5aa96417c8d92a95e12d29a2d81ec07c21db50e9af7e38af007e59d3fa71dbc29a94b5659ca404bf7d5dd9043432a7f0f16c0e6d32e0cf1e0ed93b4ce5aa187ccf3489d1d9dbdfa2d9b1dc24faab18f72cbcb23ff294dca36d8a490439ceaf2369353ee083bdedf4f8fe35c1160770d78f5d64fbed9431cf81528f9622f7a07d1fa149d4fd02bd896369ab3f26b823360f381a0a6075f6929834d67a38abef0e45532ac94c66d9df8fdeb70d594d31c9da16011d67d7e9a1527eb80d863d712a9a4cdf9b01aefa5448b5cccedc6e79e0887a38bd7f251de7d93947cdc995c3eb405e8e1585d53211fddd455dd461268dca10907055d2642dab410106a834cc3d65fcb266813f35d2c0075f89a9d69b11bb3b08ef77e04af7c9de95fea67459b062df703444f6173dbe1ffa2f3a4a43b285c120d3b2dd95b921a1f9d2720cfd73e1ef1345e41259efe7b20ecb3fba945e8cd0cf0efeed06d4c917d3d5a1bfae858ffcdad063e35f12dbc41f02202c0bc10560e2a6f23ff9762f7e94b7b282a53a6b9461a4f439deea38872bffd50ce151546162be53afe52dd131f3b618ed62497753a872e2bfa4e3979a35cdcbf48fcf6ea1850c053aff2ecd779bdf2b22645f9707565a9f87407b785042faf15245c2d69c565ed9e7164d3a98365b0923169ffdba3ef7aaac102137e851a29326e91cc2c5ee9f5b47a1106af0dbecd352ba41505432a8ea9c9535ba419060f482ea829685efee4f08646ccb7a0d259bb50660cb43dd53cfd877cec607f810059ac177fefb9786b19365b7eb49f97e7bdda3b0e78240aa0202fdce8d56f4a3b23a07a32b2372af5d87ab67cf21b855bfb048a83966a8c06fd4cd27e0d212fd1f3c95adf7cc4dd74b1acdac8b38d6dae6e115bd974dde02b5ac96ba90bcee907fa4ba2bba09790a6c8f6ab6ed8029a0b36efc6fa398f11bfa3beb6c8b18f27faf1b6806c9fc937624f10868ec086ec08bdd9349e71fbf57112557e3a1ea2d87b413b48d57b2253f024434a4ffca0cecbd7e41aca59ced4d7119e9a64f073d03d87352e83afb409810e1e7c75503154e815815057ec7fa151f5c32fd128700a028c77b5d4cd8d12d8eef3ba5de76a6b2b90c592867d46f77156175e9afb1ba909246b8cbf9ce3ef68c6093bb0d7755a51328b2279b741a36082e8c65bdfb1b3ded8fa2a1357679a185bb44c5ba6d54d26802d61b53db70087a9df8a957ab2243c2239b56b72689de6dc5b52c47b6956bcdf0b2c63941d070c48f6d299bc199b41c20ce5b7c1ede1d47d5e85e84677f0b58be081f990b51df1f804a50284813eb8fd8e1acb7b7d6ac4a2abbd91a94af7477ff22b5f5841cfd5314708448cf6b15e97e07aad56a809cad4157dd50b538b71d3f9e3ba41488a6ba07ef16f1ac6bb1044cf527ac5ed95814819e2441debf9a7b60d208f23b7729cead9af445b7be74db174353397be26bbf94de296f7fd06e3fd5c3ad4e963583f7e62dd4767429c73a0cdd61471d04fb8f6f2bbf1c343924d95b2af8327005b6b35b64ca6fe4e09872b5c1ab7edbb1d51446a242af8684f9cc87b1d9cd95f52664c27d7dc6eef48ba24e8582d999759f26dca84b516d4797f8b84aa2a206b278a87e82f9c33e406eca7b1aadaefbfe8c9d8bb914a6bb7b6230a0d4e23e014f461f8ba1845e4fa78fe7cfb27339934c999fd5659fc0ecb5436b107e8d006b51198407e3216faa2477de5d769c6e62e1bd9de04dcf0c4524bc618536c9190d47fe1096a98900d609c46679a03ee2cf4b07b2ddd9753650f0acc10b8d6c44d78050d638f798bdd5df7dc51ee98d901200051702ae72b46eb981cdf369fea4720d2b09ee4d9b9b19480fb62615db8278cb83af666eb3a5ea96bddfe07a33ff7d5215838de88e0f6b1674c6024f449a3ec0348366e6ed3145b5465f621a2e7a4e2ce5018d4633ced9b252dbcf9f6f41f659ac34697b1de81c22a491662378ff7686b66e41858dcf938e3da27f676767a89a98597d511e21bab41ec6c7398ae7ee79ac9cb80cea942cb611bf069084a3810dd76bb5b877e6cc11bbe451ad8ccb8588ca02f7449afd598dddae0067e1ed9cf903a7093cb5cc61bdfa46b453e8e0f1c916d4ec4d4e35c67d404ea9607f28e42980a1709f080acbac5b5330b947d4744e5f553ce94fe50125278a7268adce94d9fcb9c9d17380243379927773e2c11107cb9b9adf358dc9b40235a52024ccfb4815e40445c33101d06198bbc37b6c2244476916e5ccaa5010e77380c24059028735c58de48ae9b176d2b6e818551e47cae91920fad5883d8e726d9eb1aebfe74048ed3819e9a3bfdbd2f011c911dd3d9632c62244fc22b8f75ffd9844b2e5ea5afa7433211034213ef0cea493da09f1632ded3dac73ee5b480101f831168f5cb1db232792097ea143e9aba46daecb4cce521d66cf165f5f7f2bb4a9492ee429ed38240810dcb05f8aafab4c22f193c4629eb16de4c77955bcef6b586868531fbb60b82941d756c3b53bec5ee2ddf19243c1ef916c45c22dd109d80000e8248c9416cff4314c4bf49c6d21099359b4a1adfa459a5b05bac538464308b44574c7245ca9e362121dc461fcf2d93c417c9f28f9b316eaa197d73014aa5b62af639f2e672139a6f93708f19fe091201753dd0715dd5997695ce476e8b109bbd71c13c9df9fce7b752899f3ee78ec169a306c2b346e8d365fea45cac3f7980bea53a082fd10a5bfe99e8f33355d8ec1775c7dbd67606ad8d0886866874dc190550e0fee8e540153f9923e803c8180b408cd77b03c515fd6bfd6b32baac2db2ceab9948d39ef95a7f0512db2b44e25dac4de5a58e19e04cee5227b59d84b43209fb7d90d9bc391cf1fca80d07507cfdbe8617ab62c67348e76daa767a846b6c1dca29e7f6f740c505558ef26560ba235960e92783a51580b39e1edfd0212fbe933cde188e5459045f58216efd519224eae6689d9ba6c04b377c7e3fac2823685631de385c36e82c1ba0c86a995998e8b42a55a3fa762354c93a3d9d68f1cfc90f95d937e28a6975f97b02b30b5cb617240cfb038044368a25d5dfdcda1f6ec8bdc451236582cc6208bbea9006dac22047b8d48964768fd5780012e22011991d057c5182727bcf256885520a587e908235caa6abdc864a9bea9d7aa22abf4e17a9191ff83e0393d7effdae056860d6a80fc73eaaf1d36b4bb4666a8c128d5e07067c2621674382867cc571f88a79b31f843e048d174cda76cbcdfdde2838d362b208a483e2cf62708b4a6a4a8062f96060c759c9f644261d1b899e45f3e92d7ad1a7713a1a8d9ffb63d817e6f467d6b2a360e59c206bae0e22cd2a213af3a209948c0998636544da982f47e78f892930d0a341084685d98df05c54c22a275978e0ec6cca6edd21ca6ac8063d81874f705b21f43519f03c2611af412f230ed5c0e3be43f02c80474897e4018f5ad3c32c82e680076937a02f07402d743c5ecace16075d0e6c117148a099e4b74c4842ce3bea716b43f996752ae92f44089d8b9f34a495110ff64b88815505558b4f69a74840260d8761f9281bf344e8888077737c7d661e9834bbf8477fc03604bcfd6d432ee61d322f1f68451b9ca6cf8dcc059c07331eca803aabbbc631ff59c0b90421ad4a8c71c6d10927ba1669fc08e1ff0993d0eeaa7d9fb33865f052a43dae19cfbc9f93a46e07f78447cd88aae302da0c3558c7242c6a25a06a72e74c316d2b2f55a8739aa1712f5994350315ec91683b43e9017571aa2f079809914e55aaa64f1b005cf5b16581ff27f3fb10be0c797b8dd41a6c3681199929f72a1bb82a82ac405c6cf47b63dd48edd14dc19cf4e04c1f6c3831ed21d4fb78f52159da98b24a743181734330c0de82ff5f27cf1e8ce689328a03e093e3a22a69ead6325570e674a198781877b751f52a7fef658cdfaff2d6ae7270310beac0d8d7b88e0b9322eafd193c365abacf609b05603ef5678e50f7eb8412b4a32f96c338a4dec4d55682d2b2e255e075773e186cc4827388e9e355df2e5382e843cef4da0b7739dcd2180d6664e7c15dc2e27e33f7bbc560cbb446b0b7ce07157a62d4ac4a4db0b9082cad2431df8259201cd8d5baf0024bc72891ad7d6fa170e0a63381225f2b850a5e27490b04bae7c17a5d782ef0812352668d6db7a6bdd673f5b4440bd5ef05bc862f2f66c336281c7a1be1dd617fdafdbd9a9aa8915980a3df155c035f44cd404268c38ee79c73dd8106e927a3eb0632cde4f0b68644d2b1264171f4a474f8c4220ccc349aceccdee5b5be407de14fa9da63c756231ee34d7c93b8832e61fd2d4c5ee7fe27c320fa5b855856d2e30cd26517564004838fc33f0d81ffb8e0ff229798817ef1a49330bff2a34141291c30bae18f223705f6d9e730afaafaf7cac69ecb1706863a82a3cd9a3e1d1a3d3fdf333cefe672537bd05f6cb21e826118464d95d8ccd921871964772956c31bbdc4ab10b88e731dc7187b6f765658bac68c37dcd23cb9eaf7761e00a72f33f24239e8715cfda404141bbebe36fb32e0e74ec54b5eb77fe1b19f16cb67fbf61e2222a81c046c906e9d4f9321d5b493c45a497210c2228f03f7fcf9b7d09543cf54bb9bc050e09ee093053788908f7f906715221a375f27cda6b627c891be9d673d95e33fd2bb83e796f0a67c82641d084cf4a3dc7545e95d9c243eb6a24a69e7997b658ced195e78df02dfba55afc65969c0e91bfe8749d9769bfe38bded35cea3baba96eae70e8520ae4b4dad8f8df5bc3cdf42a3ce89c93479a487b3db01a635eaa1c47f5121f9f4e396912a0da900fa2605a392963dd42ea3166d0aaccd17beb140cfbde958cdf161608c5d2f0044ae65f444babfc4afc6d5c1591d237b11ab98a8d09665a82bb7d9cd7bdd467442a9eeea1ae0a09fe3f9d003c6c2256a6e89c6aaf9481051f42fbd0d5c7df94f8e088bc2f2f46d90e1ecefa753698af87286eb5c1af94c7880f2d9298a23788eb79829e3b7efb5fabd126bfaeec1cae6d1d241da54676e1dd1289534c0a2496fc058a05cbd389284fe2fe336b4b90cb761eca0b356fb95486d455219e733b4ba912c103875872395d03aeff3f6e431332dbdd6369745334ffb1cbf4ff869cf133a88cdc2c01eb493068de26db72caa4e06aa6f8897f4f83184e448ea36dca52a1ce5a6078f25bb64e90caa2c03b261113b798448b3e7d1b4cea910abccb36721956c47596e058790648b27aabbfc652f5299e478757fe3cad0bdf6a26b67327515009297da1fc449e0f4b489ba2cf352e629e1adba37bfcadbb9c41781caf65f27311d41b1798710404f9c4c919f33646306eee38404926bec87d5e625acbd2b614201fa181e4955a377b7a61d7f30a3fea10432b8a32e87785151fee18df396427362f3672d207e76b1b8a03541c798b5992519c8e04d547674782cc74d23463eeb01e3bc3349e8a8d798207ba7c009afda9123797bd920a80e06c852d86b2d92fb4e769e5557d96ecc145a5c1a9aceb2de4d8202cdf07133448614cecf67eabc8aca17dd57fb86d5cfeffa784eb0ec4ccd3169e37e75332d1a1e3376472fcf70838b2d60d79a4fc573b39d54ebbf94da43b8d87891c89bf48b4f52dca6924dad6d8b73f80875bfa0d8207ce1fae9bfee9485a6aa41b7a0b2fe77967b86a999ba2633885922ef31715385e7d94f9e63888d4f1ad4615297812254582bb8a7d95d3d8eb5c1b335c95276ca594676137d3363b14e9d26553af566ac3f26c77cb7fb208c56ddfabc9632bb8522ac5cd32f4de87710635629daffea3a29d944f17277d54d86a9af0be34062f8e3c6e1eacbed69ace4551d5b91646220a0a84b1220e17d2b837c1678d8b496fb84d35d36d81fab2734f1415df01d5f98c46c93a03db9f8b032d9cb126f8ef49b786929dbad072b02ee44c9185563843772b5c9fb67d8c615e17335164045298175a87053c749ead7d49cfc9e33878925804508f1a997a38c754afe079a101c9f7317d70e927fa49c2b3df7ea066f16f05bd015251b2fc2f7ae292e9252392fb307aabc767ad567e52e33f6a481968830c3933a08f0b8dcbde72115ffc1a6fc91339a2490744624211fdc51da9fd725d924b78cb9f92dd2e7a19ad01ac774f7efcbd6b90a774b2b8b81c22d1be513ef031b1da224b19fe0f8b858b27381303a4603704d8868025db18ded0a1d5be08d7847c67e30b3d255a741a1dcef16ffa373346b81da68cf8f16b3990bb8deac8caea423c9a601774a75e34187de87be17dfae98be5fb6bb82d7e67ecd7c5d28534fd147c581a0b04c392d252750bd01e31f76777c6468217e8c0718885af2b3cc8ad833b4212c3f75acb6b2f20104ee883d2743f15d8de80ea3f35e5b01a46148a9f69a12e2383c8d4bbb1835185d83ab0ca0290033dd95c4dd74bd1065155199d0699ab5e5772fc20aa95520180c51284c00be9b61dea05987cf3852b002af70f075bceefb09a58cb89da5aa009ac39da12e368027f0255393b80b3b99b917b4a62b913f9af9faf655776c245faf111f4fc22ac8255962633e90a181cdf1a1a2e7f8ee7617d2642897cf2d5235e7b84dfbf6ade69e0d9578b8d99b11a215ba25ea7ac7ff606edb1754b3921f79dbe27bbaef4c4e9163091a6e5ec1444ec896af1e60883cf1ac8cdf5cdc3f1a27c13de4b77bcb2630124ca93eae587c4c3e1778d6debc058f222cf30103aaec06f61d0fcba0c40ebf4ba7a3f09ccaab224bdcd2b987ab687e3d09fc1907d530c3f9791c3e7164daa13ac8210755341b267c29eba66d50cbe460f6efce64a11d4ce93d7c3421882563d5ca83299359e7b744e1c63c4b4528c2229c2b1e98c2f680f2d31c3dec20dfc7933ed20e0dbbf67cd5ebd152e1dd0302e4b7f41a421ca865e87b2537457198309dcb2d78bc5650a12e7c20eac04d9f5a83f103e42918454b7bf8c113e7556d5d5bdc2207d107360f72e7b0dcda87003baacf56dec00c23137735c207c52166989a3a0ab3b766abf3e580283a9413361d97a07c0cef3647c2959c9c568292c962b2ddbb32c73d894515dab95532771e411f00d01653caf2bf6436a05351fe9481da141a12d45587308cf59c38fe89e309f365189e47f84e3815f19de7dbd73725024e88691f2acb148df9aa56ee16c1bac92ee1c32cc2d52cb9fac26d30ef227b1edd3924254f0b90e8d8cd64e73886873952a8d0636a7beb48f2df1df6adbe6c99e5cff127591bf2141b7693f0b5c5b52ce464113053aa547c4f3c7ca3fd0d504b750c9d1feed21d11309dbb2b15597d4ac4d1177d2074025b39362d8957eb5be562ad28bff9b0f0a5c3a6c712b76d23ba2a990a87d6a6e5d3302d56f9591aaa58436635e18c097e2aa9ac0fe399cc4534afb45c516e721dc49d3fedbaf59bb0e3f679acb9b53a6dd4763e66f2d696c55cabdf347cdd875a338590d934f6d60de734ca95f06b16984c39708d81602fee068fe1f55572ae5d5afeb49518d0104d6dcaa5a8aa0fe9ca89c56c2fd122e64e2f6ce255ac6d790877b0dfb5296574c14cb8d8054b5f8e3e90881ff85947265a922f5461d731f1a0cf0c9d9761501a9b009e73f18a3e1aa6f6d29914d80026f3c03a6c4d7e7e04e7e3f9b0cadc50eae0d1210aa00e0780cb16764e4036813f5a7a11b7dd0bed9e85278c1387745f4f4008503a022acc4fd112c57d1bb3c778cc37ebface5c32f29ff6bf31cb41de784443bb06f9b34d2eca72e6a88f8c55453cadd25715ec1819023386bc901266fa1c0365116ea3ee1327c57618f21bb5dcd5d7e20b10f4821f3b5aed7b440d2f24be13dfa3d069e1e680d2221c15fc5cac180014c76fe2f9791fc5e32ef63365297ec517baf76bbee7af55645b059756fb4f1264f49dc48fa805cd87262adee5405b618706ced34a9daa326fe25728c4e3254957d7597a76c2f3cdee4a295c86c221315a508c666bd1aa18a440a4d2003fb7df61a45d0045d07b644706f37b8eb0ff38fb04688d77348ec11d4fa90dd7bf221b0ddb5e8e26e263de92757882350a97015988d8a525e8c4bc26ff479a2c3d1fbebfcaab8669ad34889f8ab5aadafe5c3dfc02a146b728b445f196888b3b893cc4bb463831c43b84f820076f84580aa38376c51d01da3b0c906a0b04d0a984bb3c49b6114323fe57ba378f2bcfc9457d86163071b95d8fcf54a36f18fe29e5cb986a3b595543e099f8dd48be576949036f04caada60957c03d3d6d96806901afc1668c1204db455f714c92b63fac423959ed65c3aa86d85ce6bf2efb1332abb633b1ce1becf5b437395a1ddeac88c566ea9a3c9aca7b11cdf4f7f34d51f882bd6be0254aee9e4678f5e18b2a987737edf16528010edb741725343dac9e11898757b87543cbeb1f34b537f2dcaeabd274b69f4ed32be777ee389bb2a5febd25c68b6c347e530c481b1128c33d903b66bf83e205bcb741505b37709124467a94ef64738ed4cc5f52ca09c777a730eba11fd3e923f74fadc3f1f2216a08bc279a64056860edfe322adf3ba3d52fa74fff63c72ec335efd9ce8fb938cbfe85fce9354639da46e43c1b2a403a5073ef94081c693ee70db15c53b1c1541f396621d2ff7d8640dbaa1c51ef583b3272d02bced760ccf99f31d05ded231f4619c2dece8963b6b78dd2682d3a536a29382b09ff9d5c708b9009b4de223a113c383ac4bf95941a7bb78f13c140bcf71f323c14e31f3d1a0df8714935924dcbae1be3c799d12ebb6824194d4f26014dceb1b3d3c54734eaac05d4a1a3023de487a3b39141ce510b355d581444ffc2982ecf6a0a892588bbc0030f83af9a7d03979fd598c331fa2cd5f594ec59847fe8facf836b00150d54e6822f542cc9afd7b85a83e31d67332cf691bf8768226ace492ed761376fb66022e4564cdb6ce8b66eca76eae3ef336f8867eda92378d1ba1036938b0e95269284c6b8190929ae0d92a10b7b8ef9f8ba9e74c854cce952cf426573a7eaa89e4bded2406fd61fd7a46d07b7a42cbf1c7169485649491127c05355a33b4592372f06a541e3631e7b92826dc700efbe665e1e08e4b64aff3a25b00b2bde4f2cb6b403cc0c3bfe0687f646dc7d0c77f4a65f3281982ff7e905fe8e3a75a93979e89b17ed9a2b42d3c87d6bbd38aa56cc3d0aa4ab3001f5b617c65d5d60e2f35dfc3f52e430f613c66126d30e76976a280002d0c251d1d22265db169a1ddb14022db3463b590b288fd400dc46f4ae99eb895c2db5577035d480cabdb09d71af63b4754705c49f9add1f6f3b7f11e2a480074fde7feb51324e5853fe3e959025902915c70df5d598e18ad1b4dd1cb8dae38a5b4c9fff8b1a2173ad8c301cfa39e6f1cd5290a29691df2aa78ae73e10cac6ee0b2bfe9848c32fcae563b980cd9cc0b3aaea9ed37585d586596cfd45c8c65638b838b4f022445550d9549a1988e494c0a9a96fda5d6a51f8c42ebab59222e87fa69994eba296db508a86f215762daa11d8e85bf2c3adb4749aeb627640d20ec02c153b6bc213e404a394614a00e4ae4476567b2e3c669f6548a3ace19e37701068c34201fd1914ca428df7209b2ae1abf2b2fce658abe26b5f55509d5e24ff86796c09d8301394dce01c33b562ac618db10dcf7fb813c25048d42b90c13a6596ccba9c3c2a030d43cff07fafc970bab380f4c988b70f55351e350fb0e8dd4ca2c10ffc59b29623429c76ceb87a276ccb9c6da7398233c494225014e1f3b0a18bf10bff3240500a23cca87b320239fb1d0d1e09b24008fb811f45757e0b0ea85d74e812159ada97a6290fcc2c1bedbba0233483ff7583354a932dc29caddca1a11edf6735722214e38fe4fd4e84dad375304cbaca6efeb1780af34a13f93aa33b6840fdaf86979b4bcc87816718646579d535e424ba98ea19edf9514563b7229a0ea17c95827d97f8c1d3f95cca156427d2854e01303a62e3c7854db19fcf9a9c5cca192a869aa0118bd98bb2fed8c82bf4f73449fe9e5871028562004c0ccc2305d35e60df1604dbc60b87739100b8e175b7f549f1bdc3b36289d040f39b2408fac65e06ad01da322e0a879aaac46d4b77e7ab1381d1d4f63a54507202dc9679f3cc8450d995ecc677aa142c3292af515fef7687cd345f2e5bd8da547c012a2e5d08323a73763266116a2445ab9a3c43cb18422902e6562c14429f829c01edaeab63936f2bdfefc94ccb153941de5f15703ce1b744aeeacc91ae08462e0b5df9440de16b9109dd4a4ba0355e3092606f9c47c586f135205bb52e24fb839455127ed0138b57687a6c0f68f0d20ccf9b6f6f9f4fbba0f86f270e82cc91b442fcfd8c8178de1b3167c48f221ad738020eb7664a2a8d61b748c0ee4093dea0d859aae2e8df8adc3207759d5ecbb16aadc5fd101085617aed3735189f5102cbcf8b1c70445896b554666f64cd32af94442901be5d64ddb7bd4c12a9821a24e1bf201d57e52beb026b7d6f76dbc9807dbb599866f7f1ed7e32134043c36b80bfb3d316ca4338ab03ba1c09eecf8e08b6cdb477f8af8df9907e101fd91a226dc9d809890f9c80ee8a52f4746bbf78424ad4bfab120b1affa3b69bf47de7649fe82ee1ad23ba2027c8a6a300b22566871082502e148a4865616fd8fcbb6ef4868e61924fe9e9bde1eb83f5d14f7acb30055f1e59c15f8e8b45f6a26b629ed65fd58817821217a72eb2a50c3c62421535072c92ee620a77a49795dcf06e6a494436abf0591da7185d5fba5c0626f8f086c3f287550abff51f823e8156e9383007973b33b2e8a614f7ff60dd092b6955b64ef3010da41d542922805924dedd9c007dafe49e0e45b4ee256ee2a288e396651e435e73a49c8e74b2d5d6128b42dee6a82392612382f837b887c4b2e083c07a498483cd4d08b1142eec7a457eaf7039f69ed20044b05572dc253a57ff6ed8d81474aa427bed5e3bc909d539e0becc8748b4e1de55b0b8415f6eb57362aa9bead35bc992fad35f2953c5b1048f3ee14197eed6d047e0ce9e5681efbb9886052318049afee8479717103257c211b8ad07afc2793cad5829bfa5073221530e279dac7f03e13126756970854e4d8ccfdcca6bd93af13db08ffb562559a813fad8e4313b5c7b3340dcba3a42e0eba2b3d1417d081bbc99cd4ffab0736e001b25ef937b4518f58fc7461be3985f6ff51151d6c704182f919518dcd3764b64ef307cebb4099359a2286e89e0da25199d4fbb907f25f4c1752b2e2654a866f1f0a539c9f04e9f71bb81ad15ded97b4d37c9c15babbaaf18c0051985b6927b9d39679ad933331660f9f9a6aa7f9cf5ae59f9a761f25129cf1c6d05b735c14261140dc116ef57d462473c77d8ec01a4bfa4531f2d004648c28415aed1d27ae4764d9acffba80274ac6270b028adc9596b89a3c21307fbb22a22d71954e34ba26a0a8f94b72de57550de8a472834af9d1ec377d2273a145728ae81c01268220fe0fb4e24522670bebd77f24f0927bf68b607cdf6ddc0bab2942afd1f918ed3e5c776abd08419127be3f05a21f91347d2f96383ee4caeed156c37e1e37493fc9f840a67fbe26ddc3414c6e22bcba9244308ee5cdaa8549fe1482a7e3fed18905b3945669bf90aea505697560676faf8de04ca4638b9a150cbf46c1b30bc396e103f3d4f0791c45378aed582797e618a7c899dff3a76d97b2bb958089bf23b65f6d83004108e10d341723903aa65ad014d8651e40e5535c288aff0500139ea166a191843de930392d107ffbf0ad010cf4c05242f719c7adaec2f382ce12b59c6f84fcad6eb49cac7f88477b1dc92903cf110ae323efda583b3e400c30f24abd6cf97e32a6cd1712f4c6f26e91d9e2b1e2b2895c1c0d79f5080a498797d6db8ee4b0e53f9d63d4b9a2f991296241b19441aa18d9d365646399f6328054574125019af4846b8a39d7f238f0d74d069c7561c4165c376854ffb77958e96f24d6478ce996143aab53f831a61a795ed6f0ab2c8c57609e03dbb47ca70b33ffcc958b52cc761917aef806f3890a150208218522cb9bdbac20d903710e3fc2b7fe95428ff002b6d72e2306d2144c474b03f41b1b029d46a91079ae011611349a4665caccc7bff7e89644a29daf563e660e9c0ee17038aed7b7919f03b34539bbb9470fb090db3e1a621e58814264236494408221c75b082bcca0333501231c8a51859e7b9d848c74642c8e1196d74aecaa1c8d41f63701832144623f20cac534a9a6fed200d14ef1f05bc753c2bbd4e55d134cd8c9b01ad33a7e7982a7d336969066e0e109e283e4a2a9c2cfa9357f225586330158b36f5f68ca75f453074af6429299527ed2121d864049a806d3b39ff19dc0b7498a54abe3211308338df7e9c0f160c7520e92e4e87db443423a6a773ceb22520b86b9f1feca35adba9de1aeb99768d92a3813e4507b333cd38582d94a309c118514ffd1e4564ffb1e40a9cff681f90db13ee4550564c2538c00ac0462904e7bed20a0a60898f830b7828e454da7df0a42d6c92c39bc69959a9591290b1ec5f61980d3970de3b7164a4205ce0b848c34708b331527987564073eba3c25b05c5fed517b5cd3db8ef9383346d19d6f40eb07237c621bb66dcdbfa71d8ac295a1d8104025d84b6c38349187a0933d3d2decfbb6667bf509550c7093a2a9cdad7df5bf26198cf697d0bf7d8fcbabc82c41e8454ab01413c4420fd0b9723901319222ee4eb516819cccf2794f3e1bb3c546456abd1a08ada5648b4d063b5b090e8d9f86e4497d3b417dfc8536a403df8a84afbfe33f538ee33672895a045371dbdad39d7ffe5494ea748cea2d4056fbf5f96e24d64a8d04dd3df380f3b7111a77de57826800cb194f44ab803a010d0008706a579c78f508c603e4a02aceb492258e2535056a4bfd8b2832962259bad06118037b6acfe4c47c99b3d1e999588bff228b47164a0cf48ff2bc8df47099cec388d215f843870a9e90fc7318325b9ea6d1da24dab15180eb4b1e24d1716c356ebace0ed2996ed35a7e335f7da6810eb3c06543dfc331d3c090a547071b456e50f0a985b07fdc75b3790d003de79f0f611b2b477c1648ee718da4a60d68f500a6b432c9d59f3095d907653a4488cee6827c891f5d45fd5b0a2f66924c3c7a2bd64aeb31008912994a51fb16af93fc185f8c1ec9f3ebccd78593e1419634b3f85e7beddd25f8d2e09004c6143deccab15fe8d7961b2c7bfc91ac11ec935810c25438098351a845053173f483f582d15af3ee8fae7450889af1a2d045d4215ce41769d535a7b3845081d3e7ecce6d7ba934c97c9221ac1a826fc5d4a8914868df3b623a478476a637fd5d8c2786f86d3afb4c571ea4d89563b8f132ed66264d34299ce56625c5d28a7344124d2ce5b10681e836015ff1a07bc1132986add4f5fd2c5ce7b85abad5024704957b0df9bb7f0e4b47526fffada4eba42008b17c9e36ea6fee5eb685e7ee2c0a7912c1fc12bf48e944523b849d19b40a6930f30373dcff332d1a72e6099c30c048d200a53bc851cbae1d8097451958c37df6f15547057bd3aea50e116e1f82fea78f5bfe2ad8cb8181b36bea1f1cd8650d741262ebca771eb6c396a4a20493ff667d93e8e0919ce51ed8929bc068076137b1fa0584aa72b00e4d3dea3bdc9d2b6b065af4283abc073c35c9ead766fb27e59cb6e5df2a3c5db97a0846894bd063f1ff2f97469efbbadac48e41473cca53d6e3f3dfc70e56aa6eddee7ea9b05c6dee2efba206d7c937cd2e4463e92c7857bff958f6378bcb35c92838641078e9caf8fae199d32cdfa16cf6900051cf1014a2ba9bf15a197bbf162889a30dd9abf4f783b52f54977b7f49094b2e1e47ed06763189a2d3befc83df1728101ee1a67d711cba613c062daf474b8f117ab4f1c4939b329b0d7b18c59ce1d23405db3fd73ad1a03af6571bd3d3dfd04354fd89e999b6e1a5c796c3a333d06f2075907844c26362fa767bd44b8322c2d54bd5852195569fa36ea1e3247ac978e9b7be03b0bf689d02ebd708a2457d74d6683b5fa8cb9dbbff9f414472eac0dc58bbc66a32af9e712faf025a0d20aa737539b0dd3acccae8c9c6c32b993482061845f79a4fa507061b4f77bfbe862ceb84095f32db034bcb90175a649b32286ee0d3b251015d882e95717b67a8d96372021b2f2d77423df46727658306bca9e2e54ed54426f64dbe1c6e01255192af5b70983f3fe696b9153d0e8729a9c877f7de59e7ce8812074652e3c119ad2b496f6820dc088b8a4bbe72508f051b169f29ba561e5543eb6ec654f8e8ba852d976a0b0fe4f26a2da8320a23b472eeeac2366bd1451dce5aaf8c4ecbecd662561f06860384833fe5fa7f98302a6cb1a37e0b6e468a335881169f693b24bc6d58d60c0b822c8e455b1936a8f1f6bed34ed4f8fcbb143ddac43a8ef7570f5794e56e4cc4392e234f436ba90d4374a0c22478c09bb70e4b7f1373f9d1cb05d55937693624bd292cf6ffcce675594a27ade6e1c0d8b17cb91882a5cbc1d67ca64d407b723aa07c46e7feb889df6c1cecb46d6cc35033d005439d4437f88c679d15462b988bdc2300b7deaa30b149027c727b9b69e0294826a61e0792c727ff445aacf778a159fa84db424de1c188b883560db521e6eb8f0b9712836c92581523a37f766dfcb49523dfb9250c14a8358945f859c6ac244dfa13392b63156a5ff4d2ef89d0e77fe8b115d3d7906628d3241ea5c38f40da2292b19bf93951ca8ab0d8146ec135449f790f0ec340d25a90f063ea5aa68b99d4e88c2f49927bc19c684a42467096c7de55436837cf93b731a2a0362cf2589774d455ab4331b73130217eef5f1732b7feafbfa78e6a62046ee417e26dd827be286c378a2c491f3979ed62528176e2524d3e7174acf6b28c76d48b2bd140e31886353c52d6b8f13472c14e32843b8ecddf147c46a95911cc250adc784eefa86d090a0a7b314048b3bac5771ef4d2363de0b92043937db18bdd9e44d94fcae8aef5d9deed782f84845363cd07912e608896cdbc6c449c09b13391d1d0658d5474822af5a3f6ba1343b76a18f5b6fca01e9af29aa8c889a90abdd59789f72b0fe76b64653bb95d0033eb629cf95479cb061112e34cbd9a7c2d4120aa74b1056a6636478fed906349751853fb425973aef8c755cbf4ab67da90d1ea5c432ab731df03c301519a5b4b64e3eca8d082eecc8801c557d608d5d7e67d8e0e80085d7146fb83d742f67905c402fbc15312a355c82ba76fc84591c2bb36c72eb800d1d1a830ec042e8b57c0337dc0d0c49e8855c872f799091d150bb89476dfc664f0f222b5f6ef074e9b5b9d4c05cdb6bba871d38be4f17ba0e0806d243524e730ba3ee0ae06bc0f80b972c38a38a64e1c8437949b98ef8b5c0b62e9d0c616072487b8a951276aa3c4b8d5d6d204352aa7b9a8a7adaca8dafff37229d5adebf21cc2a864e1b7a562e8a35ebd143fc0c1fcc135f2a62e969b33b97c58b20ffb0c7e7bb6deb99f7d302c0a61de4fa999750a825ed72745af2656e6aa8850a745a53ea6669f5ffa157b557d54f7a96d47abe75fef71e74b9aa7a8b73eca9b8b3c331583402172f16a6d485d5de6c616313b210edb40dcecf0c9a46385bea74d6b2912f08be5566edf521af55a2f8ba53b5ec831af23d1192471624b7ee5f305af328c567e00b6b4879e9e5ad652f90d52eff24f0675f30afcd837d97f0b76f452e4717c264b22a5a1e6dd06358bec567e9c66584b25004c5e6264a6b571cbe8e53b33d6bc44dee7231825209f52c20190485e781a2024abe113232073188d1ba7df861b782b47d32ce023ecbf0e1c18d59303f753936cc0e61988b90a4dbedf1013ab3df04776d1a57c6896074a421eb6b4fa56a1dbe686e767a6b2179176a0a0dfeed01a43e241872e9afcc65f96de7bdc66fdeea3c63586fe532385cddee1dfffdab5a3f3547fb0aea2942de004dfae0749f4f75eefd479d87ea240084c4424fcbbce8c4a842e9e0c4951511514e9749709d095e83acd26840d098b6e26a0258492eb41be1faee13524db188f8f6725069229a2a16c7eb8525d62dcb16c1af5283076cb5c3db0d704535f0ccc27f95ec646e31715402bb470e28704b2ace9fb8ebeea37e2054647e9f172c61da8ffe8f556be7bae32ced21bd508dd0c64e435cfcc8ccaa6f178e4fee0c44cea4d8286df5a146b72796a4b1bc0e221511a63b812bbef51eafdfd97abaedb1193f0932b41c2976f1d5157ed7bfbc796cca84a00ec434a5ddc3d660696d0450e84b131938b019e145c5231219b4873eec1bb66f8305c6dbcffe3cbe66a9242dbe233c28dacfd211ad3b0b52c4b996ac0adb1fe0242b6f17ea68bed1e7c8a8ae19e0c1fabf70a0cce309941d5a02137d2e6f52d4446aed3bfdd25e8ef6263ba72e967278d55c558cad8eb615e11398ff0e340978c6b708a111a7399fdb120ce24915419762f9b884dea6dbd0e77c6ec12a1268eb39f458670e824fb456436837e769a872a2d0fe7013ca33b734de3442c274d8aac3ac5c74f476befc7658a4b8d74818b0f25f062ac820573fa64a84ee7e69c86f24c12c722b19335df75c488068204bd67f7fddcf714bc0a68dad05c87d670d0c8a8d0b0e7ccd22cf827ff5ec660be68cb6b3d5a72c11e260175629642c8496c61dd2df1afdbaa78bff2e0c6c3a0d8e0efa94179290b8561b848cb1bff64467c0c2e9065bd029199f1dd0bb57ee35afb71396d02d248f93e79df7ad3baafab503918cd884fb5d6a699841be089311218d8cdeb7576cf4311e8bca2b55a3aa463fa7cb31ad92dce51d90cdde28bbe67a03a296456b082bbc6fc716ca1f79773b3a8c5da3e202dfea404eabdaa9f4375bfab2f6b42a45d86d246d9a96096008206f8239501dae4c1fa73ba5d2181ecd1b1309dc3cd3e34c6468288756c1bc193df2a23b7849c25895cbb19ba8037aa02ae68efb7fb5796b092b7476007c23e1029c3ac850919fd844a4945225c69d3e72a5dc0c292fceb3d6cd827a50fcfe7554060cc3655a46d98ec5a9ad2b20bd1af675a70dcf6f3af260c10da73a54a3cce5e60fb59bcc24ee9030624f5d152a2f2a5d9f7822afb56048fb0550c7fb8e25e8f976a542cd3af680bf78c2f5595b035d335bff7247f55a54e99ae71aa84c6a47d9d762a0b19d73a2b61715bb509e47646f2fce60beaeb6645321ee6163880e6ea224e91049709b827b5ce31c41ae553f3d711bd9db4beb3baf7f531be75711718ad4a79e2114a60fd26f2818839d334f2704442d980a90c17e5b92544653dad24563952c5ee5ff57ff12cf2ec542835513f1f5700306b651b3be386e96355c63b011db281003f83a35e43d3531e284d97b4d99d0311d8984d47cc6bfb918814b473d89b0ce82b1bcccbcd501c21fda9e8eff2ac92ecde391c3c086991066491f439d72b2a2e8711a61fae31806e081f5b959ea2ffb2fc0ed133a454e4af5ff9c869375ad4d34f4b3f6123ea1602393b6be6b3be7b979db7382bf97524608fb5c816560ab393f75a86a74e2fb138efee7ee370423e1bb545d4fff1f0bf80ebdda25c538f0161d8e9910279f419db27a9b65af7adfba22730f40ecbcb81feefb15773dafb18f67fb12b52d8c4298160d955bc1c0b0a50e58a921ecc9c05919e2f43d6198f8ad86fa47642a7728cb7698bf488c1faf01a0982b22d9fc805cfbcb1cd509fa2280d71d1ad3d751c1e0b9fa021d1272aa408a7658ad1fe2516245189eac372118686682101d19e85d568bfa851ca737cadc8156e1344081a49200268ed8692733aa7e5d3e3d44111198276162ca80726b964e39607b93528d7072982e3432073b35ec707079a520f43457137af717e31c0921f5a1d47347425988e918270a824a2d5db3dc2711f69d58177a845b86649f83452c2dcdfbe8358091048d5b3a36bd4af0011de4eed9910fe6ca10c44f042ff6054579631dc041188f70db4c726d41101a99156f49d5d3b12a9d2ecec8a16522297e123903d12df6a1adf88b64662dad75e03ed483dbdf34b7b3280ff1ab3cec6770a29498c0f8a55821a39ada0cbb67cc897cf0b1f21e12f2c791296ea940aa1c90b469dfd69f7b8f9fc65a5ffdde36b9618daa1b96301422f308f578463577d108dc32b0e612df4d27d1a53617c1cd111c09dc528dd99d1411076e4e81969a22e0669c5f334038f4ef57a4b3d384a0f174440a0a22f3e4dec603e974cfd4a2605597d1ca058359fce335c4f5a5548b77f343ed6c031363e08877cf3864a5de85d390bdbd6deac415c3bd187764cc155e0d1e9e03e3d989bd2e4a499e570eb17750d2f865bf7b89d699b7db3d9c15788eb41a3bfc09b0b79272924daf6f0d729b14aa5e196c1b2f24a3a80d09d5b267443e5be0ed556287174396686d1676e2d29fb993d86cbc4a413b68c916fd9d4ae09102596ff1331fbc5456aa4b157dfb17993a9373f35c5ec550725614cb11be903e06759bab0ef982317a3ce4c955b204060457b5e2cfc4dd7361e7b018cecc73b4384c17a2e5fbcc8c3094079027b9ad941fca451fe702e5065478203867e52832bb776cadeb02c25e5e4691752016890e4696a058dcd2d918a73fe705bab336c5093862b59b98445b4132a057a22fe7415a2c296948338ed0d2bd13d35b5b5b4d85b8846b7140fe42c4d3be7dd9e3147c04f0db728bc29785fc48f19956e0d73d9bc1a634c186f17b25fc40a828afde6efd802f06f3aad438ec8f2f0f4379a4d0346fd5cf4e8c88f7996e9dea6bd07f74bfd3dc3f05f3608b03b64ff844173620ba1f404113d8e5e9d8d13e4ac54cfcb2cf943df8f653440f752d4ff16b2314ecf814db6d39b1a768690a78cf73ad418ff83cbbe9577f6c2f006ece72c1c82e20bbd0f71ab9bccf5b7bac8629a4e23efe9f21441f512eaf274b0b2ed1ba2069987aa9699e17938868ae57709a5dbe6ecd288e5cf1101200e404588362915fd066d6d7f5d5ff99f9e8c16f63cb81d3c1b949f202b9d2259809bc6c266934358d40fe0ce956973b47eb04b054c538abc9ff308ea165264064eca5a3aba442f3a97fd6d42cf0984601086ab782e22736ff8789fba5756e5f9cf9885be89fd62b8ad08e97fc33c50663254031335254a0b97986d62140a96b1469eab903965f6cd4cbf0d2c8e5fc42efb7436480e525338543da56fa0bfec947c0e50244cceef64ad1cef802a2a7accd2318dc9a83b7af91f0cb3c3defc80d035bd179a3c2313a0a2a95d5656a0dd45ecf24343dc0fa90aa74a448b7413a431afb6a5504e9773281410e35b62622a3dd5f515ef30ec5c8e602b22b0489663ef535b39ef7b6f3abfe8efa123893f172c3d1c32d3353e787b4011ac3a786b23be297876e34c816365c0722e3fbb3aca18eecf18f4cf1f4b422892397aea0867d59d42d8b96cae5719646d26523952f723dba7e980efb375f7a838a7e64f08c23a100412ba87243deba602127b741dbde8d207851a9aeeec2ec8bb1d13098a10fc4486d6cc33db648d4c6636131126cb19ece96c9126a5d5e441ff7ad3f7a653192b9dc435f40ab3d7d789d37b7aa9603a7e1d5d497fe6cb88f820a31a72e58adeb68911a71573edc0c9c912619bf0c059b8c2b3ac3a79f19234a2273630df89ca98306597a7810f6f1f46a235b5839f91900ee81e2030d96d5731599c1f937ccbb5bcda99d81c39a01a89610560aaca19236b96be94d17927fb621343ac0c429508f2592819d00e325e02e241a4871beaf90b03b760c58bd3a7758f34b0f4b8baf4beb211861d55a0cefcedc7e1a43b6a36ccee4e8375292bf0a5a0e3bb69ddc5a54557240c8d5d457ac133a2f634d89d00d1a2ec0b43787b4eeed8193de9e54228de2338835fe821db877f470358639dda14765c6452e0f82a9575c13b2c1c79d97641489c854e134931f15efcc3485b4ca306508470368b4f0ec54119319caaec8efc35f80d2717cb2bd19b7ab77ce872b4549135a8063f078d3baa8fdca30a1088e69e04b696b8c57795e16cbcc40554d7bae4c88b0f5b87291c7cd56a6373952848bb1254696ddab7b420a8d1c2f66614f810c230d14daa8a51d874f6f8759b2e3a19639531f772ab00b075c3fe93795814b5d3cbd33b4651eab9de4f79419892261247825e9816f436cf42627348473b4335a1873aad19d98fa7687b3d49a8306ba6127eabb637f69c9fd6ff22a1533e1893311ca0b6711e2bded730e276533b4dceeb752184c3b780277b518ffbdc272286fe088bad82dbe4177d593e88f374e321f57a1641a68c1f331594410a54c3db78b5a4aec234eb57dfccc322e5d777c14493ac1ff314f250ab81bfdb88bcbe922c6d307d8e472ab85625e88220d662621a127cfa298a12eafdd66ae89e15eaceada43e64618cc85075933b176088f1f9cc1b197aba9d2f99e002e5877880596c4ce8c60d342a304f7629ace374a1160b5df1366f6295af990551b27e9a3041375a023f54fde66067d41ae465313bebb69503c7076077bff87b58ddf565c7029bac653624f5478a87e1b8a9cda4285088dc4dd3f75ea4e8a27212178c6e636236d48ea3dd33be1226c5588ad891511d00c33b458de0a6a3f54f53636f3fdd0d7a9b57ae07ac9bfeec1732f15ef1cdba2bfed9e7a8ba082e64a8cc1959bf1bd07c56285afdfe12d61d6bbdaf465e47a2d095a1eb4f157ef6bc1ff8be200775fbdedd68d55b88e77c02e156b708c00f3ad6f0e4df0742d7965c952ea836e96064b6554f0fa9f0a6e755d5e2f927dafc7ae57cec857b3f9ff8270006441e4be49f8cf2550b5a883af58ca566183c61e3eb9159a5ad77a89fc8ea5ed90c1ed0d5f74dabad263ac415245105e2275ceab8e79fc780502902bf687b60e116c1c2282e2301c0874b492d58eb47cec3f51b145388af4fbe286ac364fd7d05d8869a758baa2ae717ae164eec323115f219cefb74c82a504bd1a9bff48925e4d24e7e6f2bc0ac50b5f75ec962ae68bb112aaa1ca0bdcfe1893afd207e4de710b840fe33e610f8bf6450357bac30fa2f109fc880718e0089a55acfaec9bf101b18b007f68407182be569ef24a2c051f01bc1bcf81206f48dbdd521df488e61941845ad1b4b1d1d3a5ea8ad6354423588e51ab322afc713c69e6c77b0f8aaa67ce8285123051f97b1055410a71fb9a16e4cfa614e89b7db989c21ffef079207aadbe00bc06834657ea9e67f59b09ef3f24b23742958666504de66d53f09aec5a2f35ebb42ae78ec205926b0d57efb05f1e8822b4c23f26f897d220ef39759e19c8b4649b47f377e3e20ef96dfda41f2b536576a0c88a0240d8e469653ebfb9c715facaafd75eb6f19be08cb74bbcbaf40c33e5f10c2718cb0e2b23a65cc91a8a9d6f504f02eefe29538a5c4b2ee3c7fa8a2dbb4706db75b9bf5a5b7a37de7dde2ac3c62f0fdf4cb1c01a22e2ea60e5afa31d47825408c7d90d46274ddf8f0d465e409d542d7a2264939a9bdd85a4461190e28aaaf746d4b9abac5c56d66936bafdeee7d8859e14ab52d16150bed375dbe75818c72f7dc62eac6fa5392fbd120ef383488ef2d5a97bd917188b384756163140a3f77b0ccec5d724b9e1392cd15c86ead4ef2f1630b404d056b26e2623b9e963a88f5c507109df7dbaf7a21a8838ee38379bb2376ae310067a6b247d605c0b334385641df2e47162fd4ab1f6a5ffe6d2c0118f194991177d014a9b893eb97803f955e5130fc07555180f5915d4e02d78bb60c8038161f07910154fb3bb090df9342c2e4596e971bbe3de7608d35b11ab29ef96649ef8a5730d2801af288e117764c407c7faba5e59f6128ea370d025571c02265f3c43682a554c2ae3a118a75e2403fee06858e2e23a62c26e9df2f4f35cb0bce5e6f16b041acda04a1ea4b11ac6ceaa1ee7bbd75c70bbd625ae1906496ed3cf4acf08174a022a3580af3dfaef54e3f2397dfde754eea67137222157f74f1997448aec694eac55d1105bfb459ec4b08f4c92a6f297b9ea988cd78d29955fca77b3bd3c76bc120b61ff79b884ede325da7e021b8742e4e36b2ccf5e44d36ebe3735d804eaae259bd6219a12341f40e83a9b5cd380addc80b2257c4c23e2b2fce8b8ae686d6e7fae0bf121555a2544b62834074f1bcdebdd98243b9844232e12f6ad7439ff56acb5f8feb0d97c9945ac177cb7620ee7c7b91e784e7125a96706539349b9a580f3646826d40ff65ac43a6a5e0bf08ed4a277afff38cf14bf18050e1f4efe551eaa65b2f8c828ee8debd7a9736ae410c824d8172de7599b54e6699abd3f1d75a4f143ba1dc8fce963d80f5ef8fe92c24b7d320af1ca9113882cfcb4a80d3e39c438589b93ec0a10adfe24d001d3792bdaf60da37ed5e33eeed3ffc52ce3430c1b05b6b3f4e69925a83cec3a701f09b29dafa4d06d29969471b91d706945d5e1f604bb2c34b44c3a271c3b86963063f482111b575c8db2cac3f816d12b1419237c45e1a2acee42c068be89aeb5ea408a1fffb64a4273b84afdc34fc4a35f3defdddb559a782c1cc186206d50a3bacef20f432805fd847f7a371c22ff7db5fe95705b7ff7703dd2057194fa314f0d8f6bb2015703ffec19221de5d89eb0ff0450df5cc4e605a4e3a241ae8d82b2b85ab1c93cad51948715179180497bb2df0f3c7cd20ffbaf256c46409fdce2a62d3e5da6e3e11834a6240239200a5fef531d3cc01a5238c7046d6b89868f8e9a7293248d9854f049ea1a126d20b6415c5ac95f7c10677ee6b9b564a256a52ab6970847d5ca89008b05ebbd1f9936c3449767d21536d3a2c7bbf331ba5224ae60181ce4232b72c8ffc841a33b4bfde0be8eb20a27f3ae11e94371fee58dd750baec68d6a6ffcb9a9dbad8b041ce49a500c89023a1433b70b6de08f05ae510f85ecec0cf8b99ebbf14f831f60ca730ce20b54611727284aef9a19908bcb55f331dd0de1f0f4e49e4ac22404da747f042eb587bf9ef66ee93b3c252e130e1bec749e90a21b349126e0aeab727d9b80154c6aeff8a2765d8f37c5254f6ffde8e9a3541a5362e4ac2240ee9938f55c5f9c0e174a5d30f4fcbb0f9486fe88bac33487f88a31b6a882eade5bee91d5ba0988fd95aa01591ae347c35a157b635800793120721b5c8737c21610383750a9c8372452f5d428c3534d97845e12f7674f22f24535a69a91f33f3afa37a4b2f512c16494a37f251b9c41366295c54cc51dd249f7ec137271c787a74f91305664088b76717e87835933e218d672b9353175972ab4634fadee6dc83e1327bd1bad52ee4181d21e1d6a6147e8a845e7e527bdf5fe5bfea7051476fe31eb0a3d56c333fa7dce0ee7f67354df576d89b1565556d60aa3a484eae7e982c121b68723bae9d8ac67a0a05b93dffd69587c000971d805807b7401484a5bc48fa323ad427f9a31b11a0ae02130fc7e26750829567e73e93543b40f6adaabab75eab2fa3e0fb128f8f23482fdfc3eb8bf39874e207073a041de165d0f754e228e6b91a0edd6ee157a38e9774be71d6276200d1beba2558aa448c8394e49be22651f736df0639f3f9bfcb921b2fe121cf4735d7ba1a153638429046c8868e05e2ff185ebfa972e08681f0370135329f8976301feb12a855a7467ac8dff128da37219e61caf7e6385864b69384735ff5b9877252cacfd497bed1ee65b22b32a73275d4a32d1a49096c71d8b8b2d753e5ce0f0c138c4754e0bbc2cad60eb9dcac8c39fd502ce5f470a798676638d60aca33c3d64d0ee820d5ffc1a963393a4576cacb2111053336d3e3551c7123d60855183694492d58b5b9e6177be0ced998bb9b4b239b2410d1f7a04c571df9d68aa8c380c7074fa8ea04cba28b109ef8f434f02099e0be8869ea7a32dca0568edb25cc85c83fa56a1814174661d3a31d30259e5e0993407c1f305c40d6e62ac80dd76e39da5ca719d728c7253011d4f20c146c5cfebb9e6d137b937788757da027016fe9c7b58aaaa1ab352e825bdc513388b169e42a9564afd3e59a769374ca44cb1b1e4ff2a318dbf0cc0517b86bee6be03634194b3113c1db30b829efa69a022f64bc01eb29e40a71a75187b8e890d23f9c52b5970111027560907492b0749a73f44af5948b71e50b9c80ff6fa2268d80387bdce0de14bfdbe8b62626f3507918e320ab290b70db4e8e9f62cbb115c33d09e56dad80d49aea1bc759035c7aa8d4f17bf38ba36b118cbee9c3401b55763e3537a87ca665c2208be740bbb956e46f8d3e7e16a3087101004ff52c1ddbe0f0e05345585820a54f8a62821a033beb6b50fc7d6dcde7bf2f533959195c547a8a890545e37e703dcb7826dca6c95ebb79c3b667b8d48a7b3e51d4571c2dcca69c48c209a6a87fc2510e705a30e8266c1ab8f52e8d01b8867a97a89c60a0e133a13186c134859704ed8c9e0b40b3efa209b7a63dea498b10e6ba308aee604ec99d49efb10364ee3481ec76b56b3059ff1e6e40aa5ddaace127be0375ffe12c74f9f01b2476844037438087228c6ace3dc311ef1dd24f0ddf5c6a31f4ca69e728f2847f86aaec62219a56a2e1a44ccc35d85104abbc91673e369b6cf05aff8e4ab92ebf8a00040dd980aac2f2d941067d4dfd54a3cccbca1a3a959fb929b9922bbae4e24d29853165e2fa85ad5a53132499f9c2e83dd6acc09b7c3fcd32773eeff1b1130d36b1dfb2a3b39312bdff36931d87b358b056b97323f41c64078d6231f48bbafefad9be9a82b50986200b9c457dd46f586382caa85470c6a6590ed12703277bfaffc0a77861101a730f90a088e934bdfa75ef383b2b65f994f8a2b251a926912c36d2c62d71c807a754c2280185937b5dc237b0899b7536f06a7b7f399bf299d2e23a4e5504f841423534b829911740f5cb101a591a564c38a692ecec182e4a725ee62a84a84a4d47fb50ff27045b5285d467d5bd4c7422cb5a2c115378bcab791f9960734cd6aa3be01bbe69584defa312e02cb641c9297ac2ccb7aba4c891a447a89ad00178108e8729b3ecf545e0b8eae2a156692b1d3ec8bc39942e5c13e06005ceb1d862cb75157fbec08f97f32c0d416521e312e81d0fc036a31a99d388988a36a0b26c9f36495117601fdb00fffb7a0102a448005533d6354fa00cfd44afca20d8abbdc2fc7e78522bc7f5fe523f1a5388a97dd4f3bae85526b6ad8d5889b0671b42646b7b41b0a8ceac46226497b09219eec10885e7069cac32d5fb0c0c4c5af7067657e406b7d4651926312e3c3d4ba1b6b8e7ae6b67e99d1fcefa146716e8a412fe1b98f54a20247b35758b466857739408b410c6d8a0b46ef15dbcae67c51a1772e6be3b1094b7c11457378f10be3c0d0abcd78dc5205207926ae3f0c8e77f7c677ced43afa2177aa2e47fe5b7522cd61592ee1ddeb163f94836ed3b13f6614515b3c90dd783f90c2b1961b3a186aa8072baa46abb47c1ed9195508d989839908c0ec2965057844dc13a7cfd163989b1ef2bfc2bff0c4c134eb13143338a51678dbf448bfd02cf58238c309a384a4b1763ff2e6e1d83f24b043221938df8e2df1792a52d14c08a424b5168ecd3cf16b86a0c25f36a5d747a9e48b116103c5aafee359c3999cba6b058a7ed6981edd6f9362cd8d0e227eb6016658d1cafa8b7b0f29d3f208f1ed5a63f0697d177e67114c890363afcff2b3e5f46302f159298fe9c4c68d585690b8e8dc1c786af482f6488139788b061c1c95cd20fc88c04ddcd91a616593f24cad43e631b2cabaa1856f5059c06e56df2a3a980681138e454bc81f379626ac786477e28cecb78e521876b762b7852024944342c6c235dbdc6c9e3523c319a2495189ab0738bd6a8509eaa026b511fdab366da21c20f9e8c1cba4fe3d89052959e08a75f406b91c0fb017a4e39cdd6279115ce8af21bc67185c758c7e86b479c85259815bc6b4e3d4f688c397d8586a67eaf5bd89c42946f37ba24d9df5f0b0a2ea8cc66ea0b8da7f8febbe89bb39b319c0c78e7f6e4f12a8d29ad617ff8d40dfd22a8d9be370390f47f3fab8bf9b401ce486cbb8bdbdd2e481aad56edb02c8e564904bc35742400603ec372b5fab319170b406446bee98b14a84f0475f3ec43b02bd23d8958ede2fb5ee8436ec7230c69313a026aeb37549b95d15930c1db5f552303f493d0768aaf132d378134e5be9166d3253da1bf98364f261b31b34a5a7caa2f88f81c8e20219357c153826d7c512b5dbba0b4122882e940c8e01608d5ad349536bd25ca0e4c82588a350555bcdf83c1721673d9ae2580132fe7805360733c1b9d0fc3e8d15c6368f6f61076398e436530aabd142d9db45268d41b3b907572c36a5ac95370c13defa0c6a27154281f4250541a265b87ec98e41618fb2c388c920abf37b33b5a3f81d824698cc8b52818f187e72f956e93897b049af15a7d90cc9f151631a1151e8111165b0bef279e0658c1f0983e512f1aad182c126b5556f15e64aab1ef00418ea2ed8f9cb959cabb7058981df05073896043b16bba6b60571158fdd86ba182bc59989afc17b874c22b15073755890eae88a205804785bccbbea436a001ee82260acb72508a6c83fe59a580a0f2c0854c7b437e661c02fe9d2e9a1bddb85e4b07b2c9cd73f267f42cb2b86920efbab189474550f37e320bc490cd6716b986119280ef8eb6660c73a9e3e8b85e53dde018db273c671692d37e91a6eda8068b3bea9922ba90ff70375a23cc95113f04797e7e76a48abc5b3bdc5c77bcb9ebb7ba6a0d97a0dc0c65ba96fdba94ab90c2d3d91f5fb612565ffc4e08bb90e1089a8361dc0849775ca540365cf78673ae6631a4de043b83fde914ebafb2ae052fe79ddeaf71bd7af1b348317b31672eacc440e23fe5853c4f68c3a6d0d8a48a0f1abb30a78a4dd1dbff3d2decab66b9f0159815acbaa1ad31b4dc4e4dc2f5a8bb49c75bb6e5b08d7bbbd3ab976511e1ed7247f4dff004e26ab0f5cc21c8e96d3d9d98fb0c864a835c0ad14d98ee044e45159245070ec859e0acf994c70e31706dfc61461fdf7f11c94ba65997e173ff81fa75ea0baac7bf6eeab225d005b3f4e8762bfcee39aa92c5f9d94e10be02d19d8139da6345211080e732d2dfd8a57c0b4288d244dc8a86af7465589e2a1857c1d5fb792583c76268d2432a917d7dbc54dcc2139a9c7750205c20ca3bd0e0e1651481cb74e47b32e17df901c521a84dd50b17efc6bb1cb8e43fe122cd271866131d12e21dc0b178e31856ec7088442ca2eacf44a47a4e0e692fa66fdee2df7db5d7da6aac5a52fb7660bcbda3f2e4306ef5b4650e0b83b77717e764dddb8da312f9e4e11cff0d10281c70885e65c89ab17549bb4e75c2401f8800e3fb49a6292d258712d7896c1e4f26b2b540fa9270adbe502c345e09ddd6bf352f821ab8f7be70277a74e463fb415c7a9adbab101990536dee8b3b61d607fe2386ff6d1c9b8902e96356a81a88fd7e05d10da3500e7484b53b8f96f54fe52a827251a96fc148c3d7d04f1f1cbc0e7b2a2fa7afdac6a304517e8e1e2713313cce3151737724b96dda91b9a49c7f5fc7094c2d7b46f20441abe9c18154bc6eed25eab77c715aa469297ef75da1fc7c3a914d752b00da83198e487c785e6d6612fde97b05281d79e377178bfde3cdc8238fe6ffabe108dc66b25e643cbd2d0c17df9661219042d73c03e136ce0c4ea129a1fe5f13535e0e2f5b49e2ad78b388819b42a851e216bc50b234f11349a0429342c0fa8f667fc4615c24060114fa4b1dba50fa84f9c60bc115e51c4831a1ec9c86d619132251f5fb79114e78eac40faf45b9e0219e8d1c0f0b780ec0b54c89a78bf1b6830dfe7fad30c8cbbd71eac2c9275e93e46f5d726d1eadb6b5b2b2a11cf0affde2aaa8a9e6d8c0215748a3cf545bc8ae25d52249ea1f471ee2af64fc86e600783c059708a0e28ec51dd2e0412d8ced0557308777bfd4b3f1eef6d1ce77db3e6c4ee10c6edc1f74a256ae58a0cba7bdd53534fee5207a2c33dd5f7f2c460ac625c0c22f552539b92ee56bfade74d419e83cfa947b550a85980f213b9bf3e137168976ad8db389d8756d189c260ee0c16c4c2bf76be8a811f6d441933a6720e151a8b51ab1c49ff46843a325014229939568de6fede083eb8de50e2227e2c68b82e3dd321345671d83164477eaba3708e103678fc57839a60395aef8cebb9cc1c0eb7441c85f5e4b983a18b874eb70dd444b52685eb912aa1bfc92fb290695bd6a658a87bfdac900ca47e96768b4b79e0b7011fff8e7d74d6f219368b093e29c37e23ca2155666f7f4897f79bda34fe21e64fbdf39c8cbdd890b69103a312e46048bf90198233604254d82718511a5032fa47593043fd343ecb2ff3025de773956706d4ac2ce8f4786a46ed7f4565df3f441e8a5673ec46d50a02c0e2be41331a1656afda68cf6acc73c82f6c05933741a2cffee4afb34c62bda4af3c157f14fe1c771b5deae852e22f87bb08ea53bb4913c00fe78319faf2bb499c988a35ccf51e19d76d5b09e1c6348326e494067c6b07389ea0af6e842f5357022d5238fa0ad89d2413017bed5485e1b6be44bc5d38d79973e258c84d23003428bd5a07b7891de9d9c56afc39ae79996914aa73a8f63991c82f6f43cb49a85706bf9df6a65b95e06087459d90cb45dea2da3f6844d8f8e98c90c53c0adacbf3a3321dd69b314883e6e3fe9e8264ac172d653ff64751b78cfc2e509c33037c5bae3c9c9ff0834421641997747a01390d39ecf8cb0d4f783d09fb86e5d626328272566ec94a3c47128f0943817eef568763162a57c5a754ff4c05012e4a07003d260c7dd9c640b14eed271ae960c10cf3ba3c2bc53962a2b71d95d841a53cb0af93d094508b953680298b46131a11744f4e2b86d0edf2b5a16ffae32530a424a9091280ef48b1ec6085107602ed8bb48befc5a2fa706fa3c14def51cafa568c2aa01e50ce08978ac614143956210c7fe536d0e58f2f1c9bd7e9fe015f65ff61bbffef70e14b957b56b62b72d0102c3492dc3c406268fb4e0025de6f081d958ac2ded331a3744cda6332f5d414d41600821f5ef679b285285dbcd18b2236bac86ed06c0cfb224f88a31ca2fe4eef93a5e45c0b962f08d51bacdd3cb78c17b44039ea11e0014ecc0265b2a2f089216da77ba043ebed80d74421bad607790565b723dd04ee3c606858cdd73f34f748c15538cd17c10c65baaaa8d45a554bfeae0c066eb7d3bdf191180ae7c45b31f078e24dbb4772b6324c5825a4469c2c650329cd8ff6858c4975fc1b2e3a1785598494053082a911e1b9b2f96d43bbf5b01a0d90bc5a86cb472091065bba8486db9d881d41780742a2317ee7975d1877710fd945f8670dd886683d2ac56b8f17d82bada7fcbfe609c8976146cc113603fe93f4e1bae4c34d244310e1f7341cd4ab91b9ef3f17e81665243f250c9ae6ab0aa0366b5e6f22fdb7d29d6f8189b921e7391a84cb4973e3e0d11c3eccdd417791148b0d0f7d3421d74e28070545885ffdc7883271c9d221217853263ce330f8639b8dddeb36d8ae5e3e8a6be50420656716a5836237e928992dee1e6b0c5a2dcd406def3eecf571526b8e6ec8dbfed6308acb213725e884bec73dd322c329e2aeebab6c0630867003040b8a82c482d086a84d897f1f253970cec5b4b6e2a37c8a883d57d495ffdbf90920183454f98e5c2fb83b8132a096df89cbab29321a26883f7147e2369edc0d71727863b3c106ff5a80463cefc33bd99b4e5909d1ca2a1a3246615832ac4fd476ebfd23dab49008971b8983d14fd9126214c778e2a645a40f796ef5b21bb60a00dd1332adc8c9292402b2bb1ea491fc3276e8857965fa2695d0ea3e9a995b6e1c9203deb963bd371b72827d1fdb747df2536ddf6011b1dcca049f373c8600532252ea75c10e024608b387a53cef3bc18248d3a9850ec52308b92ad0ad951edadf6d5eaef916752a040c18e7a8a2160a2021302c40646fbb51f77b3e65573325e08c9d5bbae267e7e4855020a04069b38d766511dadc20c172e556f0d64bfc4b4e02586c5ddd2b1356c9256fca46a8bc6fa4804d12de53bd600b0b1b569099422f53041584d2113610313a6821478bc5e86f7a57776232a7f11d8077435031cb6bfaa17a1b462fd2881e9d4df838d03c005627aa0364a9516b1fced6f064751a36a43c18cd7cc1c140c5de3debeee4e5d2e5b4c1f4e34bdf64dd4b09338c9ad36126ef7f0a6af68dc1ea52caa983232afe9576170335f6f4cd5ab1a059f1c2fa5b30d10368c4073883efe76064bc5eb539723efcd112a0c75d5c1ab5b77a3489d896332cfd54c621c0bbb62e434a40b5e76fe37d53b28d1556e2478150836e5361af3eb563066ed241f4d4d4ff648aa8388b25069daec68b87c3335715c32a2bd198debf9f00aa09de5467f6012c3a845e82ece35bf74dbbbd359e547a857d67b38833e708fdb967087b91f3bd68460910491e5481f3f6ab1acfb92b067f3d264b271d376e48535d27ee28a50851795faa405739a4eab66f6288562c5123cd6fe8db5c8bcd65793cc4524b5e3cc91a53ed4a0f32d21719e7e5f3653213ac4df81157f79ac2f494b6182bc85565ee6b90026cc876ae20cf7e97901a84d10823398c4444f4fa84b1fee495bc71640fc37b940ea6d848895db7149d8e39489d79c28b32d82b874d6d08c80f3ab393fbc929ed0078264880e1d1000c85918c21cabbdc29208f39438a2f5aa3c62994d4e556f7d4f7893beda4e6f3540c27827b71095687280651fb2bed7603bb0b686980e9b94037bc3a46d440dfac883bf774b18158e55072b5674990d925ccfc0a4eba0fcc98a16308754a80c52f144d0d5bed2f94c67db21e4b57ff8f9afbf529fe9fb6ef2bc48af1ec0a806fa5ad38cec495382212026982026241d51c7e0a6aae137ac25c872a537c4ee3dda8ab972e328992e1a264db98540c8040df8d38c1b6ca53514b0d4b33fa4cadf9f3d24fdc09f4675d0f5dd0674662906eafeacedd3fa9f3c7ebb2959bca2d251ea40b587e56e427bf8ec269af911a7f5a9fe0faae54a4d5a3a3373fa17bd1f8af3657f76ab293ff10c89a3c21c46958cc8fbb16f84086b14b8a3c5b0552501665a9b94b9c229ad3b4bf8a9dbb7694ca93c0321e7b76a2aa1c21be7b43f65f61a5eadd2c7df17b938a1be68e98c577799cc59171cb2c8524c8f7d21a84359263e584786e2e67044bcea130060324d775939079288722b73cc73f19d51fc43a4f4263d27f0c5b85db07d8f13f695eaece4e3f4ebca4ca8186d6354e074c4b462089bb916c5a7a1ddfbb059b4237748bd39ed83d4feb9147db50a7e07294f71b5dd91d724d8241f678e55db4adc6dc3d465744930cac7c8e589bcbb885dbb47ae84648f39db7245b77b5d4463d43f93f164bb3ef6f3480df1f1dc80844cd3eb9ea6b09e7ff8796205050f623f43412b4cc742ccdff5a81d42a8c0956523ac639103ecd0f00a9da8f0db3edc6121124cbbab8772b31645d7092862ecc5aa684454191f679862dc8003dc3ec8af7d5c33980bab261814e6cdfdfbff6ac68d4e1dab681ce69b4feff5695897684903d7a1695ae002f008d8a1d684f7a19371bd3d4611ceab5f41849e4f331d134796d75a446bde8dd3e1149aa9910b2152d077dac8f91307f85f70d85590b23d9888159df04dc15080e946a9d5bef9c4da68758232c12ead768e73f96e7c1cb542bac86c09e8e4efe7f3b541fb024bd4f794910cc92ed2d249be6b768ac1b16d8b4660b7faba79a2be6b4253141396b24700b4e75c42dd31af6191a58535d9809441eeb801128c805b1e69a3660f790d15db5493daa757362c215f32449d92a477577048b9e2f76d4b7b4d80b45cb45d37681ee96ebd40e28d4266447dce63af99f504566bbbdad9c50fd49f2cc0e2d8e70734b9eeaf953353549ffa7b97ec07fa795c4b6e71651d927708ad14f2314b06e431b108beb98c4c1e96374042d8ebfa441002ee2fded83fee21435772b9874bd7a9fa0b7f63656b3f4b31c74cfffb5267fe2a6054ef38cf7e75b05c55b4fb7b38914c8dcd882dce75e49b97f2314e57b315cf78fbd2e0611afc714eef7961918d4553ed46d7ad88228468a52be6a64df3a9c180abc3b418a7af570d5b0d565486370363f288652e8078c5aa30ac9baae99f5a5552dc892cd24302bed36296795a161ae5c68b7108cddeda862a216c9ed6a6c79c5823b44fb4be2888c85d4d5d9946ae80aa3c7144ef14d37cd2b3ebc33666e43d62dd3ff1ea2d2775cdb5ad6709cd5e23477d87f974161a712d8f9f48dbb5f15db92828e8f5b33ed4ff025ec46d4ce49cf7138ed04afd472464d6e211fda369fb97f5ce2d98333ad360c94e3d0ca399176faceb823a8c360fa81c5ab9e578608d46544d25ece663df96a4e0f89cc1f3ae7d4bc494872df259a2a0b3020aa53f44ae72a95daad7bd4b2e3974df13dbdeae1ee1ede7c663d5ffd142a426f45b7325d073b617cd1b036c090d7d894ab1d21c6ecfc24a5f46403cea3433c94be8485f1fe58b091647bbf859578103665039cc02a5c3da6998a5fccf3cd75bf664a5c55d364da7d3d080f50b0e2fda7bf1bd8eae63d74b9885c896b2a73fb9410b8db2c034e201afb937c9378a0fd37d07e478d78c09720bbed001d158fa226b5d7a6473bd45331e5eb0db880fc80dfa6125711574a14a331e65074b7b85a00faa8da7de7088ca7c77a06073d5d85be704a47b03912bc1e340d7fd4713e255c2f820d692d8f642aff580e5d653e60fff83918da42beb4e3a5557b381e96f3a21aae86ee49bfba2f89af7cf666cc4ae53099886723f0a7fe06f6f5e45b6ad484c9a917393c6b696802a55d286c97ca4b82a37a5e326f22707e520b6f5748608f5f3623c183f48e5ccb8aacedac9c583fec506775c92fa9df3153d7ac27c755b3da2b15d8fcaf7fc0e4e919eb035f817a033cc54aa80004e2a74909a404332514d2d6c27fb423406c027b88775a93a8ed6872368e3746873b9f2fdaecef81bab769bef02d5580a405d46aa551a80e5a531c758aad27a5e8c0a332cc3d1ba47e242baa08cbfc1a22c2f20a7b26e048185d4912de745f640da4736adf7358f2af529f893d4f89851b67ca604b087b8097fb688c0592d667c60b4f8b58767c9a87c22e073d482de411ec0708aad087b71f6557e357bfc7ae3bd4173e6c2088e61f418cd15c703a3f7bbb5d95aee94c541afde612831dbeb235bf94ddc92916710e0682d5ed36c43b1138919104da3843f159621cacdfd17bd9d41e8f5a9632268d5666959507967fadce56f2926ae4687d0a722c2406de2bcd58f1c95ed5af8d2ea386c7d5f177c8d9344251ce90d4da6d35dc368336ab72df99e06ecc9ce8c6eb4612228652b3d2086426da46db02d1bb93efa50644261c4599b6c53a12577e483f4c3bf511d6ea409adaddb5012faabe66e1265642dd0e1278e1f5ad73bf1c46ec069bca69d12b5d04b93c86b0c3d07fb1771594d83275ad0cc9fb779f1349d36b98100e781515b863552b831467d51c79b483d428cea0a8a097ae111731b22c54d6b8b62164b7300a0dae1e0f1db303141ba50f71bfe1e9f66cf23c05ddc078b0bc4b2bb803915d4612a947a40ef17746c43a9fca6ea90810657ede66da31ad44be102f452a29288989887f41bb2cb6a06ab84e1137cb2d3acd5d0a80528050f178eb70de753818ca806883f57d663e7d7e5aab90cc5b12fac734d349c14d7b9a2a666356cd1da437aa50ad29c993dbb737eb193a0cffaa7b975d65eeebdc4ac6fd6b222d0cf05f2919fb14e7efa0fc00e33e49d7baaf77e633de11572e1635a6302614adb015f3a0f70f1f9dbf8a0ef1840b1ceff8d106bf61cbe5de63b2e0c2ac517385ae7c25338f738af028b5a5734ec9713fed0e43716e1dd05654b2c92f003136975c254a567bb8a35f91faa588f8da6637ee1001fdc8072b1c25239b87af612242eebf4bfd3e9c5aec03abf1b85ba98694d189c1430c02f7487b6ce2738642ad66b10e13b56a0c7f6059b4c27a1ee7a857bd129cd536691ae66db25dd6b8d940a7d8bc793c4e867c2cbb4dbd1c2c53ea4d2e83d377560aec712b0d55ddfa934560fd74943031720a643b0a4e4d7b61c72c0fde633c346b9c0205d26272f0c8c491527dfcf27831c6847f705cc1b8d466fa388becd796b18707a8cffc766f8ee87c417162ac781182c84c33cd96732231c4f279a0c80649bf8deee0aa4daad73db71e6b33dbf24cf1224321a9f7dcffaf597ea99091602c86d0bd7653bc085b5559030ee4583c6f73e74dee43e32c4d9c29cecfa0ad62aa0502fb6438321f2d2a3c3137d701216db7de8b20186bc7d18801c8360e9f4f54ad4a15dcdb2cf8f41f70e4b3504df53872cc33e167582631556359c63e8344a58b211add26afb8ce5383ec14021d5478aa692aca1b916a830d642152675af6bf36de7c54eeb301588334efb802c067d8982cb3a699d2482b2df2dc3a3760bfb9f2345ebe255cbf161713b2ee7e682c14f9d2d4dce595fa5ae2aaf0adf03575d6c7f7d2e0a10e815cd2fbb589c9c5e7389b63db1f136056409a3beb5f00df8f9cb0f5ab193b8f8e200650362d708d6870216db48ce6e4a35c41f077fafeb808afc0db621bf6c35c3452608af414c6706a0050d0bc628af6e18ec309488f3b2a02bad54a83bc8e9c5cb888b31c7db1374dd23f3d91192c02a1e38704b1541daeea41a13ba311320a0c1e984972103755104cc79807c1825fb77213970d824dae6e68f8566e8a66c536f67c18758f2a94e0ed06517909e1814666c91ed95e0006157eb8defcae4536c0354c5113b65d86a154bf126e0e342ff3258998bc0b76cda94f6f16e938182b8400cde1429c1f2628ee38c166f37f636f54c5f69f09c828344c7609e2dfe49adf6c7e78762ac6525655e86178a694abcdf497f7fff779d3574f2d8c82d71fd08f01b1c12d891a46f4b054c9f696192d8d24b838787d7ea60de675cd5c133ee8bece00e05e272aab30c707c06f97fc136645b84674736e37b8ccb206e5408cc94cd8de1041f031a40cfb52cc9b3607ade4b8f6bd3527c6af502028df184705ced639f33efed6f1ad845db1e46a40baf2c8c7870864c90f7e106b8bfc72d5e07141d039da36b4883e1e49d10fa772dea27ce69d306cab6e3fc5f257e2d6cb4dcd0e8931f99c362798fb05740058586e597b6935a9721606290bb99b3cbb1cd5064eb2daacacc68c08f7e336d9f8a561b3f854e3a73e11539d6a28c9ccb74e6596aa45b68c843ab23a567468a20c520eaa2cf09d257f72c0757a81e663396ca421bd97fc0093e8d3395ae13f5166f84ec2e5c57915ca87796fba7dc8ba705870d4955053e09d0848e59286137fe4958eb5f9f7f1cf4cad228875c47d13c0225146217ffaab2756cbc944741f6420dd375dee8281f083f2a4034748563d1b636f5d46f0c9ec1d6d146c7a3aa637d979391f63a675481b48f21dfb5d11845156b0f0454f948de40f997958b30cbb237428850f27e023a4a0eed82db2af9f948c688eda51b3c7ab81a932238d5c5b37b16f903a582f79d99c71a5efa266b39c3fcebea99e22cfd22b9003c4a195fe0bb279c8ba19f13edcfac32f736ae9e29ef85d798772705a053cc1095a037e7c7eaa20ca2a5d1cc975e836b811e1869658e7766e2d38f4be33134ae910f53010ca4bd1693953ec78d2eb6e653dad0bc0e06ae61348d0ff14f4283ba37844d8762b6133bb48fb1f2ef250c6e2946684658d310c4443bee0cd445f055f6a194972917f925d154d9013b0dd673e4b11f014f32dd748cb8fabba28105e2203a25a1aa4e1b9116da1a42bd0029420578d1f345ad0d77a0bbe707ad9862e7246f2f420acf552ba3e009a4623e5d7eff90f6be2f0625c4cfd7e63ce1a778a2804f6eccfe212d04021cef50a1993ad2b80d52ef2ec81673d68180b9b8f9889a02f9291026864f00bad5277ebb528be2f3af5b8e86d1f12d3b3f8985b1ef07df0ddd8e4e4e957636893f2cd089195981b7f6be777e50b9575463ff18e418882e24db82f67a6021ab776b89a765686ec9aba5005eb0291d48103aed7a4c5eff10d0d4652fb5b3efae325ca16162921d1434970a852ef04c1c6d9cadb183e9b95d090da6d8c9caee2f4fb59060792686afea9225d794ec2bbe0d662fa889baf786a4bbf10256d434a98ab2030a671cf97cd73307cacab280f7ffd992c95f51ee6181491a6a2862c6c3e494038335f25ec419ecf6c2dff34d9931833e5b54d1e6b0e39aa3a343e999959f74f9984201750abdad824ae82714ecaeb300f9e42de8b4532855847a271c5596b9e430d57d10f1b24bd8449ce06836bc57695c3ce68925ef8523c09c91f4f0d4c231cf361fcb143f5d3c4d6410bda1730db1e9d186e765b7af1d4ec002acf9a97aa7261411e4fc0335e24c891a570ae4240a124f8778202bbe0aa993362da0bd90d34f9fd83d44764a80f4c9117748b8cace60fafec262ab0532cabc8c7fe3f33ff8f496ec2d4a75bd425ca6247e92d927eeee02703568341d79560b65d14b49b5ed3570b6baeb1773a929d36164de36616fe04983383997aed04c66ea6b6d18d103c8e0c26f5e31bd38a4b207ee72432eb4fb0ef921fa2fec9007c629ff2856f2ca8190fbb263ec6b3fd6621e388e37f474860f132fd46ef3b45a373470fb067ad99e6adc950f73338cd34b48f60846374e3d191f40311ad0b3efd5fbaba81fe8c6483ddc1eba2ba06be8ea59f0c72f31d890c962d5f59d4a5c56516e95fc86b18866f4a8576ba63b1e3a4652905b3d9f5ebea29c42be50d49aa19e6516b71e1898712007c5a29aede4dd0b10ee42c925e0dfce659f09eeb01da261bae9c3cf5659829c9f8636e74fff170e4f868e996d0b45aa8394adbc9f8079803d90957e16014bf70a5a46bc2b7c6d028f7c82ee108e9ca5008679c4578996d2f3358790edd69c6c3db8182c20fc8c503dc0e98be7525a7cbdc54b4dc7d11c24fd0eb56d51d19befd6886662b813bee7d267a14bc2105864737fa3438e1c06b47a56fb8257687cac0273b9d2d47c4313e4fd39726e2d08d50918448e3281b9a776a4ed5b0ebe3b59cf0f2781261a61a3e6e7f511fa6afe9419c39bf3bf72f3ae8e7233a3aa6136cd262d4724467a44cf977bd15820a5f97f9b9f8598a0f80761740ab302daba247a142b122b43c8f693ad1efb8e6996deaee7eb520ac91fa21397d356beaa77f92eef7bb2ae8600442d95d2adcf5000ef0da397a32170af692d4e3e645fce44c71ed9e2917ba4ffd77a6d4ea5a0d9e29497791bf1a45f056b7a43cccd383d2cdedef2d9930cc3b105b527801c49ea867261ddca40487677ecd6a8aaf1843895024a4a2daad701a3ea26e50160853e8ba6061b92035ad54cb245293d780fd447750bed7ce8527f50803a60b8b26702c6acc5b8a34d8798035c5eee1f25fcb3553619925372f6345e48e13a3c5a593378159403dbf37732900dedd58cfabe7c4ed8d993cb81433d7351ab0a664d8d0fcd787938e514648e5e0a399e80c525139569e314181092f55ce59a7bce9a5d0762405da8ccce4b92a2311811fbc7d85b17c94438ab0bcfeb6e7ecd61ac1078e7a07e40b6f88bbe8399ff559b0234aaa99561761c92e1f7cd0a8dfb18a117d7394b28e639e4dad06637b42023810dad3ee08f87857f0399bbc79a2c80b55accc7d9d1503e17d5972805726003740752e8ff678a3c835ff4a16789edfbb69eadeddc06f8e6a8a01e43b8377e3f6a6a91e49cca1aa4bb8049780a16c75e618d084ab13f89ef5dda466bb372b25174ebe6fe1b3b94a9234705759346eccb69803cdad2cf2124de043e8b4577a5dac8c7267edccbe5f55eb270bf3b9a7f777c5fdd07d7e02d4642126917c4486ab57a797e9552cdd63a2f82e2404c17ebbf505ee9b27b29051fbf09694005bd8bf0f7535e9fdfcfcf19c5ee18f59034f19273e01b02e0a1745ecb6d7fa4297c14c8ef2b5033ad469f426dec46356d5104a2608676749562e5d7e0fdc8f8784e884abce1257b1fef8c00daac63b305d05ecb449821af023104a1d6d6824f42ed693ca19f71b669965d3fd1395eea378136b1ce9df581773b748fac1c53f3d5c5478746a400e827c4a7873bec2e1b63d8f08dd79e6573f625a638659e83b97adae6d02b854ac99eb3f2a03d33e90e2e5a7307e6272efa1cae4af173774c427aeaf21622ec02685086be8fe5d51a5a5b751b3ff88d1210ab84ee1207e3ecbca3420864230b62c532ffe1d98b88f0ad6cd241a3af1cb333c7b25fa267829354a452ad96a5872134a228b0dfb38797be3826afe27506927debed127040684533ae6d13c5b56feaed6227b5883d7c612fa7661d6c0bd64354ebd4894af9d64e3156eefe2d4d221a88dd2698aed161718c5ce1f31ff903c356f460b2499df7da75239bd7a5f48f360682e38c14880b2694ea210e779a9e0fa31ea9814ade5cc0837a2081298304188b3324bbf294358f21fe6fc80377c030f7d3da1a25c85b30d51178ac7aba9a3caa4166b8c296ee76420b70a3f519fe4c06d1d72f2bc1ebfefd7970b7ec0dd3cfea67d6f86b01cb6b38d71320806a7731b2655a83ac9dd808d574c7de054d131940d57ddef762bbc618495dc4b986f648859dc2ca279f7411b7157bbe4086fa462642345deaa5036f7650fbfc9399bb06b1a21ebe2c9f94003b05be0041457224dc5f560b1a690e1d2accaee530dd33da5c70aaa61112b85371e7f5796588736f80bf6bda9ba584f9d410be0d659b43f16005ae0f6c551148e79d19f4ee20570250a20f78ad75a6ea8b803627aeb6e95492c516a52ea01329646b1a51e2f4bcf610ed192a29f773fff2473ec6b37186c6916a2e449339ba8c8896c70a07869bf75deafd5aee63cd3e9d3ead1536ab9275b6ad1516457801bda595b3b9fea4a530a67281ca0992493ca114d6e06036b840f0a7a0e730f1a9d93f8292be34fda4f3feb42fab7dd119be852e9afc3928e133b552723dac96865023348ac80dc67df6f15697d98bb2662ebcf32a8b29ad8efebfd181b2366b679fb1d9c692c7cd5e380201bf4f538cc7d96a707a666ee5b6a2e6e8958329263f931d81da192aa0550ec3a6dd9daa8024658efb8e9c818203d857b6e08abbc0e1930fdecac37cae19b300ab49fe3bbc07c2473c580c6adcd36e1cb5c049a8f28cc1bd2abb08969a32ed96784fd616a02953a019ab2ea9409e85be535da7a82ee36c519c61352dd9b8fea439c74cd2b7b944475836f46332710561f64c3ecf375a88b4e71f5d12255858e7d7972ab9115eb58837790f7d9d9646ec9bb408bfae6ec957285eac130ce6ec153cdbd2845e80bf7b9f45e20131e4f2c758c0fec6f3eefd38ae1abf53a655fdce7c6ec019f2d2252cb755793509ba1c9ce187b596cec6df9edf11c34bacdd90d2b8c12aa6dd69114b5cd90a213652e521e122691a689c5e0fe901f9949cb3da3293717fa66fcd7e05d4ac12fb491aa76c2949af6e3748909993e777a42fd2d50cc2aa19784811b4e13ec9e1b6bbee1ae75fb65328c8103e8e294d4498a13f29e341065f8cc9251ca2ad64757bf69c7d74b7781b9eccdf0faffa473d47097b8b690c7c47bc23a334fa8a62db1e15ebfc40d58369f701d1a8b4dff84bd0f83552a16863fa7e4ad9d0420bf87a36ff6e2d592f07e27c4cbd9db7b8425a1b897b0e3cab55ecb770c4d0d6c4a5cd822691df2e3dd545bf8463f64221ed2d4b7c3e00ae79a4d14787511a9b8d453ffc7c7923127680b3954dccaee2861c7ada83135bfc9998689d5f2bd0ac76afc977dce6575477926a52d92f803acea03d8dbe8d35a086d92340d0399400640750fb1fd3b0f752681d0f503a2c3ceecaef259d5803cf50ecdadaf4a6466d4edfdf8a35c2ede1ce0eb199ad387a639ccc79500c17e0ea1a39e0ef8a397be7723dd1c65b39c03bba14d135a5628ad4a33e6dbf99e42f3e45fdcd77ac95ca33d28e3e512d21181eb8a2b508cf6a538df09cda8d8cf3906f6ff826e459334d3dadf2ed36d8d43c323af9bbf1e89e6c2188120f5cd4533d40d517a93696842273bcbe3d5240a4f1c440437477309725f6fa2e3c63723c8d14ff7e36781576716f5e366ffb75f7115e229132776408505efcbfede5da61c7aa42dfca99350ad986150320d877ab6512e443be3493d7526ace35877cd2e8429d31a222ae231d977dbca22347f32f2faf5ed412e73acf1e415f2a4564108db7e0ca0bac47b1b5c2cb3cc38ed222d2d915f8e2ec2e37030d8e1dd3ef6254c1e360f17092ed4fe19b5235dfc439bfe7250861008cf495cda3c5937bd6f9346640106d6d5842b4b42bab04acf9e0f4cc0bf9a2fe90cf65431e321d368bb22b2113156a88287f1b0cf61d52635377e8d29d80316559e7bc0246152c4392f3c881901daa1519e2570bbb3c0e7cdd98efb1af76897955d7c278328093ba950168a15757f569da4add8b57b7e7d6796ce99b7b42d58e0c6e9915185a142065aa7f4866cd0a36b40fd4002342523ce7a13420efa80c4d1fc01c5b32e34f9e8839b4636a6bbbfa154f3274c75ea2c749e10cc03d69dcdb4e03c2ec12399868f02552d25283bcd54fa847cfa16f2cffd25228b7edf9687a4715ef8eaa421502903a715615ce88883f0258a582bc81590ce57c25b77617c0b0ab4c00d427655e085f53bc2c0c9c750a1e4e12916e21f7ef7613db74fc3f78fdf488dc12a2393660c793fdc887bafd50446b3552c28e81c62d969d2c11d72cecd6e4e82dc58590ca616183f2447d2f960ee03c3e11ee34014cf18f0da83babd1c5db1d66e89d9e76384266e780117374263177fbf334bbf13cd473ba23d064cc7c24b62e3146bf926505ffa1d4ca618cf14ca6c9ef54d7a308b87bdbca2d5cf57a70858fa7259f8738fdeef04f8b5f930f1bb6e09f2308fe419f3ac114b0a6cc25bd0aa5ba5b7fae7035d2a0d3590e70014b2502734de752765046271422e757bfe05671a1e9fcd5341e0c1b5b0358001ae9fe646b94c3540fd25853eb7a18aeeb8a68b624440abff808a11939e98c33d40dd2049e1bef563f74009e834d74324fec109fb6f06ca99196c830f36b9b2945d3d6f6562659eb25ec4ff9c34e30d7c904c7b75108b8115cf869e796b64c62664bccea63b7792c63a1b6c2c60b15c68313c4a8bc13fd29ae4a93e5e2e389b1c2499ef1a67d7dafc73216ddeb4ce1580e8b2a84d8f04e42bbf174f47ea8a33278f00cbf161e4651962ae645d5a72e8ad95d7962e1de38df39ddb5a5d78b3fa2288bcc65b5fd3bdf3c3824f3496306d1d1ea93f58a2fb1ff3520646490fd37cfe6f4f0ebf223fcc39e98ef4f83ac8004c473e57d0ad7ed1c4b2d8851e0d2f8ac9b15da9949b5c27b844d0b672bf4cc4ac956e4267b2677015256f449968543c3de381aa5ddc0fb6b3209a7739068df1991492557e6c6409ccb726e506a41e1d52bfc3cc7f4e1562e1c2054de807bfeca501b95772ae62e86ae956ace72de4fd741b1ff9090beb1487804d59f0a5315e21749410270781f845ac6e57c5c5e9a2aababfbd2848469c832d5cbb22535eba9803f9fe99725925d01915bde75d7d076f8ae06070ee5bd135a25a45401ea12bfce3aef7cf1030a0ad9cee0aca405e2f54295dc2f468950fe63340733e4c7c07a50d9dca0c6ad56306a9a2ad014cf15b7dae00423e0c7e73aa93646ebc0ee6da5e8350782f666b8bf1f0152a1bd08a8b539ce1a1ff6da3d63da532e65a94f9f32e202c533f1953dc5d9d6d6e96cb6dcf5179cf9eceddab4c1962acae1d520371502e98079b8e2c2321c3aae95e367f5ef7ede9f77dcbba673d7b0b16fb8dc7b19cc85537b7699aca26b152a253262186577dcf21ffe26ac204e9cdb2879bafa98b889a2feffd2f9c35c2af5e65e1938ba0844da0bd5b698336a214c171c6e101bc394734a46297969238ef97c7a7022e8c7949c93c316fe87049301b46c5acea65927c4ef738d7654cf8342663696be0f2ce78abf5cb168393fbe801c371420707784beffd85c2b95f4ca121ea1fb491b93aa6893efa337919bcbef2a8474f2bb2082634cec7e4ad3330103a74e643d42333d1dab5c11b360802fbbcbfa0c65429e4d678a2e10c0e3f4481101c4c6c9fe1dcf2df8dde547d9ab663428d91030bb974c953fb9367fdb70c58af62d25658ac0eac6d3cc993a7601d9de89e19bb2dffd5bfa19bed50548235e8427dd37aaf0f4e04b40d66e6bedd28539e1938641e054770d41d22f427f67563fedc11f4b4770cfa2e6c622e1e1ed2bae6a2149c2c4e535f3e0fe6576405c22401b9e95b3c7c2bbd268eac4ff5519ad908a5ce1e46cf9fb46ff8fa8bd3fad3dde2324d36da5beeffb467138df51285a132b77ec2baf1332531da8c08b111c0855c3e309203a9172e07d5d03fa71101a5832aac2f68c9ad0d4f2bda507c05218c61e549aa2a11ecce016c634eb731308c70c91cc3e7e64a4fbc8fdd8c4d8697faa898cff87b20b4807a914002c7829a9d54f3afc23f414620ae586a75e7a65bc3e8ac78bb9be767e1be3775c0aeaf115ccb0e6269f792542a44d35c738bf61182af6e6e5b099e5da93f29e8c6db1008ec106e05c5b1e94d55d35d1c903831e97c749fe9196373de53955a4a2933b8d9eab44856e41234213dd1e1936192b0dca1328b96ad2b63490dd432811a9b44f32ac786fad600594105021914ad24fa14c958c535cdb25137a98870b1db096c13b26792ac6523e883fad0ac7fdbbc60bba2e750f43ea965f6874f6992771fdd5cd1e2604f1c591a4cd5ae33399103e63b0ff8715042f39cc225feae91d9ff4e8dcbd431e20f4ea961a276fd92513112e96a25861a01291e9c3411125aa365083eac0e5c051055d0617d56abf4751be949a343803d14007ab727853ab81fc173dbd4dcf7e1bc5daab380471b5734b097b985e6c9a86538d7f15b5822985ae194d6c9dc52c6520c926e65ed9073c2caaed7da92592cc5853979c61c21f204cb1050ce1481b2c1d5fcd02207fdf5264ac0f88b6586fb7fcf1a2b13f6f14687d632ae0addeb72ad19008c30955caf2fe32a2b3d0672d201dea8350f28b8ce5849795eeb72bfa330bac28a7a2f225fd9452c8fc807097d1b78feda2be1abefc32309324ec5e1f413ca95608357c7ec264130abebc329e803a9cabd338ee6e1c922e7633e492cbce559f5385dce30273c991c11feff5a8dbedbf07a69fa8e9da80f60c9b5b9f44444b9511106c98206b76329b47ff469ac139475c19df0a5f2b838a6a15d65fb4771d283b5dcb60a6b336350ff17d6d95bb481c8426abf95073c416ed0fc40d918d77e184a8d79c2b2f6d0cb9e917068e760f412ee7e158e820d9cca097fd0f6d2c574151f3add9df6bd449b04cc92a08712536319ca2f38ef1c05eaaa9cc47bf3d69adabff9f81027ff4d36313157a4f8a9c6220b27410d817de7276209fc9c1c080ebce81a16664f4c165fedb17d27096c652e56acb3858f61e208a7263d077da4dcfa823d9c99a98e30b6b29a4a02e24404d59950011551e7a49972007decd50c31532012e58cce7c3b1c1fa194e3b38274f23cdfd8b161d1a9dda607761d035c53e2f5f4c2ef85237dfcf6535a5eb2910809833c23b99852e540a8e022a2746694fdf6cc80761dbeedce1b0824e3d9c4fa176c3cd63f16c23524f43e5d00b7c169a24a71d044ad46fafc2b411b7417937ff2e74455eb0f3f5535a03084f86d640dd6e10a68ce43faa16306cde1ebcf2045f91dceada11c15a4eb1d10b67c3566b43286217051097ea7efc3067787c6c42f625113223e95d462e321b696d043cbcebded9c792c78ac91b561a62d525ec45f6e54469f3aa676181ad97833ba4871a9a0fa0014c20034a1555e3b6dc5a3a4120d4212696439c8d9b2c228c10610fecba05c4c3e07b8c2c3675030a2f8b65016a5eac78695cc5dcd962cd52e44084eca9dc5e77b947bead94e4c6de3adeafae6d04e1e0b1701941212d0fc4ea7599418d65cfbcf7c9acc88240015c8b23c740d4a18c674522aec5efe4a4986cec994e61c8769e0b7dab27afa42c5fd16941d6b5acf1e00113db0c9ac8e8b1dce63e46ac413a59ea7bd8b3fea57d0fc758872d81f323e0b9cf33cf84a80d41a597f245668cd8f03db68c31b7a0d7b88c4af18c140d7332dd8cd54d04e8ab0b4e33abd1e975bc64227e82ea68e6556ca0fa851418331a21b134275f131e0c5446a9a2f4ff0b2f05214ead8b3298a4f610302d362e11cc097b39f7de8b4b11e79df62a371c4f30d4bf690076265dadfa6cb0ca4158e9e70707a72730034ae5631910312db84055c81340d4e7fde4c459bb8fc2e3d87d487972febd28475d4d88082b6f4d379732eed25205ef01dfe56e8dfe52027858a544600cb94eb7fd0bd8252cfd995ed2ba3fd752f61eff8ddb451ad3c511920370cbaa848ececdcfe84fa897041d72b75234e4d5442cf9c50077333439394955d36e0721d9d039f86525f9ec82259c8fa4ae639c074650c69db4e7348b92a5d5e753c848c7c10c04512d593cc13a2d061f578a6b5630bb4b354bb8d513e9949509747a413faa137b808bc164bf302019a79168c88795fbfdc985d40b1911b96e460a0c1febc4b09a242fc59bc5a20cb8602af109e22b46c4616f29276aacf22d7b155f28af5dcca761390a6efae1b5d531edf30349062698b400197060cd0df5de15c1100a35c53a240e55f3447c08643eaf1a521c71c3e8dcb3e7ed10b555d43261793de783b8191586785d5e29590d32e849dac5d67ff552a6b8e3791d9990232b424a116aeeab0c3b7f110b3a93ee4a43c81ec7424c63cb13df1a408fdac6dfc5fa978ce90091c37ec37a6cdbca55b8fdbdbe5e56775e532b90bf545eb93ab7b99c2f89e5ec770bb89d3b7ed65a7a9f9bfa26ab9d1a8d63f3c14d2462cd3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>私人笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PYQT5的安装与使用</title>
    <link href="/my_world/content/PYQT5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/my_world/content/PYQT5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PyQt5是一套来自Digia的Qt5应用框架和Python的粘合剂。支持Python2.x和Python3.x版本。</p><p>PyQt5以一套Python模块的形式来实现功能。它包含了超过620个类，600个方法和函数。它是一个多平台的工具套件，它可以运行在所有的主流操作系统中，包含Unix，Windows和Mac OS。PyQt5采用双重许可模式。开发者可以在GPL和社区授权之间选择。</p><p>PyQt5的类被划分在几个模块中，下面列出了这些模块：</p><ul><li>QtCore ：模块包含了非GUI的功能设计。这个模块被用来实现时间，文件和目录，不同数据类型，流，URL，mime类型，线程和进程。</li><li>QtGui：模块包含的类用于窗口化的系统结构，事件处理，2D绘图，基本图形，字体和文本。</li><li>QtWidgets：模块包含的类提供了一套UI元素来创建经典桌面风格用户界面。</li><li>QtMultimedia：模块包含的类用于处理多媒体内容和链接摄像头和无线电功能的API。</li><li>QtBluetooth：模块包含的类用于扫描蓝牙设备，并且和他们建立连接互动。</li><li>QtNetwork：模块包含的类用于网络编程，这些类使TCP/IP和UDP客户端/服务端编程更加容易和轻便。</li><li>QtPositioning：模块包含的类用于多种可获得资源的位置限定，包含卫星定位，Wi-Fi，或一个文本文件。</li><li>Enginio：模块用于解决客户端访问Qt云服务托管。</li><li>QtWebSockets：模块用于解决客户端访问Qt云服务托管。</li><li>QtWebKit：包含的关于浏览器的类用于解决基于WebKit2的支持库。</li><li>QtWebKitWidgets：模块包含的关于WebKit1的类基本解决浏览器使用基于QtWidgets应用问题。</li><li>QtXml：QtXml 模块包含的类用于解析XML文件。这个模块提供SAX和DOM API解决方法。</li><li>QtSvg：模块提供类用于显示SVG文件内容。Scalable Vector Graphics (SVG) 是一种语言，用XML来描述二维图形和图形应用程序。</li><li>QtSql：模块提供类驱动数据库工作。</li><li>QtTest：模块包含了方法提供PyQt5应用的单元测试。</li></ul><p>PyQt5不向后兼容PyQt4；这是一些在PyQt5中的重要改变。然而，将旧代码迁移到新的版本中并不是非常困难。不同点如下：</p><p>Python 模块已经被改写. 一些模块被舍弃 (QtScript), 部分的模块被分割成子模块 (QtGui, QtWebKit).<br>新的模块被引进, 包含 QtBluetooth, QtPositioning, 和 Enginio.<br>PyQt5 只支持最新风格的信号和槽的写法. SIGNAL()和SLOT()的调用将不会被长时间支持.<br>PyQt5 不支持任何在Qt 5.0版本中弃用或取消的API.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先安装pyqt5</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install PyQt<span class="hljs-number">5</span></code></pre></div><p>其次安装qtdesiner，在安装的时候需要耗费长一点的时间</p><div class="code-wrapper"><pre><code class="hljs awk">pip install PyQt5-tools -i https:<span class="hljs-regexp">//</span>pypi.douban.com/simple</code></pre></div><p>可以在%python路径%\Lib\site-packages\qt5_applications\Qt\bin中找到designer.exe，双击打开qtdesiner</p><h1 id="qtdesiner基本的使用"><a href="#qtdesiner基本的使用" class="headerlink" title="qtdesiner基本的使用"></a>qtdesiner基本的使用</h1><p>一下简略介绍qtdesiner基础使用</p><p>大概流程为File -&gt; New -&gt; Main Window -&gt; Create -&gt; 在组件框中拖选组件进入主窗口 -&gt; 修改组件名字 -&gt; 保存为.ui文件</p><p>更详细的操作可查看该网址：<a href="http://c.biancheng.net/view/3956.html">Qt Designer的简单使用 (biancheng.net)</a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>功能框内可以拖选文本框，标签等等放入到主窗口中，并且可以随意调节大小。</p><p><img src="../../image/qtdesiner功能框.png" alt="qtdesiner功能框（红色框框内）"></p><p>注意右边，该页面是作者调节过的，在Object Inspector页面中可以修改主界面中各组件的名字，选择某组件会在主界面中高亮</p><p>Property Editor可以调节该组件的参数</p><h2 id="阅读代码-预览效果"><a href="#阅读代码-预览效果" class="headerlink" title="阅读代码/预览效果"></a>阅读代码/预览效果</h2><p>可在以下操作中预览和浏览代码</p><p><img src="../../image/qtdesiner预览.png" alt="qtdesiner预览"></p><h2 id="ui转换为-py"><a href="#ui转换为-py" class="headerlink" title=".ui转换为.py"></a>.ui转换为.py</h2><p>保存为.ui文件后，需要转换为.py文件</p><p>在cmd中将当前路径设置为ui文件所在的位置，使用pyui5</p><div class="code-wrapper"><pre><code class="hljs vim">pyuic5 -<span class="hljs-keyword">o</span> <span class="hljs-symbol">&lt;name&gt;</span>.<span class="hljs-keyword">py</span> <span class="hljs-symbol">&lt;name&gt;</span>.ui</code></pre></div><p>\<name>.py是想要生成py文件，\<name>.ui是刚刚保存的ui文件</p><p>enter后会生成一个py文件，该py文件即是该ui的python文件</p><p>这是小例子</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">pyuic5</span> -o mainFrame.py mainFrame.ui</code></pre></div><h2 id="初始化页面"><a href="#初始化页面" class="headerlink" title="初始化页面"></a>初始化页面</h2><p>生成.py文件后，我们需要打开页面，在生成的类中继承QMainWindow，然后输入代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QMainWindow<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>(<span class="hljs-params">QMainWindow</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-built_in">super</span>(MainWindow, self).__init__(parent)        self.setupUi(self)</code></pre></div><p>在运行的类中，输入如下代码</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span>app = QApplication(sys.argv)<span class="hljs-comment"># 初始化</span>mw = MainWindow()<span class="hljs-comment"># 将窗口控件显示在屏幕上</span>mw.show()<span class="hljs-comment"># 事件窗口绑定</span>self.__ButtonEvent(mw)<span class="hljs-comment"># 程序运行，sys.exit方法确保程序完整退出。</span>sys.exit(app.exec_())</code></pre></div><p>运行该类即可打开窗口</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h2><p>通过主要窗口获取组件名称，点击后调用方法</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__ButtonEvent</span>(<span class="hljs-params">MainWindow</span>):</span>MainWindow.组件名称.clicked.connect(<span class="hljs-keyword">lambda</span>: self.事件方法(MainWindow))</code></pre></div><h2 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h2><p>获取文本框中的内容</p><div class="code-wrapper"><pre><code class="hljs python">mainFrame.文本框组件名称.toPlainText()</code></pre></div><p>文本框设置内容</p><div class="code-wrapper"><pre><code class="hljs python">mainFrame.文本框组件名称.setText()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>桌面级应用程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透测试漏洞大全</title>
    <link href="/my_world/content/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%BC%8F%E6%B4%9E%E5%A4%A7%E5%85%A8/"/>
    <url>/my_world/content/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%BC%8F%E6%B4%9E%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8366d49c8a437bf8b88170cd2e973301fb3166f53eec3e6708150ecbb69d1a62">0006ec5224ea6a36cd05f87fb7ce308862f2662afba26cd8bb37fbf4b96ab72c2dd7f80ca58284e718696451f40bf1338fca206fccb3761e834907c642d69ef2c4632274de235a092e763fce508f3ced60fa38201c2a7ab49f954655517f211bf5fbc32209436f4e42b02a789aab70b849994718fb6adad80b1093a1fa895056635ba67a9091bfb4f14aa4e6cc2b1dd42241bb51c348e9426b887b0b5463234c6ac9b39b125edfe936f2d8c7cc5a061fa59230fb7f71314f48c893a4a543d31ec48fe8a6c1bef0fc473e1f9bb2830428e58bcc2fdfc576d7d3ce887a28590cc931d9264b49e904ea8c5b28028d6c77e64a160526ee45201ca1a022ef27db189061e8133ed3abb54815656532bdb5bc667b2ecf72bcabd666624cd2515a40b7589e2e31b36d5b7e0c5cfdb3a666ed7eba8aeb0871213422c536e994ed5ba929b290936bef248e0fe5d7874ca943ad5f98ce46140adfb6b8a389a708b71948cfa303adebd96ef31ae8d5e2a5fe9c64eefe17154a312a957534ef23cd1cc72f39edc60ba290f94d93e68813ee4614723245a00e8b0da549b8a72a7cef577fc005631ffc9f8e2718275849b900e0384eff2f6c3c34f43cd27b49598419b5bb0e7eac3e7fda0a9e44220454ebac5d3a9961e924dc526408e30015cf82f02b2e7d6eb6753a4759d84ce5b81aa763da404f294d8c9040c69f802fd0892bbf8810bda5822fe1f9d1c3404af8e32ecdad26e801defbf61841287e57f651f5ea332599f353fb459ad46b42536f8129a677a4fc4df0740734e41063bb329fd3a3acd015e988ab9f6c92b0e0824140f2094d8848eb8e6ea4dbc06761e893ed22df69b51768377c34c68ea3a3767e45a7b53c861159d60f8ef0e84c3810c6061be771dabbeac611b9c900a33232545eb909c3e1dcfe2e12de86b2103a535b206cad1f01d32d4e2f4ebdd6a49050055345da81ba06f1fe186665f9ddd2a70dfe018c41c7a2cff2e12242d62cea53caa549f2443d7b690fc1a7d5853eac97dedd46a46266cb962978d9e46264b3294b81a885d24021fc1dd106cd2733215ebffad632009f84bc1f56ba095a5a7ca6e5bfc263f1301072620dcacdfe3c2ef5c5e53bd31769dd1be7f2834aca4815cadc3a7d30dccfa4eb8d90a8b7e7d4d238941af73b911f5076062cb94499d58d428a509f488ce626fc719845d0c2b27770754a4e16cbdd44346e5a4ab0bb60ee23ac8f49cadf7a17b27e9421d570807e8e875fae99c82849c02162ec0e1d7f61fcd6bc2211e1f95f14123f118ec57c537e4d34cb1ce68f78e7c88b4768c3e761495ed0930e55729d9af9a2cecdd9316b2e7355d11a3a7bc3bfcb1f081c6d133101e73a9216012094abbd5e640d0d85b54a23a6828463028d679640a8611bd3a22b4da31913d4e9578e8cdd76d3bc93ce7860193ffbf3611a15bad0512480e070689cd7f04dbd9654a4630367ed1322c7f522aaa9818949203853f879cb30509b8e242d003ee7a9d9374af918e9ca1cb36f03ff995b474061258bc3cec69a86bae1d6454e93b48a9c3ce2d586c383f1df525c9d1690f8b87b852f226d8a77c7e31a72a19c25d049a46b7aeda25291142104e251dbd8e553666c3d04a52193d86197b435ac34914400af35d574759a5435c061c48952c944dc5f89b68e1e4fad465b32baff79328b963310994a13a8d099408a33113fb28ab905d8aee929f0e4c07314054b1c26fdab3f284c451add50a095d22773f0b20564e8ee12ae4d8a420f12202f460dab2ec5a9654cd8bbf04892b553137d6895b6c1617181cf4b79f23f7572296878957b409acdfb63e582efd33a917eafad01eb979443fe0a05f68e691ff6fc64eac1e236f354dabe62760a527f93593bae325079499dd2edcc1da383638edd1c26f7db598ceab36c4a4960f3787866008fdb71ea850a1e58d4b73b24a2bccee5636dbf1dc2aac7f5e07963a45003ff25854d4dd5316363023dc6f54922dc938358c2f9eedc88b498d849187e1c34604dbb480e4cc4e69f4a541df556c4eb251ae094512f87376a7817bf07c20c8b79b391175a0761f21fb7f2b3e199e6286360ed3cc378c3214a25485fdccab4d115980446e5d05ed47b22f6638faf658ff99c1c9ef7231452bee3eea432f73dc2c3d851e4cb4dd092cd12c64560b89e36719b59b84c752b247ea1e28a173b8cfc25c671c257d83db7ed0ec2befa268c232a6fc60e7abeccba963217f489f1f8ab77763e9b8d64cfe904bd153c054ddb88601715e58a26ac79d56fa37353f8a2d9714ba80f4f5345e058c1887dc04527cf213442406878163b6014f26999b5a281a221de75fb49dbbeb6a70f4876a1fe6e00f8cd4a0a6b10e9188ce5d12b78cbe3b9c8c2dcae391f099a494a4a9c36ac79ce57a9ca4f64e9f3f3e4018fde0929bfb140238cc8993de188f7b4c91113ac372336109752f605b971e5cbaf565b39e36a7f692b66174d71d6ac961d723254a42e8017bc46a65aa8b5af82134546bf1f3d9ce850a582bd5173c4bb1f41a95cb1582fb863ab4324e4ff4ff20b8c507b3a070b55c57faf0b0c6367bf2420185f1845aa26614fd5ff769adfeac8d2de6d6df9aadac1927df9fe28b911228c3a4511c19753c9a6e0576e87eaa103c8d3db889a5ee7531e43001aea51bc251e57c5cdaeaee0a2ab3f4f36b0acb0055df85d8849849fc5544a3d4656cb93bd23afb172dd85aa6ed10f4a063bbe1bf8ee94e8d1ca5b6877e3aa810e09f767ad6348016fa469ab1959251e8ecdddf39fe588d00e9d2dab6d1973f85c2f4a91651f350c3129a212da6b3a8d0fc51af63657344ab56891f9d3a0fe202665b01677e8f892a583d11812d6669278216716edd39c9d0b3382ed4a088110be81b4e606d50de250ce781eae4f49cc2c79540041fd9595aff9e57eac8987704b0d9e3e5b33e9374b5fdf9717f3d61c3fcb66e8617de2d44360d0ae7d079b177d108ea82d27c2ff68743f84f403abc79b3bc2b7015dfd84697d4ec9d432507aa9bc4a892ef9529bf81edc7675912ed8b73e51de9cf7033b1af43dd7f85214f3d6f5833743f0b2e7eb285d0691fed0ea99237936ef0ad6d8d8ae3ec146b6ebb66b37febdbd3ea4f9ea28adcf4d0b0d615d38a25b5cd845bdfbabe36c049af9554e6b8e0fde889781c686b18a0d5e495b86a27013407ff3635b44544d023d047f80428d2810e213cef4bf14766aef106fd1ccc3369b59f19d0879ecded951d4350d2992e9ee0e491e7462972528dabca0ba0fef7eb2880b51a7478a278a5652968e28b5006db8d4ca0cfa6ebca384d7bc85127c7a4ca2202fa055e5a3e2ed517fb5d7dc16d88f8e7520f33d360fe99af2c39990f6252c324d24d13f3ab185ef6c9cc90e4d8f87ba2991b8d8acd239437f1214c787bce4514dc4a4e2e87d633433a591b6f0ff7965e23fdea15eaac4a19c66262453201868c2c14696bda1fb91040b7cea63b32ede1a613750d3f510cff09101df9e50410676abc081dd4aee9cd9a70ef7629accfeba274161f1c7d94283fcfb2b08b1cbce407cb7687d7908249e4d71af433257d132e001a524b10130c9660a7644f26d42cb21d089033486c0694681ad2998ecfca22e5ba42b8b8ba5d87373f16d2f489c09f4f2acaa7fdaad7d5e5995e56369ae4e3b49dcfdcb9a06bac2d2122923b0cf1ea0bf28fbe04c6c8513dc9769be269a9c5fbc835a2265acb2417f941a3896b584151609c40a56853a5cacc1e3d9679c3d3cd5ed5e39c71f7754716578147f6ef7c15ac9835e41eb1af6868d558a0f48c53a59274517bda88e03152622eb91cfc705e19df1fce1db843e5b73fc0313520feda6b83646a89a7d187e708293337377468f20def9f7fba20d41d7c19f991658def157e31b01fa8fc519a8007727bc01fcab52d3559cd436bf85db8a9657bfaaef143d2de054944b2835656adecc2acfd6c03993f1ac2fcf1ca932e6f4d586ca327b4eec89775b36eb7dab98dd6580b33523e0af2bc1f91fc2743006f6993a33d957b4ab23fa7af39b1f72904f16e3781e77b4ce932a57d2ce1c9cd4c9e07eda5481bea830bb8b3198bc885748427399a9c09b00809c70553875e75cc59736d31fa8fc2912fc2b0025c0a1fa99fc42cb18c1ec4ee651fe07e24deae7fbfbd0fe00c93a7fc557a481dc2b53dd5d8b0623f3827d774a8fae9d86bdcf269f04624d51008f268a66704b2347198098db84bd60a310e85bc7602ae8af69261339ecbd62de380cc9783b9d46eea32ee857fc89e8be88c20ec3dc09b0ff5528a4aedd39f5bd031e855ba406f325e2306aa9ead1f26a119fbd98b27d2fe5c71bbe2a0936541048faa22a294ddd944f6a926447eaca24763348cec7a4bae4e10f776bf7f528f111d9b209ade537e0cef394ccc8863bb54e9a41e27e74faafb2d177a63c8eb1006a6a33f93a9d0be454a6914e932fc1af23538c477fce5f8f316d18254c8690903f903ffc648dd3a4986274a91895f1070281c331db495d59f43cae20d8155565330e1cc6b13dc312e84dc40b37800924f7fc718725b23d2431f38b2cb784868303e0c22a53ec52c1741f1bedc3f63098f8e1cd877cee770c75b11205727df236b39db8d980f13d14f96b47471eb4c69b317f79a0f8981d589504e963de25e2378f22fccefe6afcf5a30eae75433086737265c14ffc284e233b34269dbe6eadbbfd154ceb35b139bb9e0f16e2c4066f11602aafb68a0382abbd30ac30b4417548beb97dbfa279c0a41e7125c90725726d0bdc77b3a8e30ba98bedcb5e4c4c50b1a4747a0dbceeb61d0ecbad8bf532dcbc2eb392d93773e44df2f6ff8479c72611df015f03bd496b8bc6e4bbd6742b22f124ce51e25dcb364eeee4ff54bf99f1a5471cd66c45f23aafe4cd2a7522f8265a6b075fb36f56ab11a30b2a699c0d646cb46af7f6d209101de160fd7220fdacb7142cbd6bee92ddad685a92a754a4714144256793117e61c0618a32e5fbafc129327de8553132a2ab395b963c635afeecffb3e8d262aee929571d30e1ac9b754d1f7eb108ff655c90934a792c82b4c0f8d932957309d17ac6b7721ed72b262f774258d8eecfdb6a1baaa2d21296023d53e593de32ddb1c04df0a18658325b831c971435cd48fbe0503324c61b470702b2aeaead965877d9ff51e4b631efac135a5058de99e67c4341e3e098ec420aff9d79bea2c2344af31353b5b06795a019025d0b08deb9f26061b0b323faee5bb75392227428f0df5bdbdd4af7ae90729ad78f5e3adc4fd0c40a2a9b3aa8cb7e27e3e739148142175be0e6a3acdb3de1a1fce53175f46af39337f2a125bf09a4d0d334c5a6fd77d9bc94305f25fbfac16e5a54868fd5287ff59447ca05e9479b5049e9d8e1ee18220a8f29d7e80e416ebdb4e85dd8947dd6affc4eea437abec186fb5fcac14c2d6315c6b082865baa2504f25c9065a7d4a6464898cb97fe5fbdd841bf0dd55cee2c0fce0170d1f176e19732cf564db4893538882ec3d1f57720588134bd9e1cf68cbe85e3c1b435810cd54d1b70cf77aa070583e4478ff3328b7dd548cc0245d06f6f01722f3925588844275134049a21bd9e3f05efcd84a555060814b030139133f46bff805dc130e49f8ad7289790a15c3b358c8b43ed02f4576818eb24d4b0d3cccafb7e18403a70a9132d0bd111239f5cf392814b9fe8a9053edab73997b78b00fd6216c3d3b6754d168173bbb65351b1cf15d40dd030b4d255bd91cf3260d82d7452f2830e2839926aedc45f79734df4cc990a93dbbf9b035235b4c2ef5ca5788e3256a72dbb1702d12c222247cb7fd70303d434fa02f409940a618746515e9fa68efaede3e063300bcceff57c71579256eda7f1d5fe2d3c3cc58c2b2818b14dcba280e23f40e521ab6c7e5f56499c5358d2d9065326dc72818f518301952119328068d47b7c6ae66028aa785362f345067ea634472220f250d25d4aa9f8b7ca388d6db65d328b7c277e5dbfa6aa69d268d2e2445f18cfc8bd8aab30db83ea7fed29522fdecf903fdc8dba44a963b9a1de642d9a9fdd4dee89dbaf16ca066fa529e535b97ea72a175fe67aca3a2c870a61f8958810f42468b7ac181fdb71ec302c81a6afca5ef4bea379fb11e1cd11a9fbcc32fa0527cf8ae123e9f08c1e8279cc66c8ee9c6700995ae78959a0a203c188be749875d66e55eecc802173b094af324eb2b716b234f486c5ccf6cdfb7bd8070e1da817012506eef5070b0e398e6c16e2b183c5141a179b06e757e13a6d9e6333aa7f81feff44175c245438d0b14fe8e6e887286118aa35383fdfd5ebb5906119cd7e416c3ffdee2231ae0980a9d3011f11ef7b570edc8c722bae5c8024430ec945a475c015f8b8cdb84ac73729415d28f930f41b875816127fb853f3c5a4be81a7084c8acbe96c32152b5d042a64649f3ab7822a4e71c151870d82a78cbabae47c3c8b8073b817c3382c37cb0e2b6e656903fc806a4da37734f2d66e2b1102b839f922349e7bf9e8606d4233f72b5604249263f51c9fa309332aa77d6c9051e39e94919b6c02cc5a68b9732206d98ca8ee6860b3fea206d16a91c9a9cd2d261080dfcaa62fbde087fc3c211a1966502365e89cdf812881c672d1ff52410606816b2c9d1cf0164f01990df474b4a861cab53e10d932a3f01e9f91bf4f566358e6a4033adcf6053b40ac847aa062e7b317340de536abe0f87850fcfb9ee4b0360a3810b881b1208d3af1b327695f81bf9a1a5538e0cb7f8f829fa3105a42dfd1aa0024744dfe1846de5b3c575101b8c908850b8f0ba63d4d203a7463ff3e9fb5c7dcef7b4d72ca37e82df48e0c115b925ce530485970d59eca635033463fcbb37760771c3e42be15e05923081d95ae2372ac3db017baa63fd51ad1f60cb19ccde6781f3fd5fc9e57d7cd198964fc6777505b9eade179bbd6202ff0178e3ffae222dec624245d2ce516382f1b73e83186ca5da5d27b0748ff04cec7885f77185bb708ff139d4e91f4527f0c9fbde9165b47ad0a9bbba325632a62f0f0927ce4d37bc9664c9cf8481353be6a4cabd43e884f7e77217b06da4dc6aaf1610a6ae80d5f360b31f387c3d65776c334f1d42d8552a7e64bb6ce2634586035066118d3d4a81539026c90c0e2092564b60ea0195a8b7852576a4d66159456f5ad18fcd36738b03f47117c36ff4bb2af33387d0b2117e694cc19d5104ff1a40b97509214701dd77cb31004457dc483c7fed03c818c9449e1878e46aa31b721b0da7147e403bbcf1a07dce80ebe657d58b7ca75ec5baf1762b9137de903aad684dc150ef77cfdb1942bc30e57598486222f6b0ff0948a1f5b18bcf3589eacada320808ff372e6ad55544879376b95efb7e35e47388ba6b4391a79b391c10293e989ffe31ed8307221c48e84837837d7729bffdb6dee67e15584ff72ec39b5abc40c29b3607764e84f2bcfb81505caaec338e4721fc4f3aa7ab9d16606a192f2197c1379e56d82f3d1d87f38abbbec61604aa5ed30a3a4e0594246250ba2f0f92a576ac0ada6dcc450493bd7bf4f19c7d2b8ba88c575266a3857c5b82e5394936c6ae195c624527fca5ce82843c175a98c0c7f15f5468ce269658d82909e81e363a63a855e8a77a0c8b172996879ce724506feb3dcdfb5ae48b820637728c47adec9b2d2f159c122a942acccab7015ee9abea139f2222984e3bc0041aaac1ef7dce8ad4b8f7a219edaaac0b3cd871176e810cd3f9b2bbd9282e4d30fd7d19689f4f4561202beae94d8bfc5f10df33781cc93e0694baf194a1055003458ad28fb0f2b49d4ddc019c290ef6fe85eb302bb802273c295b011db43f68fbe91a37407edf8630916dc1783cb0cf85798b23abc85a144df42eac6c586ed2fe3a79e33dac0a1c379b10d2cf85b8ba4efd3ed1927a0a0f138de21e23723494b3c15f373b57962a7da22af5c2bd2b51526b43341923b1071452b536097f99fba8b16c1726607e27476983097d2fa1f36fa0b70a58a4220c1780b34383f1a07cf505f83093f5a66b3837df7f5bb932aa435663444309edb8be9e83998e3eaabe324eafc7334bc8726b1eb745ce36a450b58fa9f31a72531b2cd8148a25dfc925b4deab6fd8b0a67ed1e44be1a95f1c8566ad8fe8bd7c11f288ff12b4ee402b1057eb1fe02cf41c1f86f2209ae09bbff10dd1868f370055cd290b41917e24efea47db47a9766f4375e92293b9fc6c51715b83cedfdd2adb204aea1edd8d063b53f463a73a12bb25d44a7c9440dba6b123a1df80f72f70e0c22b4ddd658f783db105d89a46a0b06d2a3b012bd80401794daa0047bc62520b54ba7a82ed54b5c5c5db2338253437576b9e71de0d3b57dd2ba70d41f8ab0e689380dc13b82f178d655debf7ee1403b834a7f7f9ee8c5302a678114241b0952143d2d9a9361e23ab8662b1584e1780d995a16cb22e89e3b40f479ed32c9bf9120a9194a89a4b00cd9243115b4c5409ab3599dc2a17aaf56105cdfbc7b6fb0b138c7410a803fb15d2d8d385bf7deb1962834b08a84ffa12c78ebec698501209316ee63c5861f65607a8c9978821b11e5a75b74d24054ae27d2310fbb1973a3ea4e7549124dae6aabe0b21b2951b0ac09f4002e35ebd7cdd73ecc81cc69b230105a267036a66d423167974c87ac3b85b522aa5945e6915e36b9524ec9c170029a09a241cc9cd2e4e15202a93bf8af31fc89edef2544a4db799c1db3c3ede40b24c1dc67d2d0df788694e1df23e58e5ea8554d22fe547d6f0730da2d86120542036414e9a7118d9ff5d9d2517a6b7881bb26550f61991ece49900c33ae2415280113be8063d1b876949501641fec5bd5d510b1faae889dba8d672e532c8bc1a07136b64b25befa944dcdf3f8f1aed4d02ca8079b00c81691e945e6c0e7752d0d447985bf6fb8a8f868e804981825322e552a292d6f295b65938caaa2a0143d57613e37b0d09e72a90444612aa4465b31b3ce53ebf4b70d33725fe03c6b40bf6bf6e4ac56e83f205c3a9b86ee155f74253ad0d8529f9f90634d5bb9c6a58142b4ec5315a63f4021c1f5b497cf6b824c59348195696aeeb9f3c20329ba7138e240f4a11962738daa213312f2d9330c2729c87631086d89b08a32ebdc0e56139276207c11f2a0fd0f76e1e6b4300d6a97af6ba39432cf61dc71b62cc4bfa158f3d38a1430613f0845177e9fbea9515acd83ac3fbe38b5cba4d06da323fa983337851d1a85a4829f59762023ca19e3303ee2eddff39d1c7e06939eac0933c937965ea602888385f2b614efd4f4fde37f6b4c2c9ae9d5ee1455f49c89c661e7126bd4073af6dd263b2d72b9c71b3682f1be6f376d2fd1facf1620bbe531c89f031178bbbe865a8339367a872078da9bf319de5d5b3ca5af9c7aef98c139c261714804a0774891d7b71bc03fc657795bac2a4ba803c9f0fd01dcc033d544499e01fe54984d6f3c9f2d2f44cae088ee26a7112c358b743b58ee62f2ab3ecd1907e810404638a3f0f153194b3500decbd6d7aeba4cd1543339d7c7c338e0489c67d37a42dcc5017e9d0209342ba71a4b76851c13b22a0a310b79d6b3839b8e4c0f9847d4e4e0210f93635e0f42232735314cc6ecea18e138aa3235addcaaadab14773c4d87f92f483ad8908a55c2a541cc3785efe7474a933d950646b2f7aa5dc4cf9cd3c19866da7537413a8cdc76fe2f0e6c96cb756a4230e6771ad5d10ee98da4f4e43d9de33230fc2e66c86243d88e2389840e0308d03e971e80f13530dd1425899153b6a08af40faec44182d6c6b1a3b4f86c0574808698eaeb24ee03a8659dcb98ec2410dfac4e1bb3676fdb1c2e94c598a25b78841565e4124f053cc295c5132e65fedb1cd1942ce99be93e0e5af9bc676082513c147428d36b7704692da4039913c59888e0d9f2caf3eaf47e30c70e9007c9426fd8ab4a8a32ae6708d891b65f5d9d7619fa4782eb9973c06e07ff41082e22f7d6402eb0061ab95ecd747cdde3de256883e249adbec57a7fea1a4aae66b24192aa1b6c7cecca20b0e36d41c153eb3707b1cd8c8be5e1fd42ab8b9deba69b8724152e67ea320cdc89e0d3a312df01da6ce71bff1a9d1329510a3486308166d4cbf2ebfbe96323fad85cca565e5e6062b3ed9a461f123d1566bb82b5ae92d262c0292069a230e22d0fc8cb17284e35ba55f3782b918a3965623250d19682ba89d07db2d22c3200958f66ef3a41d29093f84e77bcc8a591c63498ad7e090596d821e33d104fb9381873ffd7813d7609ea9a5115</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章是作者私人笔记，已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/my_world/lib/hbe.js"></script><link href="/my_world/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>私人笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python数组</title>
    <link href="/my_world/content/python%E6%95%B0%E7%BB%84/"/>
    <url>/my_world/content/python%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章会简要说明python的数组，适合0基础的人看。python的数组和java的数组用法和写法都有区别，不过也有相同的地方。这里不会对java的数组进行赘述。</p><h1 id="python数组"><a href="#python数组" class="headerlink" title="python数组"></a>python数组</h1><p>python数组用于在单个变量中存储多个值</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>新建一个包含数字的数组</p><div class="code-wrapper"><pre><code class="hljs python">number = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]</code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="返回-修改数组中某下标的值"><a href="#返回-修改数组中某下标的值" class="headerlink" title="返回/修改数组中某下标的值"></a>返回/修改数组中某下标的值</h3><div class="code-wrapper"><pre><code class="hljs python">number[<span class="hljs-number">0</span>] <span class="hljs-comment"># 返回</span>number[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-comment"># 修改</span></code></pre></div><h3 id="返回数组的长度"><a href="#返回数组的长度" class="headerlink" title="返回数组的长度"></a>返回数组的长度</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(number)</code></pre></div><h3 id="循环打印数组元素"><a href="#循环打印数组元素" class="headerlink" title="循环打印数组元素"></a>循环打印数组元素</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> number:    <span class="hljs-built_in">print</span>(i)</code></pre></div><h3 id="添加数组元素"><a href="#添加数组元素" class="headerlink" title="添加数组元素"></a>添加数组元素</h3><p>这里开始的操作和java中的List类非常相似</p><div class="code-wrapper"><pre><code class="hljs python">number.append(<span class="hljs-number">10</span>) <span class="hljs-comment"># 在数组的末尾加入元素10</span></code></pre></div><h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h3><div class="code-wrapper"><pre><code class="hljs python">number.pop(<span class="hljs-number">1</span>) <span class="hljs-comment"># 删除第一个元素</span>number.remove(<span class="hljs-number">3</span>) <span class="hljs-comment"># 删除数组中元素为3的元素</span></code></pre></div><h3 id="清除数组中的所有元素"><a href="#清除数组中的所有元素" class="headerlink" title="清除数组中的所有元素"></a>清除数组中的所有元素</h3><div class="code-wrapper"><pre><code class="hljs python">number.clear()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈、队列浅认识</title>
    <link href="/my_world/content/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E6%B5%85%E8%AE%A4%E8%AF%86/"/>
    <url>/my_world/content/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E6%B5%85%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p>栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><p><img src="../../image/image-20211222200425521.png" alt="出栈入栈操作"></p><h2 id="上溢"><a href="#上溢" class="headerlink" title="上溢"></a>上溢</h2><p>栈<strong>存满数据元素</strong>的情况下，如果继续向栈内<strong>存入数据</strong>，栈出错</p><h2 id="下溢"><a href="#下溢" class="headerlink" title="下溢"></a>下溢</h2><p>栈内<strong>为空</strong>的状态下，如果继续进行<strong>取数据</strong>的操作，栈出错</p><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p>共享栈，即是两个栈使用同一段存储空间。这片存储空间不单独属于任何一个栈，某个栈需要的多一点，它就可能得到更多的存储空间；第一个栈从数组头开始存储，第二个栈从数组尾开始，两个栈向中间拓展。</p><p><img src="../../image/image-20211222201319215.png" alt="共享栈演示图"></p><h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。（先进先出原则）</p><p><img src="../../image/image-20211222201553601.png" alt="队列演示图"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理公式与体积面积公式</title>
    <link href="/my_world/content/%E7%89%A9%E7%90%86%E5%85%AC%E5%BC%8F%E4%B8%8E%E4%BD%93%E7%A7%AF%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F/"/>
    <url>/my_world/content/%E7%89%A9%E7%90%86%E5%85%AC%E5%BC%8F%E4%B8%8E%E4%BD%93%E7%A7%AF%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h1><blockquote><p>资料来源于：<a href="https://baike.baidu.com/item/面积公式/3696832">面积公式_百度百科 (baidu.com)</a></p></blockquote><h2 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h2><p>$S = \pi r^2$</p><h1 id="体积"><a href="#体积" class="headerlink" title="体积"></a>体积</h1><blockquote><p>资料来源于：<a href="https://baike.baidu.com/item/体积公式/8880018">体积公式_百度百科 (baidu.com)</a></p></blockquote><h2 id="柱体"><a href="#柱体" class="headerlink" title="柱体"></a>柱体</h2><p>设$S$表示柱体的底面积，$h$表示柱体的高，$r$表示底圆半径</p><h3 id="常规公式"><a href="#常规公式" class="headerlink" title="常规公式"></a>常规公式</h3><p>$V = Sh$</p><h3 id="圆柱"><a href="#圆柱" class="headerlink" title="圆柱"></a>圆柱</h3><p>$V = Sh = \pi r^2h$</p><h3 id="长方体"><a href="#长方体" class="headerlink" title="长方体"></a>长方体</h3><p>$a、b、c$分别表示长方体汇于一点的三条棱的棱长</p><p>$V = abc$</p><h3 id="正方体"><a href="#正方体" class="headerlink" title="正方体"></a>正方体</h3><p>$a$表示正方体的棱长</p><p>$V = a^3$</p><h2 id="椎体"><a href="#椎体" class="headerlink" title="椎体"></a>椎体</h2><p>设$S$表示椎体的底面积，$h$表示椎体的高，$r$表示底圆半径</p><h3 id="常规公式-1"><a href="#常规公式-1" class="headerlink" title="常规公式"></a>常规公式</h3><p>$V = \frac{1}{3}Sh$</p><h3 id="圆锥体"><a href="#圆锥体" class="headerlink" title="圆锥体"></a>圆锥体</h3><p>$V = \frac{1}{3}Sh = \frac{1}{3}\pi r^2h$</p><h2 id="球体"><a href="#球体" class="headerlink" title="球体"></a>球体</h2><p>设$V_3$表示三维球体的体积，$r$表示球体半径</p><h3 id="三维球球体"><a href="#三维球球体" class="headerlink" title="三维球球体"></a>三维球球体</h3><p>$V_3 = \frac{4}{3}\pi r^3$</p><h1 id="物理公式"><a href="#物理公式" class="headerlink" title="物理公式"></a>物理公式</h1><blockquote><p>资料来源于：<a href="https://baike.baidu.com/item/常用物理公式大全/6040386">常用物理公式大全_百度百科 (baidu.com)</a></p></blockquote><h2 id="质点运动"><a href="#质点运动" class="headerlink" title="质点运动"></a>质点运动</h2><h3 id="匀变速直线运动"><a href="#匀变速直线运动" class="headerlink" title="匀变速直线运动"></a>匀变速直线运动</h3><ol><li>平均速度$\overline{v} = \frac{s}{t}$</li></ol><h2 id="力"><a href="#力" class="headerlink" title="力"></a>力</h2><ol><li><p>重力$G = mg$,方向竖直向下,$g = 9.8m/s \approx 10m/s$</p></li><li><p>滑动摩擦力$F = \mu F_N$，$\mu $摩擦因数，$F_N$正压力</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构绪论</title>
    <link href="/my_world/content/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    <url>/my_world/content/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是<strong>数据</strong>的<strong>逻辑结构</strong>和<strong>数据</strong>的<strong>物理结构</strong>以及<strong>它们之间的相互关系</strong>，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p><h1 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据是对客观事物的符号表示</p><p>在计算机科学中是指所有能输入到计算机中并且被计算机程序处理的符号的总称</p><p>例如，整数、实数和字符串是数据</p><h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据元素是数据的基本单位，是数据结构这门课讨论的最小单位</p><p>在计算机程序中通常将其作为一个整体进行考虑和处理</p><p>有时，一个数据元素可由若干数据项组成</p><p>例如，一本书的书目信息为一个数据元素，而书目信息的每一项（如书名、作者名等）为一个数据项</p><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>数据对象是性质相同的数据元素的集合，是数据的一个子集</p><p>例如，大写字母就是一个数据对象，大写字母数据对象是集合{‘A’，’B’，…，’Z’}</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合</p><p>数据结构包含三方面的内容：</p><ol><li>逻辑结构</li><li>存储结构</li><li>对数据的运算</li></ol><h2 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h2><p>数据的逻辑结构是对数据之间关系的描述，它与数据的存储结构无关，同一种逻辑结构可以有多种存储结构。归纳起来数据的逻辑结构主要有以下两大类：</p><ol><li>线性结构：简单地说，线性结构是一个 数据元素的有序（次序）集合。它有以下4个基本特征：<ol><li>集合中必存在唯一的一个”第一个元素”</li><li>集合中必存在唯一的一个”最后一个元素”</li><li>除最后一个元素之外，其他数据元素均有唯一的”后继”</li><li>除第一个元素之外，其他数据元素均有唯一的”前驱”</li></ol></li><li>非线性结构：与线性结构不同，非线性结构中的结点存在着一对多的关系，它又可以细分为树形结构和图形结构。</li></ol><h2 id="数据的物理结构"><a href="#数据的物理结构" class="headerlink" title="数据的物理结构"></a>数据的物理结构</h2><p>数据的物理结构又称为存储结构，是数据的逻辑结构在计算中的表示。它包括数据元素的表示和关系的表示。</p><p>当数据元素是由若干数据项构成的时候，数据项的表示称为数据域。</p><p>例如，一个链表结点，结点包含值域和指针域，这里结点可以看作一个数据元素，其中的值域和指针域都是这个数据元素的数据域</p><p>数据结构中有以下4种常用的存储方法</p><ol><li>顺序存储方法：把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的领接关系来体现</li><li>链式存储方法：结点间的逻辑关系是由附加的指针字段表示</li><li>索引存储方法：存储结点信息时建立存储结点信息和附加的索引表来标识结点的地址，一般形式是&lt;关键字，地址&gt;</li><li>散列存储方法：根据结点的关键字通过散列函数直接计算出该结点的存储地址</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>由基本运算及规定的运算顺序所构成的完整的解题步骤，或者看成按照要求设计好的有限的确切的计算序列</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>有穷性：一个算法必须保证执行有限步骤之后结束</li><li>确定性：算法的每一个步骤必须有确定的定义</li><li>输入：一个算法有0个或多个输入</li><li>输出：一个算法有一个或多个输出</li><li>可行性：算法中的所有操作都必须通过已经实现的基本操作进行运算，并且在有限次内实现</li></ol><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ol><li>正确性：算法能正确执行预先规定的功能和性能要求</li><li>可读性：算法易于人的理解</li><li>健壮性：算法能够对不合理的数据进行检查</li><li>高效率与低储蓄量要求：对于同一个问题如果有多种算法可以求解，执行时间短的算法效率高。算法执行过程中所需要的最大存储空间越少越好</li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>将算法中基本操作的执行次数作为算法时间复杂度的度量</p><p>时间复杂度的大小如下：</p><script type="math/tex; mode=display">O(1) \le O(log_2n) \le O(n) \le O(nlog_2n) \le O(n^2) \le O(n^3) \le O(n^k) \le O(2^n)</script><p>计算时间复杂度的操作：</p><ol><li>找基本操作：多数情况下取最深层循环内的语句所描述的操作作为基本操作</li><li>确定规模：由循环条件$i &lt; n$可知，循环执行的次数（基本操作执行的次数）和参数$n$有关，因此参数$n$就是我们所说的规模$n$</li><li>计算出$n$的函数$f(n)$</li></ol><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的空间复杂度指算法在运行时所需存储空间的度量，主要考虑在算法运行过程中临时占用的存储空间大小</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构公式大全</title>
    <link href="/my_world/content/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
    <url>/my_world/content/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ol><li>二叉树的第$k$层<strong>最多</strong>有$2^{k-1}(k \ge 1)$个结点，针对的是某一层</li><li>高度（或深度）为$k$的二叉树<strong>最多</strong>有$2^k-1(k\ge 1)$个结点，针对的是整棵树</li><li>在任意一棵二叉树中，若叶子结点的个数为$n_0$，度为2的结点数为$n_2$，则$n_0 = n_2 + 1$</li><li>给定n个结点，能构成$\frac{C^n_{2n}}{n+1}$种不同的二叉树</li><li>包含n个结点的完全二叉树的高度为$[log_2(n + 1)]$。（注：[ ]表示向下取整）</li><li>给定完全二叉树的叶子结点数为n，则总结点数为$2n$</li><li>有n个结点的完全二叉树，对各个结点从上到下、从左到右一次编号（范围为1-n），若i为某结点a的编号，则：<ol><li>如果$i \neq 1$，则a双亲结点的编号为$i{\div}2$</li><li>如果$2i \le n$，则a左孩子的编号为$2i$；若果$2i+1 &gt; n$，则a无右孩子</li><li>如果$2i + 1 \le n$，则a右孩子的编号为$2i+1$；如果$2i+1 &gt; n$，则a无右孩子</li></ol></li><li>由n个权值构成的哈夫曼树共有$2n-1$个结点</li></ol><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ol><li>给定n个元素，以某种顺序进栈，并且可在任意时刻出栈，则出栈序列有$\frac{C^n_{2n}}{n+1}$种<ol><li>一个循环队列$Q[maxSize]$的队头指针为front，队尾指针为rear。除此之外，该队列再没有其他数据成员，该队列的队满条件为$Q.front == (Q.rear+1)\%maxSize$</li><li>一个循环队列$Q[maxSize]$的队头指针为front，队尾指针为rear。该队列的队列元素个数为$(Q.rear-Q.front+maxSize)\%maxSize$</li></ol></li></ol><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ol><li>有向图中有n个顶点，则最多有$n(n-1)$条边，具有$n(n-1)$条边的有向图称为有向完全图</li><li>无向图中有n个顶点，则最多有$n(n-1)/2$条边，具有$n(n-1)/2$条边的无向图称为无向完全图</li><li>在有n个顶点的有向图中，每个顶点的度最大为$2(n-1)$</li><li>顶点数为n的连通图，最少有$n-1$条边</li><li>对$n$阶对称矩阵压缩存储时，需要表长为$n(n+1)/2$</li></ol><h1 id="ASL"><a href="#ASL" class="headerlink" title="ASL"></a>ASL</h1><p>查找过程中对关键字的<strong>平均比较次数</strong>（也称为<strong>平均查找长度</strong>）作为衡量一个查找算法效率优劣的标准。平均查找长度用<strong>ASL</strong>来表示。</p><h2 id="折半判定树"><a href="#折半判定树" class="headerlink" title="折半判定树"></a>折半判定树</h2><p><img src="../../image/image-202107281628499919.png" alt="折半查找的判定树"></p><p>图e中折半查找判定树的查找成功（ASL1）和不成功（ASL2）的平均查找长度为：</p><p>$ASL_{成功}$ = (每层的结点个*层数后相加)/总结点数 = (1*1+2*2+4*3+3*4)/10</p><p>$ASL_{失败}$ = (空结点*层数-1后相加)/总空结点数 = (5*3+6*4)/11</p><h2 id="线性查找法和拉链法"><a href="#线性查找法和拉链法" class="headerlink" title="线性查找法和拉链法"></a>线性查找法和拉链法</h2><p><img src="../../image/线性探查法和拉链法查找成功的ASL.png" alt="线性探查法和拉链法查找成功的ASL"></p><p><img src="../../image/线性探查法和拉链法查找失败的ASL.png" alt="线性探查法和拉链法查找失败的ASL"></p><p><img src="../../image/拉链法查找成功和失败的ASL.png" alt="拉链法查找成功和失败的ASL"></p><h1 id="排序算法手排演示"><a href="#排序算法手排演示" class="headerlink" title="排序算法手排演示"></a>排序算法手排演示</h1><h2 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h2><h3 id="直接插入排序和希尔排序"><a href="#直接插入排序和希尔排序" class="headerlink" title="直接插入排序和希尔排序"></a>直接插入排序和希尔排序</h3><p><img src="../../image/希尔排序手排.png" alt="希尔排序手排"></p><h2 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>过于简单，不写</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="../../image/快速排序手排.png" alt="快速排序手排"></p><h2 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p><img src="../../image/简单选择排序手排.png" alt="简单选择排序手排"></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="../../image/堆排序手排.jpg" alt="堆排序手排"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="../../image/归并排序手排.png" alt="归并排序手排"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数公式大全（一）</title>
    <link href="/my_world/content/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/my_world/content/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><ul><li>行列式的定义与性质<ul><li>本质定义（第一种定义）</li><li>性质</li><li>逆序数法定义（第二种定义）</li><li>展开定理（第三种定义）</li><li>几个重要的展开式<ul><li>主对角线行列式</li><li>副对角线行列式</li><li>拉普拉斯展开式</li><li>范德蒙德行列式</li></ul></li></ul></li><li>行列式的计算<ul><li>具体型<ul><li>化为基本形</li><li>递推法</li><li>行列式表示的函数和方程</li></ul></li><li>抽象型<ul><li>用性质</li><li>用公式</li></ul></li></ul></li><li>余子式与代数余子式的计算</li></ul><h2 id="本质定义"><a href="#本质定义" class="headerlink" title="本质定义"></a>本质定义</h2><p>2阶行列式是由两个2维向量组成的，其（运算规则的）结果为以这两个向量为邻边的<strong>平行四边形的面积</strong>。</p><p>3阶行列式是由三个3维向量$a<em>1=[a</em>{11},a<em>{12},a</em>{13}],a<em>2=[a</em>{21},a<em>{22},a</em>{23}],a<em>3=[a</em>{31},a<em>{32},a</em>{33}]$组成的，其（运算规则的）结果为以这三个向量为邻边的<strong>平行六面体的体积</strong></p><p>n阶行列式是由n个n维向量$a<em>1=[a</em>{11},a<em>{12},\cdots,a</em>{1n}],a<em>2=[a</em>{21},a<em>{22},\cdots,a</em>{2n}],\cdots,a<em>n=[a</em>{n1},a<em>{n2},a</em>{nn}]$组成的，其（运算规则的）结果为以这n个向量为邻边的<strong>n维图形的体积</strong></p><h2 id="行列式性质"><a href="#行列式性质" class="headerlink" title="行列式性质"></a>行列式性质</h2><ul><li><p>行列互换，其值不变，即$|A| = |A^T|$</p></li><li><p>对调行列式的两行（或列），行列式变为其相反数</p></li><li><p>行列式的某行（或列）有公因子可以提取</p></li><li><p>若行列式某行（或列）的元素全是0，则该行列式为0</p></li><li><p>若行列式某两行（或两列）相同，则行列式为0</p></li><li><p>若行列式某两行（或两列）的元素成比例，则行列式为0</p></li><li><p>行列式某行（或列）为两个元素之和时，行列式可拆为两个行列式之和</p><ul><li><script type="math/tex; mode=display">\begin{vmatrix} a+j & b & c\\ d+k & e & f\\ g+l & h & i\end{vmatrix}=\begin{vmatrix} a & b & c\\ d & e & f\\ g & h & i\end{vmatrix}+\begin{vmatrix} j & b & c\\ k & e & f\\ l & h & i\end{vmatrix}</script></li></ul></li><li><p><strong>行列式某行（或列）的倍数加到另一行（或者另一列），行列式不变</strong></p></li><li><p>行列式等于某行（或列）的元素与其代数余子式的积的和</p><ul><li>按行/列展开时，将行/列其他元素化成0，降低计算量</li></ul></li><li>行列式某行（或某列）的元素与另一行（或列）元素的代数余子式的积的和为0</li></ul><h2 id="逆序数法定义"><a href="#逆序数法定义" class="headerlink" title="逆序数法定义"></a>逆序数法定义</h2><h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>由n个数$1,2，\cdots，n$组成的一个有序数组称为一个n级排列，如23145是一个5级排列，41352也是一个5级排列。n级排列共有n!个。</p><h3 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h3><p>在一个n级排列$i_1,i_2,\cdots ,i_s,\cdots ,i_t,\cdots ,i_n$中，若$i_s &gt; i_t$，且$i_s$排在$i_t$前面，则称这两个数构成一个逆序。</p><h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><p>一个排列中，逆序的总数称为该排列的逆序数，记作$ \tau(i_1,i_2,\cdots ,i_n) $,如$ \tau(231546)=3 $,$ \tau(621534)=8 $.由小到大顺排的排列称为自然排序，如12345，显然，自然排序的逆序数为0.</p><h3 id="奇排列和偶排列"><a href="#奇排列和偶排列" class="headerlink" title="奇排列和偶排列"></a>奇排列和偶排列</h3><p>排列的逆序数为<strong>奇数</strong>时，该排列称为<strong>奇排列</strong>；排列的逆序数为<strong>偶数</strong>时，该排列称为<strong>偶排列</strong>。</p><h2 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h2><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{n1} & a_{n2} & \cdots & a_{nn} \\\end{vmatrix} = \sum_{j_1 j_2 \cdots j_n} (-1)^{\tau(j_1 j_2 \cdots j_n)}a_{1j_1}a_{2j_2}\cdots a_{nj_n}</script><p>当列下标为奇排列时，应附加负号；当列下标为偶排列时，应附加正号</p><h2 id="展开定理"><a href="#展开定理" class="headerlink" title="展开定理"></a>展开定理</h2><h3 id="余子式和代数余子式"><a href="#余子式和代数余子式" class="headerlink" title="余子式和代数余子式"></a>余子式和代数余子式</h3><p>把行列式中的元素$ a<em>{ij} $所在的i行元素和j列元素去掉，剩下的n-1行和n-1列元素按照元素原来的排列次序构成的n-1阶行列式，称为元素$a</em>{ij}$的余子式，记为$M<em>{ij}$，称$A</em>{ij} = (-1)^{i+j}M_{ij}$为元素的代数余子式</p><script type="math/tex; mode=display">\begin{vmatrix} 1 & 1 & 1\\ 0 & 2 & 1\\ 0 & 0 & 3\end{vmatrix}=A_{11} = (-1)^{1+1}\begin{vmatrix}2 & 1\\0 & 3\end{vmatrix}</script><h3 id="行列式展开"><a href="#行列式展开" class="headerlink" title="行列式展开"></a>行列式展开</h3><p>行列式的值等于行列式的某行（列）元素分别乘其相应的代数余子式后再求和，即</p><script type="math/tex; mode=display">|A| = \begin{cases}a_{i1}A_{i1} + a_{i2}A_{i2} + \cdots + a_{in}A_{in} = \sum_{j = 1}^n a_{ij}A_{ij}(i = 1,2,\cdots,n)\\a_{1j}A_{1j} + a_{2j}A_{2j} + \cdots + a_{nj}A_{nj} = \sum_{i = 1}^n a_{ij}A_{ij}(j = 1,2,\cdots,n)\end{cases}</script><p>但行列式的某行（列）元素分别乘另一行（列）元素的代数余子式后再求和，结果为零，即</p><script type="math/tex; mode=display">a_{i1}A_{k1} + a_{i2}A_{k2} + \cdots + a_{in}A_{kn} = 0,i \neq k\\a_{1j}A_{1k} + a_{2j}A_{2k} + \cdots + a_{nj}A_{nk} = 0(j \neq k)</script><h2 id="几个重要的行列式"><a href="#几个重要的行列式" class="headerlink" title="几个重要的行列式"></a>几个重要的行列式</h2><h3 id="主对角线行列式（上（下）三角行列式）"><a href="#主对角线行列式（上（下）三角行列式）" class="headerlink" title="主对角线行列式（上（下）三角行列式）"></a>主对角线行列式（上（下）三角行列式）</h3><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\0 & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\0 & 0 & \cdots & a_{nn} \\\end{vmatrix} = \begin{vmatrix}a_{11} & 0 & \cdots & 0 \\a_{21} & a_{22} & \cdots & 0 \\\vdots & \vdots &        & \vdots \\a_{n1} & a_{n2} & \cdots & a_{nn} \\\end{vmatrix} = \begin{vmatrix}a_{11} & 0 & \cdots & 0 \\0 & a_{22} & \cdots & 0 \\\vdots & \vdots &        & \vdots \\0 & 0 & \cdots & a_{nn} \\\end{vmatrix} = \prod^n_{1 \le i < j \le n} (x_j - x_i)</script><h3 id="副对角线行列式"><a href="#副对角线行列式" class="headerlink" title="副对角线行列式"></a>副对角线行列式</h3><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{1,n-1} & \cdots & a_{1n} \\a_{21} & a_{2,n-1} & \cdots & 0 \\\vdots & \vdots &        & \vdots \\a_{n1} & 0 & \cdots & 0 \\\end{vmatrix} = \begin{vmatrix}0 & 0 & \cdots & a_{1n} \\0 & a_{2,n-1} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{n1} & a_{n,n-1} & \cdots & a_{nn} \\\end{vmatrix} = \begin{vmatrix}0 & 0 & \cdots & a_{1n} \\0 & a_{2,n-1} & \cdots & 0 \\\vdots & \vdots &        & \vdots \\a_{n1} & 0 & \cdots & 0 \\\end{vmatrix} = (-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2,n-1}\cdots a_{n1}</script><h3 id="拉普拉斯展开式"><a href="#拉普拉斯展开式" class="headerlink" title="拉普拉斯展开式"></a>拉普拉斯展开式</h3><p>设A为m阶矩阵，B为n阶矩阵，则</p><script type="math/tex; mode=display">\begin{vmatrix}A & O \\O & B \\\end{vmatrix} = \begin{vmatrix}A & C \\O & B \\\end{vmatrix} = \begin{vmatrix}A & O \\C & B \\\end{vmatrix} = |A||B|</script><script type="math/tex; mode=display">\begin{vmatrix}O & A \\B & O \\\end{vmatrix} = \begin{vmatrix}C & A \\B & O \\\end{vmatrix} = \begin{vmatrix}O & A \\B & C \\\end{vmatrix} = (-1)^{mn}|A||B|</script><h3 id="范德蒙德行列式"><a href="#范德蒙德行列式" class="headerlink" title="范德蒙德行列式"></a>范德蒙德行列式</h3><script type="math/tex; mode=display">\begin{vmatrix}1 & 1 & \cdots & 1 \\x_1 & x_2 & \cdots & x_n \\x_1^2 & x_2^2 & \cdots & x_n^2 \\\vdots & \vdots &        & \vdots \\x_1^{n-1} & x_2^{n-1} & \cdots & x_n^{n-1} \\\end{vmatrix} =</script><h2 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h2><p>对方程组：</p><p>(1)</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = 0\\a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = 0\\\vdots \\a_{n1}x_1 + a_{n2}x_2 + \cdots + a_{nn}x_n = 0\\\end{cases}</script><p>(2)</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = b_1\\a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = b_2\\\vdots \\a_{n1}x_1 + a_{n2}x_2 + \cdots + a_{nn}x_n = b_n\\\end{cases}</script><p>其中(1)为齐次线性方程组，(2)为非齐次线性方程组，由(1)得：</p><script type="math/tex; mode=display">D = \begin{vmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{n1} & a_{n2} & \cdots & a_{nn} \\\end{vmatrix}</script><script type="math/tex; mode=display">D_1 = \begin{vmatrix}b_1 & a_{12} & \cdots & a_{1n} \\b_2 & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\b_n & a_{n2} & \cdots & a_{nn} \\\end{vmatrix}</script><script type="math/tex; mode=display">D_n = \begin{vmatrix}a_{11} & a_{12} & \cdots & b_1 \\a_{21} & a_{22} & \cdots & b_2 \\\vdots & \vdots &        & \vdots \\a_{n1} & a_{n2} & \cdots & b_n \\\end{vmatrix}</script><p>若$D = 0$，方程有无穷多个解；若$D \neq 0$，方程有唯一解，则：</p><script type="math/tex; mode=display">\begin{cases}x_1 = \frac{D_1}{D}\\x_2 = \frac{D_2}{D}\\\vdots \\x_n = \frac{D_n}{D} \end{cases}</script><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="章节概括"><a href="#章节概括" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>矩阵的定义及其基本运算<ul><li>定义</li><li>基本运算<ul><li>相等</li><li>加法</li><li>数乘矩阵</li><li>矩阵的乘法</li><li>转置矩阵</li><li>向量的内积与正交</li><li>施密特正交化</li><li>矩阵的幂</li><li>方阵乘积的行列式</li></ul></li></ul></li><li>矩阵的逆<ul><li>定义</li><li>性质与公式</li><li>用定义求逆矩阵</li></ul></li><li>伴随矩阵<ul><li>定义</li><li>性质与公式</li><li>用伴随矩阵求逆矩阵</li></ul></li><li>初等交换与初等矩阵<ul><li>初等变换</li><li>初等矩阵<ul><li>定义</li><li>性质与公式</li><li>用初等交换（初等矩阵）求逆矩阵</li></ul></li></ul></li><li>矩阵方程<ul><li>AX = B</li><li>XA = B</li><li>AXB = C</li></ul></li><li>矩阵的秩与等价矩阵<ul><li>秩<ul><li>定义</li><li>初等交换不改变矩阵的秩</li><li>几个重要式子</li></ul></li><li>等价矩阵</li></ul></li></ul><h2 id="矩阵的本质"><a href="#矩阵的本质" class="headerlink" title="矩阵的本质"></a>矩阵的本质</h2><ol><li>矩阵也是由若干行（列）向量拼成的</li><li>矩阵不能运算，但是其若干行（列）向量之间可能存在某种关系</li></ol><h2 id="矩阵的基本运算"><a href="#矩阵的基本运算" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h2><h3 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h3><p>$ A = (a<em>{ij})</em>{m \cdot n} = B = (b<em>{ij})</em>{s \cdot k} \Leftrightarrow m=s,n=k $且$ a<em>{ij} = b</em>{ij}(i = 1,2,\cdots,m;j = 1,2,\cdots,n) $，即A,B是同型矩阵，且对应元素相等</p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>两个矩阵是同型矩阵，可以相加，即</p><script type="math/tex; mode=display">C = A +B = (a_{ij})_{m \cdot n} + (b_{ij})_{m \cdot n} = (c_{ij})_{m \cdot n}</script><h3 id="数乘矩阵"><a href="#数乘矩阵" class="headerlink" title="数乘矩阵"></a>数乘矩阵</h3><p>设k是一个数，A是一个$m \cdot n$矩阵，数k和A的乘积称为数乘矩阵，即</p><script type="math/tex; mode=display">kA = Ak = k\begin{bmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{m1} & a_{m2} & \cdots & a_{mn} \end{bmatrix} = \begin{bmatrix}ka_{11} & ka_{12} & \cdots & ka_{1n} \\ka_{21} & ka_{22} & \cdots & ka_{2n} \\\vdots & \vdots &        & \vdots \\ka_{m1} & ka_{m2} & \cdots & ka_{mn} \end{bmatrix} = k(a_{ij})_{m \cdot n}</script><p>即A的每个元素都乘以k</p><p>加法运算和数乘运算统称为矩阵的线性运算，满足下列运算规则</p><ol><li><strong>交换律</strong>：$A+B = B+A$</li><li><strong>结合律</strong>：$（A+B)+C = A+(B+C)$</li><li><strong>分配率</strong>：$k(A+B) = kA + kB，(k+l)A = kA + lA$</li><li>数和矩阵相乘的结合律：$k(lA) = (kl)A = l(kA)$</li></ol><p>其中，A,B,C是同型矩阵，k,l是任意常数</p><p>当用n阶方阵A计算行列式时，记成|A|，关于方阵行列式，有以下几点</p><ol><li>$ |kA| = k^n|A| \neq k|A|(n \ge 2,k\neq0,1) $</li><li>一般地，$|A+B| \neq |A| + |B| $</li><li>$ A \neq O $不能推断出$ |A| \neq 0 $</li><li>$ A \neq B $不能推断出$ |A| \neq |B| $</li></ol><h3 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><p>设A是$m \cdot s$矩阵，B是$s \cdot n$矩阵（矩阵A的列数必须与矩阵B的行数相等），则A，B可以相乘，乘积AB是$m \cdot n$，记$ C = AB = (c<em>{ij})</em>{m \cdot n} $，C的第i行第j列元素$c_{ij}$是A的第i行的s个元素与B的第j列的s个对应元素两两乘积之和，即</p><script type="math/tex; mode=display">c_{ij} = \sum_{k = 1}^s a_{ik}b_{kj} = a_{i1}b_{1j} + a_{i2}b_{2j} + \cdots + a_{is}b_{sj}(i = 1,2,\cdots,m;j = 1,2,\cdots,n)</script><p>矩阵乘法满足下列运算规律</p><ol><li><strong>结合律</strong>：$ (A<em>{m \cdot s}B</em>{s \cdot r})C<em>{r \cdot n} = A</em>{m \cdot s}(B<em>{s \cdot r}C</em>{r \cdot n}) $</li><li><strong>分配律</strong>：<ol><li>$ A<em>{m \cdot s}(B</em>{s \cdot n}+C<em>{s \cdot n}) = A</em>{m \cdot s}B<em>{s \cdot n}+A</em>{m \cdot s}C_{s \cdot n} $</li><li>$ (A<em>{m \cdot s}+B</em>{m \cdot s})C<em>{s \cdot n} = A</em>{m \cdot s}C<em>{s \cdot n} + B</em>{m \cdot s}C_{s \cdot n} $</li></ol></li><li><strong>数乘与矩阵乘积的结合律</strong>：$ (kA<em>{m \cdot s})B</em>{s \cdot n} = k(A<em>{m \cdot s}B</em>{s \cdot n}) $</li></ol><p>要注意以下几点：</p><ol><li>矩阵的乘法一般情况下不满足交换律，即$ AB \neq BA $</li><li>存在$A \neq O,B \neq O$，而$AB = O$的情况，故$AB = O$不能推出$A = O$或$B = O$</li><li>$AB = AC \Rightarrow A(B -C) = O$，此时即使有$A \neq O$，一般也得不出$B = C$</li></ol><h2 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><script type="math/tex; mode=display">设A = \begin{bmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{m1} & a_{m2} & \cdots & a_{mn} \end{bmatrix},记A^T = \begin{bmatrix}a_{11} & a_{21} & \cdots & a_{m1} \\a_{12} & a_{22} & \cdots & a_{m2} \\\vdots & \vdots &        & \vdots \\a_{1n} & a_{2n} & \cdots & a_{mn} \end{bmatrix}，称A^T为A的转置矩阵</script><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><script type="math/tex; mode=display">(A^T)^T = A</script><script type="math/tex; mode=display">(kA)^T = kA^T(k为常数)</script><script type="math/tex; mode=display">(A \pm B)^T = A^T \pm B^T</script><script type="math/tex; mode=display">(AB)^T = B^TA^T</script><script type="math/tex; mode=display">\Lambda^T = \Lambda(对角矩阵)</script><script type="math/tex; mode=display">m = n时，|A^T| = |A|</script><h2 id="向量的内积与正交"><a href="#向量的内积与正交" class="headerlink" title="向量的内积与正交"></a>向量的内积与正交</h2><h3 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h3><p>设$\alpha = [a_1,a_2,\cdots,a_n]^T,\beta = [b_1,b_2,\cdots,b_n]^T $，则称</p><script type="math/tex; mode=display">\alpha^T \beta = \sum_{i = 1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n</script><p>为向量$\alpha,\beta$的内积，记作$(\alpha,\beta)$，即$ (\alpha,\beta) = \alpha^T \beta $</p><h3 id="正交"><a href="#正交" class="headerlink" title="正交"></a>正交</h3><p>当$ \alpha^T \beta = 0 $时，称向量$\alpha,\beta$是正交向量</p><h3 id="模"><a href="#模" class="headerlink" title="模"></a>模</h3><script type="math/tex; mode=display">||\alpha|| = \sqrt{\sum_{i = 1}^n \alpha^2_i}</script><p>称为向量$\alpha$的模（长度），当$||\alpha|| = 1$时，称$\alpha$为<strong>单位向量</strong></p><h3 id="标准正交向量组"><a href="#标准正交向量组" class="headerlink" title="标准正交向量组"></a>标准正交向量组</h3><p>若列向量组$\alpha_1,\alpha_2,\cdots,\alpha_3$满足</p><script type="math/tex; mode=display">\alpha_i^T\alpha_j = \begin{cases}0 & i \neq j \\1 & i = j\end{cases}</script><p>则称$\alpha_1,\alpha_2,\cdots,\alpha_3$为标准或单位正交向量组</p><h3 id="施密特正交化过程"><a href="#施密特正交化过程" class="headerlink" title="施密特正交化过程"></a>施密特正交化过程</h3><p>线性无关向量组$\alpha_1,\alpha_2$的标准正交化（又称正交规范化）公式为</p><script type="math/tex; mode=display">\beta_1 = \alpha_1</script><script type="math/tex; mode=display">\beta_2 = \alpha_2 - \frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1</script><p>得到的$\beta_1,\beta_2$是正交向量组</p><p>将$\beta_1,\beta_2$单位化，得</p><script type="math/tex; mode=display">\eta_1 = \frac{\beta_1}{||\beta_1||}，\eta_1 = \frac{\beta_2}{||\beta_2||}</script><p>则$\eta_1,\eta_2$是标准正交向量组</p><h2 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h2><p>A是一个n阶方阵，$ A^m = \overbrace{AA\cdots A}^{m个} $称为A的m次幂</p><h2 id="方阵乘积的行列式"><a href="#方阵乘积的行列式" class="headerlink" title="方阵乘积的行列式"></a>方阵乘积的行列式</h2><p>设A,B是同阶方阵，则$|AB| = |A||B|$</p><ol><li><p>零矩阵：每个元素均为零的矩阵，记为$O$</p></li><li><p>单位矩阵：主对角元素均为1，其余元素均为零的n阶方阵，称为n阶单位矩阵，记成E（或I）</p></li><li><p>数量矩阵：数k和单位矩阵的乘积称为数量矩阵</p></li><li><p>对角矩阵：非主对角元素均为零的矩阵称为对角矩阵</p></li><li><p>上（下）三角矩阵：当$i &gt; (&lt;) j $时，$a_{ij} = 0 $的矩阵称为上（下）三角矩阵</p></li><li><p>对称矩阵：满足条件$A^T = A$的矩阵A称为对称矩阵，$A^T = A \Leftrightarrow a<em>{ij} = a</em>{ji}$</p></li><li><p>反对称矩阵：满足条件$A^T = -A$的矩阵A称为对称矩阵，</p><script type="math/tex; mode=display">A^T = A \Leftrightarrow \begin{cases} a_{ij} = -a_{ji},i \neq j\\a_{ii} = 0\end{cases}</script></li><li><p>正交矩阵：设A是n阶方阵，满足$A^TA = E$，则称A是正交矩阵</p></li><li><p>分块矩阵</p></li></ol><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><p>设有矩阵A，则A的秩为<strong>非零子式的最高阶数</strong>，记作$rank(A)，简写为r(A)$，例子：</p><script type="math/tex; mode=display">A = \begin{pmatrix}1 & 2 & 3\\4 & 5 & 6\\7 & 8 & 9\\\end{pmatrix},r(A) = 3</script><script type="math/tex; mode=display">A = \begin{pmatrix}1 & 2 & 3\\4 & 5 & 6\\0 & 0 & 0\\\end{pmatrix},r(A) = 2</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><script type="math/tex; mode=display">若A = 0，则r(A) = 0。若A \neq 0，则r(A) \ge 1,A的秩最大为 max(m,n)</script><p>西尔韦斯特不等式：</p><script type="math/tex; mode=display">如果 A 是一个 m*n 的矩阵，且 B 是 n*k 的矩阵，则rank(A) + rank(B) - n \le rank(AB)</script><script type="math/tex; mode=display">当AB = 0时，r(A) + r(B) \le n</script><script type="math/tex; mode=display">\begin{align}rank(A^*) = n,rank(A) = n\\rank(A^*) = 1,rank(A) = n-1\\rank(A^*) = 0,rank(A) < n-1\\\end{align}</script><script type="math/tex; mode=display">r(A+B) \le r(A) + r(B)</script><script type="math/tex; mode=display">max(r(A),r(B)) \le r(A,B) \le r(A) + r(B)</script><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><script type="math/tex; mode=display">以三阶矩阵为例，E = \begin{pmatrix}1 & 0 & 0 \\0 & 1 & 0 \\0 & 0 & 1 \\\end{pmatrix}，E即是单位矩阵</script><h2 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>如果有n阶矩阵A，其矩阵的元素都为实数，且<strong>矩阵A的转置等于其本身</strong>（$a<em>{ij}=a</em>{ji}$，$A^T = A$），(i,j为元素的脚标），则称A为实对称矩阵。</p><h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h3><ol><li><p>实对称矩阵<strong>A</strong>的不同特征值对应的特征向量是正交的。</p></li><li><p>实对称矩阵<strong>A</strong>的特征值都是实数。</p></li><li><p>n阶实对称矩阵<strong>A</strong>必可相似对角化，且相似对角阵上的元素即为矩阵本身特征值。</p></li><li><p>若<strong>A</strong>具有k重特征值$\lambda _0$必有k个线性无关的特征向量，或者说秩$r(\lambda E-A)$必为n-k，其中<strong>E</strong>为单位矩阵。</p></li><li><p>实对称矩阵A一定可正交相似对角化。</p></li><li>$A \simeq A^{-1}$</li></ol><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="矩阵可逆的充分必要条件"><a href="#矩阵可逆的充分必要条件" class="headerlink" title="矩阵可逆的充分必要条件"></a>矩阵可逆的充分必要条件</h3><script type="math/tex; mode=display">|A| \neq 0</script><script type="math/tex; mode=display">A^{-1} = \frac{1}{|A|}A^*</script><h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h3><p>设A，B是同阶可逆矩阵，则</p><ol><li>$ (A^{-1})^{-1} = A $</li><li>$(kA)^{-1} = \frac{1}{k}A^{-1} (k \neq 0)$</li><li>A,B也可逆，且$(AB)^{-1} = B^{-1}A^{-1}$</li><li>$A^T$也可逆，且$(A^T)^{-1} = (A^{-1})^T$。此处可称为“穿脱”原则，即穿衣时先内后外，脱衣时先外后内</li><li>$|A^{-1}| = |A|^{-1}$</li><li>$ A^{-1}A = E $</li><li>$r(|A|) = n$(矩阵A的阶层)</li></ol><h3 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h3><p>设A为n阶矩阵，则A可逆</p><ol><li>等价于$|A| \neq 0$</li><li>等价于$r(A) = n$</li><li>等价于$Ax = 0$只有零解</li><li>等价于A的行列向量组线性无关</li><li>等价于A的特征值均非零</li></ol><h3 id="逆矩阵的求法"><a href="#逆矩阵的求法" class="headerlink" title="逆矩阵的求法"></a>逆矩阵的求法</h3><p><strong>定义法</strong></p><ol><li>依定义，即求一个矩阵B，使$AB = E$，则A可逆，且$A^{-1} = B$</li><li>将A分解成若干个可逆矩阵的乘积，因两个可逆矩阵的积仍是可逆矩阵，即若$A = BC$，其中，$B,C$均可逆，则A可逆，且$ A^{-1} = (BC)^{-1} = C^{-1}B^{-1}$</li><li>一些简单分块矩阵的逆，若$A,B$均是可逆方阵，则</li></ol><script type="math/tex; mode=display">\begin{bmatrix}A & O\\O & B \end{bmatrix}^{-1} = \begin{bmatrix}A^{-1} & O\\O & B^{-1}\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}O & A\\B & O \end{bmatrix}^{-1} = \begin{bmatrix}O & B^{-1}\\A^{-1} & O\end{bmatrix}</script><p><strong>伴随矩阵法</strong></p><p>利用$A^{-1} = \frac{1}{|A|}A^*$求逆矩阵，一般不用</p><p><strong>初等变换法</strong></p><p>$(A \vdots E)\overset{行变换}{\rightarrow} (E \vdots A^{-1})$</p><p>矩阵有三种初等变换</p><ol><li>对调矩阵的两行</li><li>矩阵的某行乘以非零常数倍</li><li><strong>矩阵某行的倍数加到另一行</strong></li></ol><h3 id="克拉默法则求矩阵的逆矩阵"><a href="#克拉默法则求矩阵的逆矩阵" class="headerlink" title="克拉默法则求矩阵的逆矩阵"></a>克拉默法则求矩阵的逆矩阵</h3><script type="math/tex; mode=display">A = \begin{pmatrix}0 & 2 & -1 \\1 & 1 & 2 \\-1 & -1 & -1 \\\end{pmatrix}，求A^{-1}</script><script type="math/tex; mode=display">用\begin{bmatrix}A & B & C\end{bmatrix}^T分别替换A的第一、二、三列，并计算行列式</script><script type="math/tex; mode=display">\begin{vmatrix} A & 2 & -1\\ B & 1 & 2\\ C & -1 & -1\end{vmatrix} = A\begin{vmatrix}1 & 2\\-1 & -1\end{vmatrix}-B\begin{vmatrix}2 & -1\\-1 & -1\end{vmatrix}+C\begin{vmatrix}2 & -1\\1 & 2\end{vmatrix}=A+3B+5C \Rightarrow \begin{bmatrix}1 & 3 & 5\end{bmatrix}</script><script type="math/tex; mode=display">\begin{vmatrix}0 & A & -1 \\1 & B & 2 \\-1 & C & -1 \\\end{vmatrix} = -A\begin{vmatrix}1 & 2\\-1 & -1\end{vmatrix}+B\begin{vmatrix}0 & -1\\-1 & -1\end{vmatrix}-C\begin{vmatrix}0 & -1\\1 & 2\end{vmatrix}=-A-B-C \Rightarrow \begin{bmatrix}-1 & -1 & -1\end{bmatrix}</script><script type="math/tex; mode=display">\begin{vmatrix}0 & 2 & A \\1 & 1 & B \\-1 & -1 & C \\\end{vmatrix} = A\begin{vmatrix}1 & 1\\-1 & -1\end{vmatrix}-B\begin{vmatrix}0 & 2\\-1 & -1\end{vmatrix}+C\begin{vmatrix}0 & 2\\1 & 1\end{vmatrix}=-2B-2C \Rightarrow \begin{bmatrix}0 & -2 & -2\end{bmatrix}</script><script type="math/tex; mode=display">将求的矩阵按行排好，再乘以矩阵得\begin{pmatrix}0 & 2 & -1 \\1 & 1 & 2 \\-1 & -1 & -1 \\\end{pmatrix}*\begin{pmatrix}1 & 3 & 5 \\-1 & -1 & -1 \\0 & -2 & -2 \\\end{pmatrix}=\begin{pmatrix}-2 & 0 & 0 \\0 & -2 & 0 \\0 & 0 & -2 \\\end{pmatrix}=-2E</script><script type="math/tex; mode=display">A^{-1} = -\frac{1}{2}\begin{pmatrix}1 & 3 & 5 \\-1 & -1 & -1 \\0 & -2 & -2 \\\end{pmatrix}</script><blockquote><p>原视频：<a href="https://www.bilibili.com/video/BV1yJ411A7Ym">克莱姆法则求矩阵的逆_哔哩哔哩_bilibili</a></p></blockquote><h2 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h2><p>设存在可逆矩阵A，$A<em>{ij}$是$a</em>{ij}$的代数余子式，$A^*$为A的伴随矩阵</p><script type="math/tex; mode=display">A^*=\begin{pmatrix}A_{11} & A_{21} & \cdots & A_{n1}\\A_{12} & A_{22} & \cdots & A_{n2}\\\vdots & \vdots &        & \vdots\\A_{1n} & A_{2n} & \cdots & A_{nn}\\\end{pmatrix}</script><p>且有$ AA^<em> = A^</em>A = |A|E $</p><h3 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h3><p>对任意n阶方阵A，都有伴随矩阵$A^*$，且有公式</p><ol><li>$ AA^<em> = A^</em>A = |A|E $</li><li>$ |A^*| = |A|^{n-1}(A为n阶矩阵) $</li></ol><p>当$ |A| \neq 0 $时，有</p><script type="math/tex; mode=display">(kA)^* = k^{n-1}A^*</script><script type="math/tex; mode=display">(A^*)^* = |A|^{n-2}A</script><script type="math/tex; mode=display">A^*A = |A|E</script><script type="math/tex; mode=display">A^* = |A|A^{-1}</script><script type="math/tex; mode=display">设A的特征向量为\lambda _n,A^*的特征向量 = \frac{|A|}{\lambda_1},\frac{|A|}{\lambda_2},\cdots,\frac{|A|}{\lambda_n}</script><script type="math/tex; mode=display">r(A^*) = \begin{cases}n && r(A) = n\\1 && r(A) = n-1\\0 && r(A) < n-1\end{cases}</script><h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><script type="math/tex; mode=display">|kA| = k^n|A|(A为n阶矩阵)</script><script type="math/tex; mode=display">A可逆,|A^{-1}| = \frac{1}{|A|}</script><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="章节概括-1"><a href="#章节概括-1" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>向量与向量组的线性相关性<ul><li>向量定义</li><li>线性组合</li><li>线性表出<ul><li>能表出</li><li>不能表出</li></ul></li><li>线性相关性<ul><li>相关</li><li>无关</li></ul></li><li>判别线性相关的七大定理</li></ul></li><li>极大线性无关组与向量组的秩<ul><li>极大线性无关组<ul><li>定义</li><li>求法</li></ul></li><li>向量组的秩<ul><li>定义</li><li>重要定理和公式</li></ul></li></ul></li><li>等价向量组<ul><li>定义</li><li>判别</li><li>与等价矩阵的区别</li></ul></li></ul><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><script type="math/tex; mode=display">\begin{pmatrix}a_{1} & a_{2} & \cdots & a_{n}\end{pmatrix}称为n维行向量，\begin{pmatrix}a_{1} \\\vdots \\a_{n}\end{pmatrix}称为n维列向量，构成向量的所有元素皆为零的向量称为零向量</script><h2 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h2><script type="math/tex; mode=display">若k_{1} \alpha_{1}+k_{2} \alpha_{2}+\cdots+k_{n} \alpha_{n} = 0，当且仅当k_{1} = k_{2} = \cdots = k_{n} = 0 时成立</script><script type="math/tex; mode=display">即齐次线性方程组只有零解，称向量组\alpha_{1}, \alpha_{2}, \cdots, \alpha_{n} \text { 线性无关 }</script><script type="math/tex; mode=display">A = (\alpha_1,\alpha_2,\cdots,\alpha_n),r(A) = n</script><h2 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h2><script type="math/tex; mode=display">存在不全为零的常数k_{1},k_{2},\cdots x_n,使得k_{1} \alpha_{1}+k_{2} \alpha_{2}+\cdots+k_{n} \alpha_{n} = 0成立</script><script type="math/tex; mode=display">即齐次线性方程组有非零解，称向量组\alpha_{1}, \alpha_{2}, \cdots, \alpha_{n} \text { 线性相关 }</script><script type="math/tex; mode=display">A = (\alpha_1,\alpha_2,\cdots,\alpha_n),r(A) < n</script><h2 id="向量组的线性表示"><a href="#向量组的线性表示" class="headerlink" title="向量组的线性表示"></a>向量组的线性表示</h2><script type="math/tex; mode=display">存在常数x_{1},x_{2},\cdots x_n,使得x_{1} \alpha_{1}+x_{2} \alpha_{2}+\cdots+x_{n} \alpha_{n} = \beta 成立</script><script type="math/tex; mode=display">称\beta 可由向量组\alpha_1,\alpha_2,\cdots,\alpha_n线性表示</script><script type="math/tex; mode=display">通常在线性方程组的基础解系中出现</script><h3 id="向量组相关性与线性表示理论"><a href="#向量组相关性与线性表示理论" class="headerlink" title="向量组相关性与线性表示理论"></a>向量组相关性与线性表示理论</h3><ol><li>若$\alpha_1,\alpha_2,\cdots,\alpha_n$线性相关，则其中至少一个向量可由其余向量线性表示</li><li>设$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关，而$\alpha_1,\alpha_2,\cdots,\alpha_n,\beta$线性相关，则$\beta$可由$\alpha_1,\alpha_2,\cdots,\alpha_n$线性表示，且表示方法唯一</li><li>若一个向量组线性无关，则其中任意一个部分向量组也必然线性无关</li><li>若一个向量组的一个部分向量组线性无关，则此向量组一定线性相关</li><li>设$\alpha_1,\alpha_2,\cdots,\alpha_n$为n个n维向量，则$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关 =&gt; $|\alpha_1,\alpha_2,\cdots,\alpha_n| \neq 0$</li><li>若一个向量组的个数大于维数（n），则此向量组一定线性相关</li><li>设$\alpha_1^\prime,\alpha_2^\prime,\cdots,\alpha_n^\prime$为$\alpha_1,\alpha_2,\cdots,\alpha_n$扩充了分量的向量组，若向量组$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关，则向量组$\alpha_1^\prime,\alpha_2^\prime,\cdots,\alpha_n^\prime$也线性无关，反之不对</li><li>若$\alpha_1,\alpha_2,\cdots,\alpha_n$为一个两两正交的非零向量组，则$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关</li></ol><h2 id="极大线性无关组"><a href="#极大线性无关组" class="headerlink" title="极大线性无关组"></a>极大线性无关组</h2><ol><li>向量组$\alpha_1 , \alpha_2,\alpha_3,\cdots,\alpha_n$中存在含$r$个向量的<strong>线性无关</strong>的<strong>子</strong>向量组</li><li>任意$r+1$个向量构成的字向量组（如果有）线性相关</li></ol><p>称含$r$个向量的线性无关的子向量组为向量组$\alpha_1 , \alpha_2,\alpha_3,\cdots,\alpha_n$的一个极大线性无关组</p><p>$r$称为向量组$\alpha_1 , \alpha_2,\alpha_3,\cdots,\alpha_n$的秩</p><h3 id="求极大线性无关组例子"><a href="#求极大线性无关组例子" class="headerlink" title="求极大线性无关组例子"></a>求极大线性无关组例子</h3><script type="math/tex; mode=display">\alpha_1 =(1,3,-1)^T, \alpha_2 = (0,1,0)^T,\alpha_3 = (0,-1,1)^T,\alpha_4 = (3,6,-1)^T,\alpha_5 = (-1,-6,5)^T</script><script type="math/tex; mode=display">(\alpha_1,\alpha_2,\alpha_3,\alpha_4,\alpha_5)  = \begin{pmatrix}1 & 0 & 0 & 3 & -1\\3 & 1 & -1 & 6 & -6\\-1 & 0 & 1 & -1 & 5\\\end{pmatrix} \rightarrow \begin{pmatrix}1 & 0 & 0 & 3 & -1\\0 & 1 & -1 & -3 & -3\\0 & 0 & 1 & 2 & 4\\\end{pmatrix}\rightarrow \begin{pmatrix}1 & 0 & 0 & 3 & -1\\0 & 1 & 0 & -1 & 1\\0 & 0 & 1 & 2 & 4\\\end{pmatrix}</script><script type="math/tex; mode=display">以上得一组极大线性无关组为\alpha_1,\alpha_2,\alpha_3</script><script type="math/tex; mode=display">\begin{cases}\alpha_4 = 3\alpha_1-\alpha_2+2\alpha_3\\\alpha_5 = -\alpha_1+\alpha_2+4\alpha_3\\\end{cases}</script><h2 id="向量秩的性质"><a href="#向量秩的性质" class="headerlink" title="向量秩的性质"></a>向量秩的性质</h2><ol><li>矩阵的<strong>行向量组的秩</strong>、<strong>列向量组的秩</strong>及<strong>矩阵的秩</strong>都相等</li><li>设$A=(\alpha_1,\alpha_2,\cdots,\alpha_m)$，$B = (\beta_1,\beta_2,\cdots,\beta_m)$为两个向量组，若<strong>A组可由B线性表示</strong>，则A组的秩不超过B组的秩（$r(A) &lt; r(B)$）</li><li><strong>等价的向量组</strong>有<strong>相等的秩</strong>，$r(A) = r(B) = r(A,B)$，A，B为向量组矩阵，A和B等价。若两个向量组的秩相等，则两个向量组不一定等价。</li></ol><h2 id="向量单位化"><a href="#向量单位化" class="headerlink" title="向量单位化"></a>向量单位化</h2><h3 id="向量模"><a href="#向量模" class="headerlink" title="向量模"></a>向量模</h3><script type="math/tex; mode=display">设向量n = (a,b,c)^T，则模为:||n|| = \sqrt{a^2+b^2+c^2}</script><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><script type="math/tex; mode=display">设向量n = (a,b,c)^T，则n的单位向量为n = \frac{1}{||n||}(a,b,c)</script><h2 id="向量内积"><a href="#向量内积" class="headerlink" title="向量内积"></a>向量内积</h2><script type="math/tex; mode=display">设有n维向量，x = (x_1,x_2,x_3,\cdots,x_n),y = (y_1,y_2,y_3,\cdots,y_n)</script><script type="math/tex; mode=display">[x,y] = x_1y_1+x_2y_2+x_3y_3+\cdots,x_ny_n,[x,y]称为向量x与y的内积</script><script type="math/tex; mode=display">||x|| = \sqrt{[x,x]} = \sqrt{x_1^2 + x_2^2 + x_3^2 + \cdots + x_n^2}</script><h2 id="向量正交"><a href="#向量正交" class="headerlink" title="向量正交"></a>向量正交</h2><script type="math/tex; mode=display">[x,y] = 0，称x,y正交，记x\perp y</script>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表的概念总结</title>
    <link href="/my_world/content/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <url>/my_world/content/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表(linear list)是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。</p><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>采用顺序存储的方式实现线性表简称顺序表，把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p><p>顺序表的静态实现：<strong>采用数组</strong>，表初始化后不能扩展存储空间。</p><p>顺序表的动态实现：<strong>采用动态分配内存</strong>，表可任意扩展存储空间</p><p>顺序表的<strong>优点是随机访问很快</strong>，通过数组下标或指针的运算，时间复杂度为O(1)，但<strong>插入和删除数据的时候，需要移动元素</strong>，内存拷贝次数比较多。</p><p>总结：</p><p>优点：可随机存储，存储密度高。</p><p>缺点：要求连续的内存空间，扩容不方便，插入和删除元素需要移动其它的元素。</p><p>使用的时候参考<strong>数组</strong></p><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;cout &lt;&lt; i[<span class="hljs-number">0</span>] &lt;&lt; endl;</code></pre></div><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><blockquote><p>以下图片原链接：<a href="http://data.biancheng.net/view/5.html">链表（单链表）的基本操作及C语言实现 (biancheng.net)</a></p></blockquote><p>单链表是一种<strong>链式存取</strong>的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素+指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><p>单链表<strong>设置头结点的作用</strong>是：<strong>为保证处理第一个结点和后面结点的算法相同，使程序更高效</strong></p><p><img src="http://data.biancheng.net/uploads/allimg/170727/2-1FHG45629418.png" alt="单链表演示"></p><p>优点：不要求连续的内存空间，<strong>扩容很方便，插入和删除元素不需要移动其它的元素</strong>。</p><p>缺点：<strong>不支持随机访问</strong>，指针需要消耗空间。<strong>只能由开始结点走到终端结点</strong>。因此访问效率低</p><p><img src="http://data.biancheng.net/uploads/allimg/170718/2-1FGQ0394c05.png" alt="插入节点图片演示"></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//q-&gt;next = p，在qp之间插入结点s</span>q-&gt;next = s;s-&gt;next = p;<span class="hljs-comment">//q-&gt;next = s，s-&gt;next = p在qp之间删除结点s</span>q-&gt;next = p;<span class="hljs-built_in">free</span>(s);</code></pre></div><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><blockquote><p>以下图片原链接：<a href="http://data.biancheng.net/view/166.html">双向链表及其创建（C语言）详解 (biancheng.net)</a></p></blockquote><p>双链表就是在单链表结点上增添了一个指针域，指向当前节点的前驱。对于<strong>逆向查找（从后往前）相关</strong>的问题，使用双链表，会更加事半功倍。</p><p>与单链表相比，双链表的优点之一为：<strong>访问前后结点更灵活</strong></p><p><img src="http://data.biancheng.net/uploads/allimg/181128/2-1Q12R01Q63Q.gif" alt="双链表演示"></p><p>优点：从双链表中的任意一个结点开始，都可以<strong>很方便地访问前驱结点和后继结点</strong>。</p><p>缺点：增加删除节点复杂，<strong>需要多分配一个指针存储空间</strong>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//q-&gt;next = p，p-&gt;prior = q，在qp之间插入结点s</span>q-&gt;next = s;s-&gt;next = p;s-&gt;prior = q;s-&gt;next = p;<span class="hljs-comment">//q-&gt;next = s，s-&gt;next = p，s-&gt;prior = q;s-&gt;next = p在qp之间删除结点s</span>q-&gt;next = p;p-&gt;prior = q;<span class="hljs-built_in">free</span>(s);</code></pre></div><h1 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h1><blockquote><p>以下图片原链接：<a href="https://www.dotcpp.com/course/100">循环链表一 - 数据结构与算法教程 - C语言网 (dotcpp.com)</a></p></blockquote><p>将当链表的最后一个指针域指向链表中的第一个结点即可。若第一个结点为头结点，则最后一个结点连接的是头结点，若单链表没有头结点，则最后一个指针域要指向开始结点。</p><p>循环单链表的最大优点是：<strong>从任何一个结点出发都能够访问到链表中的其他所有的结点</strong></p><p><img src="https://www.dotcpp.com/oj/ueditor/php/upload/image/20190712/1562924138210258.png" alt="循环单链表演示"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自带数据结构头文件/库/包大总结</title>
    <link href="/my_world/content/%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <url>/my_world/content/%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>无论是c++、java、还是python，都会自带已经实现的数据结构，下面是总结所有的数据结构的头文件/库/包的用法</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>无论引用任何的数据结构头文件，都需要加上以下命名空间</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;</code></pre></div><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span></code></pre></div><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre><code class="hljs c++">list&lt;<span class="hljs-keyword">int</span>&gt; _list;<span class="hljs-comment">// 一个空的节点为int类型的链表</span>list&lt;<span class="hljs-keyword">int</span>&gt; _list(<span class="hljs-number">10</span>);<span class="hljs-comment">// 一个长度为10的节点为int类型的链表</span></code></pre></div><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>从前面插入一个数据</p><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);</code></pre></div><p>从后面插入一个数据</p><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>)</code></pre></div><h3 id="移除数据"><a href="#移除数据" class="headerlink" title="移除数据"></a>移除数据</h3><p>移除与值相同的节点</p><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">remove</span>(<span class="hljs-number">1</span>);</code></pre></div><p>移除最前面的数据</p><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">pop_front</span>();</code></pre></div><p>移除最后面的数据</p><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">pop_back</span>();</code></pre></div><p>清空链表的内容</p><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">clear</span>();</code></pre></div><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">sort</span>();</code></pre></div><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查看链表最前面的元素</p><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">front</span>();</code></pre></div><p>遍历所有的list元素</p><div class="code-wrapper"><pre><code class="hljs c++">list&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter;<span class="hljs-keyword">for</span>(iter = _list.<span class="hljs-built_in">begin</span>();iter!= _list.<span class="hljs-built_in">end</span>();iter++)&#123;    cout &lt;&lt; *iter &lt;&lt; endl;&#125;</code></pre></div><h3 id="查看链表的长度"><a href="#查看链表的长度" class="headerlink" title="查看链表的长度"></a>查看链表的长度</h3><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">size</span>();</code></pre></div><h3 id="查看链表是否为空"><a href="#查看链表是否为空" class="headerlink" title="查看链表是否为空"></a>查看链表是否为空</h3><div class="code-wrapper"><pre><code class="hljs c++">_list.<span class="hljs-built_in">empty</span>();</code></pre></div><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span></code></pre></div><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre><code class="hljs c++">queue&lt;<span class="hljs-keyword">int</span>&gt; _queue;<span class="hljs-comment">// int类型的队列</span></code></pre></div><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><div class="code-wrapper"><pre><code class="hljs c++">_queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);</code></pre></div><h3 id="访问队头元素"><a href="#访问队头元素" class="headerlink" title="访问队头元素"></a>访问队头元素</h3><div class="code-wrapper"><pre><code class="hljs c++">_queue.<span class="hljs-built_in">front</span>();</code></pre></div><h3 id="队头出队"><a href="#队头出队" class="headerlink" title="队头出队"></a>队头出队</h3><div class="code-wrapper"><pre><code class="hljs c++">_queue.<span class="hljs-built_in">pop</span>();</code></pre></div><h3 id="检查队伍是否为空"><a href="#检查队伍是否为空" class="headerlink" title="检查队伍是否为空"></a>检查队伍是否为空</h3><div class="code-wrapper"><pre><code class="hljs c++">_queue.<span class="hljs-built_in">empty</span>();</code></pre></div><h3 id="查看队列长度"><a href="#查看队列长度" class="headerlink" title="查看队列长度"></a>查看队列长度</h3><div class="code-wrapper"><pre><code class="hljs c++">_queue.<span class="hljs-built_in">size</span>();</code></pre></div><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="引用-2"><a href="#引用-2" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span></code></pre></div><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre><code class="hljs c++">stack&lt;<span class="hljs-keyword">int</span>&gt; _stack;<span class="hljs-comment">// int类型的栈</span></code></pre></div><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><div class="code-wrapper"><pre><code class="hljs c++">_stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);</code></pre></div><h3 id="查看栈顶元素"><a href="#查看栈顶元素" class="headerlink" title="查看栈顶元素"></a>查看栈顶元素</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> top = _stack.<span class="hljs-built_in">top</span>();</code></pre></div><h3 id="将栈顶元素移出栈"><a href="#将栈顶元素移出栈" class="headerlink" title="将栈顶元素移出栈"></a>将栈顶元素移出栈</h3><div class="code-wrapper"><pre><code class="hljs c++">_stack.<span class="hljs-built_in">pop</span>();</code></pre></div><h3 id="查看栈大小"><a href="#查看栈大小" class="headerlink" title="查看栈大小"></a>查看栈大小</h3><div class="code-wrapper"><pre><code class="hljs c++">_stack.<span class="hljs-built_in">size</span>();</code></pre></div><h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>插入效率高</p><h3 id="引用-3"><a href="#引用-3" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;</code></pre></div><h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre><code class="hljs java">LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</code></pre></div><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>添加</p><div class="code-wrapper"><pre><code class="hljs java">list.add(<span class="hljs-number">1</span>)</code></pre></div><p>从头部添加</p><div class="code-wrapper"><pre><code class="hljs java">list.addFirst(<span class="hljs-number">2</span>)</code></pre></div><p>从尾部添加</p><div class="code-wrapper"><pre><code class="hljs java">list.addLast(<span class="hljs-number">3</span>)</code></pre></div><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除头部元素</p><div class="code-wrapper"><pre><code class="hljs java">list.removeFirst();</code></pre></div><p>删除尾部元素</p><div class="code-wrapper"><pre><code class="hljs java">list.removeLast();</code></pre></div><h3 id="查看链表长度"><a href="#查看链表长度" class="headerlink" title="查看链表长度"></a>查看链表长度</h3><div class="code-wrapper"><pre><code class="hljs java">list.size();</code></pre></div><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>获取头部元素</p><div class="code-wrapper"><pre><code class="hljs java">list.getFirst();</code></pre></div><p>获取尾部元素</p><div class="code-wrapper"><pre><code class="hljs java">list.getLast();</code></pre></div><p>获取指定位置的元素</p><div class="code-wrapper"><pre><code class="hljs java">list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// index为0的元素</span></code></pre></div><p>迭代查找（遍历）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : list) &#123;    System.out.println(i);&#125;</code></pre></div><h2 id="可动态修改数组（非数据结构）"><a href="#可动态修改数组（非数据结构）" class="headerlink" title="可动态修改数组（非数据结构）"></a>可动态修改数组（非数据结构）</h2><p>查找效率高</p><h3 id="引用-4"><a href="#引用-4" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;</code></pre></div><h3 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre><code class="hljs java">ArrayList&lt;<span class="hljs-keyword">int</span>&gt; list =<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre></div><h3 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h3><div class="code-wrapper"><pre><code class="hljs java">list.add(<span class="hljs-number">1</span>)</code></pre></div><h3 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h3><p>获取特定位置的元素</p><div class="code-wrapper"><pre><code class="hljs java">list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// index为0的元素</span></code></pre></div><p>迭代</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : list) &#123;    System.out.println(i);&#125;</code></pre></div><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><div class="code-wrapper"><pre><code class="hljs java">list.set(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// index为0的元素修改为1</span></code></pre></div><h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除特定位置的元素</p><div class="code-wrapper"><pre><code class="hljs java">list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除index为1的元素</span></code></pre></div><p>删除所有</p><div class="code-wrapper"><pre><code class="hljs java">list.clear();</code></pre></div><h3 id="查看长度"><a href="#查看长度" class="headerlink" title="查看长度"></a>查看长度</h3><div class="code-wrapper"><pre><code class="hljs java">list.size();</code></pre></div><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collections;  <span class="hljs-comment">// 引入 Collections 类</span>Collections.sort(list);  <span class="hljs-comment">// 排序</span></code></pre></div><h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><p>LinkedList实现了queue接口</p><h3 id="引用-5"><a href="#引用-5" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;</code></pre></div><h3 id="初始化-5"><a href="#初始化-5" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre><code class="hljs java">LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</code></pre></div><h3 id="添加元素-2"><a href="#添加元素-2" class="headerlink" title="添加元素"></a>添加元素</h3><div class="code-wrapper"><pre><code class="hljs java">queue.offer(<span class="hljs-number">1</span>);</code></pre></div><h3 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> peek=queue.peek();</code></pre></div><h3 id="队头出队-1"><a href="#队头出队-1" class="headerlink" title="队头出队"></a>队头出队</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> top = queue.pop();<span class="hljs-keyword">int</span> top = queue.poll();<span class="hljs-comment">// 用Queue的时候用这个方法</span></code></pre></div><h3 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h3><div class="code-wrapper"><pre><code class="hljs java">queue.isEmpty(); <span class="hljs-comment">// 为空返回T,否则为F</span></code></pre></div><h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><h3 id="引用-6"><a href="#引用-6" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;</code></pre></div><h3 id="初始化-6"><a href="#初始化-6" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre><code class="hljs java">Stack&lt;Integer&gt; stack=<span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();</code></pre></div><h3 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> top = stack.peek();</code></pre></div><h3 id="栈顶元素出站并获取"><a href="#栈顶元素出站并获取" class="headerlink" title="栈顶元素出站并获取"></a>栈顶元素出站并获取</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> top=stack.pop();</code></pre></div><h3 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h3><div class="code-wrapper"><pre><code class="hljs java">stack.push(<span class="hljs-number">1</span>);</code></pre></div><h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><div class="code-wrapper"><pre><code class="hljs java">stack.empty();</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>头文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python翻译</title>
    <link href="/my_world/content/python%E7%BF%BB%E8%AF%91/"/>
    <url>/my_world/content/python%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h1><p>python的google翻译模块，但是有次数限制</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> translate</code></pre></div><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> translate <span class="hljs-keyword">import</span> Translator</code></pre></div><h2 id="英译汉"><a href="#英译汉" class="headerlink" title="英译汉"></a>英译汉</h2><div class="code-wrapper"><pre><code class="hljs python">translator2CN = Translator(from_lang=<span class="hljs-string">&#x27;english&#x27;</span>,to_lang=<span class="hljs-string">&#x27;chinese&#x27;</span>)translator2CN.translate(<span class="hljs-string">&quot;How the financial crisis was caused&quot;</span>)输出：金融危机是如何引起的</code></pre></div><h2 id="汉译英"><a href="#汉译英" class="headerlink" title="汉译英"></a>汉译英</h2><div class="code-wrapper"><pre><code class="hljs python">translator2EN = Translator(from_lang=<span class="hljs-string">&#x27;chinese&#x27;</span>,to_lang=<span class="hljs-string">&#x27;english&#x27;</span>)translator2EN.translate(<span class="hljs-string">&quot;金融危机是如何造成的&quot;</span>)输出：How the financial crisis was caused</code></pre></div><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 首先翻译成英文</span>self.__TSdriver.find_element_by_xpath(<span class="hljs-string">&quot;//*[@id=\&quot;i13\&quot;]/span[3]&quot;</span>).click()<span class="hljs-comment"># 点击英文</span><span class="hljs-comment"># 清除内容</span>self.__TSdriver.find_element_by_xpath(<span class="hljs-string">&quot;//*[@id=\&quot;yDmH0d\&quot;]/c-wiz/div/div[2]/c-wiz/div[2]/c-wiz/div[1]/div[2]/div[2]/c-wiz[1]/span/span/div/textarea&quot;</span>).send_keys(Keys.CONTROL + <span class="hljs-string">&#x27;a&#x27;</span>)self.__TSdriver.find_element_by_xpath(<span class="hljs-string">&quot;//*[@id=\&quot;yDmH0d\&quot;]/c-wiz/div/div[2]/c-wiz/div[2]/c-wiz/div[1]/div[2]/div[2]/c-wiz[1]/span/span/div/textarea&quot;</span>).send_keys(Keys.BACKSPACE)<span class="hljs-comment"># 输入文章</span>self.__TSdriver.find_element_by_xpath(<span class="hljs-string">&quot;//*[@id=\&quot;yDmH0d\&quot;]/c-wiz/div/div[2]/c-wiz/div[2]/c-wiz/div[1]/div[2]/div[2]/c-wiz[1]/span/span/div/textarea&quot;</span>).send_keys(sentence)<span class="hljs-comment"># 等待翻译</span>sleep(<span class="hljs-number">3</span>)<span class="hljs-comment"># 输出结果</span>english = self.__TSdriver.find_element_by_xpath(<span class="hljs-string">&quot;//*[@id=\&quot;yDmH0d\&quot;]/c-wiz/div/div[2]/c-wiz/div[2]/c-wiz/div[1]/div[2]/div[2]/c-wiz[2]/div[5]/div/div[1]/span[1]&quot;</span>).text</code></pre></div><h1 id="翻译的作用"><a href="#翻译的作用" class="headerlink" title="翻译的作用"></a>翻译的作用</h1><ol><li>阅读</li><li>改变句子的结构，同义句的转换</li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python 库</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的概念总结</title>
    <link href="/my_world/content/%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <url>/my_world/content/%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。通常，图形以图解形式描绘为顶点的一组点或环，并通过边的线或曲线连接。 图形是离散数学的研究对象之一。</p><h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><blockquote><p>访问链接：<a href="https://blog.csdn.net/Real_Fool_/article/details/114141377">数据结构：图(Graph)【详解】_UniqueUnit的博客-CSDN博客</a></p></blockquote><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵是图的顺序存储结构。<strong>一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</strong></p><h3 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h3><p>首先构建结点</p><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @author: Vsoapmac</span><span class="hljs-comment"> * @time: 2021年9月17日</span><span class="hljs-comment"> * @use: 结点</span><span class="hljs-comment"> **/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> data)&#123;        <span class="hljs-keyword">this</span>-&gt;data = data;        <span class="hljs-keyword">this</span>-&gt;id = id;    &#125;    <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">int</span> id;&#125;;</code></pre></div><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>初始化领接矩阵数组</p><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nodeSize = <span class="hljs-number">5</span>;<span class="hljs-comment">// 领接矩阵</span><span class="hljs-keyword">int</span> graphMatrix[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<span class="hljs-comment">// 领接矩阵有向图的权</span><span class="hljs-keyword">double</span> graphMatrixSize[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<span class="hljs-comment">// 已阅读的结点</span><span class="hljs-keyword">int</span> visit[<span class="hljs-number">5</span>];<span class="hljs-comment">// 队列或栈</span>queue&lt;Node*&gt; _queue;stack&lt;Node*&gt; _stack;<span class="hljs-built_in">Graph</span>()&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodeSize;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nodeSize;j++)&#123;            <span class="hljs-comment">// 初始化方向</span>            graphMatrix[i][j] = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 节点的自身的权为0</span>            <span class="hljs-keyword">if</span>(i == j)&#123;                graphMatrixSize[i][j] = <span class="hljs-number">0</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">// 初始化路径</span>                graphMatrixSize[i][j] = <span class="hljs-number">-1</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="构造领接矩阵"><a href="#构造领接矩阵" class="headerlink" title="构造领接矩阵"></a>构造领接矩阵</h3><p>构造领接矩阵</p><p>c++（有向、无向）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @use: 构造有向领接矩阵</span><span class="hljs-comment"> * @parameter: 新的结点，结点连接的下一个节点，节点的权</span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatrixBuild</span><span class="hljs-params">(Node* new_node,Node* next_node,<span class="hljs-keyword">double</span> length)</span></span>&#123;    <span class="hljs-comment">// 连接下一个结点</span>    <span class="hljs-keyword">if</span>(next_node)&#123;        graphMatrix[new_node-&gt;id][next_node-&gt;id] = <span class="hljs-number">1</span>;        graphMatrixSize[new_node-&gt;id][next_node-&gt;id] = length;    &#125;&#125;</code></pre></div><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++">Graph gh;Node* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);Node* first = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);Node* second = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);Node* third = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);Node* forth = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>);Node* fifth = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">// 连接0 -&gt; 1,0 -&gt; 4</span>gh.<span class="hljs-built_in">MatrixBuild</span>(root,first,<span class="hljs-number">1.1</span>);gh.<span class="hljs-built_in">MatrixBuild</span>(root,forth,<span class="hljs-number">8.0</span>);<span class="hljs-comment">// 连接2 -&gt; 3,2 -&gt; 5</span>gh.<span class="hljs-built_in">MatrixBuild</span>(second,third,<span class="hljs-number">5.7</span>);gh.<span class="hljs-built_in">MatrixBuild</span>(second,fifth,<span class="hljs-number">5.0</span>);<span class="hljs-comment">// 连接3 -&gt; 1,3 -&gt; 0,3 -&gt; 4</span>gh.<span class="hljs-built_in">MatrixBuild</span>(third,first,<span class="hljs-number">3.2</span>);gh.<span class="hljs-built_in">MatrixBuild</span>(third,root,<span class="hljs-number">2.2</span>);gh.<span class="hljs-built_in">MatrixBuild</span>(third,forth,<span class="hljs-number">3.3</span>);<span class="hljs-comment">// 连接4 -&gt; 5</span>gh.<span class="hljs-built_in">MatrixBuild</span>(forth,fifth,<span class="hljs-number">6.0</span>);</code></pre></div><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><h1 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h1><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><p>DFS（Depth-First Search）：深度优先搜索属于图算法的一种，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><p>深度优先遍历图的方法是，从图中某顶点v出发：</p><ol><li>访问顶点v；</li><li>依次从v的未被访问的邻接点出发，对图进行DFS；直至图中和v有路径相通的顶点都被访问；</li><li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行DFS，直到图中所有顶点均被访问过为止。</li></ol><p>深度优先遍历使用的数据结构是<strong>栈（Stack）</strong>，将访问过的节点标记后，并压入栈中，再遍历此时跟栈顶元素相关联的节点，将其中未标记的节点标记，并压入栈中……以此类推，当该栈顶的元素相关联的节点都被访问过了，则该元素弹出栈……直到栈空，遍历完成。</p><blockquote><p>原链接：<a href="https://zhuanlan.zhihu.com/p/126311017">深度优先搜索算法 - 知乎 (zhihu.com)</a></p></blockquote><p>深度优先搜索类似于<strong>二叉树的先序遍历</strong></p><p>c++（注意，不用栈实现的深度优先搜索算法）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @use: 深度优先搜索遍历</span><span class="hljs-comment"> * @parameter: 根节点</span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Node* root)</span></span>&#123;    <span class="hljs-keyword">if</span>(visit[root-&gt;id]!=<span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">// 操作数据（存储、输出）</span>        cout &lt;&lt; (<span class="hljs-keyword">char</span>)root-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;        <span class="hljs-comment">// 记录已阅读的结点</span>        visit[root-&gt;id] = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 若结点有连通结点，则遍历结点</span>        <span class="hljs-keyword">if</span>(!root-&gt;next_node_list.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-comment">// 初始化迭代器</span>            list&lt;Node*&gt;::iterator iter;            <span class="hljs-comment">// 遍历领接结点</span>            list&lt;Node*&gt; next_node_list = root-&gt;next_node_list;            <span class="hljs-comment">// 顶点出栈</span>            _stack.<span class="hljs-built_in">pop</span>();            <span class="hljs-keyword">for</span>(iter = next_node_list.<span class="hljs-built_in">begin</span>();iter!= next_node_list.<span class="hljs-built_in">end</span>();iter++)&#123;                <span class="hljs-comment">// 递归遍历到的点</span>                <span class="hljs-built_in">DFS</span>(*iter);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>java（半伪代码）：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> visted[]; <span class="hljs-comment">// 初始化记录已阅读顶点数组</span>List&lt;Node&gt; _final; <span class="hljs-comment">// 初始化深度优先搜索算法最终的运算结果</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@use</span>: 主方法，从某个顶点开始</span><span class="hljs-comment">  * <span class="hljs-doctag">@parameter</span>: 整个图和从某个顶点</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span>: 搜索后的结点数组</span><span class="hljs-comment">  **/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph g, Node node)</span></span>&#123;    <span class="hljs-keyword">if</span>(visted[node.getId()]!=<span class="hljs-number">1</span>)&#123;        _final.add(node); <span class="hljs-comment">// 保存在结果数组中</span>        visted[node.getId()]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 记录状态</span>        <span class="hljs-comment">// 若顶点有连通顶点，遍历</span>        <span class="hljs-keyword">if</span>(!g.visitNext(node).isEmpty())&#123;            Queue&lt;Node&gt; nodeQueue = g.visitNext(node);<span class="hljs-comment">// 所搜顶点的领接顶点</span>            <span class="hljs-comment">// 循环领接顶点队列，每个队头出队直到队列为空为止</span>            <span class="hljs-keyword">while</span>(!nodeQueue.isEmpty())&#123;                DFS(g,nodeQueue.poll());            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><p>广度优先搜索（以下采用广度来描述）是连通图的一种遍历算法。这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。</p><p>广度优先搜索别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。</p><p>换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。基本过程，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现BFS算法。</p><blockquote><p>原链接：<a href="https://www.jianshu.com/p/bff70b786bb6">基本算法——深度优先搜索（DFS）和广度优先搜索（BFS） - 简书 (jianshu.com)</a></p></blockquote><p>广度优先搜索类似于<strong>树的层次遍历</strong></p><p>BFS遍历图的时候，需要用到一个队列，算法执行过程简单概括如下：</p><ol><li>任取图中一个顶点访问，入队，并将这个顶点标记为已访问</li><li>当队列不为空时循环执行，出队，依次检查出队顶点的所有领接顶点，访问没有被访问过的领接顶点并将其入队</li><li>当队列为空时跳出循环，BFS完成</li></ol><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment">     * @use: 广度优先搜索遍历</span><span class="hljs-comment">     * @parameter: 根节点</span><span class="hljs-comment">     **/</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Node* root)</span></span>&#123;        <span class="hljs-comment">// 顶点入队</span>        _queue.<span class="hljs-built_in">push</span>(root);        <span class="hljs-comment">// 记录结点被阅读的状态</span>        visit[root-&gt;id] = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 以队列为焦点对图进行操作</span>        <span class="hljs-keyword">while</span>(!_queue.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-comment">// 队列的队头如果有领接顶点则进行入队操作</span>            <span class="hljs-keyword">if</span>(!_queue.<span class="hljs-built_in">front</span>()-&gt;next_node_list.<span class="hljs-built_in">empty</span>())&#123;                <span class="hljs-comment">// 操作数据</span>                cout &lt;&lt; (<span class="hljs-keyword">char</span>)_queue.<span class="hljs-built_in">front</span>()-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;                <span class="hljs-comment">// 初始化迭代器</span>                list&lt;Node*&gt;::iterator iter;                <span class="hljs-comment">// 遍历领接结点</span>                list&lt;Node*&gt; next_node_list = _queue.<span class="hljs-built_in">front</span>()-&gt;next_node_list;                Node* node_save = <span class="hljs-literal">NULL</span>;                <span class="hljs-keyword">for</span>(iter = next_node_list.<span class="hljs-built_in">begin</span>();iter!= next_node_list.<span class="hljs-built_in">end</span>();iter++)&#123;                    <span class="hljs-comment">// 临时存储结点</span>                    node_save = *iter;                    <span class="hljs-comment">// 若结点并未阅读，存储结点，并标记阅读状态</span>                    <span class="hljs-keyword">if</span>(visit[node_save-&gt;id]!=<span class="hljs-number">1</span>)&#123;                        <span class="hljs-comment">// 递归遍历到的点</span>                        _queue.<span class="hljs-built_in">push</span>(*iter);                        <span class="hljs-comment">// 记录结点被阅读的状态</span>                        visit[node_save-&gt;id] = <span class="hljs-number">1</span>;                    &#125;                &#125;                <span class="hljs-comment">// 队头出队</span>                _queue.<span class="hljs-built_in">pop</span>();            &#125;        &#125;    &#125;</code></pre></div><p>java（半伪代码）：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> visted[]; <span class="hljs-comment">// 初始化记录已阅读顶点数组</span>List&lt;Node&gt; _final; <span class="hljs-comment">// 初始化深度优先搜索算法最终的运算结果</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@use</span>: 主方法，从某个顶点开始</span><span class="hljs-comment">  * <span class="hljs-doctag">@parameter</span>: 整个图和从某个顶点</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span>: 搜索后的结点数组</span><span class="hljs-comment">  **/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Graph g, Node node)</span></span>&#123;    Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList();<span class="hljs-comment">// 初始化队列</span>    queue.offer(node);<span class="hljs-comment">// 起点入队</span>    visted[node.getId()] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 记录阅读的状态</span>    _final.add(node); <span class="hljs-comment">// 保存结点</span>    <span class="hljs-comment">// 在队内操作直到队列为空</span>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;        Node current = queue.poll();        Queue&lt;Node&gt; currentNext = g.visitNext(current);        <span class="hljs-comment">// 如果结点有领接顶点将领接顶点入队并标记阅读的状态</span>        <span class="hljs-keyword">while</span>(!currentNext.isEmpty())&#123;            Node current1 = currentNext.poll();            <span class="hljs-comment">// 如果该节点并未阅读则入队和记录</span>            <span class="hljs-keyword">if</span>(visted[current1.getId()] != <span class="hljs-number">1</span>)&#123;                queue.offer(current1); <span class="hljs-comment">// 入队</span>                visted[current1.getId()] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 记录阅读的状态</span>                _final.add(current1); <span class="hljs-comment">// 保存结点</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="图的最小（代价）生成树算法"><a href="#图的最小（代价）生成树算法" class="headerlink" title="图的最小（代价）生成树算法"></a>图的最小（代价）生成树算法</h1><p>以下算法皆用顶点构建生成树，适合稠密图</p><h2 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h2><p>普里姆算法查找最小生成树的过程，采用了贪心算法的思想。对于包含 N 个顶点的连通网，普里姆算法每次从连通网中找出一个权值最小的边，这样的操作重复 N-1 次，由 N-1 条权值最小的边组成的生成树就是最小生成树。</p><p><strong>Prim算法适合稠密图</strong></p><p>那么，如何找出 N-1 条权值最小的边呢？普里姆算法的实现思路是：</p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B 类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li></ol><blockquote><p>原链接：<a href="http://c.biancheng.net/algorithm/prim.html">prim算法（普里姆算法）详解 (biancheng.net)</a></p></blockquote><p>以下为笔者用口语通俗化普里姆算法的过程：</p><ol><li>将图中所有的结点全部提取出来</li><li>找出两个结点之间的最短路径（权值最小）的边并记录</li><li>循环2步骤，直到所有结点连通为止</li></ol><p>图示可以查看上面的链接</p><h2 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h2><p>克鲁斯卡尔算法查找最小生成树的方法是：将连通网中所有的边按照权值大小做升序排序，从权值最小的边开始选择，只要此边不和已选择的边一起构成环路，就可以选择它组成最小生成树。对于 N 个顶点的连通网，挑选出 N-1 条符合条件的边，这些边组成的生成树就是最小生成树。</p><p><strong>Kruksal算法常用于稀疏图</strong></p><blockquote><p>原链接：<a href="http://c.biancheng.net/algorithm/kruskal.html">kruskal算法（克鲁斯卡尔算法）详解 (biancheng.net)</a></p></blockquote><p>以下为笔者用口语通俗化克鲁斯卡尔算法的过程：</p><ol><li>将图中所有的结点全部提取出来</li><li>将所有的边的权值全部排序</li><li>连接所有权值最小的边</li><li>若存在回路，比较通往同一结点的两条路径的权值，哪条最小取哪条</li><li>所有的结点连通后结束</li></ol><p>图示可以查看上面的链接</p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h2><p>迪杰斯特拉算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先遍历思想)，直到扩展到终点为止。</p><p><strong>基本思想</strong></p><ol><li>通过Dijkstra计算图G中的最短路径时，需要指定一个起点D(即从顶点D开始计算)。</li><li>此外，引进两个数组S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点D的距离)。</li><li>初始时，数组S中只有起点D；数组U中是除起点D之外的顶点，并且数组U中记录各顶点到起点D的距离。如果顶点与起点D不相邻，距离为无穷大。</li><li>然后，从数组U中找出路径最短的顶点K，并将其加入到数组S中；同时，从数组U中移除顶点K。接着，更新数组U中的各顶点到起点D的距离。</li><li>重复第4步操作，直到遍历完所有顶点。</li></ol><blockquote><p>原链接：<a href="https://zhuanlan.zhihu.com/p/346558578">最短路径算法-迪杰斯特拉(Dijkstra)算法 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h2><p>弗洛伊德算法计算图中各个顶点之间的最短路径，如果求图中任意一对顶点间的最短路径，则通常使用弗洛伊德算法。弗洛伊德算法算法不能解决带有“负权回路”（或者叫“负权环”）的图，因为带有“负权回路”的图没有最短路。</p><p>Floyd算法采用动态规划的思想，分多个阶段解决问题</p><p>若图中有n个顶点($V_0$~$V_1$),求图中每一对页点之间的最短路径分n个阶段</p><ol><li>初始化，在没有其它顶点中转的情况下，求得各顶点间的最短路径</li><li>如果在各顶点间增加$V_0$作为中转点，求得各顶点间新的最短路径</li><li>增加$V_1$作为中转点，求得各顶点间新的最短路径</li><li>增加$V_2$作为中转点，求得各顶点间新的最短路径。</li><li>$\cdots$</li><li>最后增加$V_{n-1}$作为中转点，求得各顶点间最终的最短路径。</li></ol><h3 id="初始化矩阵"><a href="#初始化矩阵" class="headerlink" title="初始化矩阵"></a>初始化矩阵</h3><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 复制权矩阵</span><span class="hljs-keyword">double</span> MatrixSize[nodeSize][nodeSize];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodeSize;i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nodeSize;j++)&#123;        MatrixSize[i][j] = graphMatrixSize[i][j];    &#125;&#125;<span class="hljs-comment">// 初始化中转结点矩阵</span><span class="hljs-keyword">int</span> MatrixMiddle[nodeSize][nodeSize];<span class="hljs-comment">// 为中转结点矩阵赋初始值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodeSize;i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nodeSize;j++)&#123;        <span class="hljs-comment">// 中转结点矩阵的值初始值为-1</span>        MatrixMiddle[i][j] = <span class="hljs-number">-1</span>;    &#125;&#125;</code></pre></div><h3 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h3><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 第一层循环，中转次数</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; nodeSize;k++)&#123;    <span class="hljs-comment">// 第二层循环，矩阵的行</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodeSize;i++)&#123;        <span class="hljs-comment">// 第三层循环，矩阵的列</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nodeSize;j++)&#123;            <span class="hljs-comment">// A[i][j] &gt; A[i][k] + A[k][j]?A[i][j] = A[i][k] + A[k][j]:A[i][j]</span>            <span class="hljs-keyword">if</span>(MatrixSize[i][j] &gt; MatrixSize[i][k] + MatrixSize[k][j])&#123;                <span class="hljs-comment">// 赋值</span>                MatrixSize[i][j] = MatrixSize[i][k] + MatrixSize[k][j];                cout &lt;&lt; MatrixSize[i][j] &lt;&lt; endl;                <span class="hljs-comment">// 改变中转次数</span>                MatrixMiddle[i][j] = k;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="算出最短路径和路径"><a href="#算出最短路径和路径" class="headerlink" title="算出最短路径和路径"></a>算出最短路径和路径</h3><h1 id="AOV和AOE网"><a href="#AOV和AOE网" class="headerlink" title="AOV和AOE网"></a>AOV和AOE网</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="AOV"><a href="#AOV" class="headerlink" title="AOV"></a>AOV</h3><p>概念：在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，一个工程常被分为多个小的子工程，这些子工程被称为活动（Activity)，在<strong>有向图</strong>中若以顶点表示<strong>活动</strong>，<strong>有向边</strong>表示<strong>活动之间的先后关系</strong>，这样的图简称为AOV网。它是一种可以形象地反映出整个工程中各个活动之间的先后关系的有向图。</p><p>AOV图没有回路</p><p>总结：AOV网是一种用<strong>结点表示活动、用有向边表示活动先后关系</strong>的有向无环图</p><p>拓扑排序：找到活动的先后顺序</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>从图中找出一个没有前驱的结点（入度为0）的结点并输出</li><li>从图中<strong>删除</strong>该<strong>结点</strong>和全部<strong>以它为起点的有向边</strong></li><li>重复步骤1和2，直到图为空</li></ol><p>拓扑排序的结果不唯一</p><p>逆拓扑排序：</p><ol><li>从图中找出一个没有后继的结点（出度为0）的结点并输出</li><li>从图中<strong>删除</strong>该<strong>结点</strong>和全部<strong>以它为终点的有向边</strong></li><li>重复步骤1和2，直到图为空</li></ol><h2 id="AOE"><a href="#AOE" class="headerlink" title="AOE"></a>AOE</h2><p>概念：在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，一个工程常被分为多个小的子工程，这些子工程被称为活动（Activity)，在<strong>带权有向图</strong>中若以顶点表示<strong>事件</strong>，<strong>有向边</strong>表示<strong>活动</strong>，<strong>边上的权值表示该活动持续的时间</strong>，这样的图简称为AOE网。</p><p>AOE网中，<strong>最大路径长度的路径</strong>称为<strong>关键路径</strong>。<strong>完成整个工期的最短时间</strong>就是<strong>关键路径长度所代表的时间</strong>。<strong>关键路径</strong>上的<strong>活动</strong>称为<strong>关键活动</strong>。关键路径是个特殊的概念，它<strong>既代表了一个最短又代表一个最长</strong>，它是图中的<strong>最长路径</strong>，又是整个工期所完成的<strong>最短时间</strong>。</p><p>总结：AOE网是一种<strong>用结点表示事件</strong>、<strong>用边表示活动</strong>、<strong>用边的权值表示完成活动的开销</strong>（如完成活动需要的时间）的有向无环图</p><p>AOE网有以下特点：</p><ol><li>只有一个入度为0的结点，称为开始结点（源点），表示整个工程的开始</li><li>只有一个出度为0的结点，称为结束结点（汇点），表示整个工程的结束</li><li><strong>只有在某结点所代表的事件发生后，从该节点出发的各有向边所代表的活动才能开始</strong></li><li><strong>只有在指向某结点的各有向边所代表的活动全部都结束后，该节点所代表的事件才能发生</strong></li><li>AOE网中，有些活动可以并行地进行</li></ol><p>AOE网用于表示工程，为了保证工程的进度，我们需要关心：</p><ol><li>每个子项目最早和最晚完成的时间</li><li>每个子项目最早和最晚的开始时间</li></ol><p>事件最早发生时间按<strong>拓扑排序的顺序</strong>计算，最迟发生时间按<strong>逆拓扑排序的顺序</strong>计算。</p><ol><li>缩短关键活动的时间，可以缩短工程的工期</li><li>当关键活动缩短到一定的程度时，关键活动可能会变成非关键活动</li><li>如果关键活动耗时增加，整个工期将延长</li></ol><p>设事件最早发生时间符号(ve)，事件最迟发生时间(vl)，活动最早发生时间(e)，活动最迟发生时间(l)，时间余量(d)，箭头的另一端为开端，则：</p><ol><li>ve = 开端事件 + 活动消耗时间（拓扑排序的顺序）</li><li>vl = 箭头端事件 - 活动消耗时间（逆拓扑排序的顺序）</li><li>e = 活动开端的ve</li><li>l = 活动箭头端的vl - 活动消耗时间</li><li>d = l - e（d = 0为关键路径点）</li></ol><p><img src="../../image/AOE关键路径求法.png" alt="AOE关键路径求法"></p><h3 id="AOV和AOE之间的关系"><a href="#AOV和AOE之间的关系" class="headerlink" title="AOV和AOE之间的关系"></a>AOV和AOE之间的关系</h3><p>相同点：都是有向无环图</p><p>不同点：AOE网的边表示活动，边有权值，边代表活动持续时间；顶点表示事件，事件是图中新活动开始或者旧活动结束的标志。AOV网的顶点表示活动，边无权值，边代表活动之间的先后关系。</p><h1 id="二部图（二分图）"><a href="#二部图（二分图）" class="headerlink" title="二部图（二分图）"></a>二部图（二分图）</h1><blockquote><p>原链接：<a href="https://zhuanlan.zhihu.com/p/89972891">干货｜二分图详解 - 知乎 (zhihu.com)</a></p></blockquote><p>二分图又称作二部图，是图论中的一种特殊模型。顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。</p><p>如果某个图为二分图，那么它至少有两个顶点，且其所有回路的长度<strong>均为偶数</strong>，任何无回路的的图均是二分图。</p><blockquote><p>链接：<a href="https://blog.csdn.net/li13168690086/article/details/81506044"> 二分图的定义和判定<em>知行合一-CSDN博客</em>二分图的判定</a></p></blockquote><p><img src="../../image/image-20211222205129529.png" alt="二分图演示"></p><h2 id="二分图判断"><a href="#二分图判断" class="headerlink" title="二分图判断"></a>二分图判断</h2><p>对于二分图的判断方法最常见的是染色法</p><p>给一个无向图。要给图上每个顶点染色，并且使任意相邻的顶点染色不同。并且最多用两种颜色。如果可以进行二分图染色，证明是一个二分图。</p><p>对于判断是否是一个二分图的方法可以用深度优先搜索算法（DFS）和广度优先搜索算法（BFS）两种方式去实现。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的基础总结--持续更新</title>
    <link href="/my_world/content/C++%E7%9A%84%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/my_world/content/C++%E7%9A%84%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。</p><p>C++不仅拥有计算机高效运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。</p><p>笔者的第一计算机语言为java，这里大部分为java的思维来构建Linux，会<strong>重点说出C++与java不同的地方</strong>，在阅读本章节默认读者<strong>认识java或者c/c++的基础</strong>，比如说数据类型、循环、判断等</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>C/C++可以在Linux或者Windows中运行，这里推荐Linux（因为方便）</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>这里选择VScode作为IDE，默认VScode已经安装中文翻译插件，整体界面大部分为中文</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>分为服务器和虚拟机的情况，虚拟机用VMware，安装linux后直接在控制台新建xxx.cpp，然后编辑即可</p><p>服务器：</p><ol><li>用VScode连接服务器<ol><li>安装Remote-SSH，在插件中输入ssh后安装即可，安装完毕后左侧会出现一个远程资源管理器</li><li>选择SSH Targets，进入config配置文件，输入HostName和User，保存以后左侧会出现对应机器名称。</li><li>更改设置，<code>文件-&gt;首选项-&gt;设置-&gt;扩展-&gt;Remote-SSH</code>，找到Show Login Terminal并勾选。</li><li>点击SSH TARGETS下的服务器旁边的按钮纽行连接，弹出让你输入密码。在这里可能会弹出让你选择服务器的平台，需要选择以后才会出现输入密码的步骤</li><li>成功连上服务器。</li><li>以上引用<a href="https://zhuanlan.zhihu.com/p/141205262">「效率」使用VScode连接远程服务器进行开发 - 知乎 (zhihu.com)</a></li></ol></li><li>找到一个个人文件夹，在VScode中新建xxx.cpp，在VScode中编辑即可</li></ol><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>C++：</p><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">g</span>++ <span class="hljs-keyword">test</span>.cpp <span class="hljs-comment">//默认输出a.out</span><span class="hljs-keyword">g</span>++ <span class="hljs-keyword">test</span>.cpp -o <span class="hljs-keyword">test</span> <span class="hljs-comment">//指定输出文件名为test</span></code></pre></div><p>C</p><div class="code-wrapper"><pre><code class="hljs cmake">gcc <span class="hljs-keyword">test</span>.c</code></pre></div><p>查看编译结果</p><div class="code-wrapper"><pre><code class="hljs ada">./a.<span class="hljs-keyword">out</span></code></pre></div><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。下面这段程序中，包含了头文件 \<iostream\>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></code></pre></div><h1 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h1><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// int main为main方法</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;helloworld \n&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//终止 main( )函数，并向调用进程返回值 0。可加可不加</span>&#125;</code></pre></div><h1 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h1><p>下面需要在后面加入\n，若不加，打印输出的helloworld不会换行</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">&quot;helloworld \n&quot;</span>;</code></pre></div><p>也可以这样</p><div class="code-wrapper"><pre><code class="hljs C++">std::cout &lt;&lt; <span class="hljs-string">&quot;helloworld&quot;</span> &lt;&lt; std::endl;</code></pre></div><p>上面这一句等价于</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">&quot;helloworld&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</code></pre></div><p>为了简便，推荐用以下方法输出</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;helloworld&quot;</span> &lt;&lt; endl;&#125;</code></pre></div><p>可以连接，形如System.out.println(“helloworld”+i+”连接”+i+1)</p><div class="code-wrapper"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;helloworld  &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;连接&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; endl;</code></pre></div><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>似乎只有java中称方法，其他语言形如python，c/c++，javascript都叫函数</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;helloworld  &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;连接&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> i;&#125;</code></pre></div><p>调用如下</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-built_in">function</span>(<span class="hljs-number">1</span>);    cout &lt;&lt; i &lt;&lt; endl;&#125;</code></pre></div><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>可以和java一样</p><div class="code-wrapper"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;helloworld&quot;</span>;</code></pre></div><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;helloworld&quot;</span>;</code></pre></div><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>动态内存分配，指针是对内存的直接操作。指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，用户必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *i;</code></pre></div><p>int为任意类型,i为类型名称</p><h2 id="查看指针-变量在内存的位置"><a href="#查看指针-变量在内存的位置" class="headerlink" title="查看指针/变量在内存的位置"></a>查看指针/变量在内存的位置</h2><p>在指针/变量名称前加&amp;（该符号为引用，以下有说到）即可查看内存位置</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;helloworld&quot;</span>;cout &lt;&lt; &amp;str &lt;&lt; endl;输出：<span class="hljs-number">0x7fffadceda80</span>    <span class="hljs-keyword">int</span>* var = <span class="hljs-number">0</span>;cout &lt;&lt; &amp;var &lt;&lt; endl;输出：<span class="hljs-number">0x7ffe75ed7b30</span></code></pre></div><h2 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h2><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>  var = <span class="hljs-number">20</span>;   <span class="hljs-comment">// 实际变量的声明</span><span class="hljs-keyword">int</span>  *ip;        <span class="hljs-comment">// 指针变量的声明</span>ip = &amp;var;       <span class="hljs-comment">// 在指针变量中存储 var 的地址</span>cout &lt;&lt; <span class="hljs-string">&quot;var的值为: &quot;</span>;cout &lt;&lt; var &lt;&lt; endl;<span class="hljs-comment">// 输出在指针变量中存储的地址</span>cout &lt;&lt; <span class="hljs-string">&quot;ip的值为: &quot;</span>;cout &lt;&lt; ip &lt;&lt; endl;<span class="hljs-comment">// 访问指针中地址的值</span>cout &lt;&lt; <span class="hljs-string">&quot;*ip的值为: &quot;</span>;cout &lt;&lt; *ip &lt;&lt; endl;输出：var的值为: <span class="hljs-number">20</span>ip的值为: <span class="hljs-number">0x7ffd08a6b944</span>*ip的值为: <span class="hljs-number">20</span></code></pre></div><h2 id="对象中调用指针对象的方法-变量"><a href="#对象中调用指针对象的方法-变量" class="headerlink" title="对象中调用指针对象的方法/变量"></a>对象中调用指针对象的方法/变量</h2><p>在二叉树中，常常需要用到地址连接来连接左子树或者右子树的结点。在java中，我们常常用对象容器来存储下一个节点：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;        string data;        <span class="hljs-comment">// 左子树</span>        Node leftNode;        <span class="hljs-comment">// 右子树</span>        Node rightNode;&#125;</code></pre></div><p>存储时：</p><div class="code-wrapper"><pre><code class="hljs java">Node root = <span class="hljs-keyword">new</span> Node();Node node = <span class="hljs-keyword">new</span> Node();root.leftNode = node;</code></pre></div><p>调用时：</p><div class="code-wrapper"><pre><code class="hljs java">Node root = <span class="hljs-keyword">new</span> Node();System.out.println(root.leftNode.data);</code></pre></div><p>c++中不一样，它只能指定指针，并且让下一个节点的地址传输到指针中，调用时用指针和-&gt;来调用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&#123;</span>    <span class="hljs-keyword">public</span>:    string data;        <span class="hljs-comment">// 左子树</span>        Node* leftNode;        <span class="hljs-comment">// 右子树</span>        Node* rightNode;&#125;</code></pre></div><p>存储时：</p><div class="code-wrapper"><pre><code class="hljs c++">Node root;Node left_node;root.leftNode = &amp;left_node;</code></pre></div><p>调用时：</p><div class="code-wrapper"><pre><code class="hljs c++">Node root;root.leftNode -&gt; data;<span class="hljs-comment">// 方法同理</span></code></pre></div><h2 id="判断指针为空"><a href="#判断指针为空" class="headerlink" title="判断指针为空"></a>判断指针为空</h2><p>指针为：root-&gt;rightNode</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(root-&gt;rightNode)&#123;    <span class="hljs-comment">//指针不为空</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!root-&gt;rightNode)&#123;    <span class="hljs-comment">//指针为空</span>&#125;</code></pre></div><p>c++中大部分时间是使用指针</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><p>引用和指针的区别：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>声明引用变量</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">17</span>;<span class="hljs-keyword">int</span>&amp;  r = i;<span class="hljs-keyword">double</span>&amp; s = d;</code></pre></div><p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 声明简单的变量</span><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">double</span> d;<span class="hljs-comment">// 声明引用变量</span><span class="hljs-keyword">int</span>&amp; r = i;<span class="hljs-keyword">double</span>&amp; s = d;i = <span class="hljs-number">5</span>;cout &lt;&lt; <span class="hljs-string">&quot;i的值为: &quot;</span> &lt;&lt; i &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;引用i的值为: &quot;</span> &lt;&lt; r  &lt;&lt; endl;d = <span class="hljs-number">11.7</span>;cout &lt;&lt; <span class="hljs-string">&quot;d的值为: &quot;</span> &lt;&lt; d &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;引用d的值为: &quot;</span> &lt;&lt; s  &lt;&lt; endl;输出：i的值为: <span class="hljs-number">5</span>引用i的值为: <span class="hljs-number">5</span>d的值为: <span class="hljs-number">11.7</span>引用d的值为: <span class="hljs-number">11.7</span></code></pre></div><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>c++和python，java一样都是面向对象语言，那么它也会有面向对象的特性</p><h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><h3 id="针对类"><a href="#针对类" class="headerlink" title="针对类"></a>针对类</h3><p>类前加注释，写明作者，用途，时间</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @作者: xxxx</span><span class="hljs-comment"> * @时间: xxxx</span><span class="hljs-comment"> * @用途: xxxx</span><span class="hljs-comment"> **/</span></code></pre></div><p>英语版</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @author: xxxx</span><span class="hljs-comment"> * @time: xxxx</span><span class="hljs-comment"> * @use: xxxx</span><span class="hljs-comment"> **/</span></code></pre></div><p>python英语版</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;  </span><span class="hljs-string">@author: xxxx</span><span class="hljs-string">@time: xxxx</span><span class="hljs-string">@use: xxxx</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div><h3 id="针对方法"><a href="#针对方法" class="headerlink" title="针对方法"></a>针对方法</h3><p>方法前加注释，写明用途、输入参数以及返回参数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @用途: xxxx</span><span class="hljs-comment"> * @参数: xxxx</span><span class="hljs-comment"> * @返回: xxxx</span><span class="hljs-comment"> **/</span></code></pre></div><p>英语版</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @use: xxxx</span><span class="hljs-comment"> * @parameter: xxxx</span><span class="hljs-comment"> * @return: xxxx</span><span class="hljs-comment"> **/</span></code></pre></div><p>python英语版</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;  </span><span class="hljs-string">@use: xxxx</span><span class="hljs-string">@parameter: xxxx</span><span class="hljs-string">@return: xxxx</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div><h3 id="针对有实际用途的行代码"><a href="#针对有实际用途的行代码" class="headerlink" title="针对有实际用途的行代码"></a>针对有实际用途的行代码</h3><p>代码前添加注释，写明代码用途，//后加一个空格</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 输出hello world</span>cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;</code></pre></div><h3 id="构造函数初始化类变量"><a href="#构造函数初始化类变量" class="headerlink" title="构造函数初始化类变量"></a>构造函数初始化类变量</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> data;    <span class="hljs-comment">// 左子树</span>    Node* leftNode;    <span class="hljs-comment">// 右子树</span>    Node* rightNode;    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> data)&#123;        data = data;        leftNode = <span class="hljs-literal">NULL</span>;        rightNode = <span class="hljs-literal">NULL</span>;    &#125;&#125;</code></pre></div><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>class定义，但是公开私有的方法和java不一样，虽然都是用private、public、protected。类的大括号收尾要跟分号。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">box</span>&#123;</span>    <span class="hljs-keyword">private</span>:        <span class="hljs-keyword">double</span> length;   <span class="hljs-comment">// 盒子的长度</span>    <span class="hljs-keyword">protected</span>:        <span class="hljs-keyword">double</span> height;   <span class="hljs-comment">// 盒子的高度</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">double</span> breadth = <span class="hljs-number">12.5</span>;  <span class="hljs-comment">// 盒子的宽度，注意编译的时候加-std=c++11，以上为c++11的特性</span>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span></span>&#123;            <span class="hljs-keyword">this</span>-&gt;length = length; <span class="hljs-comment">// this指针用 -&gt;</span>        &#125;        <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;length;        &#125;&#125;;</code></pre></div><p>初始化对象</p><div class="code-wrapper"><pre><code class="hljs c++">box box1;</code></pre></div><p>访问类方法</p><div class="code-wrapper"><pre><code class="hljs c++">box1.<span class="hljs-built_in">getLength</span>()</code></pre></div><p>访问类变量</p><div class="code-wrapper"><pre><code class="hljs c++">box1.breadth</code></pre></div><p>若为静态的类变量，在变量前加static</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> stabreadth;<span class="hljs-comment">// 盒子的宽度</span></code></pre></div><p>初始化静态类变量需要在类的外部执行</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> box::stabreadth = <span class="hljs-number">12.5</span>;</code></pre></div><p>访问和普通的类变量一样</p><div class="code-wrapper"><pre><code class="hljs c++">box1.stabreadth</code></pre></div><p>用类访问的变量是类变量</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>java只能继承1个类，c++能继承多个</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 基类 Shape</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span><span class="hljs-class">&#123;</span>   <span class="hljs-keyword">public</span>:      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span><span class="hljs-function">      </span>&#123;         width = w;      &#125;      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span></span><span class="hljs-function">      </span>&#123;         height = h;      &#125;   <span class="hljs-keyword">protected</span>:      <span class="hljs-keyword">int</span> width;      <span class="hljs-keyword">int</span> height;&#125;; <span class="hljs-comment">// 基类 PaintCost</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaintCost</span> </span><span class="hljs-class">&#123;</span>   <span class="hljs-keyword">public</span>:      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span> area)</span></span><span class="hljs-function">      </span>&#123;         <span class="hljs-keyword">return</span> area * <span class="hljs-number">70</span>;      &#125;&#125;; <span class="hljs-comment">// 派生类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span> <span class="hljs-keyword">public</span> Shape, <span class="hljs-keyword">public</span> PaintCost&#123;   <span class="hljs-keyword">public</span>:      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span><span class="hljs-function">      </span>&#123;          <span class="hljs-keyword">return</span> (width * height);       &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;   Rectangle Rect;   <span class="hljs-keyword">int</span> area;    Rect.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">5</span>);   Rect.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">7</span>);    area = Rect.<span class="hljs-built_in">getArea</span>();      <span class="hljs-comment">// 输出对象的面积</span>   cout &lt;&lt; <span class="hljs-string">&quot;面积为: &quot;</span> &lt;&lt; Rect.<span class="hljs-built_in">getArea</span>() &lt;&lt; endl;    <span class="hljs-comment">// 输出总花费</span>   cout &lt;&lt; <span class="hljs-string">&quot;花费: $&quot;</span> &lt;&lt; Rect.<span class="hljs-built_in">getCost</span>(area) &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Logging的极速入门</title>
    <link href="/my_world/content/Logging%E7%9A%84%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/my_world/content/Logging%E7%9A%84%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：</p><ol><li>可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；</li><li>print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出；</li></ol><blockquote><p>引用<a href="https://www.cnblogs.com/dahu-daqing/p/7040764.html">python logging模块 - dahu1 - 博客园 (cnblogs.com)</a></p></blockquote><h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging</code></pre></div><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>输出级别（优先度从低到高）为：debug =&gt; info =&gt; warning =&gt; error =&gt; critical</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打印调试信息</span>logging.debug(word)</code></pre></div><h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打印正常的信息</span>logging.info(word)</code></pre></div><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打印警告信息</span>logging.warning(word)</code></pre></div><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> traceback<span class="hljs-comment"># 打印错误信息</span>logging.error(word)<span class="hljs-comment"># 获取错误信息，在try,except使用最佳</span>logging.error(traceback.format_exc())</code></pre></div><h2 id="Critical"><a href="#Critical" class="headerlink" title="Critical"></a>Critical</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打印致命错误信息</span>logging.critical(word)</code></pre></div><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>调用basicConfig，传入参数即可，如：</p><div class="code-wrapper"><pre><code class="hljs python">logging.basicConfig(level=logging.DEBUG,<span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,datefmt=<span class="hljs-string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,filename=<span class="hljs-string">&#x27;logger.log&#x27;</span>)</code></pre></div><p>参数细节如下：</p><ul><li>filename：指定输出日志的文件名</li><li>filemode：和file函数意义相同，指定日志文件的打开模式，’w’或者’a’，不传默认为a。’w’的时候，日志会覆盖书写，’a’是保留前面的日志，并将新的日志存放到文件里面</li><li>format：指定输出的格式和内容<ul><li>参数：作用</li><li>%(levelno)s：打印日志级别的数值</li><li>%(levelname)s：打印日志级别的名称</li><li>%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]</li><li>%(filename)s：打印当前执行程序名</li><li>%(funcName)s：打印日志的当前函数</li><li>%(lineno)d：打印日志的当前行号</li><li>%(asctime)s：打印日志的时间</li><li>%(thread)d：打印线程ID</li><li>%(threadName)s：打印线程名称</li><li>%(process)d：打印进程ID</li><li>%(message)s：打印日志信息</li></ul></li><li>datefmt：指定时间格式，同time.strftime()</li><li>level：设置日志级别，默认为logging.WARNNING</li><li>stream：指定将日志的输出流，可以指定输出到sys.stderr，sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略</li></ul><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>可以将logging封装成一个类，然后调用类的方法即可，详细如下，可直接复制</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=UTF-8 -*-</span><span class="hljs-keyword">import</span> logging<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> datetime<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingProxy</span>:</span>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">    日志代理类</span><span class="hljs-string"></span><span class="hljs-string">@author: xxxxxxxx</span><span class="hljs-string">    @time: xxxxxxxxxx</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        today = datetime.date.today()        year = today.year        month = today.month        <span class="hljs-comment"># 检测Log文件是否存在，不存在则创建</span>        path = <span class="hljs-string">&quot;./src/log/&quot;</span>+<span class="hljs-built_in">str</span>(year)+<span class="hljs-string">&quot;/&quot;</span>+<span class="hljs-built_in">str</span>(month)+<span class="hljs-string">&quot;月&quot;</span>+<span class="hljs-string">&quot;/&quot;</span>        filename = <span class="hljs-built_in">str</span>(today)+<span class="hljs-string">&quot;.log&quot;</span>        <span class="hljs-comment"># 文件夹路径不存在则创建</span>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> os.path.exists(path)):            os.makedirs(path)        <span class="hljs-comment"># 文件不存在则创建</span>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> os.path.exists(path+filename)):            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path+filename,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>) <span class="hljs-keyword">as</span> f:                f.close()        logging.basicConfig(level=logging.INFO,                            <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,                            datefmt=<span class="hljs-string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,                            filename=path+filename) <span class="hljs-comment"># logging的基础配置</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">self, word</span>):</span>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        打印调试信息</span><span class="hljs-string"></span><span class="hljs-string">        :param word: 调试信息</span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        logging.debug(word)        <span class="hljs-built_in">print</span>(word)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info</span>(<span class="hljs-params">self, word</span>):</span>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        打印正常的信息</span><span class="hljs-string"></span><span class="hljs-string">        :param word: 正常的信息</span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        logging.info(word)        <span class="hljs-built_in">print</span>(word)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span>(<span class="hljs-params">self, word , Exception</span>):</span>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        打印错误信息</span><span class="hljs-string"></span><span class="hljs-string">        :param word: 错误信息</span><span class="hljs-string">        :param Exception: expect中的Exception</span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        logging.error(word)        logging.error(Exception)        <span class="hljs-built_in">print</span>(word)        <span class="hljs-built_in">print</span>(Excetion)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">warning</span>(<span class="hljs-params">self, word</span>):</span>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        打印警告信息</span><span class="hljs-string"></span><span class="hljs-string">        :param word: 警告信息</span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        logging.warning(word)        <span class="hljs-built_in">print</span>(word)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">critical</span>(<span class="hljs-params">self, word , Exception</span>):</span>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        打印致命错误信息</span><span class="hljs-string"></span><span class="hljs-string">        :param word: 致命错误信息</span><span class="hljs-string">        :param Exception: expect中的Exception</span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        logging.critical(word)        logging.critical(Exception)        <span class="hljs-built_in">print</span>(word)        <span class="hljs-built_in">print</span>(Exception)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        开始</span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        logging.info(<span class="hljs-string">&quot;======= start =======&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">end</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        结尾</span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        logging.info(<span class="hljs-string">&quot;======= end =======&quot;</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>log4J的极速入门</title>
    <link href="/my_world/content/log4J%E7%9A%84%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/my_world/content/log4J%E7%9A%84%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog、守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>maven中加入：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="构建配置文件"><a href="#构建配置文件" class="headerlink" title="构建配置文件"></a>构建配置文件</h1><p>在Resources/src文件夹下建立log4j.properties，该文件中的配置如下</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">### 设置###</span><span class="hljs-meta">log4j.rootLogger</span> = <span class="hljs-string">debug,stdout,D,E</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出信息到控制抬 ###</span><span class="hljs-meta">log4j.appender.stdout</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.stdout.Target</span> = <span class="hljs-string">System.out</span><span class="hljs-meta">log4j.appender.stdout.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span> = <span class="hljs-string">[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><span class="hljs-meta">log4j.appender.D</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-comment">#log4j.appender.D.File = E://logs/log.log</span><span class="hljs-meta">log4j.appender.D.Append</span> = <span class="hljs-string">true</span><span class="hljs-meta">log4j.appender.D.Threshold</span> = <span class="hljs-string">DEBUG </span><span class="hljs-meta">log4j.appender.D.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.D.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><span class="hljs-meta">log4j.appender.E</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-comment">#log4j.appender.E.File =E://logs/error.log</span><span class="hljs-meta">log4j.appender.E.Append</span> = <span class="hljs-string">true</span><span class="hljs-meta">log4j.appender.E.Threshold</span> = <span class="hljs-string">ERROR </span><span class="hljs-meta">log4j.appender.E.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.E.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span></code></pre></div><h1 id="设置日志内容"><a href="#设置日志内容" class="headerlink" title="设置日志内容"></a>设置日志内容</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.log4j;<span class="hljs-keyword">import</span> org.apache.log4j.Logger;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log4jTest001</span> </span>&#123;  <span class="hljs-comment">// 得到记录器并读取配置文件 -- 基于类的名称获取日志对象</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = Logger.getLogger(Log4jTest001.class);      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 插入记录信息（格式化日志信息）</span>    <span class="hljs-comment">// 记录debug级别的信息</span>    logger.debug(<span class="hljs-string">&quot;调试info&quot;</span>);    <span class="hljs-comment">// 记录info级别的信息</span>    logger.info(<span class="hljs-string">&quot;输出info&quot;</span>);    <span class="hljs-comment">// 记录error级别的信息</span>    logger.error(<span class="hljs-string">&quot;错误info&quot;</span>);    <span class="hljs-comment">// 记录warn级别的信息</span>    logger.warn(<span class="hljs-string">&quot;警告info&quot;</span>);    logger.trace(<span class="hljs-string">&quot;跟踪info&quot;</span>);    logger.fatal(<span class="hljs-string">&quot;致命info&quot;</span>);  &#125;&#125;</code></pre></div><p>在运行该代码后，会保存好相应的日志文件，若想改变日志文件的保存位置，修改properties配置文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>log4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python爬虫大总结</title>
    <link href="/my_world/content/python%E7%88%AC%E8%99%AB%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <url>/my_world/content/python%E7%88%AC%E8%99%AB%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</p><h1 id="Requests和Beautifulsoup4"><a href="#Requests和Beautifulsoup4" class="headerlink" title="Requests和Beautifulsoup4"></a>Requests和Beautifulsoup4</h1><p>requests：其库中的 get() 方法能向服务器发送了一个请求，请求类型为 HTTP 协议的 GET 方式；post() 方法，也能向服务器发送一个请求，请求类型是 HTTP 协议的 POST 方式，可根据访问的网页而定。</p><p>beautifulsoup4：Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install requests  (python<span class="hljs-number">3</span>自带)<span class="hljs-attribute">pip</span> install beautifulsoup<span class="hljs-number">4</span></code></pre></div><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests; <span class="hljs-comment"># requests</span><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup; <span class="hljs-comment"># beautifulsoup4</span></code></pre></div><h2 id="request的各种请求方式"><a href="#request的各种请求方式" class="headerlink" title="request的各种请求方式"></a>request的各种请求方式</h2><div class="code-wrapper"><pre><code class="hljs python">requests.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>)requests.put(<span class="hljs-string">&#x27;http://httpbin.org/put&#x27;</span>)requests.delete(<span class="hljs-string">&#x27;http://httpbin.org/delete&#x27;</span>)requests.head(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)requests.options(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)</code></pre></div><p>请求的含义如下：</p><p><strong>GET： 请求指定的页面信息，并返回实体主体。</strong></p><p><strong>HEAD： 只请求页面的首部。</strong></p><p><strong>POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。</strong></p><p><strong>PUT： 从客户端向服务器传送的数据取代指定的文档的内容。</strong></p><p><strong>DELETE： 请求服务器删除指定的页面。</strong></p><p>get 和 post比较常见 GET请求将提交的数据放置在HTTP请求协议头中；POST提交的数据则放在实体数据中</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>    self.target = <span class="hljs-string">&quot;https://www.xxxx.cn&quot;</span>;    self.name = [];<span class="hljs-comment"># 卡片名称</span>    self.level = [];<span class="hljs-comment"># 星阶</span>    self.ATK = [];<span class="hljs-comment"># 攻击力</span>    self.DEF = [];<span class="hljs-comment"># 防御力</span>    self.race = [];<span class="hljs-comment"># 种族</span>    self.attribute = [];<span class="hljs-comment"># 属性</span>    self.<span class="hljs-built_in">type</span> = [];<span class="hljs-comment"># 类型</span>    self.desc = [];<span class="hljs-comment"># 效果</span>    self.imgurl = [];<span class="hljs-comment"># 图片URL</span></code></pre></div><h3 id="获取html"><a href="#获取html" class="headerlink" title="获取html"></a>获取html</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">## 获取HTML</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHTML</span>(<span class="hljs-params">self,page</span>):</span>    html = requests.get(self.target+page);    html.encoding=<span class="hljs-string">&quot;utf-8&quot;</span>;    <span class="hljs-keyword">return</span> html;</code></pre></div><p>这里转换html的编码，防止出现乱码错误</p><h3 id="beautifulsoup4解析html数据"><a href="#beautifulsoup4解析html数据" class="headerlink" title="beautifulsoup4解析html数据"></a>beautifulsoup4解析html数据</h3><p>流程如下：</p><ol><li>调用beautifulsoup解析requests获取的html数据。<code>htmlbody = BeautifulSoup(html.text,features=&quot;html.parser&quot;);</code>,features=”html.parser”是告诉beautifulsoup解析的是html数据，不然整个控制台全是一些警告信息</li><li>利用find<em>all找出html标签。两种方式，第一种是直接搜索盒子 <code>cardList = htmlbody.find_all(&quot;script&quot;);</code>,第二种是通过盒子的class查找`div_bf.find_all(‘div’, class</em> = ‘listmain’)`。注意它们返回的值为数组</li><li>找到合适的，写入数据，可以利用json.loads将json字符串转化成json，处理更加轻松。</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">## 获取怪兽卡片</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMonster</span>(<span class="hljs-params">self,page</span>):</span>        html = self.getHTML(page);        htmlbody = BeautifulSoup(html.text);        cardList = htmlbody.find_all(<span class="hljs-string">&quot;script&quot;</span>);        cardScript = cardList[<span class="hljs-number">2</span>].string;        bracesIndex = cardScript.index(<span class="hljs-string">&quot;[&quot;</span>);        <span class="hljs-comment">## 处理json string，变成python对象(看着像二维数组)</span>        cardJSON = json.loads(cardScript[bracesIndex:].split(<span class="hljs-string">&quot;,\&quot;meta&quot;</span>)[<span class="hljs-number">0</span>]);        i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>):            <span class="hljs-comment">## 获取卡片属性</span>            name = cardJSON[i][<span class="hljs-string">&quot;name&quot;</span>];            level = cardJSON[i][<span class="hljs-string">&quot;level&quot;</span>];            atk = cardJSON[i][<span class="hljs-string">&quot;atk&quot;</span>];            def_ = cardJSON[i][<span class="hljs-string">&quot;def&quot;</span>];            race = cardJSON[i][<span class="hljs-string">&quot;race&quot;</span>];            attribute = cardJSON[i][<span class="hljs-string">&quot;attribute&quot;</span>];            <span class="hljs-built_in">type</span> = cardJSON[i][<span class="hljs-string">&quot;type_st&quot;</span>];            desc = cardJSON[i][<span class="hljs-string">&quot;desc&quot;</span>];            imgurl = cardJSON[i][<span class="hljs-string">&quot;img_url&quot;</span>];            <span class="hljs-comment">## 存储</span>            self.name.append(name)            self.level.append(level)            self.ATK.append(atk)            self.DEF.append(def_)            self.race.append(race)            self.attribute.append(attribute)            self.<span class="hljs-built_in">type</span>.append(<span class="hljs-built_in">type</span>)            self.desc.append(desc)            self.imgurl.append(imgurl)            i = i+<span class="hljs-number">1</span>;</code></pre></div><h2 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h2><p>爬虫后的数据可通过数据库保存，可以保存到表格或者word文档中</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests,time,json,sys;<span class="hljs-keyword">import</span> xlwings;<span class="hljs-comment"># excel操作</span><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup;<span class="hljs-comment">## 爬取YGO网页的所有怪兽卡</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectYGOcard</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.target = <span class="hljs-string">&quot;https://www.xxxx.cn/&quot;</span>;        <span class="hljs-comment"># self.target = &quot;https://www.xxxx.cn/&quot;;</span>        self.name = [];<span class="hljs-comment"># 卡片名称</span>        self.level = [];<span class="hljs-comment"># 星阶</span>        self.ATK = [];<span class="hljs-comment"># 攻击力</span>        self.DEF = [];<span class="hljs-comment"># 防御力</span>        self.race = [];<span class="hljs-comment"># 种族</span>        self.attribute = [];<span class="hljs-comment"># 属性</span>        self.<span class="hljs-built_in">type</span> = [];<span class="hljs-comment"># 类型</span>        self.desc = [];<span class="hljs-comment"># 效果</span>        self.imgurl = [];<span class="hljs-comment"># 图片URL</span>        <span class="hljs-comment">## 清除list</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clearList</span>(<span class="hljs-params">self</span>):</span>        self.name.clear;<span class="hljs-comment"># 卡片名称</span>        self.level.clear;<span class="hljs-comment"># 星阶</span>        self.ATK.clear;<span class="hljs-comment"># 攻击力</span>        self.DEF.clear;<span class="hljs-comment"># 防御力</span>        self.race.clear;<span class="hljs-comment"># 种族</span>        self.attribute.clear;<span class="hljs-comment"># 属性</span>        self.<span class="hljs-built_in">type</span>.clear;<span class="hljs-comment"># 类型</span>        self.desc.clear;<span class="hljs-comment"># 效果</span>        self.imgurl.clear;<span class="hljs-comment"># 图片URL</span>    <span class="hljs-comment">## 获取HTML</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHTML</span>(<span class="hljs-params">self,page</span>):</span>        html = requests.get(self.target+page);        html.encoding=<span class="hljs-string">&quot;utf-8&quot;</span>;        <span class="hljs-keyword">return</span> html;        <span class="hljs-comment">## 获取怪兽卡片</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMonster</span>(<span class="hljs-params">self,page</span>):</span>        html = self.getHTML(page);        htmlbody = BeautifulSoup(html.text);        cardList = htmlbody.find_all(<span class="hljs-string">&quot;script&quot;</span>);        cardScript = cardList[<span class="hljs-number">2</span>].string;        bracesIndex = cardScript.index(<span class="hljs-string">&quot;[&quot;</span>);        <span class="hljs-comment">## 处理json string，变成python对象(看着像二维数组)</span>        cardJSON = json.loads(cardScript[bracesIndex:].split(<span class="hljs-string">&quot;,\&quot;meta&quot;</span>)[<span class="hljs-number">0</span>]);        i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>):            <span class="hljs-comment">## 获取卡片属性</span>            name = cardJSON[i][<span class="hljs-string">&quot;name&quot;</span>];            level = cardJSON[i][<span class="hljs-string">&quot;level&quot;</span>];            atk = cardJSON[i][<span class="hljs-string">&quot;atk&quot;</span>];            def_ = cardJSON[i][<span class="hljs-string">&quot;def&quot;</span>];            race = cardJSON[i][<span class="hljs-string">&quot;race&quot;</span>];            attribute = cardJSON[i][<span class="hljs-string">&quot;attribute&quot;</span>];            <span class="hljs-built_in">type</span> = cardJSON[i][<span class="hljs-string">&quot;type_st&quot;</span>];            desc = cardJSON[i][<span class="hljs-string">&quot;desc&quot;</span>];            imgurl = cardJSON[i][<span class="hljs-string">&quot;img_url&quot;</span>];            <span class="hljs-comment">## 存储</span>            self.name.append(name)            self.level.append(level)            self.ATK.append(atk)            self.DEF.append(def_)            self.race.append(race)            self.attribute.append(attribute)            self.<span class="hljs-built_in">type</span>.append(<span class="hljs-built_in">type</span>)            self.desc.append(desc)            self.imgurl.append(imgurl)            i = i+<span class="hljs-number">1</span>;    <span class="hljs-comment">## 将数据保存到表格</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveTOExcel</span>(<span class="hljs-params">self</span>):</span>        wingsAPP = xlwings.App(visible=<span class="hljs-literal">False</span>,add_book=<span class="hljs-literal">False</span>);        excel = wingsAPP.books.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;YGO.xlsx&quot;</span>);        sheet = excel.sheets[<span class="hljs-string">&quot;怪兽&quot;</span>];<span class="hljs-comment"># 初始化sheet</span>        i = <span class="hljs-number">0</span>;        page = <span class="hljs-number">2</span>;<span class="hljs-comment"># 想要爬多少页就写多少数字</span>        pager = <span class="hljs-number">1</span>;<span class="hljs-comment"># 从第几页开始爬</span>        row = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(pager &lt; page+<span class="hljs-number">1</span>):            self.getMonster(<span class="hljs-built_in">str</span>(pager))            <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>):                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.name[row]<span class="hljs-comment"># 保存卡片名字数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;B&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.level[row]<span class="hljs-comment"># 保存星阶数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;C&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.ATK[row]<span class="hljs-comment"># 保存攻击力数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;D&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.DEF[row]<span class="hljs-comment"># 保存防御力数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;E&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.race[row]<span class="hljs-comment"># 保存种族数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;F&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.attribute[row]<span class="hljs-comment"># 保存属性数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;G&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.<span class="hljs-built_in">type</span>[row]<span class="hljs-comment"># 保存类型数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;H&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.desc[row]<span class="hljs-comment"># 保存效果数据</span>                sheet.<span class="hljs-built_in">range</span>(<span class="hljs-string">&#x27;I&#x27;</span>+<span class="hljs-built_in">str</span>(row+<span class="hljs-number">3</span>)).value = self.imgurl[row]<span class="hljs-comment"># 保存图片URL数据</span>                sys.stdout.write(<span class="hljs-string">&quot;\n录入了&quot;</span>+ <span class="hljs-built_in">str</span>(row+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;张卡片&quot;</span>);                sys.stdout.flush();                time.sleep(<span class="hljs-number">1</span>)                i = i+<span class="hljs-number">1</span>;                row = row+<span class="hljs-number">1</span>;            pager = pager+<span class="hljs-number">1</span>;            i = <span class="hljs-number">0</span>;<span class="hljs-comment"># 归0，对程序没有任何影响</span>        excel.save();<span class="hljs-comment"># 保存表格</span>        excel.close();        wingsAPP.quit();        self.clearList();    <span class="hljs-comment">## 保存卡牌图片，网站图片错误，有大量图片获取失败</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downloadImg</span>(<span class="hljs-params">self</span>):</span>        headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36&#x27;</span>&#125;        i = <span class="hljs-number">0</span>;        number = <span class="hljs-number">1</span>;<span class="hljs-comment"># 展示，对程序无影响</span>        page = <span class="hljs-number">10</span>;<span class="hljs-comment"># 想要爬多少页就写多少数字</span>        pager = <span class="hljs-number">1</span>;<span class="hljs-comment"># 从第几页开始爬</span>        <span class="hljs-keyword">while</span>(pager &lt; page+<span class="hljs-number">1</span>):            self.getMonster(<span class="hljs-built_in">str</span>(pager))            <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-built_in">len</span>(self.imgurl)):                imgUrl = requests.get(self.imgurl[i]);<span class="hljs-comment"># 请求图片的url</span>                name = self.name[i]                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;monsterImg/&quot;</span>+name+<span class="hljs-string">&quot;.png&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:                    f.write(imgUrl.content);<span class="hljs-comment"># 将请求内容写入到文件中</span>                    f.flush();                    time.sleep(<span class="hljs-number">2</span>)                sys.stdout.write(<span class="hljs-string">&quot;\n保存了&quot;</span>+ <span class="hljs-built_in">str</span>(number) + <span class="hljs-string">&quot;张卡片图&quot;</span>);                sys.stdout.flush();                i = i+<span class="hljs-number">1</span>;                number = number+<span class="hljs-number">1</span>;            pager = pager+<span class="hljs-number">1</span>;            i = <span class="hljs-number">0</span>;<span class="hljs-comment"># 归0，对程序没有任何影响</span>            self.imgurl.clear;<span class="hljs-comment"># 清除list，让循环正常</span>            self.name.clear;<span class="hljs-comment"># 清除list，让循环正常</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    YGO = CollectYGOcard();    YGO.saveTOExcel();</code></pre></div><h1 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h1><p>Scrapy是适用于Python的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。</p><p>Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。</p><h2 id="scrapy基本结构"><a href="#scrapy基本结构" class="headerlink" title="scrapy基本结构"></a>scrapy基本结构</h2><p>Scrapy框架主要由五大组件组成，它们分别是调度器(Scheduler)、下载器(Downloader)、爬虫（Spider）和实体管道(Item Pipeline)、Scrapy引擎(Scrapy Engine)。</p><ul><li><strong>调度器(Scheduler):</strong><ul><li>把它假设成为一个URL（抓取网页的网址或者说是链接）的优先队列，由它来决定下一个要抓取的网址是 什么，同时去除重复的网址（不做无用功）。<strong>用户可以自己的需求定制调度器</strong>。</li></ul></li><li><strong>下载器(Downloader):</strong><ul><li>它是所有组件中负担最大的，它用于高速地下载网络上的资源。Scrapy的下载器代码不会太复杂，但效率高，主要的原因是<strong>Scrapy下载器是建立在twisted这个高效的异步模型上的</strong>(其实整个框架都在建立在这个模型上的)。</li></ul></li><li><strong>爬虫（Spider）:</strong><ul><li>它是用户最关心的部份。<strong>用户定制自己的爬虫(通过定制正则表达式等语法)，用于从特定的网页中提取自己需要的信息</strong>，即所谓的实体(Item)。 用户也可以从中提取出链接,让Scrapy继续抓取下一个页面。<strong>类似于springboot中的controller。</strong></li></ul></li><li><strong>实体管道(Item Pipeline):</strong><ul><li>实体管道，用于处理爬虫(spider)提取的实体。主要的功能是<strong>持久化实体、验证实体的有效性、清除不需要的信息</strong>。类似于java中的orm，是操作数据库的。<strong>Item类似于java中的实体对象，Pipeline更像数据库中的业务操作。</strong></li></ul></li><li><strong>Scrapy引擎(Scrapy Engine):</strong><ul><li>Scrapy引擎是整个框架的核心.它用来控制调试器、下载器、爬虫。实际上，引擎相当于计算机的CPU,它控制着整个流程。</li></ul></li></ul><h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><p><img src="../../image/image-20210904103045606.png" alt="整体架构图示"></p><h2 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h2><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">/</td><td style="text-align:center">从根节点选取，使用绝对路径，路径必须完全匹配</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">从整个文档中选取，使用相对路径</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">从当前节点开始选取</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">从当前节点父节点开始选取</td></tr><tr><td style="text-align:center">@</td><td style="text-align:center">选取属性</td></tr><tr><td style="text-align:center">text()</td><td style="text-align:center">获取文本</td></tr></tbody></table></div><p><strong>案例</strong></p><blockquote><p>引用<a href="https://blog.csdn.net/weixin_43430036/article/details/84836516">(7条消息) Scrapy爬虫：XPath语法_灵动的艺术的博客-CSDN博客_scrapy xpath语法</a></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">路径表达式</th><th style="text-align:center"><strong>结果</strong></th></tr></thead><tbody><tr><td style="text-align:center">body</td><td style="text-align:center">选取 body 元素的所有子节点。</td></tr><tr><td style="text-align:center">/head</td><td style="text-align:center">选取根元素下head。假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td style="text-align:center">div/a</td><td style="text-align:center">选取属于 div 的子元素的所有 a 元素。</td></tr><tr><td style="text-align:center">//a</td><td style="text-align:center">选取所有 a 子元素，而不管它们在文档中的位置。</td></tr><tr><td style="text-align:center">div//a</td><td style="text-align:center">选择属于 div 元素的后代的所有 a 元素，而不管它们位于 bookstore 之下的什么位置。</td></tr><tr><td style="text-align:center">//@class</td><td style="text-align:center">选取名为 class 的所有属性。</td></tr><tr><td style="text-align:center">./a</td><td style="text-align:center">选取当前元素下的a</td></tr><tr><td style="text-align:center">…/a</td><td style="text-align:center">选取父元素下的a</td></tr><tr><td style="text-align:center">a/@href</td><td style="text-align:center">选取a标签的href属性</td></tr><tr><td style="text-align:center">a/text()</td><td style="text-align:center">选取a标签下的文本</td></tr></tbody></table></div><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs python">pip install scrapy</code></pre></div><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>创建scrapy项目</strong></p><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">scrapy</span> <span class="hljs-variable">startproject</span> <span class="hljs-function"><span class="hljs-title">baidu</span>(项目名)</span></code></pre></div><p>目录大致如下：</p><p><img src="../../image/image-20210904103313805.png" alt="文件目录"></p><p>目录的解释为：</p><ul><li>scrapy.cfg：项目的配置文件</li><li>baidu/：该项目的python模块。之后在这个地方加代码</li><li>baidu/items.py：项目中的item文件</li><li>baidu/pipelines.py：项目中的pipelines文件</li><li>baidu/settings.py：项目中的设置文件</li><li>baidu/spiders/：放置spider代码的目录</li></ul><p><strong>生成爬虫</strong></p><div class="code-wrapper"><pre><code class="hljs awk">cd baidu<span class="hljs-regexp">/spiders/</span>(项目名<span class="hljs-regexp">/spiders/</span>)scrapy genspider baidu(爬虫名) www.baidu.com(域名)</code></pre></div><p><strong>启动爬虫</strong></p><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">cd</span> <span class="hljs-function"><span class="hljs-title">baidu</span>(<span class="hljs-variable">scrapy.cfg</span>的项目所在地)</span><span class="hljs-variable">scrapy</span> <span class="hljs-variable">crawl</span> <span class="hljs-function"><span class="hljs-title">baidu</span>(爬虫名）</span></code></pre></div><h2 id="制作-Scrapy-爬虫的步骤"><a href="#制作-Scrapy-爬虫的步骤" class="headerlink" title="制作 Scrapy 爬虫的步骤"></a>制作 Scrapy 爬虫的步骤</h2><blockquote><p>引用<a href="https://www.runoob.com/w3cnote/scrapy-detail.html">Scrapy 入门教程 | 菜鸟教程 (runoob.com)</a></p></blockquote><ol><li>新建项目 (scrapy startproject xxx)：新建一个新的爬虫项目</li><li>明确目标 （编写items.py）：明确你想要抓取的目标</li><li>制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页</li><li>存储内容 （pipelines.py）：设计管道存储爬取内容</li></ol><h2 id="超简单入门小案例"><a href="#超简单入门小案例" class="headerlink" title="超简单入门小案例"></a>超简单入门小案例</h2><blockquote><p>引用<a href="https://www.runoob.com/w3cnote/scrapy-detail.html">Scrapy 入门教程 | 菜鸟教程 (runoob.com)</a></p></blockquote><p>以下案例为介绍最简单的流程</p><p><strong>新建项目</strong></p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">scrapy startproject mySpider</span></code></pre></div><p><strong>明确目标，编写items.py</strong></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItcastItem</span>(<span class="hljs-params">scrapy.Item</span>):</span>    name = scrapy.Field()    title = scrapy.Field()    info = scrapy.Field()</code></pre></div><p><strong>制作爬虫</strong></p><p>首先新建爬虫文件</p><div class="code-wrapper"><pre><code class="hljs awk">cd .<span class="hljs-regexp">/mySpider/</span>spidersscrapy genspider itcast <span class="hljs-string">&quot;itcast.cn&quot;</span></code></pre></div><p>打开 mySpider/spider目录里的 itcast.py，修改start_urls属性以及parse()方法</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItcastSpider</span>(<span class="hljs-params">scrapy.Spider</span>):</span>    name = <span class="hljs-string">&#x27;itcast&#x27;</span>    allowed_domains = [<span class="hljs-string">&#x27;itcast.cn&#x27;</span>]    start_urls = [<span class="hljs-string">&quot;http://www.itcast.cn/channel/teacher.shtml&quot;</span>]<span class="hljs-comment"># 要爬的url</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span>        <span class="hljs-comment"># 获取网站标题</span>        context = response.xpath(<span class="hljs-string">&#x27;/html/head/title/text()&#x27;</span>)        <span class="hljs-comment"># 提取网站标题</span>        title = context.get()        <span class="hljs-built_in">print</span>(title)</code></pre></div><p><strong>运行爬虫</strong></p><p>命令行模式：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mySpiderscrapy crawl itcast</code></pre></div><p>脚本模式：</p><p>新建mian.py，加入如下代码</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> cmdlinecmdline.execute(<span class="hljs-string">&quot;scrapy crawl itcast&quot;</span>.split())</code></pre></div><p>运行代码即可</p><h2 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h2><p>四个方法：<strong>get() 、getall() 、extract() 、extract_first()</strong></p><ul><li>get() ：获取头一个数据，没有的时候返回None</li><li>getall() ：获取所有的数据，没有的时候返回None</li><li>extract()  ：获取所有的数据，没有的时候抛出一个错误</li><li>extract_first()：获取头一个数据，没有的时候抛出一个错误</li></ul><p><strong>get() 、getall() 是新版本的方法，extract() 、extract_first()是旧版本的方法。</strong></p><div class="code-wrapper"><pre><code class="hljs python">titleXPATH = response.xpath(<span class="hljs-string">&#x27;//*[@class=&quot;card-item&quot;]/h3/a/text()&#x27;</span>) <span class="hljs-comment"># 通过text()寻找文字</span>titles = titleXPATH.getall() <span class="hljs-comment"># 获取所有的信息，返回一个list</span>titles = titleXPATH.get() <span class="hljs-comment"># 获取一个信息，返回一个str</span>titles = titleXPATH.extract() <span class="hljs-comment"># 获取所有的信息，返回一个list</span>titles = titleXPATH.extract_first() <span class="hljs-comment"># 获取一个信息，返回一个str</span></code></pre></div><h2 id="抓取新连接"><a href="#抓取新连接" class="headerlink" title="抓取新连接"></a>抓取新连接</h2><p>有时在旧的连接中有新的连接，这个时候就需要抓取新的连接的内容，关键代码如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> scrapy.Request(url=next_url, dont_filter=<span class="hljs-literal">True</span>, callback = self.<span class="hljs-built_in">next</span>)</code></pre></div><p>参数如下：</p><ul><li>url：下一个要抓的url</li><li>dont_filter：关闭默认过滤掉重复的请求URL的功能</li><li>callback：调用的方法</li></ul><p>Demo：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YgoSpider</span>(<span class="hljs-params">scrapy.Spider</span>):</span>    name = <span class="hljs-string">&#x27;ygo&#x27;</span>    allowed_domains = [<span class="hljs-string">&#x27;ygo&#x27;</span>]    start_urls = [<span class="hljs-string">&#x27;http://www.ourocg.cn/card/list-1/1&#x27;</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span>        self.<span class="hljs-built_in">next</span>(response) <span class="hljs-comment"># 第一次抓取的直接调用</span>        i = <span class="hljs-number">2</span>        <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>):            next_url = <span class="hljs-string">&quot;http://www.ourocg.cn/card/list-1/&quot;</span>+<span class="hljs-built_in">str</span>(i) <span class="hljs-comment"># 获取每一页的url</span>            <span class="hljs-keyword">yield</span> scrapy.Request(url=next_url, dont_filter=<span class="hljs-literal">True</span>, callback = self.<span class="hljs-built_in">next</span>) <span class="hljs-comment"># 继续爬</span>            i += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span>(<span class="hljs-params">self, response</span>):</span>        titleXPATH = response.xpath(<span class="hljs-string">&#x27;//*[@class=&quot;card-item&quot;]/h3/a/text()&#x27;</span>) <span class="hljs-comment"># 通过text()寻找文字</span>        titles = titleXPATH.getall() <span class="hljs-comment"># 获取所有的信息，返回一个list</span>        <span class="hljs-built_in">print</span>(titles)</code></pre></div><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><p>该框架并不是用于爬虫的，但是可以通过Selenium获取网站数据，初始化参数如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">## Chrome后台静默运行</span>__options = webdriver.ChromeOptions()__options.add_argument(<span class="hljs-string">&#x27;--no-sandbox&#x27;</span>) <span class="hljs-comment"># 解决DevToolsActivePort文件不存在的报错</span>__options.add_argument(<span class="hljs-string">&#x27;--start-maximized&#x27;</span>) <span class="hljs-comment"># 最大化运行（全屏窗口）,不设置，取元素会报错</span>__options.add_argument(<span class="hljs-string">&#x27;--disable-infobars&#x27;</span>) <span class="hljs-comment"># 禁用浏览器正在被自动化程序控制的提示</span>__options.add_argument(<span class="hljs-string">&#x27;window-size=1920x1080&#x27;</span>) <span class="hljs-comment"># 设置浏览器分辨率</span>__options.add_argument(<span class="hljs-string">&#x27;--disable-gpu&#x27;</span>) <span class="hljs-comment"># 谷歌文档提到需要加上这个属性来规避bug</span>__options.add_argument(<span class="hljs-string">&#x27;--hide-scrollbars&#x27;</span>)  <span class="hljs-comment"># 隐藏滚动条，应对一些特殊页面</span>__options.add_argument(<span class="hljs-string">&#x27;blink-settings=imagesEnabled=false&#x27;</span>) <span class="hljs-comment"># 不加载图片，提升运行速度</span>__options.add_argument(<span class="hljs-string">&#x27;--headless&#x27;</span>) <span class="hljs-comment"># 浏览器不提供可视化界面。Linux下如果系统不支持可视化不加这条会启动失败</span>__options.add_argument(<span class="hljs-string">&quot;--ignore-certificate-errors&quot;</span>)<span class="hljs-comment"># 传入user-agent，欺骗网站，使得它认为是在实际的浏览器上运行,这样的话运行的网络速度是和UI运行的时候是一样的</span>__options.add_argument(<span class="hljs-string">&#x27;user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36&quot;&#x27;</span>)__options.add_argument(<span class="hljs-string">&quot;--ignore-ssl-errors&quot;</span>)__wukongDriver = webdriver.Chrome(executable_path = <span class="hljs-string">&quot;./browserDriver/chromedriver.exe&quot;</span>,options=__options)<span class="hljs-comment"># Chrome 浏览器驱动存放路径</span></code></pre></div><p>然后获取网站数据即可，详细Selenium讲解：<a href="http://vsoapmac.cn/content/更新未完成--自动化测试框架大总结/#Selenium">自动化测试框架大总结</a></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文自然语言库处理大总结</title>
    <link href="/my_world/content/%E4%B8%AD%E6%96%87%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%BA%93%E5%A4%84%E7%90%86%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <url>/my_world/content/%E4%B8%AD%E6%96%87%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%BA%93%E5%A4%84%E7%90%86%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自然语言(Natural language)通常是指一种自然地随文化演化的语言。例如，汉语、英语、日语都是自然语言的例子，这一种用法可见于自然语言处理一词中。自然语言是人类交流和思维的主要工具。 自然语言是人类智慧的结晶，自然语言处理是人工智能中最为困难的问题之一，而对自然语言处理的研究也是充满魅力和挑战的，也是各国人表达的方法其中之一。</p><p>以下的库对中文支持非常好，所以是对中文自然语言的处理，下面是笔者所学的所有知识的总结，会持续补充。</p><h1 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h1><p>jieba库是一款优秀的 Python 第三方中文<strong>分词库</strong>，jieba 支持三种分词模式：精确模式、全模式和搜索引擎模式，下面是三种模式的特点。</p><ul><li>精确模式：试图将语句最精确的切分，不存在冗余数据，适合做文本分析</li><li>全模式：将语句中所有可能是词的词语都切分出来，速度很快，但是存在冗余数据</li><li>搜索引擎模式：在精确模式的基础上，对长词再次进行切分</li></ul><p>大量的库的依赖是jieba，可见jieba的重要性</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs apl">pip install jieba</code></pre></div><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><div class="code-wrapper"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> jieba</code></pre></div><h2 id="jieba-api"><a href="#jieba-api" class="headerlink" title="jieba api"></a>jieba api</h2><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">jieba.cut(s)</td><td style="text-align:center">精确模式，返回一个可迭代的数据类型</td></tr><tr><td style="text-align:center">jieba.cut(s, cut_all = True)</td><td style="text-align:center">全模式，输出文本s中所有可能的单词</td></tr><tr><td style="text-align:center">jieba.cut_for_search(s)</td><td style="text-align:center">搜索引擎模式，适合搜索引擎建立索引的分词结果</td></tr><tr><td style="text-align:center">jieba.lcut(s)</td><td style="text-align:center">精确模式，返回列表类型，建议使用</td></tr><tr><td style="text-align:center">jieba.lcut(s, cut_all = True)</td><td style="text-align:center">全模式，返回列表类型，建议使用</td></tr><tr><td style="text-align:center">jiaba.lcut_for_search(s)</td><td style="text-align:center">搜索引擎模式，返回列表类型，建议使用</td></tr><tr><td style="text-align:center">jieba.add_word(s)</td><td style="text-align:center">向分词词典中添加新词w</td></tr></tbody></table></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><div class="code-wrapper"><pre><code class="hljs python">string = <span class="hljs-string">&quot;列车折返是什么意思&quot;</span>afterCut = jieba.lcut_for_search(string)<span class="hljs-built_in">print</span>(afterCut)输出：Building prefix <span class="hljs-built_in">dict</span> <span class="hljs-keyword">from</span> the default dictionary ...Loading model <span class="hljs-keyword">from</span> cache C:\Users\xxxxx\AppData\Local\Temp\jieba.cacheLoading model cost <span class="hljs-number">0.600</span> seconds.Prefix <span class="hljs-built_in">dict</span> has been built successfully.[<span class="hljs-string">&#x27;列车&#x27;</span>, <span class="hljs-string">&#x27;折返&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;什么&#x27;</span>, <span class="hljs-string">&#x27;意思&#x27;</span>]</code></pre></div><h2 id="jieba-analyse"><a href="#jieba-analyse" class="headerlink" title="jieba.analyse"></a>jieba.analyse</h2><p>通过词性，将一句话中具有该词性的词语提取出来。是分词的一种，但是是提取带有词性的关键字。</p><blockquote><p>引入</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba.analyse</code></pre></div><blockquote><p>api</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">jieba.analyse.extract_tags(sentence, topK=<span class="hljs-number">5</span>, withWeight=<span class="hljs-literal">True</span>, allowPOS=())</code></pre></div><p>sentence，需要提取的字符串，必须是字符串类型</p><p>top，提取多少个关键字，重要性从高到低</p><p>withWeight，是否返回每个关键词的权重</p><p>allowPOS，词性过滤，分别有：’ns’, ‘n’, ‘vn’, ‘v’，解释为提取地名、名词、动名词、动词</p><blockquote><p>应用</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">answerList = jieba.analyse.extract_tags(sentence = string, topK=<span class="hljs-number">5</span>, withWeight=<span class="hljs-literal">False</span>, allowPOS=(<span class="hljs-string">&#x27;n&#x27;</span>))<span class="hljs-keyword">return</span> answerList[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]</code></pre></div><h2 id="jieba-posseg"><a href="#jieba-posseg" class="headerlink" title="jieba.posseg"></a>jieba.posseg</h2><p>切割句子并分析词性，例如动词，名词等</p><blockquote><p>引用</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba.posseg <span class="hljs-keyword">as</span> posseg</code></pre></div><blockquote><p>应用</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = posseg.lcut(<span class="hljs-string">&quot;金融危机是如何造成的&quot;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)输出：Building prefix <span class="hljs-built_in">dict</span> <span class="hljs-keyword">from</span> the default dictionary ...Loading model <span class="hljs-keyword">from</span> cache C:\Users\xxxx\AppData\Local\Temp\jieba.cacheLoading model cost <span class="hljs-number">0.559</span> seconds.Prefix <span class="hljs-built_in">dict</span> has been built successfully.[pair(<span class="hljs-string">&#x27;金融危机&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>), pair(<span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>), pair(<span class="hljs-string">&#x27;如何&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>), pair(<span class="hljs-string">&#x27;造成&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>), pair(<span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;uj&#x27;</span>)]</code></pre></div><h1 id="SnowNLP"><a href="#SnowNLP" class="headerlink" title="SnowNLP"></a>SnowNLP</h1><p>SnowNLP是一个python写的类库，可以方便的处理中文文本内容，是受到了TextBlob的启发而写的，由于现在大部分的自然语言处理库基本都是针对英文的，于是写了一个方便处理中文的类库，并且和TextBlob不同的是，这里没有用NLTK，所有的算法都是自己实现的，并且自带了一些训练好的字典。</p><p>它能分词，可以标注，可以断句，可以做为情感分析。标注和分词用jieba即可完成。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><div class="code-wrapper"><pre><code class="hljs python">pip install snownlp</code></pre></div><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> snownlp <span class="hljs-keyword">import</span> SnowNLP</code></pre></div><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;这个答题很简单的好不好&quot;</span>)<span class="hljs-built_in">print</span>(s.words)输出：[<span class="hljs-string">&#x27;这个&#x27;</span>, <span class="hljs-string">&#x27;答题&#x27;</span>, <span class="hljs-string">&#x27;很&#x27;</span>, <span class="hljs-string">&#x27;简单&#x27;</span>, <span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;好&#x27;</span>, <span class="hljs-string">&#x27;不&#x27;</span>, <span class="hljs-string">&#x27;好&#x27;</span>]</code></pre></div><h3 id="断句"><a href="#断句" class="headerlink" title="断句"></a>断句</h3><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;这个答题很简单的好不好，闭着眼睛都能答出来。&quot;</span>)<span class="hljs-built_in">print</span>(s.sentences)输出：[<span class="hljs-string">&#x27;这个答题很简单的好不好&#x27;</span>, <span class="hljs-string">&#x27;闭着眼睛都能答出来&#x27;</span>]</code></pre></div><h3 id="繁体转汉字"><a href="#繁体转汉字" class="headerlink" title="繁体转汉字"></a>繁体转汉字</h3><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;繁體字&quot;</span>)<span class="hljs-built_in">print</span>(s.han)输出：繁体字</code></pre></div><h3 id="转拼音"><a href="#转拼音" class="headerlink" title="转拼音"></a>转拼音</h3><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;这个答题很简单的好不好&quot;</span>)<span class="hljs-built_in">print</span>(s.pinyin)输出：[<span class="hljs-string">&#x27;zhe&#x27;</span>, <span class="hljs-string">&#x27;ge&#x27;</span>, <span class="hljs-string">&#x27;da&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;hen&#x27;</span>, <span class="hljs-string">&#x27;jian&#x27;</span>, <span class="hljs-string">&#x27;dan&#x27;</span>, <span class="hljs-string">&#x27;de&#x27;</span>, <span class="hljs-string">&#x27;hao&#x27;</span>, <span class="hljs-string">&#x27;bu&#x27;</span>, <span class="hljs-string">&#x27;hao&#x27;</span>]</code></pre></div><h3 id="情感分析"><a href="#情感分析" class="headerlink" title="情感分析"></a>情感分析</h3><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;这个答题很简单的好不好&quot;</span>)<span class="hljs-built_in">print</span>(s.sentiments)输出：<span class="hljs-number">0.9216225993232947</span></code></pre></div><p>越接近1表示正面情绪，接近0表示负面情绪，目前该api对评论支持较好，其他类型会有未知情况</p><h3 id="概括总结文章"><a href="#概括总结文章" class="headerlink" title="概括总结文章"></a>概括总结文章</h3><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;SnowNLP是一个python写的类库，可以方便的处理中文文本内容，是受到了TextBlob的启发而写的，由于现在大部分的自然语言处理库基本都是针对英文的，于是写了一个方便处理中文的类库，并且和TextBlob不同的是，这里没有用NLTK，所有的算法都是自己实现的，并且自带了一些训练好的字典。&quot;</span>)<span class="hljs-built_in">print</span>(s.summary(limit=<span class="hljs-number">4</span>))输出：[<span class="hljs-string">&#x27;于是写了一个方便处理中文的类库&#x27;</span>, <span class="hljs-string">&#x27;SnowNLP是一个python写的类库&#x27;</span>, <span class="hljs-string">&#x27;是受到了TextBlob的启发而写的&#x27;</span>, <span class="hljs-string">&#x27;由于现在大部分的自然语言处理库基本都是针对英文的&#x27;</span>]</code></pre></div><h3 id="信息衡量"><a href="#信息衡量" class="headerlink" title="信息衡量"></a>信息衡量</h3><blockquote><p>引用至<a href="https://www.cnblogs.com/zhuminghui/p/10953717.html">Python分词、情感分析工具——SnowNLP - ‘’竹先森゜ - 博客园 (cnblogs.com)</a></p></blockquote><p>TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</p><p>TF词频越大越重要，但是文中会的“的”，“你”等无意义词频很大，却信息量几乎为0，这种情况导致单纯看词频评价词语重要性是不准确的。因此加入了idf</p><p>IDF的主要思想是：如果包含词条t的文档越少，也就是n越小，IDF越大，则说明词条t越重要</p><p>TF-IDF综合起来，才能准确的综合的评价一词对文本的重要性。</p><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;我的天啊&quot;</span>)<span class="hljs-built_in">print</span>(s.tf)<span class="hljs-built_in">print</span>(s.idf)输出：[&#123;<span class="hljs-string">&#x27;我&#x27;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;的&#x27;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;天&#x27;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;啊&#x27;</span>: <span class="hljs-number">1</span>&#125;]&#123;<span class="hljs-string">&#x27;我&#x27;</span>: <span class="hljs-number">0.8472978603872037</span>, <span class="hljs-string">&#x27;的&#x27;</span>: <span class="hljs-number">0.8472978603872037</span>, <span class="hljs-string">&#x27;天&#x27;</span>: <span class="hljs-number">0.8472978603872037</span>, <span class="hljs-string">&#x27;啊&#x27;</span>: <span class="hljs-number">0.8472978603872037</span>&#125;</code></pre></div><h3 id="文本相似性检测"><a href="#文本相似性检测" class="headerlink" title="文本相似性检测"></a>文本相似性检测</h3><div class="code-wrapper"><pre><code class="hljs python">s = SnowNLP(<span class="hljs-string">&quot;我的天啊&quot;</span>)<span class="hljs-built_in">print</span>(s.sim([<span class="hljs-string">&quot;我&quot;</span>]))输出：[<span class="hljs-number">0.8472978603872037</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre></div><p>如果传入的是句子，那么它会将所有的句子拆开然后进行相似性的检测。</p><h1 id="Gensim"><a href="#Gensim" class="headerlink" title="Gensim"></a>Gensim</h1><p>Gensim是一款开源的第三方Python工具包，用于从原始的非结构化的文本中，无监督地学习到文本隐层的主题向量表达。它支持包括TF-IDF，LSA，LDA，和word2vec在内的多种主题模型算法，支持流式训练，并提供了诸如相似度计算，信息检索等一些常用任务的API接口。</p><p>Gensim需要慢慢研究，它实在是太大了</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>引用<a href="https://zhuanlan.zhihu.com/p/37175253">15分钟入门Gensim - 知乎 (zhihu.com)</a></p></blockquote><ul><li>语料（Corpus）：一组原始文本的集合，用于无监督地训练文本主题的隐层结构。语料中不需要人工标注的附加信息。在Gensim中，Corpus通常是一个可迭代的对象（比如列表）。每一次迭代返回一个可用于表达文本对象的稀疏向量。</li><li>向量（Vector）：由一组文本特征构成的列表。是一段文本在Gensim中的内部表达。</li><li>稀疏向量（SparseVector）：通常，我们可以略去向量中多余的0元素。此时，向量中的每一个元素是一个(key, value)的元组</li><li>模型（Model）：是一个抽象的术语。定义了两个向量空间的变换（即从文本的一种向量表达变换为另一种向量表达）。</li></ul><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><div class="code-wrapper"><pre><code class="hljs python">pip install gensim</code></pre></div><h3 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim <span class="hljs-keyword">import</span> corpora <span class="hljs-comment"># 计算语料库的向量和生成语料库</span><span class="hljs-keyword">from</span> gensim <span class="hljs-keyword">import</span> models <span class="hljs-comment"># 模型算法tf-idf（主要tf：term frequency 词频;idf：inverse document frequency 倒文档频率）</span><span class="hljs-keyword">from</span> gensim <span class="hljs-keyword">import</span> similarities <span class="hljs-comment"># 计算向量相似度</span></code></pre></div><h3 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h3><p>笔者认为，gensim计算相似度是文章与文章的计算，宏观程度比SnowNLP大</p><p>在切割数据时，笔者把符号这些脏数据清除了，提高计算的准确率</p><p>以下为生成context1的语料库索引以及计算context1与context2的相似度</p><blockquote><p>切割句子</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">context1 = context1.split(<span class="hljs-string">&quot;。&quot;</span>)<span class="hljs-comment">## 切割句子</span>texts = [jieba.lcut(re.sub(<span class="hljs-string">&quot;[_.!+\-=——,$%^，。？、~@#￥%……&amp;*《》&lt;&gt;「」&#123;&#125;【】()/]&quot;</span>,<span class="hljs-string">r&quot;&quot;</span>,text)) <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> context1]<span class="hljs-comment"># 将句子切割成词语</span></code></pre></div><blockquote><p>生成词典（语料库）</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">dictionary = corpora.Dictionary(texts)</code></pre></div><blockquote><p>doc2bow生成稀疏向量值</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">corpus = [dictionary.doc2bow(text) <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> texts]</code></pre></div><blockquote><p>通过TF-IDF模型算法，计算出tf值</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">tf = models.TfidfModel(corpus)</code></pre></div><blockquote><p>通过token2id得到特征数（字典里面的键的个数）</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">num_features = <span class="hljs-built_in">len</span>(dictionary.token2id.keys())</code></pre></div><blockquote><p>计算稀疏矩阵相似度，建立索引</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">index = similarities.MatrixSimilarity(tf[corpus], num_features=num_features)</code></pre></div><p>语料库索引建立完毕，接下来对另外一篇文章进行相似度的检测</p><blockquote><p>切割测试数据</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">test_words = [word <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> jieba.cut(re.sub(<span class="hljs-string">&quot;[_.!+\-=——,$%^，。？、~@#￥%……&amp;*《》&lt;&gt;「」&#123;&#125;【】()/]&quot;</span>,<span class="hljs-string">r&quot;&quot;</span>,context2))]</code></pre></div><blockquote><p>构建新的稀疏向量</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">new_vec = dictionary.doc2bow(test_words)</code></pre></div><blockquote><p>通过语料库索引计算相似度</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">sims = index[tf[new_vec]]</code></pre></div><p>这里会得到一个转载着相似度的list，笔者这里把相似度做一个平均值，这样比较好观察</p><div class="code-wrapper"><pre><code class="hljs python">simlist = <span class="hljs-built_in">list</span>(sims) <span class="hljs-comment"># 将sims转换成list</span>avg = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> sim <span class="hljs-keyword">in</span> simlist:    avg = sim+avg    avg = avg/<span class="hljs-built_in">len</span>(simlist)</code></pre></div><h1 id="TextRank4ZH"><a href="#TextRank4ZH" class="headerlink" title="TextRank4ZH"></a>TextRank4ZH</h1><p>TextRank算法可以用来从文本中提取关键词和摘要（重要的句子）。TextRank4ZH是针对中文文本的TextRank算法的python算法实现。</p><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install textrank<span class="hljs-number">4</span>zh</code></pre></div><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> textrank4zh <span class="hljs-keyword">import</span> TextRank4Keyword, TextRank4Sentence</code></pre></div><h2 id="案例文章"><a href="#案例文章" class="headerlink" title="案例文章"></a>案例文章</h2><p>金融危机的百度百科</p><div class="code-wrapper"><pre><code class="hljs python">sentence = <span class="hljs-string">&quot;具体到行业，保险业近年来总体处于上升状态，除了受到国际金融危机的严重影响，保费增速降低，但仍超过10%。纺织行业等传统劳动密集型企业受到的影响比较严重。据海关总署数据显示，2008年9月份，纺织品服装出口较8月份减少近6亿美元，较上年同月仅小幅增加约3亿美元，9月份出口延续了8月份微幅增长的趋势。随着美国金融危机愈演愈烈，以美元计价的纺织出口接近零增长，以人民币汇率计价的出口额持续负增长，20%的纺织企业出现亏损；汽车行业受美国金融危机的影响，总体表现低迷。据中国汽车工业协会最新数据统计，2009年1～8月，乘用车产销463.24万辆和455.03万辆，同比增长13.67%和13.15%，与上年同期相比，增幅回落8.32个百分点和10.94个百分点。&quot;</span></code></pre></div><h2 id="提取关键词"><a href="#提取关键词" class="headerlink" title="提取关键词"></a>提取关键词</h2><p>调用TextRank4Keyword() -&gt; analyze -&gt; 获取关键词 -&gt; 输出</p><div class="code-wrapper"><pre><code class="hljs python">tr4w = TextRank4Keyword()tr4w.analyze(text=sentence)keywordlist = tr4w.get_keywords(<span class="hljs-number">20</span>,word_min_len=<span class="hljs-number">2</span>)<span class="hljs-comment"># word_min_len=2，关键词的最小长度</span><span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> keywordlist:    <span class="hljs-built_in">print</span>(keyword[<span class="hljs-string">&#x27;word&#x27;</span>])</code></pre></div><h2 id="提取关键句"><a href="#提取关键句" class="headerlink" title="提取关键句"></a>提取关键句</h2><p>调用TextRank4Sentence() -&gt; analyze -&gt; 获取关键句数量 -&gt; 输出</p><div class="code-wrapper"><pre><code class="hljs python">tr4s = TextRank4Sentence()tr4s.analyze(text=sentence, lower=<span class="hljs-literal">True</span>, source = <span class="hljs-string">&#x27;all_filters&#x27;</span>)<span class="hljs-comment"># 文本小写，使用words_all_filters生成句子之间的相似性</span>sentenceslist = tr4s.get_key_sentences(num=<span class="hljs-number">5</span>)<span class="hljs-comment"># num=3表示为提取3个关键句</span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> sentenceslist:    <span class="hljs-built_in">print</span>(item)<span class="hljs-comment"># index是语句在文本中索引位置，weight是权重系数</span></code></pre></div><h1 id="停用词表"><a href="#停用词表" class="headerlink" title="停用词表"></a>停用词表</h1><blockquote><p>原文链接：<a href="https://blog.csdn.net/dorisi_h_n_q/article/details/82114913">https://blog.csdn.net/dorisi_h_n_q/article/details/82114913</a></p></blockquote><h1 id="Synonyms"><a href="#Synonyms" class="headerlink" title="Synonyms"></a>Synonyms</h1><p>Chinese Synonyms for Natural Language Processing and Understanding.</p><p>最好的中文近义词工具包: <a href="https://github.com/huyingxi/Synonyms/。">https://github.com/huyingxi/Synonyms/。</a></p><p>synonyms可以用于自然语言理解的很多任务：文本对齐，推荐算法，相似度计算，语义偏移，关键字提取，概念提取，自动摘要，搜索引擎等。</p><blockquote><p>原文链接：<a href="https://blog.csdn.net/samurais/article/details/79339406">https://blog.csdn.net/samurais/article/details/79339406</a></p></blockquote><h2 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> synonyms</code></pre></div><h2 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> synonyms</code></pre></div><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><div class="code-wrapper"><pre><code class="hljs python">synonyms.display(<span class="hljs-string">&quot;飞机&quot;</span>)输出：<span class="hljs-string">&#x27;飞机&#x27;</span>近义词：  <span class="hljs-number">1.</span> 架飞机:<span class="hljs-number">0.837399</span>  <span class="hljs-number">2.</span> 客机:<span class="hljs-number">0.764609</span>  <span class="hljs-number">3.</span> 直升机:<span class="hljs-number">0.762116</span>  <span class="hljs-number">4.</span> 民航机:<span class="hljs-number">0.750519</span>  <span class="hljs-number">5.</span> 航机:<span class="hljs-number">0.750116</span>  <span class="hljs-number">6.</span> 起飞:<span class="hljs-number">0.735736</span>  <span class="hljs-number">7.</span> 战机:<span class="hljs-number">0.734975</span>  <span class="hljs-number">8.</span> 飞行中:<span class="hljs-number">0.732649</span>  <span class="hljs-number">9.</span> 航空器:<span class="hljs-number">0.723945</span>  <span class="hljs-number">10.</span> 运输机:<span class="hljs-number">0.720578</span></code></pre></div><h2 id="同义词搜寻"><a href="#同义词搜寻" class="headerlink" title="同义词搜寻"></a>同义词搜寻</h2><p>生成一个二维数组</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = synonyms.nearby(<span class="hljs-string">&quot;金融危机&quot;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)输出：([<span class="hljs-string">&#x27;金融危机&#x27;</span>, <span class="hljs-string">&#x27;次贷危机&#x27;</span>, <span class="hljs-string">&#x27;经济危机&#x27;</span>, <span class="hljs-string">&#x27;经济衰退&#x27;</span>, <span class="hljs-string">&#x27;金融风暴&#x27;</span>, <span class="hljs-string">&#x27;石油危机&#x27;</span>, <span class="hljs-string">&#x27;股灾&#x27;</span>, <span class="hljs-string">&#x27;大萧条&#x27;</span>, <span class="hljs-string">&#x27;危机&#x27;</span>, <span class="hljs-string">&#x27;经济萧条&#x27;</span>], [<span class="hljs-number">1.0</span>, <span class="hljs-number">0.85820746</span>, <span class="hljs-number">0.85081583</span>, <span class="hljs-number">0.80318713</span>, <span class="hljs-number">0.7774969</span>, <span class="hljs-number">0.7471542</span>, <span class="hljs-number">0.7450016</span>, <span class="hljs-number">0.7314842</span>, <span class="hljs-number">0.725529</span>, <span class="hljs-number">0.7105995</span>])</code></pre></div><h2 id="关键词截取"><a href="#关键词截取" class="headerlink" title="关键词截取"></a>关键词截取</h2><div class="code-wrapper"><pre><code class="hljs python">keyword = synonyms.keywords(question)</code></pre></div><h2 id="相似性比较"><a href="#相似性比较" class="headerlink" title="相似性比较"></a>相似性比较</h2><div class="code-wrapper"><pre><code class="hljs python">sen1 = <span class="hljs-string">&quot;发生历史性变革&quot;</span>sen2 = <span class="hljs-string">&quot;发生历史性变革&quot;</span>r = synonyms.compare(sen1, sen2, seg=<span class="hljs-literal">True</span>)<span class="hljs-built_in">print</span>(r)输出：<span class="hljs-number">1.0</span></code></pre></div><p>0.5 &lt; 不相似，反之则对</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python 库</tag>
      
      <tag>分词器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch快速入门</title>
    <link href="/my_world/content/ElasticSearch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/my_world/content/ElasticSearch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ElasticSearch（简称es）是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。ElasticSearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，ElasticSearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p><blockquote><p>以下大量引用至<a href="https://www.bilibili.com/video/BV17a4y1x7zq?p=5">【狂神说Java】ElasticSearch7.6.x最新完整教程通俗易懂_哔哩哔哩_bilibili</a></p></blockquote><h1 id="ElasticSearch用途"><a href="#ElasticSearch用途" class="headerlink" title="ElasticSearch用途"></a>ElasticSearch用途</h1><ol><li>快速和近乎实时地存储、搜索和分析海量的数据</li><li>为具有复杂搜索功能和需求的应用程序提供动力</li></ol><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载地址总结</p><p>官方：</p><ul><li>ElasticSearch：<a href="https://www.elastic.co/cn/downloads/elasticsearch">Download Elasticsearch Free | Get Started Now | Elastic | Elastic</a></li><li>kibana：<a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic | Elastic</a></li></ul><p>镜像网站：</p><ul><li>ElasticSearch: <a href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D">https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D</a></li><li>logstash: <a href="https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D">https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D</a></li><li>kibana: <a href="https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D</a></li></ul><h2 id="ElasticSearch安装"><a href="#ElasticSearch安装" class="headerlink" title="ElasticSearch安装"></a>ElasticSearch安装</h2><p>前提：</p><ul><li>java环境</li><li>ElasticSearch的版本对应java的核心jar包。</li><li>安装node.js环境</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>地址为：<a href="https://www.elastic.co/cn/downloads/elasticsearch">Download Elasticsearch Free | Get Started Now | Elastic | Elastic</a></p><p>根据自己的系统需求下载相应的压缩包即可</p><h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><ul><li>bin：用于启动软件<ul><li>config：配置文件</li><li>log4j2：日志配置文件<ul><li>jvm.options：java虚拟机相关的配置</li><li>elasticsearch.yml：elasticsearch的配置文件，默认9200端口，跨域</li></ul></li></ul></li><li>lib：相关jar包</li><li>logs     日志文件</li><li>modules  功能模块</li><li>plugins  插件，例如ik分词器等等</li></ul><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>双击bin/elasticsearch.bat的文件</p><p>若出现以下的提示，按回车键即可，不影响。</p><p><img src="../../image/tmpF09E.png" alt="更新提示"></p><p>当出现started或者publish_address{127.0.0.1:9200}字样即是启动成功</p><blockquote><p> 测试是否成功</p></blockquote><p>浏览器地址栏输入127.0.0.1:9200或者localhost:9200后回车。</p><p>出现以下字样证明es启动成功</p><p><img src="../../image/image-20210829125008328.png" alt="启动成功"></p><h2 id="安装可视化界面（Elasticsearch-head或类似）"><a href="#安装可视化界面（Elasticsearch-head或类似）" class="headerlink" title="安装可视化界面（Elasticsearch-head或类似）"></a>安装可视化界面（Elasticsearch-head或类似）</h2><p>笔者这里使用的是浏览器的扩展（比较方便），笔者主要用edge</p><ol><li>Chorme可以扩展商店去搜索Elasticsearch</li><li>edge扩展商店下载Elasticvue即可</li></ol><p>界面长这样：</p><p><img src="../../image/image-20210829133017443.png" alt="扩展插件Elasticvue界面"></p><blockquote><p>连接</p></blockquote><p>Elasticvue默认输入了地址，<a href="http://localhost:9200，链接即可">http://localhost:9200，链接即可</a></p><p>这里会有跨域问题，在es目录的config文件夹下elasticsearch.yml中输入以下配置即可：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre></div><p>可以把es当做一个数据库，索引（数据库），文档（数据库中的数据），这个就是es的管理器（类似于sqlyog，数据库管理软件）</p><h1 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h1><p>Kibana 是一个免费且开放的用户界面，能够让用户对 Elasticsearch 数据进行可视化。</p><p>官网：<a href="https://www.elastic.co/cn/kibana/">Kibana：数据的探索、可视化和分析 | Elastic</a></p><p>注意kibana的版本要和es的一致</p><p>这里是官方的下载地址：<a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic | Elastic</a></p><blockquote><p>安装</p></blockquote><p>下载解压即可</p><blockquote><p>汉化</p></blockquote><p>在kibana文件夹中的config文件夹下的kibana,yml修改配置如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">i18n.locale:</span> <span class="hljs-string">&quot;zh-CN&quot;</span></code></pre></div><blockquote><p>运行</p></blockquote><p>点击bin/kibana.bat，出现【http server running at <a href="http://localhost:5601】即打开成功">http://localhost:5601】即打开成功</a></p><p>在浏览器输入<a href="http://localhost:5601，出现以下画面成功打开">http://localhost:5601，出现以下画面成功打开</a></p><p><img src="../../image/image-20210829140017906.png" alt="kibana主页"></p><h1 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h1><p>Elasticsearch是面向文档、关系行数据库。它有如下几大概念：集群，节点，索引，类型，文档，分片，映射。</p><div class="table-container"><table><thead><tr><th>Relational DB</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>数据库（database）</td><td>索引（index）</td></tr><tr><td>表（tables）</td><td>types（已过时）</td></tr><tr><td>行（rows）</td><td>documents</td></tr><tr><td>字段（columns）</td><td>fields</td></tr></tbody></table></div><p><strong>物理设计：</strong></p><p>elasticsearch在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移。</p><p>逻辑设计：</p><p>一个索引类型中，包含多个文档，通过这个组合我们就能索引到某个具体的文档。</p><blockquote><p>文档（documents）</p></blockquote><p>elasticsearch中索引和搜索数据的最小档位是文档。它就是我们的一条条数据。</p><blockquote><p>类型（类似于数据类型）</p></blockquote><p>类型是文档的逻辑容器，类似于与String,int这种</p><blockquote><p>索引（index）</p></blockquote><p>类似于数据库，索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。然后它们被存储到各个分片上。</p><p>物理设计：节点和分片</p><p>一个集群至少有一个节点，而一个节点就是一个elasticsearch进程，节点可以有多个索引默认的，如果创建索引，那么索引将会有5个分片构成，每一个主分片会有一个副本。</p><p><img src="../../image/image-20210829141721349.png" alt="集群和节点的关系"></p><p>elasticsearch使用的是<strong>倒排索引</strong>的结构。</p><blockquote><p>倒排索引</p><p>引用<a href="https://blog.csdn.net/luzhensmart/article/details/105731656">ES的底层原理-倒排索引的概念_luzhensmart的专栏-CSDN博客</a></p></blockquote><p>在说倒排索引之前先说说什么是正排索引。正排索引也称为”前向索引”，它是创建倒排索引的基础。<br>这种组织方法在建立索引的时候结构比较简单，建立比较<strong>方便且易于维护</strong>;因为索引是基于文档建立的，若是有新的文档加入，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对应的索引信息，将其直接删除。</p><p>类似于线性表</p><p>优点：工作原理非常的简单。<br>缺点：检索效率太低，只能在一起简单的场景下使用。</p><p>倒排索引根据字面意思可以知道他和正序索引是反的。在搜索引擎中每个文件<strong>都对应一个文件ID</strong>，文件内容被表示为<strong>一系列关键词的集合</strong>（文档要除去一些无用的词，比如’的’这些，剩下的词就是关键词，每个关键词都有自己的ID）。例如“文档1”经过分词，提取了3个关键词，每个关键词都会记录它所在在文档中的出现频率及出现位置。</p><h1 id="Rest风格详解"><a href="#Rest风格详解" class="headerlink" title="Rest风格详解"></a>Rest风格详解</h1><p>这是一种软件架构风格，而不是标准，知识提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><div class="table-container"><table><thead><tr><th>method</th><th>url地址</th><th>描述</th></tr></thead><tbody><tr><td>PUT</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>创建文档(指定文档id)</td></tr><tr><td>POST</td><td>localhost:9200/索引名称/类型名称</td><td>创建文档(随机文档id)</td></tr><tr><td>POST</td><td>localhost:9200/索引名称/类型名称/文档id_ update</td><td>修改文档</td></tr><tr><td>DELETE</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>刪除文档</td></tr><tr><td>GET</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>查询文档通过文档id</td></tr><tr><td>POST</td><td>localhost:9200/索引名称/类型名称/_search</td><td>查询所有数据</td></tr></tbody></table></div><h1 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h1><p>分词：把一段中文或者别的划分成一个个的关键字，我们在搜索的时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，这很显然是不符合要求的，所以需要安装中文分词器ik来解决这个问题。</p><p>ik提供了两个分词算法：ik_smart和ik_max_word，其中ik_smart为最少切分，ik_max_word为最细粒度切分</p><blockquote><p>下载</p></blockquote><p>github：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">Releases · medcl/elasticsearch-analysis-ik · GitHub</a></p><blockquote><p>安装</p></blockquote><p>找到es的plugins文件夹，解压即可</p><p>注意重启es</p><p>可以通过<code>elasticsearch-plugin list</code>命令获取当前安装的插件，在bin文件夹中输入cmd，输入命令即可。</p><blockquote><p>使用</p></blockquote><p>打开kibana，进入控制面板（菜单，Management — Dev Tools）</p><p>第一个测试ik_smart</p><div class="code-wrapper"><pre><code class="hljs json">输入：GET _analyze&#123;  <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,  <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;计算机科学与大数据分析&quot;</span>&#125;结果：&#123;  <span class="hljs-attr">&quot;tokens&quot;</span> : [    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;计算机&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">0</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">3</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">0</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;科学&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">3</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">5</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">1</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;与&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">5</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">6</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_CHAR&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">2</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;大数&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">6</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">8</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">3</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;据分析&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">8</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">11</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">4</span>    &#125;  ]&#125;</code></pre></div><p>测试ik_max_word</p><div class="code-wrapper"><pre><code class="hljs json">输入：GET _analyze&#123;  <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;计算机科学与大数据分析&quot;</span>&#125;结果：&#123;  <span class="hljs-attr">&quot;tokens&quot;</span> : [    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;计算机&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">0</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">3</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">0</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;计算&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">0</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">2</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">1</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;算机&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">1</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">3</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">2</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;科学&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">3</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">5</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">3</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;与&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">5</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">6</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_CHAR&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">4</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;大数&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">6</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">8</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">5</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;数据&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">7</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">9</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">6</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;据分析&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">8</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">11</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">7</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;分析&quot;</span>,      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">9</span>,      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">11</span>,      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">8</span>    &#125;  ]&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>ElasticSearch</tag>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凝聚在生活中的定律</title>
    <link href="/my_world/content/%E5%87%9D%E8%81%9A%E5%9C%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%BE%8B/"/>
    <url>/my_world/content/%E5%87%9D%E8%81%9A%E5%9C%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下的效应解释均采至百度百科。</p><h2 id="二十世纪西方文化三大发现"><a href="#二十世纪西方文化三大发现" class="headerlink" title="二十世纪西方文化三大发现"></a>二十世纪西方文化三大发现</h2><h3 id="墨菲定律"><a href="#墨菲定律" class="headerlink" title="墨菲定律"></a>墨菲定律</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/墨菲定律/746284">墨菲定律（二十世纪西方文化三大发现之一）_百度百科 (baidu.com)</a></p></blockquote><p>墨菲定律是一种心理学效应，1949年由美国的一名工程师爱德华·墨菲（Edward A. Murphy）提出的，亦称墨菲法则、墨菲定理等。</p><p>原文为：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择。根本内容是：<strong>如果事情有变坏的可能，不管这种可能性有多小，它总会发生。</strong></p><h3 id="帕金森定律"><a href="#帕金森定律" class="headerlink" title="帕金森定律"></a>帕金森定律</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/帕金森定律">帕金森定律_百度百科 (baidu.com)</a></p></blockquote><p>帕金森定律（Parkinson’s Law）是<a href="https://baike.baidu.com/item/官僚主义">官僚主义</a>或官僚主义现象的一种别称，被称为二十世纪西方文化三大发现之一。也可称之为“官场病”、“组织麻痹病”或者“大企业病”。</p><p>帕金森在书中阐述了机构人员膨胀的原因及后果：一个不称职的官员，可能有<strong>三条出路</strong>，第一是<strong>申请退职</strong>，把位子<strong>让给能干的人</strong>；第二是让一位<strong>能干的人来协助自己工作</strong>；第三是<strong>任用两个水平比自己更低的人当助手</strong>。</p><p>这<strong>第一条路</strong>是<strong>万万走不得</strong>的，因为那样会丧失许多权利；<strong>第二条路</strong>也<strong>不能走</strong>，因为那个<strong>能干的人会成为自己的对手</strong>；看来只有<strong>第三条路最适宜</strong>。于是，<strong>两个平庸的助手分担了他的工作</strong>，他自己则<strong>高高在上</strong>发号施令，<strong>他们不会对自己的权利构成威胁</strong>。两个助手既然无能，他们就<strong>上行下效</strong>，<strong>再为自己找两个更加无能的助手</strong>。如此类推，就形成了一个机构臃肿、人浮于事、相互扯皮、效率低下的领导体系。帕金森得出结论：在<a href="https://baike.baidu.com/item/行政管理/1494215">行政管理</a>中，行政机构会像金字塔一样不断增多，<a href="https://baike.baidu.com/item/行政人员/8560305">行政人员</a>会不断膨胀，每个人都很忙，但<a href="https://baike.baidu.com/item/组织效率/6200964">组织效率</a>越来越低下。<strong>这条定律又被称为“金字塔上升”现象。</strong> </p><h3 id="彼得原理"><a href="#彼得原理" class="headerlink" title="彼得原理"></a>彼得原理</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/彼得原理/720295">彼得原理（管理心理学术语）_百度百科 (baidu.com)</a></p></blockquote><p>彼得原理是美国学者劳伦斯·彼得在对组织中人员晋升的相关现象研究后得出的一个结论：<strong>在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于被晋升到其不称职的地位。</strong></p><p>彼得原理有时也被称为“向上爬”理论  。这种现象在现实生活中无处不在：</p><ul><li><p>一名称职的教授被提升为大学校长后无法胜任；</p></li><li><p>一个优秀的运动员被提升为主管体育的官员，导致无所作为。</p></li></ul><p>对一个组织而言，一旦相当<strong>部分人员</strong>被推到其<strong>不称职的级别</strong>，就会<strong>造成组织的人浮于事</strong>，效率低下，导致平庸者出人头地，发展停滞 。将一名职工晋升到一个无法很好发挥才能的岗位，不仅不是对本人的奖励，反而使其无法很好发挥才能，也给组织带来损失 。</p><h2 id="社会心理、社会定律、现象"><a href="#社会心理、社会定律、现象" class="headerlink" title="社会心理、社会定律、现象"></a>社会心理、社会定律、现象</h2><h3 id="马太效应"><a href="#马太效应" class="headerlink" title="马太效应"></a>马太效应</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/马太效应/70100">马太效应（两极分化现象）_百度百科 (baidu.com)</a></p></blockquote><p>马太效应，一种<strong>强者愈强、弱者愈弱</strong>的<a href="https://baike.baidu.com/item/现象/2808631">现象</a>，广泛应用于<a href="https://baike.baidu.com/item/社会心理学/80310">社会心理学</a>、<a href="https://baike.baidu.com/item/教育/143397">教育</a>、<a href="https://baike.baidu.com/item/金融/860">金融</a>以及<a href="https://baike.baidu.com/item/科学/10406">科学</a>领域。</p><p>马太效应是<a href="https://baike.baidu.com/item/社会学家/1216425">社会学家</a>和<a href="https://baike.baidu.com/item/经济学家/17464">经济学家</a>们常用的<a href="https://baike.baidu.com/item/术语/3038697">术语</a>，它反映着<strong>富的更富、穷的更穷</strong> ，一种两极分化的<a href="https://baike.baidu.com/item/社会现象/6139891">社会现象</a>。</p><h2 id="棘轮效应"><a href="#棘轮效应" class="headerlink" title="棘轮效应"></a>棘轮效应</h2><blockquote><p>引用<a href="https://baike.baidu.com/item/棘轮效应/7139704">棘轮效应_百度百科 (baidu.com)</a></p></blockquote><p>棘轮效应，是指人的<strong>消费习惯形成之后</strong>有<strong>不可逆性</strong>，即<strong>易于向上调整</strong>，而<strong>难于向下调整</strong>。尤其是在短期内消费是不可逆的，其习惯效应较大。这种习惯效应，使消费取决于相对收入，即相对于自己过去的高峰收入。消费者<strong>易于随收入的提高增加消费</strong>，但<strong>不易于收入降低而减少消费</strong>，以致产生有正截距的短期消费函数。这种特点被称为棘轮效应。</p><h2 id="登门槛效应"><a href="#登门槛效应" class="headerlink" title="登门槛效应"></a>登门槛效应</h2><blockquote><p>引用<a href="https://baike.baidu.com/item/登门坎效应/9728981">登门坎效应_百度百科 (baidu.com)</a></p></blockquote><p>登门槛效应（Foot In The Door Effect）又称得寸进尺效应，是指一个人<strong>一旦接受了</strong>他人的<strong>一个微不足道的要求</strong>，为了<strong>避免认知上的不协调</strong>，或<strong>想给他人以前后一致的印象</strong>，就<strong>有可能接受更大的要求</strong>。</p><p>心理学家认为，在一般情况下，人们都不愿接受较高较难的要求，因为它费时费力又难以成功，相反，人们却乐于接受较小的、较易完成的要求，在实现了较小的要求后，人们才慢慢地接受较大的要求，这就是“登门坎效应”对人的影响。</p><h3 id="不值得定律"><a href="#不值得定律" class="headerlink" title="不值得定律"></a>不值得定律</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/不值得定律">不值得定律_百度百科 (baidu.com)</a></p></blockquote><p>不值得定律是<strong>指不值得做的事情，就不值得做好</strong>，是一种心理学效应。</p><p>不值得定律似乎再简单不过了 ，但它的<strong>重要性</strong>却时时被人们疏忘。”不值得定律”反映出人们的一种心理，<strong>一个人如果从事的是一份自认为不值得做的事情</strong>，往往会保持<strong>冷嘲热讽，敷衍了事</strong>的态度。这样的人不仅<strong>成功率小</strong>，而且<strong>即使成功</strong>，也不会觉得有<strong>多大的成就感</strong>。</p><h3 id="三个和尚没水吃"><a href="#三个和尚没水吃" class="headerlink" title="三个和尚没水吃"></a>三个和尚没水吃</h3><p>人多了互相依赖，互相推诿，事情反而没有人做。</p><h3 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/奥卡姆剃刀原理/10900565">奥卡姆剃刀原理_百度百科 (baidu.com)</a></p></blockquote><p>奥卡姆剃刀<a href="https://baike.baidu.com/item/定律/2076576">定律</a>（Occam’s Razor, Ockham’s Razor）又称“奥康的剃刀”，它是由14世纪<a href="https://baike.baidu.com/item/英格兰/1064478">英格兰</a>的<a href="https://baike.baidu.com/item/逻辑学家/1240880">逻辑学家</a>、圣方济各会修士<a href="https://baike.baidu.com/item/奥卡姆的威廉/2094755">奥卡姆的威廉</a>（William of Occam，约1285年至1349年）提出。</p><p>这个<a href="https://baike.baidu.com/item/原理/85014">原理</a>称为“<strong>如无必要，勿增实体</strong>”，即“<strong>简单有效原理</strong>”。正如他在《箴言书注》2卷15题说“切勿浪费较多东西去做，用较少的东西，同样可以做好的事情。”</p><p>这个原理称为“如无必要，勿增实体” （Entities should not be multiplied unnecessarily），有时为了显示其权威性，人们也使用它原始的拉丁文形式：</p><p><em>Numquam ponenda est pluralitas sine necessitate.（</em>避重趋轻）</p><p><em>Pluralitas non est ponenda sine necessitate.（</em>避繁逐简）</p><p><em>Frustra fit per plura quod potest fieri per pauciora.（</em>以简御繁）</p><p><em>Entia non sunt multiplicanda praeter necessitatem.（</em>避虚就实）</p><h3 id="沉默螺旋"><a href="#沉默螺旋" class="headerlink" title="沉默螺旋"></a>沉默螺旋</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/沉默的螺旋/357493?fromtitle=沉默螺旋&amp;fromid=3866548">沉默的螺旋（2013年北京大学出版社出版的图书）_百度百科 (baidu.com)</a></p></blockquote><p>沉默的螺旋（The Spiral Of Silence）是一个心理学、<a href="https://baike.baidu.com/item/大众传播学">大众传播学</a>和社会学。理论基本描述了这样一个现象：</p><ul><li><p>人们在<strong>表达</strong>自己<strong>想法和观点</strong>的时候，如果看到自己<strong>赞同的观点受到广泛欢迎</strong>，就会<strong>积极参与进来</strong>，这类观点就会越发<strong>大胆地发表和扩散</strong>；</p></li><li><p>而发觉某一观点<strong>无人或很少有人理会</strong>（有时<strong>会有群起而攻之的遭遇</strong>），<strong>即使自己赞同它</strong>，也会<strong>保持沉默</strong>。</p></li></ul><p>意见一方的沉默造成另一方意见的增势，如此循环往复，便形成一方的声音越来越强大，另一方越来越沉默下去的螺旋发展过程。理论是基于这样一个假设：<strong>大多数个人会力图避免由于单独持有某些态度和信念而产生的孤立。</strong></p><h3 id="木桶效应"><a href="#木桶效应" class="headerlink" title="木桶效应"></a>木桶效应</h3><blockquote><p>引用<a href="https://baike.baidu.com/item/木桶效应/870962">木桶效应（管理学的概念）_百度百科 (baidu.com)</a></p></blockquote><p><a href="https://baike.baidu.com/item/木桶定律/750400">木桶定律</a>是讲一只<a href="https://baike.baidu.com/item/水桶/6153516">水桶</a>能装多少水取决于它最短的那块木板。一只木桶想盛满水，必须每块木板都一样平齐且无破损，如果这只桶的木板中有一块不齐或者某块木板下面有破洞，这只桶就无法盛满水。</p><p><strong>一只木桶能盛多少水，并不取决于最长的那块木板，而是取决于最短的那块木板。</strong>也可称为<a href="https://baike.baidu.com/item/短板效应/10951410">短板效应</a>。任何一个组织，可能面临的一个共同问题，即构成组织的各个部分往往是优劣不齐的，而劣势部分往往决定整个组织的水平 。 因此，整个社会与我们每个人都应思考一下自己的“<a href="https://baike.baidu.com/item/短板/1194006">短板</a>”，并尽早补足它  。</p><h3 id="手表定律"><a href="#手表定律" class="headerlink" title="手表定律"></a>手表定律</h3><p>手表定律是指<strong>拥有两块以上的手表并不能帮人更准确的判断时间，反而会制造混乱，让看表的人失去对时间的判断。</strong></p><p>手表定理所指的另一层含义在于每个人都不能同时挑选两种不同的<a href="https://baike.baidu.com/item/行为准则/3986118">行为准则</a>或者价值观念，否则那个人的行为将陷于混乱。</p><h3 id="酒与污水定律"><a href="#酒与污水定律" class="headerlink" title="酒与污水定律"></a>酒与污水定律</h3><p>管理学上一个有趣的定律叫“酒与污水定律”，意思是<strong>一匙酒倒进一桶污水</strong>，得到的是<strong>一桶污水</strong>；把<strong>一匙污水倒进一桶酒里</strong>，得到的还是<strong>一桶污水</strong>。显而易见，<strong>污水和酒的比例并不能决定这桶东西的性质</strong>，真正起<strong>决定作用</strong>的就是那<strong>一勺污水</strong>，只要有它，再多的酒都成了污水。酒与污水定律说明对于坏的组员或东西，要在其开始破坏之前及时处理掉。</p><h3 id="蘑菇定律"><a href="#蘑菇定律" class="headerlink" title="蘑菇定律"></a>蘑菇定律</h3><p>蘑菇定律是指<strong>初入世者</strong>常常会被<strong>置于阴暗的角落</strong>，<strong>不受重视或打杂跑腿</strong>，就<strong>像蘑菇培育一样还要被浇上大粪</strong>，接受各种无端的批评、指责、代人受过，得不到必要的指导和提携，处于自生自灭过程中。蘑菇生长必须经历这样一个过程，人的成长也肯定会经历这样一个过程。这就是蘑菇定律，或叫萌发定律。</p><h3 id="二八定律（帕累托法则）"><a href="#二八定律（帕累托法则）" class="headerlink" title="二八定律（帕累托法则）"></a>二八定律（帕累托法则）</h3><p>帕累托法则（英语：Pareto principle，也被称为 80/20 法则、关键少数法则、八二法则），是罗马尼亚管理学家<a href="https://baike.baidu.com/item/约瑟夫·朱兰/446413">约瑟夫·朱兰</a>提出的一条管理学原理。该法则以意大利经济学家<a href="https://baike.baidu.com/item/维尔弗雷多·帕累托/9119237">维尔弗雷多·帕累托</a>的名字命名。帕累托于1906年提出了著名的关于意大利社会财富分配的研究结论：<strong>20％的人口掌握了80％的社会财富</strong>。这个结论对大多数国家的社会财富分配情况都成立。因此，该法则又被成为80/20法则。</p><p>朱兰博士在管理学中采纳了该思想，认为在任何情况下，<strong>事物的主要结果只取决于一小部分因素</strong>。这个思想经常被应用到不同的领域，经过大量的试验检验后，被证明其在大部分情况下，都是正确的。所以，该法则对于指导开展管理活动非常有帮助。</p><h3 id="第十名现象"><a href="#第十名现象" class="headerlink" title="第十名现象"></a>第十名现象</h3><p>一个班里最有出息的学生，往往不是学习<a href="https://baike.baidu.com/item/成绩/10020965">成绩</a>最好的前几名，而是班上处于<a href="https://baike.baidu.com/item/中游/3372885">中游</a>的第十名左右的学生。他们既没有优秀生“想赢怕输”的<a href="https://baike.baidu.com/item/负担/10274609">负担</a>，也没有<a href="https://baike.baidu.com/item/差生/28569">差生</a>的自卑心理，敢闯敢拼，这就是“第十名现象”。</p><p>这种现象说明了一个观点：<strong>一个人能否成功不取决于学习成绩的高低</strong>。</p><h3 id="第三人效应"><a href="#第三人效应" class="headerlink" title="第三人效应"></a>第三人效应</h3><p>第三人效应，最早是由<a href="https://baike.baidu.com/item/美国哥伦比亚大学/6181318">美国哥伦比亚大学</a>戴维森教授于 1983 年在《公共舆论季刊》中发表的一篇题为《传播中的第三人效果》论文中提出的。他认为“第三人效果”机制是由于大众在判断<a href="https://baike.baidu.com/item/大众传播/776716">大众传播</a>影响力之际存在着一种普遍的感知定势，即倾向于认为大众媒介的信息在社会层面（对其他人）上的影响与个人层面（对我）上的影响<a href="https://baike.baidu.com/item/大相径庭/559955">大相径庭</a>，前者的影响要比后者大。</p><p>人们倾向于高估大众媒介对他人的认知和行为的影响；具体来说，<strong>劝服传播所面对的受众会认为，这种劝服对他人比对自己有更大的影响。</strong>而且不论是否是信息的直接接受者，对媒介影响他人的预期将会导致自己采取行动。</p><h3 id="罗密欧与朱丽叶效应"><a href="#罗密欧与朱丽叶效应" class="headerlink" title="罗密欧与朱丽叶效应"></a>罗密欧与朱丽叶效应</h3><p>在莎士比亚的经典名剧“罗密欧与朱丽叶”中罗密欧与朱丽叶相爱，但由于双方世仇，他们的爱情遭到了极力阻碍。但压迫并没有使他们分手，反而使他们爱得更深，直到殉情。这样的现象我们叫它“罗密欧与朱丽叶效应”。所谓“罗密欧与朱丽叶效应”，就是当出现干扰恋爱双方爱情关系的外在力量时，恋爱双方的情感反而会加强，恋爱关系也因此更加牢固。</p><p><strong>这种情形不仅发生在男女的爱情之间，也会发生在许多地方。对于越难获得的事物，在人们的心目中地位越重要，价值也会越高。</strong>学者们尝试以阻抗理论（reactance theory）来解释这种现象，他们指出当人们的自由受到限制时，会产生不愉快的感觉，而从事被禁止的行为反而可以消除这种不悦。所以才会发生当别人命令我们不得做什么事时，我们却会反其道而行的现象。在现实生活中，也常常见到这种现象：父母的干涉非但不能减弱恋人们之间的爱情，反而使之增强。父母的干涉越多、反对越强烈，恋人们相爱就越深。</p><h3 id="宜家效应"><a href="#宜家效应" class="headerlink" title="宜家效应"></a>宜家效应</h3><p>宜家效应是<strong>消费者对于自己投入劳动、情感而创造的物品的价值产生高估的价值</strong>判断偏差现象。消费者对于一个物品付出的劳动（情感）越多，就越容易高估该物品的价值。该词源于出售需要顾客自己动手组装家具的“宜家（IKEA)”家具商店。当消费者尝试亲手制作的产品中途放弃没有最终完成时，宜家效应会消失。</p><p>我们对某一事物付出的努力不仅给它带来改变，也改变了自己对它的评价。</p><p>付出越多，产生的爱恋越深。</p><h2 id="人类无法抗拒的10种心理效应"><a href="#人类无法抗拒的10种心理效应" class="headerlink" title="人类无法抗拒的10种心理效应"></a>人类无法抗拒的10种心理效应</h2><h3 id="鸟笼效应"><a href="#鸟笼效应" class="headerlink" title="鸟笼效应"></a>鸟笼效应</h3><p>鸟笼逻辑被认为是人类无法抗拒的10种心理之一，是由一个心理学故事引出的效应。挂一个美丽的鸟笼在房间里最显眼之处，过不了几天，主人必定会做出下面两个选择之一：把鸟笼扔掉，或者买一只鸟回来放在鸟笼里，因为这比无休无止的解释和说明要轻易得多。这就是鸟笼逻辑。</p><p>鸟笼逻辑的原因很简单：<strong>人们绝大部分的时候是采取惯性思维。</strong>并不一定每一个漂亮的鸟笼里都应该装上一只鸟，但可惜的是人们总是逃不出这个逻辑的局限。所以可见在生活和工作中培养逻辑思维是多么重要。<a href="https://baike.baidu.com/item/海阔凭鱼跃，天高任鸟飞">海阔凭鱼跃，天高任鸟飞</a>。不要限制自己的思维，更不要在传统目光的审视下止步不前。敢于挂出一只空鸟笼并能够自然地坚持下去的人，才是有创见、有魄力有主张的人。</p><h3 id="破窗理论"><a href="#破窗理论" class="headerlink" title="破窗理论"></a>破窗理论</h3><p>破窗效应（英语：Broken windows theory）是<a href="https://baike.baidu.com/item/犯罪学/7617600">犯罪学</a>的一个理论，该理论由詹姆士·威尔逊（James Q. Wilson）及乔治·凯林（George L. Kelling）提出，并刊于《The Atlantic Monthly》1982年3月版的一篇题为《Broken Windows》的文章。</p><p>此理论认为<strong>环境中的不良现象如果被放任存在，会诱使人们仿效，甚至变本加厉。</strong>以一幢有<strong>少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。</strong>最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些<a href="https://baike.baidu.com/item/涂鸦/1547">涂鸦</a>没有被清洗掉，很快的，墙上就布满了<a href="https://baike.baidu.com/item/乱七八糟/64494">乱七八糟</a>、<a href="https://baike.baidu.com/item/不堪入目/1759841">不堪入目</a>的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。这个现象，就是<a href="https://baike.baidu.com/item/犯罪心理学/6443">犯罪心理学</a>中的破窗效应。</p><h3 id="旁观者效应（责任分散效应）"><a href="#旁观者效应（责任分散效应）" class="headerlink" title="旁观者效应（责任分散效应）"></a>旁观者效应（责任分散效应）</h3><p>在现场旁观者的数量影响了突发事件中亲社会反应的可能性。当旁观者的数量<strong>增加时</strong>，<strong>任何一个旁观者提供帮助的可能性减少了</strong>，即使他们<strong>采取反应</strong>，反应的时间<strong>也延长了</strong>。</p><p>旁观者效应也称为责任分散效应，是指对某一件事来说，如果是<strong>单个个体</strong>被要求<strong>单独完成任务</strong>，<strong>责任感就会很强</strong>，会作出积极的反应。但如果是<strong>要求一个群体共同完成任务</strong>，<strong>群体中的每个个体的责任感就会很弱</strong>，面对困难或遇到责任往往会退缩。因为前者独立承担责任，后者期望别人多承担点儿责任。“责任分散”的实质就是人多不负责，责任不落实。</p><h3 id="帕金森定律-1"><a href="#帕金森定律-1" class="headerlink" title="帕金森定律"></a>帕金森定律</h3><p>二十世纪西方文化三大发现之一。</p><h3 id="晕轮效应"><a href="#晕轮效应" class="headerlink" title="晕轮效应"></a>晕轮效应</h3><p>晕轮效应又称“成见效应”、“光圈效应”、“日晕效应”，是指在<a href="https://baike.baidu.com/item/人际知觉/10028160">人际知觉</a>中所形成的以点概面或<a href="https://baike.baidu.com/item/以偏概全/543015">以偏概全</a>的主观印象。</p><p>晕轮效应又称<a href="https://baike.baidu.com/item/成见效应/4680228">成见效应</a>、光圈效应等，指<strong>人们在交往认知中，对方的某个特别突出的特点、品质就会掩盖人们对对方的其他品质和特点的正确了解。</strong>这种错觉现象，心理学中称之为“晕轮效应”。美国心理学家H.凯利、S.E.阿希等人在印象形成实验中证实了这一效应的存在。</p><p>晕轮效应除了与人们掌握对方的信息太少有关外，主要还是个人主观推断的泛化，扩张和定势的结果。它往往容易形成人的成见或偏见，产生不良的后果。故在人才选拔、任用和考评过程中应谨防这种倾向发生 。</p><h3 id="霍桑效应"><a href="#霍桑效应" class="headerlink" title="霍桑效应"></a>霍桑效应</h3><p>霍桑效应，指的是在行为田野实验【Field Experiment】中，由于研究对象意识到自己正在被研究，而带来的方法上的人为效应。<strong>当人们在意识到自己正在被关注或者被观察时，就会刻意去改变一些行为或者是言语表达。</strong></p><p>“霍桑效应”给我们的启示是：人在一生中会产生数不清的意愿和情绪，但最终能实现或满足的却为数不多，对那些未能实现的意愿和未能满足的情绪，切莫压抑克制，而应适当地让它宣泄出来，这对人的身心和工作都有利 。</p><h3 id="习得性无助实验"><a href="#习得性无助实验" class="headerlink" title="习得性无助实验"></a>习得性无助实验</h3><p>习得性无助缘自前面所说的美国心理学家塞里格曼做的那项经典实验：起初把狗关在笼子里，只要蜂音器一响，就给以难受的电击，狗关在笼子里逃避不了电击；多次实验后，蜂音器一响，在给电击前，先把笼门打开，此时狗不但不逃而是不等电击出现就卧倒在地开始呻吟和颤抖——本来可以主动地逃避却绝望地等待痛苦的来临，这就是“习得性无助”。</p><p><strong>“习得性无助”指人在最初的某个情境中获得无助感，那么在以后的情境中仍不能从这种关系中摆脱出来，从而将无助感扩散到生活中的各个领域。</strong>这种扩散了的无助感会导致个体的抑郁并对生活不抱希望。在这种感受的控制下，个体会由于认为自己无能为力而不做任何努力和尝试。被认为是人类的一种沮丧表现之一。</p><h3 id="证人的记忆效应"><a href="#证人的记忆效应" class="headerlink" title="证人的记忆效应"></a>证人的记忆效应</h3><p>证人，在我们的认识里，通常都是提供一些客观的<a href="https://baike.baidu.com/item/证据/31088">证据</a>的人，就是把自己亲眼看到、亲耳听到的东西如实地讲出来的人。然而，<a href="https://baike.baidu.com/item/心理学">心理学</a>研究证明，<strong>很多证人提供的证词都不太准确，或者说是具有个人倾向性，带着个人的观点和意识。</strong></p><h3 id="罗森塔尔效应"><a href="#罗森塔尔效应" class="headerlink" title="罗森塔尔效应"></a>罗森塔尔效应</h3><p>罗森塔尔效应，亦称“皮格马利翁效应”、“人际期望效应”，是一种<a href="https://baike.baidu.com/item/社会心理效应/3794110">社会心理效应</a>，指的是教师对学生的殷切希望能戏剧性地收到预期效果的现象。由美国心理学家罗森塔尔和L.雅各布森于1968年通过实验发现。一般而言，这种效应主要是因为教师对高成就者和低成就者分别期望着不同的行为，并以不同的方式对待他们，从而维持了他们原有的行为模式。</p><p>1968年的一天，美国心理学家罗森塔尔和L.雅各布森来到一所小学，说要进行7项实验。 他们从一至六年级各选了3个班，对这18个班的学生进行了“未来发展趋势测验”。之后，罗森塔尔以赞许的口吻将一份<strong>“最有发展前途者”</strong>的名单交给了<strong>校长和相关老师</strong>，并叮嘱他们务必要保密，以免影响实验的正确性。其实，<strong>罗森塔尔撒了一个“权威性谎言”</strong>，因为<strong>名单上的学生是随便挑选出来的</strong>。8个月后，<strong>罗森塔尔和助手们对那18个班级的学生进行复试</strong>，结果奇迹出现了：<strong>凡是上了名单的学生，个个成绩有了较大的进步</strong>，且<a href="https://baike.baidu.com/item/性格">性格</a>活泼开朗，<a href="https://baike.baidu.com/item/自信心">自信心</a>强，<a href="https://baike.baidu.com/item/求知欲">求知欲</a>旺盛，更乐于和别人打交道。</p><h3 id="虚假同感偏差"><a href="#虚假同感偏差" class="headerlink" title="虚假同感偏差"></a>虚假同感偏差</h3><p>虚假同感偏差（false consensus bias），又叫作虚假<a href="https://baike.baidu.com/item/一致性">一致性</a>偏差，是指<strong>人们常常高估或夸大自己的信念、判断及行为的普遍性，它是人们坚信自己信念、判断正确性的一种方式。</strong></p><p>人们总是<strong>无意间夸大自己意见的普遍性</strong>，甚至把<strong>自己的特性也赋予他人身上</strong>，<strong>假定自己与他人是相同的，自己有疑心，就认为社会上的人都是疑心重重</strong>；自己好交际也认为别人好交际。这种虚假同感偏差使你通过坚信自己信念和判断的正确性，获得了自尊和自豪感，但同时也给你带来了决策和选择的错误。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心里社会学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语句式分析</title>
    <link href="/my_world/content/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <url>/my_world/content/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="句子的组成成分"><a href="#句子的组成成分" class="headerlink" title="句子的组成成分"></a>句子的组成成分</h1><ol><li>简单句</li><li>复合句 = 简单句 + 连词 + 简单句</li><li>主从句 = 简单句（主句） + 简单句（从句）</li><li>并列主从句 = 复合句 + 主从句</li></ol><p>连词有for、and、nor、but、or、yet、so，可以用FANBOYS来记忆</p><p>例句：</p><p>简单句：I had breakfast.</p><p>复合句：I had a good breakfast alone at local cafe this morning（第一句简单句）, and（连词）I‘m planning to go again tomorrow（第二句简单句）.（可以看到两句简单句的权重是一样的，就是他们大体都很重要）</p><p>主从句：I had a good breakfast alone at local cafe this morning（简单句主句），even though the place was crowded（简单句从句）.（可以看到第一句简单句权重比第二句简单句大，从句一般是解释和修饰主句的存在）</p><p>并列主从句：I had a good breakfast alone at local cafe this morning（第一句简单句），but（连词） I didn’t feel lonely （第二句简单句）【以上为合并为一句复合句】because the place was busy（第一句简单句从句） and（连词） I watched all the people come and go with coffee in their hands and smiles on their faces（第二句简单句从句）.【修饰第二句简单句，是一句主从句】</p><h1 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h1><h2 id="5大基本句型"><a href="#5大基本句型" class="headerlink" title="5大基本句型"></a>5大基本句型</h2><ol><li>几乎所有的句子是：<strong>主语+谓语</strong><ul><li>Eat food.</li></ul></li><li>有一个动作的承受者：<strong>主语+（及物）动词+宾语</strong><ul><li>I like(动词) you(宾语).</li></ul></li><li>有两个动作的承受者：<strong>主语+（双及物）动词+间接宾语+直接宾语</strong><ul><li>I teach you(间接宾语) english(直接宾语).</li></ul></li><li>对动作承受者的补充：<strong>主语+（复杂及物）动词+宾语+宾语补足语</strong><ul><li>I considers you(宾语) smart(宾语补足语).</li></ul></li><li>把这个词后面的信息赋予给前者：<strong>主语+（系）动词+（主语）补语/表语</strong><ul><li>This cake smells(系动词) nice(主语补语/表语).</li></ul></li></ol><h2 id="其他语类作用"><a href="#其他语类作用" class="headerlink" title="其他语类作用"></a>其他语类作用</h2><ul><li><strong>定语</strong>修饰<strong>主语/宾语</strong></li><li><strong>状语</strong>修饰<strong>谓语动词</strong></li><li><strong>同位语</strong>把<strong>主语</strong>和<strong>宾语</strong>再说一遍</li></ul><h2 id="语类总结"><a href="#语类总结" class="headerlink" title="语类总结"></a>语类总结</h2><ul><li>主语</li><li>谓语</li><li>宾语<ul><li>间接</li><li>直接</li></ul></li><li>宾语补足语</li><li>定语</li><li>状语</li><li>同位语</li></ul><h2 id="词类"><a href="#词类" class="headerlink" title="词类"></a>词类</h2><ol><li><strong>名词</strong>（Nouns）：表示人或者物<ul><li>Apple</li></ul></li><li><strong>冠词</strong>（Articles）：说明人和事物<ul><li>a</li></ul></li><li><strong>代词</strong>（Pronouns）：代替人和物<ul><li>I</li></ul></li><li><strong>形容词</strong>（Adjectives）：形容人和物<ul><li>smart</li></ul></li><li><strong>数词</strong>（Numerals）：表数量<ul><li>two</li></ul></li><li><strong>副词</strong>（Adverbs）：修饰动作或形容词<ul><li>quickly</li></ul></li><li><strong>介词</strong>（Prepositions）：表示和其他词关系的词<ul><li>with</li></ul></li><li><strong>叹词</strong>（Interjections）：表感叹<ul><li>Ah!</li></ul></li><li><strong>连词</strong>（Conjunctions）：连接词和句<ul><li>and，because</li></ul></li></ol><h2 id="如何找谓语"><a href="#如何找谓语" class="headerlink" title="如何找谓语"></a>如何找谓语</h2><p>以下为对刘晓燕考研英语的笔记</p><p>一句话一定要具备主谓结构，并且主语一定是谓语动作的发出者。如果有宾语的话，宾语一定是谓语动作的承受者。</p><blockquote><p>分类</p></blockquote><p>1、主谓</p><p>2、主谓宾</p><p>谓语：实意动词</p><p>3、主谓表（主系表）</p><p>谓语：系动词</p><p>4、主谓双宾（写得少）</p><p>5、主谓宾宾补（写得少）</p><p>主谓宾与主谓表的不同在于：俩结构的谓语不同。</p><p>系动词：</p><ol><li>be</li><li>感官动词：look、smell、taste、sound、feel</li><li>变化：become get</li><li>保持：keep stay remain</li></ol><blockquote><p>成分（词性的问题）</p></blockquote><p>一、谓语</p><p>1、谓语的成分</p><p>有时态的实意动词或系动词充当谓语</p><p>2、一句话中动词能不能多？</p><p>谓语只能是<strong>动词</strong>；<strong>动词</strong>只能做谓语；所有不做谓语的动词全部变成不是动词</p><p>动词转换成不是动词（非  谓语动词）：v-ing；v-ed；to do</p><p>He <u>beating my shoulder, saying nothing</u>,departed.</p><p>3、一句话中动词能不能少？</p><p>绝对不能，当一句话需要动词而没有动词的时候，加be动词，并且be动词没有意思</p><p>谓语的总结：一句话中，有且只能有一个有时态的实义动词或系动词的存在，并且充当谓语。</p><p>二、主语</p><p>1、主语的成分</p><p>名词、代词、非谓语动词</p><h1 id="完形填空"><a href="#完形填空" class="headerlink" title="完形填空"></a>完形填空</h1><h2 id="动词的做题方法"><a href="#动词的做题方法" class="headerlink" title="动词的做题方法"></a>动词的做题方法</h2><ol><li>看主语和宾语的逻辑关系来做题</li><li>看主语<ol><li>主语必须是人的动词有：doubt，intend，require，regard，be impressed by，believe，notice等</li><li>主语必须是物的动词有：manifest等</li></ol></li><li>看宾语<ol><li>看宾语是人还是物<ol><li>只跟人做宾语的谓语动词：assure，impress，side with等</li><li>可跟人可跟物的动词：ensure，agree with等</li></ol></li><li>看宾语是抽象名词还是具体名词（若完形填空分数要求不高可忽略）<ol><li>跟抽象名词做宾语：enhance</li><li>跟具体名词做宾语：fasten；label；feed</li><li>即跟抽象又跟具体名词的有：tighten</li></ol></li></ol></li><li>根据跟动词构成习惯搭配的介词及介词后的宾语</li><li>看动词后面有无宾语</li><li>看修饰该动词的成分</li></ol><h2 id="名词的做题方法"><a href="#名词的做题方法" class="headerlink" title="名词的做题方法"></a>名词的做题方法</h2><ol><li>看名词周围的定语或者同位语成分</li><li>如果没有，看名词充当的成分<ol><li>充当主语（看主谓宾的逻辑关系）</li><li>充当宾语（通过谓语动词判断动宾搭配的一致性）</li><li>充当表语（主语是最佳提示线索）</li></ol></li><li>Prep+n（通过已知介词和名词的习惯搭配）</li></ol><h2 id="形容词的做题方法"><a href="#形容词的做题方法" class="headerlink" title="形容词的做题方法"></a>形容词的做题方法</h2><ol><li>形容词作定语时，其修饰的名词是关键提示线索</li><li>形容词+名词+补充线索（定语、同位语）</li><li>形容词作表语时，主语作为被修饰成分是相关提示线索</li><li>副词修饰形容词，副词就是线索</li></ol><h2 id="副词的做题方法"><a href="#副词的做题方法" class="headerlink" title="副词的做题方法"></a>副词的做题方法</h2><ol><li>根据语法来确定副词题的定位线索</li><li>根据副词所在的语境来做题</li></ol><h2 id="逻辑关系题的做题方法"><a href="#逻辑关系题的做题方法" class="headerlink" title="逻辑关系题的做题方法"></a>逻辑关系题的做题方法</h2><ol><li>常见的逻辑关系词<ol><li>并列关系：and，and also，or，neither…nor…， either…..or，not only… but also，likewise，similarly，equally，in the same way，that is (to say)，as well as，the same as</li><li>递进关系：also，then，besides，in addition，additionally，moreover，what’s more，furthermore，above all，indeed</li></ol></li></ol><h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><h2 id="长难句"><a href="#长难句" class="headerlink" title="长难句"></a>长难句</h2><blockquote><p>引用<a href="https://zhuanlan.zhihu.com/p/55688022">考研英语长难句怎么破？ - 知乎 (zhihu.com)</a></p></blockquote><p>结构：分裂、嵌套、平行</p><ol><li>分裂结构：将一个简单的句子分成好几段。<ul><li>I know someone who always cuts sketches out from newspapers of model clothes that she would like to buy if she had the money.</li></ul></li><li>嵌套结构：在一个句子里面套一个从句，再在从句里面套从句。<ul><li>It hoped they would learn how shop floor lighting affected workers productivity。</li></ul></li><li>平行结构：好几个成分并列在一起。<ul><li>Your semester grade is based not only on how well you do on each test,but also on how you participate in class.</li></ul></li></ol><h2 id="翻译方法"><a href="#翻译方法" class="headerlink" title="翻译方法"></a>翻译方法</h2><p>拆、译、调</p><p>基本句 + 修饰 -&gt; 长句子 + 从句 -&gt; 长难句</p><p>拆（3-4段）：</p><p>一、拆分点法：</p><ol><li><strong>标点符号</strong>：冒号；分号：逗号</li><li><strong>关系词</strong>：who,whom, whose,what, which,that（关系代词）和how,why（关系副词）</li><li><strong>连词</strong>：and,or,but,yet,for等并列连词； when,as, since, until. before,after<br>where, because, since, although, so that,等状语从句连接词</li><li>介词：on,in,wth,at,of,to等</li><li>不定式符号to</li><li>分词：过去分词(done)和现在分词( doing)</li></ol><p>二、预感法（少部分）</p><p>译：</p><ul><li><p>when等翻译：在那个xxxx</p></li><li><p>同位语从句加“：”</p></li></ul><p>调：调整语调</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>音：随机</li><li>形：随机</li><li>意：一样</li><li>序：<ul><li>不变序<ul><li>5大基本句型</li><li>并列句（and）</li><li>符号分割</li><li>句子太长</li><li>目的，结果，伴随状语</li></ul></li><li>变序<ul><li>后置定语</li><li>状语</li></ul></li></ul></li></ul><h2 id="翻译顺序"><a href="#翻译顺序" class="headerlink" title="翻译顺序"></a>翻译顺序</h2><ol><li>找出作者想<strong>表达的意味</strong></li><li>无论句子多么复杂，将句子看作为一整块的简单句，先圈出<strong>谓语</strong>，接下来根据<strong>谓语</strong>圈出<strong>主语块、宾语块</strong></li><li>继续将<strong>主语块</strong>拆分，找出<strong>真正的主语</strong>；继续将<strong>宾语块</strong>拆分，找出<strong>真正的宾语</strong>。</li><li>将<strong>谓语</strong>和<strong>真正的主语</strong>、<strong>真正的主语</strong>拼接，做<strong>主干句子</strong></li><li>将<strong>主干句子</strong>翻译出来</li><li>翻译出<strong>主语修饰的部分</strong>，注意修饰部分的针对对象，修饰部分的倾向是<strong>主语</strong>就把<strong>关注点放在主语上</strong>，为<strong>主语服务</strong></li><li>翻译出<strong>宾语修饰的部分</strong>，注意修饰部分的针对对象，修饰部分的倾向是<strong>宾语</strong>就把<strong>关注点放在宾语上</strong>，为<strong>宾语服务</strong></li><li>将所有翻译的结果融合成一个句子。注意<strong>后置定语和状语</strong>，融合的时候需要变序。</li><li>可以将翻译的句子优化，追求信达雅</li></ol><h1 id="阅读错误总结"><a href="#阅读错误总结" class="headerlink" title="阅读错误总结"></a>阅读错误总结</h1><ol><li>没有找准句子</li><li>没有总结全文的主题（句子、句段）</li><li>没有概述句子的大体意思</li></ol><h2 id="写作错误总结"><a href="#写作错误总结" class="headerlink" title="写作错误总结"></a>写作错误总结</h2><ol><li>忘记名词复数转换</li><li>动词的词性转换，第三人称+s等</li><li>时态转换</li></ol>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语句子/作文模板以及语法探究</title>
    <link href="/my_world/content/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%AD%90-%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF%E4%BB%A5%E5%8F%8A%E8%AF%AD%E6%B3%95%E6%8E%A2%E7%A9%B6/"/>
    <url>/my_world/content/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%AD%90-%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF%E4%BB%A5%E5%8F%8A%E8%AF%AD%E6%B3%95%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习都是从模板后延伸，特别是应试考试，作文、句子模板起到了至关重要的作用。</p><h2 id="句子模板"><a href="#句子模板" class="headerlink" title="句子模板"></a>句子模板</h2><h3 id="大作文句子模板"><a href="#大作文句子模板" class="headerlink" title="大作文句子模板"></a>大作文句子模板</h3><p>用于<strong>考研英语</strong>中的大作文，该句式来源于b站的up主【<a href="https://space.bilibili.com/677131884">Fiona的英语美食</a>】，BV1Na4y1W7Wu。</p><ol><li>The picture virturally drips with(sarcasm（讽刺）/inspiration（灵感）/criticism（批评）…) when it comes to …<ul><li>图片里充满了/传达出……意味</li><li>eg：The picture virtually drips with sarcasm when it comes to how we behave towards our environment.（关于我们对待环境的行为，这张图片充满了讽刺）</li></ul></li><li>Behind the (superficial/phenomenon/sarcasm) lies the/a perception that …<ul><li>……的背后是…….的认知</li><li>eg：Behind such behavion lies a perception that people still lack the awareness of environmental protection.（这种行为的背后是一种现象，那就是人们依然缺乏环保意识）</li></ul></li><li>There is a convenient excuse for …..<ul><li>（我们）很容易找到（做某事）的借口</li><li>eg：There is a convenient excuse for putting things off.（我们很容易找到拖延的借口）</li></ul></li><li>This lack of (insights/consciousness …) is what often leads (us) to …<ul><li>正是因为缺乏……，导致（我们）…….</li><li>eg：This lack of optimism is what often leads (us) to a depressing mood.（缺乏乐观的态度会导致（我们）情绪沮丧）</li></ul></li><li>Let us set our sights upon ….<ul><li>让我们把目光投向…</li><li>eg：Let us set our sights upon some remedial work.（让我们着眼于补救工作）</li></ul></li><li>Our audacity to … helps push the boundaries of ….<ul><li>有勇气做某事，有助于推动……的边界</li><li>eg：Our audacity to take a step forward helps push the boundaries of possibility.（向前迈出一步，就是无限可能）</li></ul></li><li>…. is subject to …,so we should recalibrate …<ul><li>… 受 … 的影响，所以我们应该重新调整 … 的行为</li><li>eg：Our attitude to take a step forward helps push the boundaries of possibility.（向前迈出一步，就是无限可能）</li></ul></li><li>Only by translating … into …,can we …<ul><li>只有把 …… 转化为 …… ， 才能实现 …….. 的目的</li></ul></li><li>This is the right approach for (us) to …<ul><li>这是 ……. 的正确途径</li><li>eg：This is the right approach for us to make a better choice.（向前迈出一步，就是无限可能）</li></ul></li><li>Therefore ,it is safe to say that / We can safely arrive at this idea that / We can establish that…<ul><li>因此,这是以较稳妥的方式 …….</li><li>eg：Therefore , we can safely arrive at this idea that companionship is a recipe for a harmonious family.（我们可以得出一个结论，陪伴是一个和谐家族的必要因素）</li></ul></li></ol><h2 id="作文模板"><a href="#作文模板" class="headerlink" title="作文模板"></a>作文模板</h2><h3 id="大作文模板"><a href="#大作文模板" class="headerlink" title="大作文模板"></a>大作文模板</h3><blockquote><p>引用<a href="https://www.bilibili.com/video/BV1gy4y1z7uE?from=search&amp;seid=503992939144972780">考研英语大作文万能模板｜英语一、英语二_哔哩哔哩_bilibili</a>；<a href="https://www.bilibili.com/video/BV1ub4y1b7f9/?spm_id_from=333.788.recommend_more_video.0">【考研英语作文】中间段怎么写（下）| 源自外刊（The Economist）的万能模板句型_哔哩哔哩_bilibili</a></p></blockquote><p>字数在答题卡中大概为17-18行左右</p><p>句型安排</p><ol><li>第一段：图画/表描述</li><li>第二段：揭示图片寓意，展开说明论证 + 具体措施</li><li>第三段：总结全文 +  畅想未来</li></ol><p>自己总结的模板：</p><ol><li>第一段：The picture virturally drips with sarcasm/inspiration/criticism when it comes to …（主题，图片背后的意味）. It can be seen that,图片内容核心句（sb doing something+prep+n,ving+定语从句(what,which,when,who,where).By contrast（若图片是对比类型的）+另外一个方面）</li><li>第二段：<ol><li>Behind the (instructive（寓意哲理，行为行事）/phenomenon（社会现象）) lies the/a perception that … （揭示现象出现的原因）<ol><li>Much of this can be blamed on…（拟人修辞揭示原因，协同第一句）【社会现象】</li><li>… is an ingredient of…,and it lights the way to… （…是…的要素，并点亮了通往…的道路）【寓意哲理】</li><li>///【行为行事】</li></ol></li><li>Admittedly,<ol><li>… has put us on the paths of… while bring…（正面阐述现象，诚然，…让我们有了…的趋势，同时带来…）【社会现象】</li><li>///However,more than often,we are mired in …,killing one’s chances/slamming the door of … （人们却经常陷入….，从而失去了…的机会）【寓意哲理】</li><li>there is a convenient excuse for… （论述错误做法，我们很容易找到做…的借口）, and it all boils down to a lack of … （错误做法的原因）【行为行事】</li></ol></li><li>However,<ol><li>on the flip side,… is felt in…（引出社会现象存在的问题）【社会现象】</li><li>///This lack of … is what often leads us to … （正是因为缺乏…，导致我们…）【寓意哲理】</li><li>… is the very condition to … （…才是…促成的条件）【行为行事】</li></ol></li><li><ol><li>And it is exemplified by the case illustrated in the above picture.（图片就是一个例证，凑字数，可加可不加）///【社会现象】</li><li>Actually,  … is the very condition to … （其实，…才是促成…的条件）【寓意哲理】</li><li>All this gives enough grounds to … （鉴于此，我们有理由..）///【行为行事】</li></ol></li><li>So,<ol><li>we should recalibrate our way of… since… is subject to…（总结，鉴于此，我们应该重新调整….的行为，因为…为受到…的影响）【社会现象】</li><li>do sth. This will yield fruitful results.（总结，我们应该怎么做）【寓意哲理】【行为行事】</li></ol></li></ol></li><li>第三段：To conclude,at the center of this issue is the need to…（总结）.This is the right approach for (us) to …（结论）</li></ol><p>中间段的模板：</p><ol><li><p>社会现象：Much of this can be blamed on…（拟人修辞揭示原因）Admittedly,… has put us on the trajectory of… while bring…（正面阐述现象，诚然，…让我们有了…的趋势，同时带来…）However,on the flip side,… is felt in…（引出社会现象存在的问题）And it is exemplified by the case illustrated in the above picture.（图片就是一个例证，凑字数）For the reason,we should recalibrate our way of… since… is subject to…（总结，鉴于此，我们应该重新调整….的行为，因为…为受到…的影响）</p><ol><li>Behind such phenomenon lies a perception that, peoples misbehaviors have weighed on our beautiful landscape, and much of this can be blamed on our lack of environmental awareness.<br>Admittedly, modernization, urbanization and industrialization have put us on the trajectory of rapid development while bringing us great convenience. However, on the flip side, man-made damage is felt everywhere in day-to-day life,and it is actually exemplified by the case illustrated in the above picture. For this reason,we should recalibrate our way of interacting with the environment since sustainable development is subject to the harmonious coexistence between man and nature</li><li>这种现象揭示出，人们的不当行为给我们的美丽家园造成了沉重的负担。这在很大程度上归咎于人们缺乏环保意识。诚然，现代化、城市化和工业化进程使我们走上了快速发展的轨道，同时给我们带来了极大的便利。然而，从方面看，我们在生活中随处可以感受到人为因素造成的破坏。图中的事例就说明了这一点。鉴于此，我们应该重新调整人类与环境的互动方式。因为可持续发展取决于人与自然的和谐共存</li><li>揭示行为原因—正面阐述—反面阐述—方法论（揭原因—阐正面—诉反面—方法论）</li></ol></li><li><p>寓意哲理：… is an ingredient of…,and it lights the way to… （…是…的要素，并点亮了通往…的道路）However,more than often,we are mired in …,killing one’s chances/slamming the door of … （人们却经常陷入….，从而失去了…的机会）This lack of … is what often leads us to … , and acts as a drag on… （正是因为缺乏…，导致我们…，并构成了…的阻碍）Actually, … is measured by … , and … is the very condition to … （其实，…是由…来衡量的，而…才是促成…的条件）So,do sth. This is a recipe for…, and will yield fruitful results.（总结，我们应该怎么做）</p><ol><li>Behind this instructive drawing lies a perception that, optimism is an essential ingredient of happiness, and it lights the way to helpful actions. However, more than often, people tend to be mired in pessimism when there is a loss, slamming the door of optimism about what they have been left. This lack of positive attitude is what often leads us to a dark mood, and acts as a drag on our practice of moving ahead. Actually, happiness is measured by our own feeling of satisfaction, and a positive mindset is the very condition to impel man to unfold his power. So see the bright side when facing a setback. This is a recipe for a satisfying life, and will yield fruitful results</li><li>这幅具有启发性的图画揭示出，乐观是幸福感的基本要素，可以引导我们采取有益的行动。然而，更多时候，人们会因为失去而陷入悲观，却没有乐观地看到自己还有些什么。这种积极态度的缺失往往使我们陷入负面情绪，阻碍了我们前进的脚步。其实，幸福是由我们自身的满足感来衡量的。而积极的心态正是推动人们施展能力的条件。这是美好生活的秘诀，并将使你的人生硕果累累。</li><li>揭示寓意—通常情况下人们的意识/行为—揭示该意识/行为会带来什么结果—我们应该采取什么样的意识/行为—方法论（揭寓意—提日常—说后果—定行为—方法论）</li></ol></li><li><p>行为行事：Admittedly,there is a convenient excuse for… （论述错误做法，我们很容易找到做…的借口）, and it all boils down to a lack of … （错误做法的原因）However , … is the very condition to … （…才是…促成的条件）Likewise , the ripple effect of … allows us to tap into .. and sow a sense of …（…的涟漪效应，使我们能够…并产生…感） All this gives enough grounds to … （鉴于此，我们有理由..）So , do sth.It promises to (put you on the road to)…（所以，只要…做，我们就可以（通往）…）</p><ol><li>Behind this instructive drawing lies a perception that, our satisfaction of “having books” will eat into our motive of “reading books”. Admittedly, there is a convenient excuse for delaying our reading, and it all boils down to a lack of motivated intention. However, tangible action is the very condition to impel man to unfold his power. Likewise, the ripple effect of massive reading allows us to tap into our potential and sow a sense of confidence. All this gives enough grounds to read books instead of having books only. So, make a plan of reading right away. It promises to put you on the road to a treasure of knowledge</li><li>这幅具有启发性的图画表明，我们对”有书”的满足感，会消减我们”读书”的积极性。诚然，我们很容易找到借口把阅读行动一拖再拖，这都是因为我们缺乏主动性。然而，切实的行动是促使人们施展能力的条件。同样，大量阅读的涟漪效应，能够使我们挖掘自身潜力，并获得自信心。鉴于此，我们应该去阅读书籍，而不只是满足于拥有书籍。立刻指定你的读书计划吧，这将助你通向知识的宝库。</li><li>揭示行为原因—反面阐述—论述正面做法—顺水推舟继续论述—方法论（揭原因—阐反面—推正面—强引用—方法论）</li></ol></li></ol><h3 id="小作文模板"><a href="#小作文模板" class="headerlink" title="小作文模板"></a>小作文模板</h3><blockquote><p>引用<a href="https://www.bilibili.com/video/BV1P541157Ti?from=search&amp;seid=503992939144972780">考研英语小作文万能模板｜英语一、英语二_哔哩哔哩_bilibili</a></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">小作文类型</th><th style="text-align:center">directions—关键词</th></tr></thead><tbody><tr><td style="text-align:center">书信/信函</td><td style="text-align:center">email/letter/reply</td></tr><tr><td style="text-align:center">通知/告示</td><td style="text-align:center">notice</td></tr><tr><td style="text-align:center">备忘录、报告</td><td style="text-align:center">memo/memorandum，report</td></tr></tbody></table></div><p>最后的两种格式（备忘录、报告，memo/memorandum，report）考到的几率很小，但是不排除考到的情况，所以也需要认识到。字数在答题卡中的体现为10行。所有核心句加起来应该要大于40词。</p><blockquote><p> 格式</p></blockquote><p><strong>备忘录：</strong></p><p>To: Staff （收件人）</p><p>From: John Smith（发件人）</p><p>Date: May 1st, 2015（日期）</p><p>Subject: The modification for existing promotional mode（主题，首字母大写）</p><p>第一段</p><p>第二段</p><p>第三段</p><p><strong>报告：</strong></p><p>与备忘录一致</p><p>人物报告参考行文格式如下：</p><p>第一段：作者生平简介</p><p>第二段：作者作品的内容介绍</p><p>第三段：对作者综合性评价</p><p><strong>通知：</strong></p><p>Notice（首字母大写并居中）</p><p>第一段</p><p>第二段</p><p>第三段</p><p>署名（首字母大写）</p><p>（可以不写时间）</p><p><strong>书信：</strong></p><p>Dear xxx,（左对齐）</p><p>第一段（一个\t）</p><p>第二段</p><p>第三段</p><p>Yours sincerely（右对齐）</p><p>姓名（右对齐）</p><blockquote><p>模板</p></blockquote><p><strong>书信：</strong></p><div class="table-container"><table><thead><tr><th>分类</th><th>用途</th><th>注意事项</th></tr></thead><tbody><tr><td>私人信函</td><td>写给熟人家人（亲戚朋友同学）等</td><td>对方知道你是谁，不用自我介绍，可以寒暄</td></tr><tr><td>公务信函</td><td>写给学校领导、十字会、慈善机构等</td><td>对方不知道你是谁，需要自我介绍，不能寒暄，不礼貌</td></tr></tbody></table></div><p>书信的种类大体分为情感类和信息类。</p><ol><li>情感类：表达情感，“欣喜、感动”，“喜欢、感兴趣”，“不喜欢、厌恶”，“困扰、担忧”，“惭愧、悔恨”，“悲伤、同情”。</li><li>信息类：讲具体信息，需要有细节。以下除感谢信、道歉信以外的。</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">书信的种类</th><th style="text-align:center">Directions中的关键词</th><th style="text-align:center">信件词</th></tr></thead><tbody><tr><td style="text-align:center">感谢信</td><td style="text-align:center">thanks，appreciation，gratitude，etc.</td><td style="text-align:center">appreciation</td></tr><tr><td style="text-align:center">道歉信</td><td style="text-align:center">sorry，apology，apologize，etc.</td><td style="text-align:center">apology</td></tr><tr><td style="text-align:center">建议信</td><td style="text-align:center">suggesting，suggestions，advise，advice，etc.</td><td style="text-align:center">suggestion</td></tr><tr><td style="text-align:center">咨询信</td><td style="text-align:center">inquiry，consult，etc.</td><td style="text-align:center">inquiry</td></tr><tr><td style="text-align:center">辞职信</td><td style="text-align:center">quit，leave，depart，resign，resignation，etc.</td><td style="text-align:center">resignation</td></tr><tr><td style="text-align:center">推荐信</td><td style="text-align:center">share，recommend，recommendation，etc.</td><td style="text-align:center">recommendation</td></tr><tr><td style="text-align:center">投诉信</td><td style="text-align:center">complain，complaint，dissatisfaction，etc.</td><td style="text-align:center">complaints</td></tr><tr><td style="text-align:center">邀请信</td><td style="text-align:center">invite，invitation，etc.</td><td style="text-align:center">invitation</td></tr><tr><td style="text-align:center">介绍信</td><td style="text-align:center">specify，introduce，introduction，tell，etc.</td><td style="text-align:center">introduction</td></tr></tbody></table></div><p>称呼：</p><ul><li>写给机构：<ul><li>Dear Sir or Madam,</li><li>To Whom It May Concern,（致有关人士）</li></ul></li><li>写给集体：<ul><li>Dear Friends,</li><li>Dear Fellow Classmates,</li></ul></li><li>写给个人：<ul><li>题目有姓名：Dear+文中给出的内容，长辈论辈分写,</li><li>题目只有姓：Dear Mr.xx（男）,| Ms.xx（女）,</li><li>题目只有名：Dear xx,</li><li>题目有职位/统称：<ul><li>Dear Manager,（经理）</li><li>Dear President,（主席）</li><li>Dear Editor,（编辑）</li><li>Dear experts,（专家）</li><li>Dear professor Smith,（史密斯教授）</li><li>Dear volunteer,（志愿者）</li></ul></li><li>题目无人名：<ul><li>Dear Mr.Zhang,（自己编）</li><li>Dear Sir or Madam,</li></ul></li></ul></li></ul><p>全文：（笔者自己总结）</p><p>私人：</p><p>Dear xxx,</p><p>第一段：I’m very pleased to hear from you. I produce this letter to you in order to …（写作目的）</p><p>第二段：I could write a book just to describe my （信件词）for what （you/I）have done.核心句1，核心句2【感情类】/There are two reasons for my（信件词）which you can observe here.核心句1，核心句2【信息类】</p><p>第三段：I wish you good health and lots of happiness. Many thanks to you for your kindness and timely help. I’m looking forward to your favorable reply at your earliest convenience.</p><p>落款：Yours sincerely,（右对齐）</p><p>姓名：自己的姓名，看题目。</p><p>模板大致意思，用于<strong>辅助背诵</strong>，该意思不是整篇文章的意思（甚至有中文的语法错误）：</p><p>第一段：我很开心能听到你的消息。我将该信发给你的目的是…. 。</p><p>第二段：我可以写一本书来描述我…的感受因为你的所作所为。（感情类）/这里有两个原因来说明我的….你可以从这里看到</p><p>第三段：我希望你身体健康和快乐多多。非常感谢你亲切和及时的帮助。我期待在您方便的时候尽早得到您的满意答复。<br>公务：</p><p>Dear xxx,</p><p>第一段：I’m a staff member of … （工作人员）. I produce this letter to you in order to …（写作目的）</p><p>第二段：I could write a book just to describe my （信件词）for what （you/I）have done.核心句1，核心句2【感情类】/There are two reasons for my（信件词）which you can observe here.核心句1，核心句2【信息类】</p><p>第三段：Many thanks to you for your kindness and timely help. I’m looking forward to your favorable reply at your earliest convenience.</p><p>落款：Yours sincerely,（右对齐）</p><p>姓名：自己的姓名，看题目。</p><p>模板大致意思，用于<strong>辅助背诵</strong>，该意思不是整篇文章的意思（甚至有中文的语法错误）：</p><p>第一段：我是某xx的工作人员。我将该信发给你的目的是…. 。</p><p>第二段：我可以写一本书来描述我…的感受因为你的所作所为。（感情类）/这里有两个原因来说明我的….你可以从这里看到</p><p>第三段：非常感谢你亲切和及时的帮助。我期待在您方便的时候尽早得到您的满意答复。</p><p><strong>通知/告示</strong>：</p><p>类型：</p><ol><li>一个活动+邀请/鼓励大家参加</li><li>一个活动+招募志愿者</li></ol><p>模板：（笔者自己总结）</p><p>Notice（首字母大写并居中）</p><p>第一段：In order to 活动目的，we are going to organize a 活动,which is to be held on 时间 in 地点. 人物A,人物B,人物C and 人物 D will be invited to be the quests of honor.</p><p>第二段：（We are now searching for volunteers for the coming event. He or she should have nice appearance and temperament, and should be good at commuication and cooperation.【招募志愿者】）（Every participant will be issued a certificate of this event.）Those who are interested in the coming event are supposed to sign up with 人/机构 before 截止时间. Please come on time and don’t be late.</p><p>第三段：Everybody is welcome to be present on the occasion. For more details, please pay a visit to our offical website or Wechat.</p><p>署名（首字母大写，右对齐）</p><p>可以不写时间</p><p>模板大致意思，用于<strong>辅助背诵</strong>，该意思不是整篇文章的意思（甚至有中文的语法错误）：</p><p>第一段：为了…..，我们在组织一场活动，在xxx（时间）的xxx（地点）举办。A，B，C会被邀请来到这场活动</p><p>第二段：（我们现在在寻找志愿者。他/她应该有着优秀的品质和擅长与沟通合作）（所有的参与者会拿到相应的证书）。那些有兴趣想要来的应该在xxxx（人/机构）登记在xxxx（截止时间）之前。请及时到不要迟到了。</p><p>第三段：欢迎所有的人来出席这次活动。想要看更多的细节，请观察我们官方的网站或者微信。</p><h1 id="主题词"><a href="#主题词" class="headerlink" title="主题词"></a>主题词</h1><h2 id="个人品质类"><a href="#个人品质类" class="headerlink" title="个人品质类"></a>个人品质类</h2><p>理想：ideal, ambition, dream,goal</p><p>创新：creation, innovation, critical mind, critical thinking</p><p>独立：independence, being independent, self-reliance</p><p>顺境与逆境：Favorable Circumstances and adverse Circumstances</p><p>勤奋：hard working, diligence, painstaking efforts</p><p>谨慎：prudence and determination</p><p>坚持/毅力：perseverance, persistence, determination</p><p>热情和乐观：enthusiasm and optimism</p><p>博学和求知：learnedness and seeking knowledge/pursuit of knowledge</p><p>活力：vitality</p><p>身强体壮,充满活力：bursting with vitality and good health</p><p>独立：independence</p><p>感恩：gratitude, gratification</p><p>鼓励：encouragement</p><p>真诚：sincerity</p><p>宽容：humanity, love, understanding and tolerance</p><p>谦逊：being modest</p><p>勇敢：Courage and bravery</p><p>敬业精神：professional dedication and professional ethics</p><p>业务水平：competence</p><p>简朴：simplicity</p><p>谦逊、耐心：moderation and patience</p><p>适应性：adaptability</p><p>羡慕：admiration</p><p>榜样：example. model</p><p>时间管理：time management</p><p>守时：punctuality</p><h2 id="社会风尚类"><a href="#社会风尚类" class="headerlink" title="社会风尚类"></a>社会风尚类</h2><p>爱国主义：Patriotism</p><p>网购：online shopping</p><p>海淘：overseas purchasing</p><p>网络空间：cyberspace</p><p>偶像崇拜：idol worship</p><p>网红：influencer</p><p>人际关系：interpersonal relationship</p><p>家庭纽带：family bond</p><p>金融安全：financial security</p><p>食品安全：food safety</p><p>外卖食品：take-out food</p><p>代沟：generation gap</p><p>有效沟通：effective communication</p><p>相互信任：mutual trust</p><p>学术诚信：academic integrity</p><p>宽容：tolerance</p><p>同情心：sympathy</p><p>善心：benevolence</p><p>光盘行动：clear-your-plate campaign</p><p>遵守社会规范：abiding by social norms</p><p>社会公德：social morality</p><p>中华传统美德：traditional Chinese values</p><p>勤：hardworking</p><p>俭：thrift</p><p>信：honest</p><p>孝：filial piety/filial duty/filial respect</p><p>礼：courtesy</p><p>仁：benevolence, humanity and humaneness</p><p>爱：affection</p><p>现代美德：modern virtues</p><h2 id="环保健康类"><a href="#环保健康类" class="headerlink" title="环保健康类"></a>环保健康类</h2><p>环境保护：environmental preservation/environmental protection</p><p>垃圾分类：trash sorting, rubbish separation</p><p>生态平衡：ecological balance</p><p>可持续发展：sustainable development</p><p>清洁能源：clean energy</p><p>可再生资源：renewable resources</p><p>可回收产品：recyclable products</p><p>低碳生活：low carbon lifestyles</p><p>公共交通工具：public transportation</p><p>环境友好型经济：enviromental-friendly economy</p><p>共享经济：sharing economy</p><p>水土流失：soil erosion</p><p>野生动物保护：wildlife protection</p><p>均衡饮食：balanced diet</p><p>食品安全：food safety</p><p>宅男宅女：home body</p><p>勤俭：plain living</p><h2 id="经济文化类"><a href="#经济文化类" class="headerlink" title="经济文化类"></a>经济文化类</h2><p>文化差异：cultural difference</p><p>文化交融：cultural blending</p><p>文化认同：cultural identity</p><p>文化遗产：cultural heritage</p><p>传统文化：traditional culture</p><p>外来文化：exotic culture</p><p>继承和发扬传统：inherit and carry forward the tradition</p><p>基础设施：infrastructure</p><p>收入结构：Income structure</p><p>可支配收入：disposable income</p><p>生活水平：living standards</p><p>购买力：purchasing power</p><p>阅读偏好：reading preference</p><p>消费习惯：consumption habits</p><p>高端消费：high-end consumption</p><p>扫码经济：QR economy</p><p>快餐文化：fast food culture</p><p>消费者权益：the interest of consumers</p><p>三包：three R guarantees</p><p>品牌忠诚：brand loyalty</p><p>国货：domestic products</p><p>出国旅游：traveling abroad</p><p>出境游：outbound tourism</p><p>境内游：inbound tourism</p><p>名胜：tourist attraction</p><p>景点：place of interest</p><p>文化融合：Cultural integration/combination/fusion/blending/ mixing</p><p>文化交流：Cultural exchange/communication/interchange/ Interaction</p><p>文化传播：Cultural transmission</p><p>跨文化：inter-culture,cross-culture;alien culture;foreign culture</p><p>文化多样性：cultural diversity</p><h2 id="心态品质类"><a href="#心态品质类" class="headerlink" title="心态品质类"></a>心态品质类</h2><p>广阔的眼界：wide horizons</p><p>诚实守信：honesty, credibility and being trustworthy</p><p>时间管理：time management</p><p>平和的态度：peaceful states of mind</p><p>积极的态度：positive states of mind</p><p>精神满足：mental satisfaction</p><p>归属感：sense of belonging</p><p>安全感：sense of security</p><p>自我价值的实现和公众的认可：self- actualization and recognition from the public</p><p>独立：independence</p><p>适应能力：adaptation</p><p>自力更生：self-reliance</p><p>团对精神：team-work spirit</p><p>自律：self-discipline</p><p>进取心：enterprising spirit</p><p>首创精神：initiative</p><p>面对因难的勇气：courage to face adversity</p><p>迎接挑战的勇气：courage to take challenges</p><p>挫败：frustration</p><p>设身处地为别人着想：put oneself to others’ shoes</p><p>脚踏实地的品质：down-to-earth quality</p><p>志愿者精神：volunteer spirit</p><p>契约精神：spirit of contract, observation of the law</p><p>社会公德：public morals</p><p>梦想的力量：the power of dream</p><p>相信科学：belief in science</p><p>为人民服务的意识：consciousness of serving the people</p><p>团结互助：solidarity and helping each other</p><p>遵纪守法：observation of the law</p><h2 id="工作学习类"><a href="#工作学习类" class="headerlink" title="工作学习类"></a>工作学习类</h2><p>学业表现：academic performance</p><p>课外活动：extracurricular activities</p><p>学以致用：put into practice what one has learned</p><p>素质教育：quality-oriented education</p><p>学校教育：schooling education</p><p>家庭教育：family education</p><p>终身教育：lifelong education</p><p>创业：start one’ s own business</p><p>跳槽：job hopping</p><p>深造：pursue further education</p><p>出国留学：study abroad</p><p>专业知识：specialized knowledge</p><p>通识：generalized knowledge</p><p>虚拟课堂：virtual class</p><p>在线学习：online study</p><p>在线选课：online course selection</p><p>必修课：compulsory courses</p><p>选修课：selective courses</p><p>劳动力市场：job market</p><p>求职：job hunting</p><p>就业方向：employment orientation</p><p>同辈压力：peer pressure</p><p>体面的工作：decent jobs</p><p>理想的工作：desirable jobs</p><p>学习和娱乐取得平衡：balance between study and entertainment</p><p>因材施教：teach in accordance with their aptitude</p><p>共性：general character</p><p>特性：specific character</p><p>多种选择：diverse choice</p><p>多种期待：diverse expectations</p><p>深度学习：in-depth study</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
      <tag>英语语法</tag>
      
      <tag>句子模板</tag>
      
      <tag>作文模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化测试框架大总结（一）</title>
    <link href="/my_world/content/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/my_world/content/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自动化测试一般是指软件测试的自动化，软件测试就是在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。它是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。由于以下原因，自动化测试非常重要：</p><ul><li>手动测试所有工作流、所有阶段都需要花费时间和金钱</li><li>手动测试多语言站点很困难</li><li>软件测试中的自动化测试不需要人工干预</li><li>自动化测试可提高测试执行速度</li><li>自动化有助于增加测试范围</li><li>长时间手工测试可能会变得很无聊，因此容易出错</li></ul><blockquote><p>引用<a href="https://zhuanlan.zhihu.com/p/353489122">软件测试入门系列之七：自动化测试 - 知乎 (zhihu.com)</a></p></blockquote><h1 id="哪些测试用例可以自动化"><a href="#哪些测试用例可以自动化" class="headerlink" title="哪些测试用例可以自动化"></a>哪些测试用例可以自动化</h1><blockquote><p>引用<a href="https://zhuanlan.zhihu.com/p/353489122">软件测试入门系列之七：自动化测试 - 知乎 (zhihu.com)</a></p></blockquote><p>可以使用以下标准选择要自动化的测试用例，以提高自动化的投资回报率</p><ul><li>高风险-关键业务测试案例</li><li>重复执行的测试用例</li><li>非常繁琐或难以手动执行的测试用例</li><li>耗时的测试用例</li></ul><p>以下类别的测试用例不适合自动化：</p><ul><li>新设计的测试用例，并且至少一次不手动执行</li><li>需求经常变化的测试用例</li><li>临时执行的测试用例</li></ul><h1 id="自动化测试流程"><a href="#自动化测试流程" class="headerlink" title="自动化测试流程"></a>自动化测试流程</h1><blockquote><p>引用<a href="https://zhuanlan.zhihu.com/p/353489122">软件测试入门系列之七：自动化测试 - 知乎 (zhihu.com)</a></p></blockquote><p>自动化过程中遵循以下步骤</p><ol><li>选择测试工具</li><li>定义自动化范围</li><li>规划，设计和开发</li><li>测试执行</li><li>维护</li></ol><h1 id="使用语言"><a href="#使用语言" class="headerlink" title="使用语言"></a>使用语言</h1><p>以下均使用python作为主要的计算机语言，虽然有些可以使用其他的语言，比如说java。</p><p><strong>python 特点/特性：</strong></p><ul><li>易于学习，入门所需时间极短</li><li>少量代码即可实现功能，python代码非常精简，只需要少量代码即可构造更多功能</li><li>可扩展性非常好，python上有各种各样的模块、工具库，导入即可使用</li><li>支持多平台Windows/Linux/macOS，python作为目前美国高校最受欢迎的编程语言之一，可在多个领域平台中广泛使用</li><li>可与多种编程语言集成（C/Java/C#/ObjectC/Ruby等），且实现稳定性一流</li></ul><h1 id="设备连接"><a href="#设备连接" class="headerlink" title="设备连接"></a>设备连接</h1><ul><li>真机（Android）</li><li>Android 模拟器</li><li>电脑（Web自动化等）</li></ul><p>注意，Web自动化需要安装驱动，下面会提及</p><p>真机需要连接上电脑，然后在真机上打开USB调试方可使用</p><h1 id="Airtest"><a href="#Airtest" class="headerlink" title="Airtest"></a>Airtest</h1><p>官网：<a href="https://airtest.netease.com/">Airtest Project (netease.com)</a></p><p>教程：<a href="https://airtest.doc.io.netease.com/tutorial/1_quick_start_guide/">5分钟上手自动化测试——Airtest+Poco快速上手 - Airtest Project Docs (netease.com)</a><br>文档：<a href="https://airtest.readthedocs.io/zh_CN/latest/all_module/airtest.core.api.html">airtest.core.api module — airtest 文档</a></p><p>Airtest是一套跨平台的测试框架，它提供了跨平台的API，包括安装应用、模拟输入、断言等。 基于图像识别技术定位UI元素，你无需嵌入任何代码即可进行自动化测。测试脚本运行后可以自动生成详细的HTML测试报告，让你迅速定位失败的测试点，适用于游戏和App，支持平台有Windows、Android和iOS。</p><p>Airtest 集成的多个测试框架，基于web自动化测试的selenuim框架，基于Chrome Devtools Protocol协议，自动录制生成selenium脚本，精确定位与操作界面元素，支持多浏览器（Chrome、Safari、Firfox等主流浏览器）；Poco基于UI控件识别的自动化框架，目前支持Unity3D/cocos2dx-/Android原生app/iOS原生app/微信小程序，也可以在其他引擎中自行接入poco-sdk来使用。</p><p>AirtestIDE 是一个强大的GUI工具，是网易配套推出的跨平台UI自动化测试编辑器，它内置了Airtest和Poco的相关插件功能，可以帮助你快速简单地完成录制/编写测试脚本。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>进入官网安装Airtest IDE即可。</p><p>python需要使用pip安装，命令为：</p><div class="code-wrapper"><pre><code class="hljs shell">pip install airtest</code></pre></div><h2 id="官方Demo"><a href="#官方Demo" class="headerlink" title="官方Demo"></a>官方Demo</h2><p>官方Demo总会有它的价值。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *<span class="hljs-comment"># 通过ADB连接本地Android设备</span>connect_device(<span class="hljs-string">&quot;Android:///&quot;</span>)<span class="hljs-comment">#安装待测软件apk，路径信息。</span>install(<span class="hljs-string">&quot;path/to/your/apk&quot;</span>)<span class="hljs-comment">#开始运行app</span>start_app(<span class="hljs-string">&quot;com.pingan.certicationApp&quot;</span>)<span class="hljs-comment">#点击某个图片，Airtest中基于图像识别语法，图片自己提供。</span>touch(Template(<span class="hljs-string">&quot;image_of_a_button.png&quot;</span>))<span class="hljs-comment">#滑动语音，开头图片跟结尾图片</span>swipe(Template(<span class="hljs-string">&quot;slide_start.png&quot;</span>), Template(<span class="hljs-string">&quot;slide_end.png&quot;</span>))<span class="hljs-comment">#添加断言的图片</span>assert_exists(Template(<span class="hljs-string">&quot;success.png&quot;</span>))<span class="hljs-comment">#点击Android上的返回键</span><span class="hljs-comment">#keyevent(&quot;BACK&quot;)</span><span class="hljs-comment">#点击Android上的Home键返回</span><span class="hljs-comment">#home()</span><span class="hljs-comment">#uninstall(&quot;package_name_of_your_apk&quot;)</span></code></pre></div><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p>在AirtestIDE中新建的脚本，后缀都为 <code>.air</code> ，但实际上我们在运行的时候， <strong>运行的是.air目录下的同名.py文件</strong> 。因此，就像一个普通的python脚本那样，当我们需要使用airtest的接口时（例如touch指令），我们需要在.py脚本的最前面import airtest的api。我们可以在AirtestIDE里新建一个脚本，就能看到默认的初始化代码:</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span>__author__ = <span class="hljs-string">&quot;user&quot;</span><span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *<span class="hljs-comment"># 从api中import接口后，就能直接使用airtest的各个接口了</span>auto_setup(__file__)  <span class="hljs-comment"># 自动初始化设备</span></code></pre></div><p>在Airtest中，需要编写大量的截图语句，像这样:</p><div class="code-wrapper"><pre><code class="hljs python">touch(Template(<span class="hljs-string">&quot;image_of_a_button.png&quot;</span>))</code></pre></div><p>其中的 <code>Template(&quot;xx.png&quot;)</code> 即为一个图片对象，如果要手工进行截图和代码编写，工作量会比较大，因此这里推荐大家使用专用的 <a href="http://airtest.netease.com/">AirtestIDE</a> 进行截图语句的开发，会使脚本的编写事半功倍。</p><p>在 <a href="http://airtest.netease.com/">官网</a> 下载AirtestIDE，解压后即可使用，里面附带的Airtest辅助窗对于编写Airtest的脚本语句来说十分便捷：</p><p><img src="https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/airtest_api_info/airtest_assistant.png" alt="鼠标悬停即可"></p><p>鼠标放在Airtest辅助窗的按钮上能看到相关接口参数信息，直接点击按钮就能生成对应的语句，或是可以直接在当前连接的设备画面上进行截图，截取完成后将会在脚本窗口生成带截图的语句。</p><h2 id="apk操作"><a href="#apk操作" class="headerlink" title="apk操作"></a>apk操作</h2><h3 id="打开app"><a href="#打开app" class="headerlink" title="打开app"></a>打开app</h3><p>虽然打开app时可以使用Airtest截图打开，但是请注意：<strong>打开应用尽量使用start_app而不是截图脚本</strong>相对用截图脚本来启动应用，脚本会更加简洁，兼容性也会更好。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打开网易云音乐</span>start_app(<span class="hljs-string">&quot;com.netease.cloudmusic&quot;</span>)</code></pre></div><p>查看打开的app的包名有3种办法</p><p><strong>第一种</strong></p><p>cmd中输入命令：<code>adb shell am monitor</code><br>然后启动需要获取包名的应用</p><p><strong>第二种</strong></p><p>cmd中输入命令：<code>adb shell pm list packages -3</code><br>查看自己安装的app包名</p><p><strong>第三种</strong></p><p>下载雷电模拟器的包名类名查看器，找到app后直接点击复制包名（方便快捷）</p><p>下载地址：<a href="https://www.ldmnq.com/app/210.html">包名类名查看器电脑版下载<em>包名类名查看器PC版下载</em>雷电安卓模拟器 (ldmnq.com)</a></p><h3 id="停止应用运行"><a href="#停止应用运行" class="headerlink" title="停止应用运行"></a>停止应用运行</h3><div class="code-wrapper"><pre><code class="hljs python">driver.close_app()</code></pre></div><h3 id="安装-卸载应用"><a href="#安装-卸载应用" class="headerlink" title="安装/卸载应用"></a>安装/卸载应用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 安装应用</span>install(<span class="hljs-string">r&quot;D:\demo\tutorial-blackjack-release-signed.apk&quot;</span>)<span class="hljs-comment"># 卸载应用</span>uninstall(<span class="hljs-string">&quot;com.netease.cloudmusic&quot;</span>)</code></pre></div><h2 id="调用本地adb执行测试"><a href="#调用本地adb执行测试" class="headerlink" title="调用本地adb执行测试"></a>调用本地adb执行测试</h2><p>阅读源码可知道，airtest使用的是自带的adb，这个时候就需要调用系统的adb才能不进行冲突，修改源码：</p><p><code>%python_home%\site-packages\airtest\core\android\android.py</code></p><p>如果是linux，使用<code>which adb</code>寻找adb</p><p>第45行中，ADB初始化的时候加形参<code>adb_path</code>，让它等于自己的adb：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># init adb</span>self.adb = ADB(self.serialno,adb_path=<span class="hljs-string">&quot;F:/environment/Android_SDK/platform-tools/adb.exe&quot;</span>,server_addr=host, display_id=self.display_id, input_event=self.input_event)self.adb.wait_for_device()</code></pre></div><h2 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h2><p>在执行代码过程中，不可避免会到更改手机状态的操作，这个时候需要用到shell命令来调试手机，Airtest中的driver封装了执行shell命令的方法。</p><p>获取当前设备/连接当前设备</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 连接设备</span>dev = connect_device(<span class="hljs-string">&quot;Android:///device1&quot;</span>)<span class="hljs-comment"># 获取当前设备</span>dev = device()</code></pre></div><p>运行adb shell命令</p><div class="code-wrapper"><pre><code class="hljs python">dev.shell(<span class="hljs-string">&quot;dumpsys wifi | grep mWifiInfo&quot;</span>) <span class="hljs-comment"># 检查wifi网络状态</span>dev.shell(<span class="hljs-string">&quot;svc wifi disable&quot;</span>) <span class="hljs-comment"># 关闭wifi</span>dev.shell(<span class="hljs-string">&quot;svc wifi enable&quot;</span>) <span class="hljs-comment"># 开启wifi</span>dev.shell(<span class="hljs-string">&quot;svc data disable&quot;</span>) <span class="hljs-comment"># 关闭数据网络</span>dev.shell(<span class="hljs-string">&quot;svc data enable&quot;</span>) <span class="hljs-comment"># 开启数据网络</span></code></pre></div><h2 id="Android自动化测试常用API"><a href="#Android自动化测试常用API" class="headerlink" title="Android自动化测试常用API"></a>Android自动化测试常用API</h2><p><strong>auto<em>setup(_<em>file</em></em>)</strong>：自动初始化设备，脚本运行命令行有两种形式，命令行中的参数包含<code>device</code>、<code>log</code>等</p><div class="code-wrapper"><pre><code class="hljs python">auto_setup(__file__) <span class="hljs-comment"># 在运行时的命令行中如果传入了类似--device Android:///这样的设备参数，那么脚本在初始化时会自动连上对应的设备，不需要再另外写代码连接了。</span>auto_setup(__file__,devices=[<span class="hljs-string">&quot;Android://127.0.0.1:5037/5PZTQWQOGES8RWUG&quot;</span>]) <span class="hljs-comment"># 如果没有在初始化时连上设备，可以在接口中指定运行脚本的设备，或者使用connect_device接口来连接设备。</span></code></pre></div><p><strong>device()</strong>：获取到当前使用中的设备。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 在Android中，有一个平台独有的接口list_app可以列出所有安装过的应用</span>dev = device()  <span class="hljs-comment"># 先获取到当前设备对象，这里的dev即是一个Android对象</span><span class="hljs-built_in">print</span>(dev.list_app())  <span class="hljs-comment"># 然后就可以调用平台独有接口了</span></code></pre></div><p><strong>connect_device()</strong>：连接设备，其中<code>127.0.0.1</code>代表本机IP，<code>5037</code>是默认的<code>adb port</code>，<code>serialno</code>是<code>android</code>手机的序列号。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *<span class="hljs-comment"># 连上第一台手机</span>dev1 = connect_device(<span class="hljs-string">&quot;Android://127.0.0.1:5037/serialno1&quot;</span>) <span class="hljs-comment"># 连上第二台手机</span>dev2 = connect_device(<span class="hljs-string">&quot;Android://127.0.0.1:5037/serialno2&quot;</span>)</code></pre></div><p><strong>set_current()</strong>：在多个设备中进行切换</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 第一种：传入数字0、1、2等，切换当前操作的手机到Airtest连接的第1台、第2台、第3台手机</span>set_current(<span class="hljs-number">0</span>)set_current(<span class="hljs-number">1</span>)set_current(<span class="hljs-number">2</span>)<span class="hljs-comment"># 第二种：切换当前操作的手机到序列号为serialno1、serialno2的手机</span>set_current(<span class="hljs-string">&quot;serialno1&quot;</span>)set_current(<span class="hljs-string">&quot;serialno2&quot;</span>)</code></pre></div><p><strong>touch()</strong>：点击操作，可以是图片，也可以是坐标（坐标可以是绝对，可以是动态，推荐使用动态，可以在不同手机的分辨率下点击正确的位置）</p><div class="code-wrapper"><pre><code class="hljs python">touch(Template(<span class="hljs-string">r&quot;scriptshots/tpl1623669702383.png&quot;</span>, record_pos=(<span class="hljs-number">0.177</span>, -<span class="hljs-number">0.018</span>), resolution=(<span class="hljs-number">1600</span>, <span class="hljs-number">900</span>))) <span class="hljs-comment"># 根据录制脚本时所截取的图像进行点击</span>touch([<span class="hljs-number">500</span>,<span class="hljs-number">500</span>]) <span class="hljs-comment"># 绝对坐标点击</span>w,h = dev.get_current_resolution() <span class="hljs-comment"># 获取当前手机分辨率</span>touch([<span class="hljs-number">0.5</span>*w, <span class="hljs-number">0.5</span>*h]) <span class="hljs-comment"># 动态坐标点击，推荐使用</span></code></pre></div><p><strong>wait()</strong>：可以等待画面中某个图片出现，如果在指定的时间范围内匹配到了该图片，就会返回图片所处位置的焦点，否则抛出<code>TargetNotFoundError</code>异常</p><div class="code-wrapper"><pre><code class="hljs python">wait(Template(<span class="hljs-string">r&quot;tpl1606821804906.png&quot;</span>))  <span class="hljs-comment"># timeout after ST.FIND_TIMEOUT</span><span class="hljs-comment"># find Template every 3 seconds, timeout after 120 seconds</span>wait(Template(<span class="hljs-string">r&quot;tpl1606821804906.png&quot;</span>), timeout=<span class="hljs-number">120</span>, interval=<span class="hljs-number">3</span>)<span class="hljs-comment"># 可以在每次查找目标失败时，指定一个回调函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notfound</span>():</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No target found&quot;</span>)wait(Template(<span class="hljs-string">r&quot;tpl1607510661400.png&quot;</span>), intervalfunc=notfound)</code></pre></div><p><strong>swipe()</strong>：可以从一个位置滑动到另外一个位置</p><div class="code-wrapper"><pre><code class="hljs python">swipe(Template(<span class="hljs-string">r&quot;tpl1574067097045.png&quot;</span>), vector=[<span class="hljs-number">0</span>, -<span class="hljs-number">0.5</span>]) <span class="hljs-comment"># 以图片的坐标为原点，向下滑动0.5</span>w,h = d.get_current_resolution()swipe([<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.5</span>*h],vector=[<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>]) <span class="hljs-comment"># 以屏幕中间为原点，向上滑动0.5</span>swipe([<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.3</span>*h],[<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.8</span>*h]) <span class="hljs-comment"># 一个坐标滑动到另外一个坐标</span>swipe(Template(<span class="hljs-string">r&quot;tpl1574067097045.png&quot;</span>),Template(<span class="hljs-string">r&quot;tpl1574054095465.png&quot;</span>)) <span class="hljs-comment"># 一个图片的坐标滑动到另外一个图片的坐标</span>swipe([<span class="hljs-number">0.5</span>*w,<span class="hljs-number">0.3</span>*h],Template(<span class="hljs-string">r&quot;tpl1574067097045.png&quot;</span>)) <span class="hljs-comment"># 一个坐标滑动到一个图片的坐标</span></code></pre></div><p><strong>exists()</strong>：判断画面中是否存在某个图片,如果匹配到图片，返回图片所处位置的焦点，否则返回False</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> exists(Template(<span class="hljs-string">r&quot;tpl1606822430589.png&quot;</span>)):touch(Template(<span class="hljs-string">r&quot;tpl1606822430589.png&quot;</span>))</code></pre></div><p><strong>text()</strong>：输入文本</p><div class="code-wrapper"><pre><code class="hljs python">text(<span class="hljs-string">&quot;test&quot;</span>)text(<span class="hljs-string">&quot;test&quot;</span>, enter=<span class="hljs-literal">False</span>)<span class="hljs-comment"># enter – 是否在输入完毕后，执行一次 Enter ，默认是True</span>text(<span class="hljs-string">&quot;test&quot;</span>, search=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 在Android上，有时你需要在输入完毕后点击搜索按钮</span></code></pre></div><p><strong>sleep()</strong>：线程挂起</p><div class="code-wrapper"><pre><code class="hljs py">sleep(<span class="hljs-number">10</span>) <span class="hljs-comment"># 括号里面的单位为秒S</span></code></pre></div><p><strong>keyevent()</strong>：输入某个键，例如 home、back 等等</p><div class="code-wrapper"><pre><code class="hljs python">keyevent(<span class="hljs-string">&quot;HOME&quot;</span>)<span class="hljs-comment"># 按Home键</span></code></pre></div><p><strong>pinch()</strong>：指定放大还是缩小，还可以指定中心位置点和放大缩小的比率</p><div class="code-wrapper"><pre><code class="hljs python">pinch(in_or_out=<span class="hljs-string">&#x27;out&#x27;</span>, center=(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>), percent=<span class="hljs-number">0.4</span>)<span class="hljs-comment"># in_or_out后可输入&quot;in&quot;或者&quot;out&quot;，意思是缩小、放大</span></code></pre></div><p><strong>assert_exists()</strong>：设备屏幕上存在断言目标</p><div class="code-wrapper"><pre><code class="hljs python">assert_exists(Template(<span class="hljs-string">r&quot;tpl1607324047907.png&quot;</span>), <span class="hljs-string">&quot;assert exists&quot;</span>)</code></pre></div><p><strong>assert_not_exists()</strong>：设备屏幕上不存在断言目标</p><div class="code-wrapper"><pre><code class="hljs python">assert_not_exists(Template(<span class="hljs-string">r&quot;tpl1607324047907.png&quot;</span>), <span class="hljs-string">&quot;assert not exists&quot;</span>)</code></pre></div><p><strong>assert_equal()</strong>：断言两个值相等</p><div class="code-wrapper"><pre><code class="hljs python">assert_equal(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, msg=<span class="hljs-string">&quot;assert 1==1&quot;</span>)</code></pre></div><p><strong>assert_not_equal()</strong>：断言两个值不相等</p><div class="code-wrapper"><pre><code class="hljs python">assert_not_equal(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, msg=<span class="hljs-string">&quot;assert 1!=2&quot;</span>)</code></pre></div><p>assert_exists()与assert_equal()的区别在于，assert_exists断言的对象是图片，assert_equal断言的对象是数值</p><p><strong>snapshot()</strong>：截图到指定的路径下</p><div class="code-wrapper"><pre><code class="hljs python">snapshot(filename=<span class="hljs-string">&#x27;xxx/test.jpg&#x27;</span>,mag=<span class="hljs-string">&#x27;截图成功&#x27;</span>)</code></pre></div><h2 id="wifi远程运行"><a href="#wifi远程运行" class="headerlink" title="wifi远程运行"></a>wifi远程运行</h2><p>前面这些方法都是通过有线连接运行的，但是在无线下，Airtest也能运行，这和uiautomator如出一辙</p><p>确保手机开启了usb调试，用数据线把手机和电脑连接起来，之后在终端里面执行命令：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> tcpip <span class="hljs-number">8112</span></code></pre></div><p>其中的端口号可以自行设定，但不能和已有的端口冲突。执行后出现<code>restarting in TCP mode port</code>字样就可以将数据线拔下了。</p><p>在手机的wifi设置上，找到正在连接wifi的IP地址</p><p><img src="../../image/image-20220323144010699.png" alt="wifi大概设置"></p><p>之后在Airtest IDE中找到远程设备连接，输入：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">adb</span> connect <span class="hljs-number">192.168.31.165:8112</span></code></pre></div><p>192.168.31.165就是IP，8112就是设置的端口号，点击连接后，刷新ADB即可</p><p><img src="../../image/image-20220323144452676.png" alt="设置"></p><p>注意：</p><ul><li>更换一个网络环境需要使用新IP重新connect即可。</li><li>但是如果手机重启了，就需要重新连接数据线再次开启端口。</li><li>开启端口可以通过adb，也可以直接在手机上打开，但一般需要root权限和特殊软件。</li></ul><h2 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h2><p><strong>录屏功能仅适用于安卓平台</strong>，所以当测试设备是安卓真机或者部分安卓模拟器时才能够对脚本的运行过程进行录屏操作。</p><p>在命令行使用 <code>airtest run</code> 运行脚本时，可以通过添加 <code>--recording</code> 参数来录制脚本运行的视频。（运行结束后，录屏文件会默认保存在log文件夹里面，使用 <code>recording_手机序列号</code> 来命名录屏文件）</p><div class="code-wrapper"><pre><code class="hljs python">airtest run <span class="hljs-string">&quot;D:\test\Airtest_example.air&quot;</span>  --device android://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">5037</span>/emulator-<span class="hljs-number">5554</span>?cap_method=MINICAP_STREAM^&amp;^&amp;ori_method=MINICAPORI^&amp;^&amp;touch_method=MINITOUCH --log <span class="hljs-string">&quot;D:/test\41f68fdf265d8c13998d0a1a7b992889&quot;</span> --recording</code></pre></div><p>也可以在脚本中开启关闭录屏</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 开启录屏</span>recorder.start_recording(max_time=<span class="hljs-number">10</span>)<span class="hljs-comment"># 结束录屏</span>recorder.stop_recording(output=<span class="hljs-string">&quot;test.mp4&quot;</span>)</code></pre></div><h2 id="Windows自动化测试常用API"><a href="#Windows自动化测试常用API" class="headerlink" title="Windows自动化测试常用API"></a>Windows自动化测试常用API</h2><p><strong>device()</strong>：连接设备</p><div class="code-wrapper"><pre><code class="hljs python">win = device()</code></pre></div><p><strong>key_press(key)</strong>：通过发送键盘扫描码模拟键盘按键按下</p><div class="code-wrapper"><pre><code class="hljs python">win.key_press(<span class="hljs-string">&#x27;W&#x27;</span>)</code></pre></div><p><strong>key_release(key)</strong>：通过发送键盘扫描码模拟键盘按键释放</p><div class="code-wrapper"><pre><code class="hljs python">win.key_release(<span class="hljs-string">&#x27;W&#x27;</span>)</code></pre></div><p><strong>mouse_move(pos)</strong>：模拟鼠标移动</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> win32apix, y = win32api.GetCursorPos()win.mouse_move((x+<span class="hljs-number">10</span>, y+<span class="hljs-number">10</span>))</code></pre></div><p><strong>mouse_down(button)</strong>：模拟鼠标按下（鼠标左右键或其他）</p><div class="code-wrapper"><pre><code class="hljs python">win.mouse_down(<span class="hljs-string">&#x27;right&#x27;</span>)</code></pre></div><p><strong>mouse_up(button)</strong>：模拟鼠标释放（鼠标左右键或其他）</p><div class="code-wrapper"><pre><code class="hljs python">win.mouse_up(<span class="hljs-string">&#x27;right&#x27;</span>)</code></pre></div><h2 id="Windows脚本一些常见问题以及解决方案"><a href="#Windows脚本一些常见问题以及解决方案" class="headerlink" title="Windows脚本一些常见问题以及解决方案"></a>Windows脚本一些常见问题以及解决方案</h2><h3 id="游戏窗口嵌入问题"><a href="#游戏窗口嵌入问题" class="headerlink" title="游戏窗口嵌入问题"></a>游戏窗口嵌入问题</h3><p>一些游戏在使用窗口嵌入模式时会出现包括无法框选窗口或者画面消失在内的问题。如果窗口无法框选的话，可以尝试搜索窗口。如果连接窗口以后整个游戏窗口消失的话，可以选择无嵌入模式。如果仍旧无法连接窗口，可以尝试桌面模式。</p><p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/search.png" alt="搜索窗口"></p><p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/no_embedded.png" alt="无嵌入模式"></p><p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/desk.png" alt="桌面模式"></p><h3 id="使用桌面模式的图像脚本处理"><a href="#使用桌面模式的图像脚本处理" class="headerlink" title="使用桌面模式的图像脚本处理"></a>使用桌面模式的图像脚本处理</h3><p>因为使用了桌面模式，如果你的脚本当中涉及到图像识别，那很有可能在跑脚本的过程中识别到脚本中的图像，而不是游戏画面当中的图像。此时可以右键单击脚本，选择 <strong>图片/代码模式切换</strong> ，将模式转换成代码模式，就能顺利运行脚本了。</p><p><img src="https://airtest.doc.io.netease.com/tutorial/img_12/mode.gif" alt="运行gif图"></p><h3 id="PC游戏的光标限制"><a href="#PC游戏的光标限制" class="headerlink" title="PC游戏的光标限制"></a>PC游戏的光标限制</h3><p>一些PC游戏对光标进行了限制，玩家无法将光标移出游戏画面以外。在编写脚本的时候，可以利用<code>Tab+Alt</code>的方式进行窗口切换。</p><h2 id="IOS的WebDriverAgent安装过程"><a href="#IOS的WebDriverAgent安装过程" class="headerlink" title="IOS的WebDriverAgent安装过程"></a>IOS的WebDriverAgent安装过程</h2><p>在进行IOS的自动化测试中，我们需要用到WebDriverAgent来驱动手机。所以需要用到MacOS的Xcode来编译安装（作者已经试过用Windows，事实证明只能用MacOS来安装WebDriverAgent）。但是Windows用户占大部分，不可能让他们为了某个需求而专门买一台MacOS系统的电脑，所以需要在Windows中将MacOS系统装进虚拟机中。</p><p>关于Vmware安装MacOS的教程，链接如下：</p><p><a href="https://zhuanlan.zhihu.com/p/337036027">全网最详细的VMware虚拟机安装MacOS系统教程，没有之一！！！附全部资源 - 知乎 (zhihu.com)</a></p><p>在【使用记事本打开后缀为<code>.vmx</code>的[macOS 10.14.vmx]的文件】这一部分的添加代码，语句应如下：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">smc.version</span> = <span class="hljs-string">&quot;0&quot;</span><span class="hljs-attr">cpuid.0.eax</span> = <span class="hljs-string">&quot;0000:0000:0000:0000:0000:0000:0000:1011&quot;</span><span class="hljs-attr">cpuid.0.ebx</span> = <span class="hljs-string">&quot;0111:0101:0110:1110:0110:0101:0100:0111&quot;</span><span class="hljs-attr">cpuid.0.ecx</span> = <span class="hljs-string">&quot;0110:1100:0110:0101:0111:0100:0110:1110&quot;</span><span class="hljs-attr">cpuid.0.edx</span> = <span class="hljs-string">&quot;0100:1001:0110:0101:0110:1110:0110:1001&quot;</span><span class="hljs-attr">cpuid.1.eax</span> = <span class="hljs-string">&quot;0000:0000:0000:0001:0000:0110:0111:0001&quot;</span><span class="hljs-attr">cpuid.1.ebx</span> = <span class="hljs-string">&quot;0000:0010:0000:0001:0000:1000:0000:0000&quot;</span><span class="hljs-attr">cpuid.1.ecx</span> = <span class="hljs-string">&quot;1000:0010:1001:1000:0010:0010:0000:0011&quot;</span><span class="hljs-attr">cpuid.1.edx</span> = <span class="hljs-string">&quot;0000:0111:1000:1011:1111:1011:1111:1111&quot;</span><span class="hljs-attr">featureCompat.enable</span> = <span class="hljs-string">&quot;TRUE&quot;</span></code></pre></div><blockquote><p>参考：<a href="https://blog.csdn.net/weixin_42848413/article/details/115260253">VMware16安装Mac11.1Big Sur遇到“客户机操作系统已禁用 CPU。请关闭或重置虚拟机。”解决方案<em>strzlz的博客-CSDN博客</em>客户端操作系统已禁用cpu,请关闭或重置虚拟机</a></p></blockquote><p>成功安装MacOS虚拟机后，在虚拟机的网络设置中直接调整为【桥接模式】即可用MacOS上网</p><p><a href="https://mp.weixin.qq.com/s/rAy4fB5MOCFC48o5pYK9pA">脱离Mac搞iOS自动化，tidevice工具教你轻松实现！</a></p><h2 id="终端筛选日志级别"><a href="#终端筛选日志级别" class="headerlink" title="终端筛选日志级别"></a>终端筛选日志级别</h2><p>运行脚本后，终端除了最上面的1条运行脚本的命令之外，剩余的就是一些 [debug]、[info]等log信息，如果只关注log里面的[error]信息，可以在脚本代码开头加上 <code>log</code> 级别的设定：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span>__author__ = <span class="hljs-string">&quot;user&quot;</span><span class="hljs-keyword">import</span> logginglogger = logging.getLogger(<span class="hljs-string">&quot;airtest&quot;</span>)logger.setLevel(logging.ERROR)</code></pre></div><p>这样运行时只会在初始化手机时会有少量 <code>log</code> 输出，初始化完毕后就能够对 <code>logger</code> 进行过滤了。</p><p>若是在Airtest IDE中运行脚本，则只需要在log输出窗口中直接点击筛选即可。</p><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><ol><li>使用airtest ide运行</li><li>使用命令行运行脚本</li></ol><div class="code-wrapper"><pre><code class="hljs python">airtest run untitled.air --device Android:///手机设备号 --log log/ <span class="hljs-comment"># 使用airtest命令运行</span>python -m airtest run untitled.air --device Android:///手机设备号 --log log/ <span class="hljs-comment"># 使用python命令行运行</span>airtest run test.air --device Android:/// --log logs/ --no-image<span class="hljs-comment"># 使用airtest命令运行，但不保存截图</span></code></pre></div><p>关于安卓的手机设备号码，其字符串定义为<code>Android://&lt;adbhost[localhost]&gt;:&lt;adbport[5037]&gt;/&lt;serialno&gt;</code>，其中，adbhost是adb server所在主机的ip，默认是本机127.0.0.1，adb port默认是5037，<strong>serialno是android手机的序列号</strong>。更多adb的方面的内容请参考文档<a href="https://developer.android.com/studio/command-line/adb?hl=zh-cn"> ADB</a> 。</p><p>在平时的脚本运行中，我们一般可以这样写:</p><ul><li>什么都不填写，会默认取当前连接中的第一台手机：<code>Android:///</code></li><li>连接本机默认端口连的一台设备号为79d03fa的手机：<code>Android://127.0.0.1:5037/79d03fa</code></li><li>用本机的adb连接一台adb connect过的远程设备，注意10.254.60.1:5555其实是serialno：<code>Android://127.0.0.1:5037/10.254.60.1:5555</code></li><li>连接一个Windows窗口，窗口句柄为123456：<code>Windows:///123456</code></li><li>连接一个Windows窗口，窗口名称匹配某个正则表达式：<code>Windows:///?title_re=Unity.*</code></li><li>连接windows桌面，不指定任何窗口：<code>Windows:///</code> </li><li>连接iOS手机：<code>iOS:///127.0.0.1:8100</code></li></ul><p><strong>注意：</strong> 如果自己拼写的设备字符串无法正确连接设备，但是在AirtestIDE中可以正常连接的话，可以考虑先在AirtestIDE中运行一次脚本，然后将运行时自动生成的命令行里 <code>--device Android:///</code> 参数复制出来，即可在代码中使用了，这种做法可以极大程度避免设备字符串编写错误的问题。</p><p>除了上述命令行外，也可以通过python调用命令行输入命令来达到目的，这样就可以直接在python中开启.air项目</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding=utf8 -*-</span><span class="hljs-keyword">import</span> osos.system(<span class="hljs-string">&quot;airtest run test01.air --device Android:///127.0.0.1:7555&quot;</span>)</code></pre></div><p>注意，该.py文件需要放在.air文件夹外面，具体目录如下</p><p><img src="../../image/代码运行目录演示.png" alt="目录演示"></p><h2 id="用bat文件执行Airtest脚本"><a href="#用bat文件执行Airtest脚本" class="headerlink" title="用bat文件执行Airtest脚本"></a>用bat文件执行Airtest脚本</h2><p>首先看下如何新建 <code>.bat</code> 文件。首先我们需要在电脑上新建一个 <code>.txt</code> 文件，并输入以下内容：</p><div class="code-wrapper"><pre><code class="hljs awk">::关闭回显@echo off::切换到D盘D:::进入D盘的test目录cd D:\test::执行 airtest run 命令start airtest run newsLogin.air<span class="hljs-keyword">exit</span></code></pre></div><p>其中 <code>::xxx</code> 表示的是注释内容，可以不写入 <code>.txt</code> 文件中；另外示例脚本的路径为 <code>D:\test\newsLogin.air</code> ，所以这里还做了切换到脚本路径的操作，读者可以根据自己脚本的实际情况来进行切换。</p><p>还需要注意的是，在上述示例中已经在示例脚本的开头添加了设备和 <code>log</code> 的初始化内容，所以不用另外在运行命令后面加上各种运行参数：</p><div class="code-wrapper"><pre><code class="hljs reasonml">auto<span class="hljs-constructor">_setup(<span class="hljs-params">__file__</span>,<span class="hljs-params">logdir</span>=True,<span class="hljs-params">devices</span>=[<span class="hljs-string">&quot;Android://127.0.0.1:5037/emulator-5554&quot;</span>])</span></code></pre></div><p>如果测试设备相对固定，也建议直接将这些参数写到脚本中，可以简化命令行运行脚本的命令。</p><p>写完以上几条命令后，关掉 <code>.txt</code> 文件，将他的后缀名 <code>txt</code> 改成 <code>bat</code> ，之后会弹出重命名的警示弹窗，点击“是”即可。</p><h2 id="用bat文件顺序执行多个Airtest脚本"><a href="#用bat文件顺序执行多个Airtest脚本" class="headerlink" title="用bat文件顺序执行多个Airtest脚本"></a>用bat文件顺序执行多个Airtest脚本</h2><p>使用 <code>.bat</code> 文件成功执行单个airtest脚本之后，试试用 <code>.bat</code> 文件顺序执行多个airtest脚本：</p><div class="code-wrapper"><pre><code class="hljs awk">@echo offD:cd D:\testtitle 正在执行第一个脚本airtest run newsLogin.airtitle 正在执行第二个脚本airtest run newsUsing.airtitle 正在执行第三个脚本airtest run newsExit.air<span class="hljs-keyword">exit</span></code></pre></div><p>可以看到，在上述登录网易新闻的示例脚本之外又增加了两个脚本，分别用来实现使用网易新闻和退出登录等操作。</p><p>所以在 <code>.bat</code> 文件中分别写了三条用于运行对应脚本的命令，其中 <code>title xxx</code> 用来指定命令提示窗口的标题，可以清晰地看出当前是在执行第几个脚本。最终的执行效果如下：</p><h2 id="用bat文件实现多机运行"><a href="#用bat文件实现多机运行" class="headerlink" title="用bat文件实现多机运行"></a>用bat文件实现多机运行</h2><p>在 <code>.bat</code> 文件中，<code>start</code> 可以启动单独的命令行窗口来运行指定程序或命令。所以可以利用 <code>start</code> 命令开启多个命令行窗口，实现在多台设备上执行同一个脚本：</p><div class="code-wrapper"><pre><code class="hljs awk">@echo offD:cd D:\teststart <span class="hljs-string">&quot;正在使用雷电模拟器跑脚本&quot;</span> airtest run newsLogin.air --device Android:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">5037</span>/emulator-<span class="hljs-number">5554</span>start <span class="hljs-string">&quot;正在使用mumu模拟器跑脚本&quot;</span> airtest run newsLogin.air --device Android:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">5037</span>/<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7555</span><span class="hljs-keyword">exit</span></code></pre></div><p>上述命令可以实现在1台雷电模拟器和1台mumu模拟器上跑同一个脚本，效果如下：</p><p>当然，还可以给每一台设备单独配置1个 <code>.bat</code> 文件，最后再写1个总的 <code>.bat</code> 文件来调度前面用于在特定设备上运行脚本的 <code>.bat</code> 。 </p><h2 id="提升脚本成功率"><a href="#提升脚本成功率" class="headerlink" title="提升脚本成功率"></a>提升脚本成功率</h2><p>Airtest的上手并不复杂，可以说只要有一点Python脚本基础就能够轻松入门，然而随着产出的脚本代码越来越多，我们将会发现一个很严峻的问题：我们的脚本的运行结果，有时候似乎不受我们的控制。例如我们想要先判断当前画面上是否存在一个图标，只有在它存在时才进行下一步操作，然而明明画面上并没有，Airtest依然认为这个图标存在，打开报告一看才发现，它将屏幕上另外一个区域的内容判断认为是我们想找的图标了。再比如更加常见的一种情形是：我们框选了画面上的几个字，想要让它识别出来，但是运行结果时好时坏，Airtest常常认为我们选择的内容并不存在，但有时又能运行成功。</p><p>这个问题是Airtest的运行原理导致的，我们使用了图像识别的技术在当前游戏画面中查找对应的图片，然而图像识别并不能达到人眼识别的准确度，它只能尽可能地去寻找一个最符合预期的结果。这就经常导致了我们认为不存在的图片，它认为存在，或者 <strong>我们认为在画面上一眼就能找到的内容，Airtest认为不存在</strong> 。</p><p>也就是说，<strong>图像识别不是万能的！！！</strong> 它是有 <strong>成功率</strong> 的，假设一个脚本里有10张图片，每张图片的识别成功率都能达到95%之高，10张图片全部都正确识别的概率也不过60%而已。更何况，有许多图片因为种种原因，识别成功率远远低于95%这个值，要想脚本运行100%正确就更难了。</p><p>因此，我们在编写完脚本后，可以让脚本多运行几次，然后对成功率低的部分进行改进，这是几个值得注意的改进点：</p><ul><li>截图时尽量 <strong>保证截取的图像辨识度高、独立清晰</strong> ，例如截取一个按钮图像时，尽量不要带上太多的嘈杂背景图案，避免在背景变化后难以成功识别的问题</li><li>图像识别使用的算法 <strong>更适合用来识别按钮类（带边框）、图标类的图像</strong> ，仅仅单独截取几个文字的识别成功率很低，请尽量调整图片截取内容来达到较好的识别效果，避免截取识别效果较差的内容</li><li>Airtest会尽可能地尝试适配 <strong>不同分辨率</strong> 的手机，但是在某些游戏上可能有自定义的分辨率适配规则，可以根据自己游戏的分辨率适配情况来自定义，攻略在 <a href="https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/1_script_settings/">这里</a></li><li>若有大量重复的、非常相似的图标堆叠在一起时，有可能识别效果不佳，在我们眼中也许每一个图标上面的文字是不一样的，然而在<code>Airtest</code>的眼中它们实在是太相似了。我们可以尝试修改截图，借助一些其他的背景样式，修改成辨识度更高的图片。</li><li>尽管我们提供了便捷的自动录制功能，能够直接将当前所有操作一步一步转换成代码，但是这种情况下自动截取的图片往往不太理想，需要手工再对截图进行调整</li></ul><p><strong>图像识别的配置项</strong></p><p>在Airtest进行图像识别的过程中，有一些常见的配置项可以调整，以提升脚本运行的成功率：</p><ul><li>在AirtestIDE中，可以通过双击图片，修改 <code>threshold</code> 的值来改变图像识别的阈值，阈值越高，对图像匹配的精度要求也就越高</li><li>在识别图像时，Airtest会先将图像转为 <strong>灰度</strong> 图再进行识别。因此假如有两个按钮，形状内容相同，只有颜色不同的情况下，Airtest将认为它们都是相同内容。不过，我们可以通过双击图片，勾选设置里的 <code>RGB</code> 选项来强制使用彩色图像识别</li><li>除了可以修改 <code>threshold</code> 和 <code>rgb</code> 两个值以外，双击图片还能够设置识别成功后我们对于图像的点击位置 <code>target_pos</code> ，例如我们可以在识别出一个图标后，指定Airtest去点击这个图标的右下角/左上角等位置</li><li>具体的脚本配置方法可以在 <a href="https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/1_script_settings/">5.2 Airtest脚本相关配置</a>里查看</li></ul><p>这里是大佬总结的使用airtest时的注意点，请注意细看，这会对接下来的开发有很大的帮助。网址点击即可：<a href="https://blog.csdn.net/AirtestProject/article/details/108364907">写了10000条Airtest截图脚本总结出来的截图经验，赶紧收藏！_AirtestProject的博客-CSDN博客_airtest 截图</a></p><h1 id="Poco"><a href="#Poco" class="headerlink" title="Poco"></a>Poco</h1><p>官网：<a href="https://airtest.netease.com/home/">Airtest Project (netease.com)</a></p><p>教程：<a href="https://airtest.doc.io.netease.com/IDEdocs/poco_framework/poco_quick_start/">Poco快速上手 - Airtest Project Docs (netease.com)</a></p><p>文档：<a href="https://poco.readthedocs.io/zh_CN/latest/index.html">欢迎使用Poco (ポコ) UI自动化框架 — poco 1.0 文档</a></p><p>poco是一种基于UI控件搜索的自动化框架，与airtest不同，它的操作方式与appium相似。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs shell">pip install pocoui</code></pre></div><h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> poco.drivers.unity3d <span class="hljs-keyword">import</span> UnityPocopoco = UnityPoco()poco(<span class="hljs-string">&#x27;btn_start&#x27;</span>).click()time.sleep(<span class="hljs-number">1.5</span>)shell = poco(<span class="hljs-string">&#x27;shell&#x27;</span>).focus(<span class="hljs-string">&#x27;center&#x27;</span>)<span class="hljs-keyword">for</span> star <span class="hljs-keyword">in</span> poco(<span class="hljs-string">&#x27;star&#x27;</span>):    star.drag_to(shell)time.sleep(<span class="hljs-number">1</span>)<span class="hljs-keyword">assert</span> poco(<span class="hljs-string">&#x27;scoreVal&#x27;</span>).get_text() == <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;score correct.&quot;</span>poco(<span class="hljs-string">&#x27;btn_back&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;Button&#x27;</span>).click()</code></pre></div><h2 id="使用指南-1"><a href="#使用指南-1" class="headerlink" title="使用指南"></a>使用指南</h2><p>Poco在大多数平台中，需要 <strong>事先接入Poco-SDK才可正常使用</strong> ，在少数平台（如Android原生APP）可直接使用Poco，目前支持平台如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">平台</th><th style="text-align:left">Airtest</th><th style="text-align:left">Poco</th></tr></thead><tbody><tr><td style="text-align:left">Cocos2dx-js, Cocos2dx-lua</td><td style="text-align:left">√</td><td style="text-align:left"><a href="https://poco-chinese.readthedocs.io/zh_CN/latest/source/doc/integration.html#cocos2dx-lua">接入文档</a></td></tr><tr><td style="text-align:left">Unity3D</td><td style="text-align:left">√</td><td style="text-align:left"><a href="https://poco-chinese.readthedocs.io/zh_CN/latest/source/doc/integration.html#unity3d">接入文档</a></td></tr><tr><td style="text-align:left">Native Android APP</td><td style="text-align:left">√</td><td style="text-align:left">直接使用</td></tr><tr><td style="text-align:left">iOS</td><td style="text-align:left">√</td><td style="text-align:left"><a href="https://airtest.doc.io.netease.com/IDEdocs/device_connection/4_ios_connection/">帮助文档</a></td></tr><tr><td style="text-align:left">Egret</td><td style="text-align:left">√</td><td style="text-align:left"><a href="https://github.com/AirtestProject/Poco-SDK/tree/master/Egret">接入文档</a></td></tr><tr><td style="text-align:left">Other engines</td><td style="text-align:left">√</td><td style="text-align:left"><a href="https://poco-chinese.readthedocs.io/zh_CN/latest/source/doc/implementation_guide.html">可自行接入</a></td></tr><tr><td style="text-align:left">WeChat Applet&amp;webview</td><td style="text-align:left">√</td><td style="text-align:left"><a href="https://airtest.doc.io.netease.com/IDEdocs/poco_framework/poco_webview/">参考文档</a> 随着微信更新可能会失效</td></tr><tr><td style="text-align:left">Windows, MacOS</td><td style="text-align:left">√</td><td style="text-align:left">敬请期待</td></tr><tr><td style="text-align:left">Netease</td><td style="text-align:left">√</td><td style="text-align:left"><a href="http://git-qa.gz.netease.com/maki/netease-ide-plugin">帮助文档</a></td></tr></tbody></table></div><p>在airtest ide中新建脚本，可以在ide中直接编写poco即可，和airtest一样，可以使用录制来加速编写代码效率。但是airtest ide中没有poco的简要说明。</p><h2 id="初始化pocoui"><a href="#初始化pocoui" class="headerlink" title="初始化pocoui"></a>初始化pocoui</h2><p>这里用Android作为例子，不同的引擎有不同的初始化方式，详情看文档，这里用的最多就是Android，所以只示例了Android。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> poco.drivers.android.uiautomation <span class="hljs-keyword">import</span> AndroidUiautomationPocopoco = AndroidUiautomationPoco(use_airtest_input=<span class="hljs-literal">True</span>,screenshot_each_action=<span class="hljs-literal">False</span>)</code></pre></div><h2 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h2><p>通过元素name</p><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;com.android.systemui:id/mobile_settings_button&quot;</span>).click()<span class="hljs-comment">#.click()为点击，后面会讲到</span></code></pre></div><p>通过元素text</p><div class="code-wrapper"><pre><code class="hljs python">poco(text=<span class="hljs-string">&quot;电话&quot;</span>).click()</code></pre></div><p>通过坐标</p><div class="code-wrapper"><pre><code class="hljs python">poco().click([<span class="hljs-number">0.507</span>,<span class="hljs-number">0.013</span>])</code></pre></div><p>长按点击</p><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;蓝牙。&quot;</span>).long_click()<span class="hljs-comment"># 默认的长按点击，笔者比较喜欢用这个（因为不用动脑而且不会出现很奇葩的错误）</span></code></pre></div><h2 id="发送文本"><a href="#发送文本" class="headerlink" title="发送文本"></a>发送文本</h2><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;cn.mobile.mms:id/embedded_text_editor&quot;</span>).set_text(<span class="hljs-string">&quot;0000&quot;</span>)</code></pre></div><h2 id="滑动页面（相比Airtest，用这个最好）"><a href="#滑动页面（相比Airtest，用这个最好）" class="headerlink" title="滑动页面（相比Airtest，用这个最好）"></a>滑动页面（相比Airtest，用这个最好）</h2><p>滑动页面是通过坐标完成的，在airtest中所有的坐标使用相对坐标，查看坐标的方法为：选项—&gt;设置—&gt;勾选【实时坐标显示】和【相对坐标】。鼠标移动到设备窗口即可查看相对坐标</p><div class="code-wrapper"><pre><code class="hljs python">poco.swipe([<span class="hljs-number">0.507</span>,<span class="hljs-number">0.013</span>],[<span class="hljs-number">0.507</span>,<span class="hljs-number">0.575</span>])poco.swipe(<span class="hljs-string">&quot;down&quot;</span>)poco.swipe(<span class="hljs-string">&quot;up&quot;</span>)</code></pre></div><h2 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h2><p>有些元素是变化的，可能在某个时间段存在，某个时间段又消失了，这个时候我们可以判断元素是否存在</p><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).exists</code></pre></div><p>可以配合if，如果元素存在，则执行动作</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span>(poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).exists):    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入框存在，点击&quot;</span>);    poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).click()</code></pre></div><h2 id="控件等待"><a href="#控件等待" class="headerlink" title="控件等待"></a>控件等待</h2><h3 id="仅等待不报错"><a href="#仅等待不报错" class="headerlink" title="仅等待不报错"></a>仅等待不报错</h3><p>可以使用<code>wait</code>方法，指定时间等待控件出现，再进行点击操作（该方法的返回值是控件本身，所以后面可以紧跟控件操作，比如点击、长按）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 在10s内等待控件出现，如出现，则进行长按操作</span>poco(texture=<span class="hljs-string">&quot;icon&quot;</span>).wait(timeout=<span class="hljs-number">10</span>).long_click()</code></pre></div><h3 id="等待后不满足则报错"><a href="#等待后不满足则报错" class="headerlink" title="等待后不满足则报错"></a>等待后不满足则报错</h3><p>Poco控件还支持另外2个等待事件，<code>wait_for_appearance()</code>和<code>wait_for_disappearance()</code>；这两个API可以等待页面上 <strong>某1个UI</strong> 出现或者消失，等待的超时时间 <code>timeout</code> 默认为120秒，如果在超时时长之内元素没有出现或者消失的话，会报 <code>PocoTargetTimeout</code> 的错误。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 等待黄色小鱼出现</span>poco(<span class="hljs-string">&quot;yellow&quot;</span>).wait_for_appearance(timeout=<span class="hljs-number">20</span>)<span class="hljs-comment"># 等待计分文本控件消失</span>poco(text=<span class="hljs-string">&quot;Count:&quot;</span>).wait_for_disappearance(timeout=<span class="hljs-number">3</span>)</code></pre></div><h3 id="Poco类的等待事件"><a href="#Poco类的等待事件" class="headerlink" title="Poco类的等待事件"></a>Poco类的等待事件</h3><p>这里有两个poco类的等待方法：<code>wait_for_any()</code>和<code>wait_for_all()</code>。与上述等待事件不同的是，<code>wait_for_any()</code> 和 <code>wait_for_all()</code> 可以给定多个UI对象让其等待。（需要注意这两个方法是Poco类的方法）</p><p><code>wait_for_all()</code> 是在超时时长结束之前，需要 <strong>等待所有给定的UI对象都显示出来</strong> ，即一次轮询所有UI，例如等待三个图标都显示之后，再点击返回按钮</p><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;wait_ui2&quot;</span>).click()yellow = poco(<span class="hljs-string">&quot;yellow&quot;</span>)blue = poco(<span class="hljs-string">&quot;blue&quot;</span>)black = poco(<span class="hljs-string">&quot;black&quot;</span>)poco.wait_for_all([yellow,blue,black])poco(<span class="hljs-string">&quot;btn_back&quot;</span>).click()</code></pre></div><p><code>wait_for_any()</code> 则是在超时时长结束之前，<strong>等待任意一个UI显示出来</strong>，即一次轮询任何一个给定的UI。</p><div class="code-wrapper"><pre><code class="hljs python">bomb = poco(<span class="hljs-string">&quot;bomb&quot;</span>)yellow = poco(<span class="hljs-string">&quot;yellow&quot;</span>)blue = poco(<span class="hljs-string">&quot;blue&quot;</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    fish = poco.wait_for_any([bomb,yellow,blue])    <span class="hljs-built_in">print</span>(fish.get_name())</code></pre></div><p>可以看到，只要页面出出现了等待的任一UI，<code>wait_for_any()</code> 方法都会返回第一个等待到的UI。</p><h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><p>通过python的for循环可以 <strong>遍历任何序列的项目</strong> ，如一个列表或者字符串。</p><p>举个例子，<code>poco(&quot;playDragAndDrop&quot;).child(&quot;star&quot;)</code> 得到的就是1个控件序列（包含了5个星星元素）， <code>star</code> 代表控件序列中的1个元素。因此通过这个循环，可以遍历了5个星星元素的序列，并把每个星星元素依次拖动到贝壳上：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> star <span class="hljs-keyword">in</span> poco(<span class="hljs-string">&quot;playDragAndDrop&quot;</span>).child(<span class="hljs-string">&quot;star&quot;</span>):    star.drag_to(poco(<span class="hljs-string">&quot;shell&quot;</span>))</code></pre></div><p><img src="https://airtest.doc.io.netease.com/IDEdocs/poco_framework/poco_API/for.gif" alt=""></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>poco源码中会杀死uiautomator的进程，因为这个目前笔者不再使用该框架，目前用airtest+uiautomator2编写自动化脚本</p><h1 id="判断运行时间"><a href="#判断运行时间" class="headerlink" title="判断运行时间"></a>判断运行时间</h1><p>若有判断程序运行时延的需要，可以计算运行的时间即可。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> timefirst = time.time()<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始的时间: &quot;</span>+<span class="hljs-built_in">str</span>(first))<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;运行程序&quot;</span>)end = time.time()<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束的时间: &quot;</span>+<span class="hljs-built_in">str</span>(end))<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;运行程序用了:&quot;</span>+<span class="hljs-built_in">str</span>(end-first)+<span class="hljs-string">&quot;秒&quot;</span>)</code></pre></div><p>该方法包含了其他程序使用CPU的时间，是程序从开始到结束的时间。单位为秒</p><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><p>官网：<a href="https://www.selenium.dev/">Selenium</a></p><p>文档：</p><ul><li><p><a href="https://selenium-python.readthedocs.io/index.html">https://selenium-python.readthedocs.io/index.html</a></p></li><li><p><a href="https://seleniumhq.github.io/selenium/docs/api/py/api.html">https://seleniumhq.github.io/selenium/docs/api/py/api.html</a></p></li></ul><p>Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作，不同是Selenium 可以直接运行在浏览器上，它支持所有主流的浏览器（包括PhantomJS这些无界面的浏览器）。</p><p>Selenium 可以根据我们的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。</p><p>注意：本笔记默认读者会<strong>CSS，HTML</strong>等基础的Web语言</p><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre><code class="hljs python">pip install selenium</code></pre></div><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><blockquote><p>引用<a href="https://www.jianshu.com/p/6c82c965c014">selenium教程 - 简书 (jianshu.com)</a></p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># IPython2 测试代码</span><span class="hljs-comment"># 导入 webdriver</span><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-comment"># 要想调用键盘按键操作需要引入keys包</span><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<span class="hljs-comment"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span>driver = webdriver.PhantomJS()<span class="hljs-comment"># 如果没有在环境变量指定PhantomJS位置</span><span class="hljs-comment"># driver = webdriver.PhantomJS(executable_path=&quot;./phantomjs&quot;))</span><span class="hljs-comment"># get方法会一直等到页面被完全加载，然后才会继续程序，通常测试会在这里选择 time.sleep(2)</span>driver.get(<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>)<span class="hljs-comment"># 获取页面名为 wrapper的id标签的文本内容</span>data = driver.find_element_by_id(<span class="hljs-string">&quot;wrapper&quot;</span>).text<span class="hljs-comment"># 打印数据内容</span><span class="hljs-built_in">print</span> data<span class="hljs-comment"># 打印页面标题 &quot;百度一下，你就知道&quot;</span><span class="hljs-built_in">print</span> driver.title<span class="hljs-comment"># 生成当前页面快照并保存</span>driver.save_screenshot(<span class="hljs-string">&quot;baidu.png&quot;</span>)<span class="hljs-comment"># id=&quot;kw&quot;是百度搜索输入框，输入字符串&quot;长城&quot;</span>driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(<span class="hljs-string">u&quot;马云&quot;</span>)<span class="hljs-comment"># id=&quot;su&quot;是百度搜索按钮，click() 是模拟点击</span>driver.find_element_by_id(<span class="hljs-string">&quot;su&quot;</span>).click()<span class="hljs-comment"># 获取新的页面快照</span>driver.save_screenshot(<span class="hljs-string">&quot;马云.png&quot;</span>)<span class="hljs-comment"># 打印网页渲染后的源代码</span><span class="hljs-built_in">print</span> driver.page_source<span class="hljs-comment"># 获取当前页面Cookie</span><span class="hljs-built_in">print</span> driver.get_cookies()<span class="hljs-comment"># ctrl+a 全选输入框内容</span>driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(Keys.CONTROL,<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment"># ctrl+x 剪切输入框内容</span>driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(Keys.CONTROL,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment"># 输入框重新输入内容</span>driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).send_keys(<span class="hljs-string">u&quot;王健林&quot;</span>)<span class="hljs-comment"># 模拟Enter回车键</span>driver.find_element_by_id(<span class="hljs-string">&quot;su&quot;</span>).send_keys(Keys.RETURN)<span class="hljs-comment"># 清除输入框内容</span>driver.find_element_by_id(<span class="hljs-string">&quot;kw&quot;</span>).clear()<span class="hljs-comment"># 生成新的页面快照</span>driver.save_screenshot(<span class="hljs-string">&quot;王健林.png&quot;</span>)<span class="hljs-comment"># 获取当前url</span><span class="hljs-built_in">print</span> driver.current_url<span class="hljs-comment"># 关闭当前页面，如果只有一个页面，会关闭浏览器</span><span class="hljs-comment"># driver.close()</span><span class="hljs-comment"># 关闭浏览器</span>driver.quit()</code></pre></div><h2 id="引用Selenium"><a href="#引用Selenium" class="headerlink" title="引用Selenium"></a>引用Selenium</h2><p>使用<code>from selenium import webdriver</code>和<code>from selenium.webdriver.common.keys import Keys</code>引用Selenium和Selenium keys（用于使用特定的按键，比如说F2等等）包</p><h2 id="初始化Selenium"><a href="#初始化Selenium" class="headerlink" title="初始化Selenium"></a>初始化Selenium</h2><p>首先安装浏览器驱动，笔者用的是Edge和Chrome（这个用的最多），这两个驱动分别在<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">Microsoft Edge Driver - Microsoft Edge Developer</a>和<a href="http://chromedriver.storage.googleapis.com/index.html">chromedriver存储目录</a></p><p>下载，下载方法如下：</p><ol><li>Edge</li></ol><p>进入网页，找到Stable Channel，根据自己的系统位数选择下载即可。</p><p><img src="../../image/image-20210815014016616.png" alt="下载图示"></p><ol><li>Chrome</li></ol><p>首先查看自己Chrome的版本号，在Chrome输入<code>chrome://version</code>即可查看Chrome的版本号</p><p><img src="../../image/image-20210815014209789.png" alt="看到该字样即可"></p><p>进入网页，找到相应的版本号后，点击下载即可</p><p>保存好浏览器驱动后，使用如下代码，让Selenium找到相应的驱动后即可开启浏览器</p><div class="code-wrapper"><pre><code class="hljs python">driver = webdriver.Chrome(<span class="hljs-string">&quot;xxx/browserDriver/chromedriver.exe&quot;</span>)<span class="hljs-comment"># Chrome 浏览器驱动存放路径</span>driver = webdriver.Edge(<span class="hljs-string">&quot;xxx/browserDriver/msedgedriver.exe&quot;</span>)<span class="hljs-comment"># Edge 浏览器驱动存放路径</span></code></pre></div><p>也可以将浏览器驱动存放在python的根目录下，不用输入存放路径</p><div class="code-wrapper"><pre><code class="hljs python">driver = webdriver.Chrome()driver = webdriver.Edge()</code></pre></div><p>这样，Selenium初始化完毕。</p><p>可以使用headless无UI进行selenium，通常运用在爬虫中，特别的，headless模式通常运用在Chrome浏览器中</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Chrome后台静默运行</span>__options = webdriver.ChromeOptions()__options.add_argument(<span class="hljs-string">&#x27;--no-sandbox&#x27;</span>) <span class="hljs-comment"># 解决DevToolsActivePort文件不存在的报错</span>__options.add_argument(<span class="hljs-string">&#x27;--start-maximized&#x27;</span>) <span class="hljs-comment"># 最大化运行（全屏窗口）,不设置，取元素会报错</span>__options.add_argument(<span class="hljs-string">&#x27;--disable-infobars&#x27;</span>) <span class="hljs-comment"># 禁用浏览器正在被自动化程序控制的提示</span>__options.add_argument(<span class="hljs-string">&#x27;window-size=1920x1080&#x27;</span>) <span class="hljs-comment"># 设置浏览器分辨率</span>__options.add_argument(<span class="hljs-string">&#x27;--disable-gpu&#x27;</span>) <span class="hljs-comment"># 谷歌文档提到需要加上这个属性来规避bug</span>__options.add_argument(<span class="hljs-string">&#x27;--hide-scrollbars&#x27;</span>)  <span class="hljs-comment"># 隐藏滚动条，应对一些特殊页面</span>__options.add_argument(<span class="hljs-string">&#x27;blink-settings=imagesEnabled=false&#x27;</span>) <span class="hljs-comment"># 不加载图片，提升运行速度</span>__options.add_argument(<span class="hljs-string">&#x27;--headless&#x27;</span>) <span class="hljs-comment"># 浏览器不提供可视化界面。Linux下如果系统不支持可视化不加这条会启动失败</span>__options.add_argument(<span class="hljs-string">&quot;--ignore-certificate-errors&quot;</span>) <span class="hljs-comment"># 忽视掉证书认证的不安全连接的错误</span><span class="hljs-comment"># 传入user-agent，欺骗网站，使得它认为是在实际的浏览器上运行,这样的话运行的网络速度是和UI运行的时候是一样的</span>__options.add_argument(<span class="hljs-string">&#x27;user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36&quot;&#x27;</span>)__options.add_argument(<span class="hljs-string">&quot;--ignore-ssl-errors&quot;</span>)__driver = webdriver.Chrome(executable_path = <span class="hljs-string">&quot;./browserDriver/chromedriver.exe&quot;</span>,options=__options)<span class="hljs-comment"># Chrome 浏览器驱动存放路径</span></code></pre></div><p>user-agent可以通过在Chrome浏览器中输入<code>chrome://version</code>的用户代理查找到，这里笔者使用的是最新的chrome浏览器（作为自动化工具）</p><h2 id="打开网址"><a href="#打开网址" class="headerlink" title="打开网址"></a>打开网址</h2><div class="code-wrapper"><pre><code class="hljs python">driver.get(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>)</code></pre></div><h2 id="定位UI元素"><a href="#定位UI元素" class="headerlink" title="定位UI元素"></a>定位UI元素</h2><blockquote><p>引用<a href="https://www.jianshu.com/p/6c82c965c014">selenium教程 - 简书 (jianshu.com)</a>，有少量修改</p></blockquote><p>通过如下选择器可以精准找到网页的HTML元素和标签。</p><div class="code-wrapper"><pre><code class="hljs python">find_element_by_idfind_elements_by_namefind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector</code></pre></div><p>示例：</p><div class="code-wrapper"><pre><code class="hljs python">driver.find_element_by_id(<span class="hljs-string">&quot;txtMobileTexter&quot;</span>).send_keys(<span class="hljs-string">&quot;12345&quot;</span>)<span class="hljs-comment"># 通过id获取元素，发送字符12345</span>driver.find_element_by_xpath(<span class="hljs-string">&quot;//*[@id=&#x27;mobileSelSend&quot;</span>).click()<span class="hljs-comment"># 通过xpath获取元素，并点击</span>driver.find_element_by_link_text(<span class="hljs-string">&quot;发送&quot;</span>).text<span class="hljs-comment"># 通过元素中的字符获取元素获取文本</span><span class="hljs-comment"># 获取指定元素，并判断是否存在</span><span class="hljs-keyword">try</span>:    driver.find_element_by_xpath(<span class="hljs-string">&quot;/html/body/div[1]/div[1]/div[2]/div[2]/span&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成功&quot;</span>)<span class="hljs-keyword">except</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;失败&quot;</span>)</code></pre></div><h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">/</td><td style="text-align:center">从根节点选取，使用绝对路径，路径必须完全匹配</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">从整个文档中选取，使用相对路径</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">从当前节点开始选取</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">从当前节点父节点开始选取</td></tr><tr><td style="text-align:center">@</td><td style="text-align:center">选取属性</td></tr><tr><td style="text-align:center">text()</td><td style="text-align:center">获取文本</td></tr></tbody></table></div><p><strong>案例</strong></p><blockquote><p>引用<a href="https://blog.csdn.net/weixin_43430036/article/details/84836516">(7条消息) Scrapy爬虫：XPath语法_灵动的艺术的博客-CSDN博客_scrapy xpath语法</a></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">路径表达式</th><th style="text-align:center"><strong>结果</strong></th></tr></thead><tbody><tr><td style="text-align:center">body</td><td style="text-align:center">选取 body 元素的所有子节点。</td></tr><tr><td style="text-align:center">/head</td><td style="text-align:center">选取根元素下head。假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td style="text-align:center">div/a</td><td style="text-align:center">选取属于 div 的子元素的所有 a 元素。</td></tr><tr><td style="text-align:center">//a</td><td style="text-align:center">选取所有 a 子元素，而不管它们在文档中的位置。</td></tr><tr><td style="text-align:center">div//a</td><td style="text-align:center">选择属于 div 元素的后代的所有 a 元素，而不管它们位于 bookstore 之下的什么位置。</td></tr><tr><td style="text-align:center">//@class</td><td style="text-align:center">选取名为 class 的所有属性。</td></tr><tr><td style="text-align:center">./a</td><td style="text-align:center">选取当前元素下的a</td></tr><tr><td style="text-align:center">…/a</td><td style="text-align:center">选取父元素下的a</td></tr><tr><td style="text-align:center">a/@href</td><td style="text-align:center">选取a标签的href属性</td></tr><tr><td style="text-align:center">a/text()</td><td style="text-align:center">选取a标签下的文本</td></tr></tbody></table></div><h2 id="图像验证码识别"><a href="#图像验证码识别" class="headerlink" title="图像验证码识别"></a>图像验证码识别</h2><p>很多网站上都有图像验证码，这是自动化测试的一大难题，这里用EasyOCR来识别网站的图像验证码文字，但是一旦碰到识别准确率不高的情况下需要手动处理。</p><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><div class="code-wrapper"><pre><code class="hljs shell">pip install easyocr</code></pre></div><p>需要花费一些时间</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> easyocr</code></pre></div><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>步骤非常简单，一共有三步：</p><ul><li>创建识别对象</li><li>读取并识别图像</li><li>导出文本</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 导入easyocr</span><span class="hljs-keyword">import</span> easyocr<span class="hljs-comment"># 创建reader对象</span>reader = easyocr.Reader([<span class="hljs-string">&#x27;ch_sim&#x27;</span>,<span class="hljs-string">&#x27;en&#x27;</span>]) <span class="hljs-comment"># 读取图像</span>result = reader.readtext(<span class="hljs-string">&#x27;test.jpg&#x27;</span>)<span class="hljs-comment"># 结果</span>result</code></pre></div><h2 id="鼠标动作链"><a href="#鼠标动作链" class="headerlink" title="鼠标动作链"></a>鼠标动作链</h2><blockquote><p>以下代码和文字（包括本小章节到页面等待章节前）引用了网址<a href="https://www.jianshu.com/p/6c82c965c014">selenium教程 - 简书 (jianshu.com)</a>，有少量修改</p></blockquote><p>引入鼠标动作库<code>from selenium.webdriver import ActionChains</code>这样就可以使用复杂的鼠标动作了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 鼠标移动到 ac 位置</span>ac = driver.find_element_by_xpath(<span class="hljs-string">&#x27;element&#x27;</span>)ActionChains(driver).move_to_element(ac).perform()<span class="hljs-comment"># 在 ac 位置单击</span>ac = driver.find_element_by_xpath(<span class="hljs-string">&quot;elementA&quot;</span>)ActionChains(driver).move_to_element(ac).click(ac).perform()<span class="hljs-comment"># 在 ac 位置双击</span>ac = driver.find_element_by_xpath(<span class="hljs-string">&quot;elementB&quot;</span>)ActionChains(driver).move_to_element(ac).double_click(ac).perform()<span class="hljs-comment"># 在 ac 位置右击</span>ac = driver.find_element_by_xpath(<span class="hljs-string">&quot;elementC&quot;</span>)ActionChains(driver).move_to_element(ac).context_click(ac).perform()<span class="hljs-comment"># 在 ac 位置左键单击按住</span>ac = driver.find_element_by_xpath(<span class="hljs-string">&#x27;elementF&#x27;</span>)ActionChains(driver).move_to_element(ac).click_and_hold(ac).perform()<span class="hljs-comment"># 将 elementD 拖拽到 elementE&#x27;) 位置</span>ac1 = driver.find_element_by_xpath(<span class="hljs-string">&#x27;elementD&#x27;</span>)ac2 = driver.find_element_by_xpath(<span class="hljs-string">&#x27;elementE&#x27;</span>)ActionChains(driver).drag_and_drop(ac1, ac2).perform()</code></pre></div><p>如果是普通的点击，也可以直接使用如下代码点击，不用ActionChains类</p><div class="code-wrapper"><pre><code class="hljs python">driver.find_element_by_xpath(<span class="hljs-string">&quot;//button[@type=&#x27;button&#x27;]&quot;</span>).click()</code></pre></div><h2 id="选择表单"><a href="#选择表单" class="headerlink" title="选择表单"></a>选择表单</h2><p>若碰到<select> </select>标签的下拉框，需要使用引用<code>from selenium.webdriver.support.ui import Select</code>。代码如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 找到 name 的选项卡</span>select = Select(driver.find_element_by_name(<span class="hljs-string">&#x27;status&#x27;</span>))<span class="hljs-comment"># </span>select.select_by_index(<span class="hljs-number">1</span>)select.select_by_value(<span class="hljs-string">&quot;0&quot;</span>)select.select_by_visible_text(<span class="hljs-string">u&quot;未审核&quot;</span>)</code></pre></div><p>以上是三种选择下拉框的方式，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。</p><ul><li><strong>index</strong> 索引从 0 开始</li><li><strong>value</strong>是option标签的一个属性值，并不是显示在下拉框中的值</li><li><strong>visible_text</strong>是在option标签文本的值，是显示在下拉框的值</li></ul><p>全部取消选择的代码如下：</p><div class="code-wrapper"><pre><code class="hljs python">select.deselect_all()</code></pre></div><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>首先区分出上传按钮的种类，大体上可以分为两种</p><ul><li>一种是input框</li><li>另外一种就比较复杂，通过js、flash等实现，标签非input</li></ul><h3 id="input上传"><a href="#input上传" class="headerlink" title="input上传"></a>input上传</h3><p>该方法大概针对该类型的html：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span></code></pre></div><p>遇到该类型的html，selenium可以十分简单粗暴得上传图片：</p><div class="code-wrapper"><pre><code class="hljs python">upload = driver.find_element_by_id(<span class="hljs-string">&#x27;file&#x27;</span>)upload.send_keys(<span class="hljs-string">&#x27;d:\\all_money.wmv&#x27;</span>)  <span class="hljs-comment"># send_keys</span></code></pre></div><h3 id="非input上传"><a href="#非input上传" class="headerlink" title="非input上传"></a>非input上传</h3><p>这种上传千奇百怪，有用a标签的，有用div的，有用button的，有用object的，selenium没有办法通过直接在网页上处理掉这些上传，唯一的办法就是打开OS弹框，去处理弹框。</p><p>但是OS弹框涉及的层面已经不是selenium能解决的了，大体上有以下几种解决方案：</p><ul><li>autoIT：借助外力，我们去调用其生成的au3或exe文件。</li><li>pywin32库：识别对话框句柄，进而操作</li><li>SendKeys库</li><li>keybd_event：跟pywin32库类似，但是是模拟按键，ctrl+a，ctrl+c， ctrl+v…</li></ul><h2 id="页面前进和后退"><a href="#页面前进和后退" class="headerlink" title="页面前进和后退"></a>页面前进和后退</h2><div class="code-wrapper"><pre><code class="hljs python">driver.forward()     <span class="hljs-comment"># 前进</span>driver.back()        <span class="hljs-comment"># 后退</span></code></pre></div><h2 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h2><p><strong>切换窗口</strong></p><p>浏览器会有很多窗口，所以要有方法来实现窗口的切换</p><div class="code-wrapper"><pre><code class="hljs python">driver.switch_to.window(<span class="hljs-string">&quot;this is window name&quot;</span>)</code></pre></div><p>也可以使用 window_handles 方法来获取每个窗口的操作对象</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> driver.window_handles:    driver.switch_to.window(handle)</code></pre></div><p><strong>切换到iframe（通过页面的UI）</strong></p><p>页面中可能会存在iframe元素，需要切换到iframe里面才可以让Selenium操作里面的内容</p><div class="code-wrapper"><pre><code class="hljs python">driver.switch_to.frame(driver.find_element_by_xpath(<span class="hljs-string">&quot;/html/body/div[3]/div[5]/div[1]/div[7]/iframe&quot;</span>))</code></pre></div><h2 id="弹窗处理"><a href="#弹窗处理" class="headerlink" title="弹窗处理"></a>弹窗处理</h2><p>当触发了某个事件之后，页面出现了弹窗提示，处理如下代码提示或者获取提示信息方法</p><div class="code-wrapper"><pre><code class="hljs python">alert = driver.switch_to.alert()alert.accept()<span class="hljs-comment"># 点击弹窗的确认</span>alert.text<span class="hljs-comment"># 获取弹窗文本内容</span></code></pre></div><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>获取页面每个Cookies值</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> cookie <span class="hljs-keyword">in</span> driver.get_cookies():    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;%s -&gt; %s&quot;</span> % (cookie[<span class="hljs-string">&#x27;name&#x27;</span>], cookie[<span class="hljs-string">&#x27;value&#x27;</span>])</code></pre></div><p>删除Cookies</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># By name</span>driver.delete_cookie(<span class="hljs-string">&quot;CookieName&quot;</span>)<span class="hljs-comment"># all</span>driver.delete_all_cookies()</code></pre></div><h2 id="页面等待"><a href="#页面等待" class="headerlink" title="页面等待"></a>页面等待</h2><p>现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。</p><p>为了避免这种元素定位困难而且会提高产生 ElementNotVisibleException 的概率。所以 Selenium 提供了两种等待方式，一种是隐式等待，一种是显式等待。</p><p>隐式等待是等待特定的时间，显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。</p><p><strong>显式等待</strong></p><p>引入WebDriverWait</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait</code></pre></div><p>WebDriverWait的API</p><div class="code-wrapper"><pre><code class="hljs python">WebDriverWait(driver,timeout,poll_frequency=<span class="hljs-number">0.5</span>,ignored_exceptions=<span class="hljs-literal">None</span>)</code></pre></div><p>说明：</p><ul><li>driver：浏览器驱动</li><li>timeout：最长超时时间，默认以秒为单位</li><li>poll_frequency：检测的间隔步长，默认为0.5s</li><li>ignored_exceptions：超时后的抛出的异常信息，默认抛出NoSuchElementExeception异常。</li></ul><p>WebDriverWait通常与until()或者until_not()方法结合使用：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 调用该方法提供的驱动程序作为参数，直到返回值为True</span>WebDriverWait(driver,<span class="hljs-number">10</span>).until(method，message=<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment"># 调用该方法提供的驱动程序作为参数，直到返回值为False</span>WebDriverWait(driver,<span class="hljs-number">10</span>).until_not(method，message=<span class="hljs-string">&quot;&quot;</span>)</code></pre></div><p>可以自定义等待条件：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#设置等待</span>wait = WebDriverWait(driver,<span class="hljs-number">10</span>,<span class="hljs-number">0.5</span>)<span class="hljs-comment">#使用匿名函数</span>wait.until(<span class="hljs-keyword">lambda</span> diver:driver.find_element_by_id(<span class="hljs-string">&#x27;kw&#x27;</span>))</code></pre></div><p>WebDriverWait与expected_conditions方法结合使用：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-comment"># WebDriverWait 库，负责循环等待</span><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-comment"># expected_conditions 类，负责条件出发</span><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<span class="hljs-comment"># 页面一直循环，直到 id=&quot;myDynamicElement&quot; 出现</span>wait = WebDriverWait(driver,<span class="hljs-number">10</span>)element = wait.until(EC.presence_of_element_located((By.ID,<span class="hljs-string">&quot;myDynamicElement&quot;</span>)))</code></pre></div><p>如果不写步长参数，程序默认会 0.5s 调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。</p><p><code>expected_conditions</code>类提供的预期条件判断的方法如下表：</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>title_is</td><td>判断当前页面的 title 是否完全等于（==）预期字符串，返回布尔值</td></tr><tr><td>title_contains</td><td>判断当前页面的 title 是否包含预期字符串，返回布尔值</td></tr><tr><td><strong>presence_of_element_located</strong></td><td>判断某个元素是否被加到了 dom 树里，并不代表该元素一定可见</td></tr><tr><td>visibility_of_element_located</td><td>判断元素是否可见（可见代表元素非隐藏，并且元素宽和高都不等于 0）</td></tr><tr><td>visibility_of</td><td>同上一方法，只是上一方法参数为locator，这个方法参数是 定位后的元素</td></tr><tr><td>presence_of_all_elements_located</td><td>判断是否至少有 1 个元素存在于 dom 树中。举例：如果页面上有 n 个元素的 class 都是’wp’，那么只要有 1 个元素存在，这个方法就返回 True</td></tr><tr><td>text_to_be_present_in_element</td><td>判断某个元素中的 text 是否 包含 了预期的字符串</td></tr><tr><td>text_to_be_present_in_element_value</td><td>判断某个元素中的 value 属性是否包含 了预期的字符串</td></tr><tr><td>frame_to_be_available_and_switch_to_it</td><td>判断该 frame 是否可以 switch进去，如果可以的话，返回 True 并且 switch 进去，否则返回 False</td></tr><tr><td>invisibility_of_element_located</td><td>判断某个元素中是否不存在于dom树或不可见</td></tr><tr><td>element_to_be_clickable</td><td>判断某个元素中是否可见并且可点击</td></tr><tr><td>staleness_of</td><td>等某个元素从 dom 树中移除，注意，这个方法也是返回 True或 False</td></tr><tr><td>element_to_be_selected</td><td>判断某个元素是否被选中了,一般用在下拉列表</td></tr><tr><td>element_selection_state_to_be</td><td>判断某个元素的选中状态是否符合预期</td></tr><tr><td>element_located_selection_state_to_be</td><td>跟上面的方法作用一样，只是上面的方法传入定位到的 element，而这个方法传入 locator</td></tr><tr><td>alert_is_present</td><td>判断页面上是否存在 alert</td></tr></tbody></table></div><p><strong>隐式等待</strong></p><p>隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriverdriver = webdriver.Chrome()driver.implicitly_wait(<span class="hljs-number">10</span>) <span class="hljs-comment"># seconds</span>driver.get(<span class="hljs-string">&quot;http://www.xxxxx.com/loading&quot;</span>)myDynamicElement = driver.find_element_by_id(<span class="hljs-string">&quot;myDynamicElement&quot;</span>)</code></pre></div><h2 id="Airtest-Selenium"><a href="#Airtest-Selenium" class="headerlink" title="Airtest-Selenium"></a>Airtest-Selenium</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>airtest-selenium库是基于selenium库的进一步封装，有如下几个特点: </p><ol><li>对切换标签的界面进行了友好封装</li><li>支持图像识别功能</li><li>自动进行log记录(参考selenium-java的监听模式)</li><li>兼容selenium的原生api</li></ol><p>注意：<strong>Airtest-Selenium暂时不兼容selenium4，需要将selenium版本更改为3.0的版本后才能使用，否则会报<code>WebElement&#39; object has no attribute &#39;_w3c&#39;</code>的错误，可以在pycharm中将selenium修改为3.x的版本</strong></p><h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h3><div class="code-wrapper"><pre><code class="hljs shell">pip install airtest-seleniumpip install pynput</code></pre></div><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 引入selenium的webdriver模块</span><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<span class="hljs-keyword">from</span> airtest.core.api <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> airtest_selenium.proxy <span class="hljs-keyword">import</span> WebChrome</code></pre></div><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>需要把Chrome浏览器的驱动放在python的根目录上，具体下载在Selenium中说明。注意，要引用<code>from airtest_selenium.proxy import WebChrome</code>的接口</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#创建一个实例，代码运行到这里，会打开一个chrome浏览器</span>driver = WebChrome()</code></pre></div><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ul><li><strong>driver.airtest_touch</strong>：airtest-selenium封装的图像点击</li></ul><div class="code-wrapper"><pre><code class="hljs python">driver.airtest_touch(Template(......))</code></pre></div><ul><li><strong>driver.assert_template</strong>：airtest-selenium封装的图像存在断言</li></ul><div class="code-wrapper"><pre><code class="hljs python">driver.assert_template(Template(......), <span class="hljs-string">&quot;请填写测试点&quot;</span>)</code></pre></div><ul><li><strong>snapshot</strong>：airtest-selenium封装的页面截图操作</li></ul><div class="code-wrapper"><pre><code class="hljs python">driver.snapshot()</code></pre></div><ul><li><strong>previous_tab</strong>：airtest-selnium封装的切换到上一个标签页的操作</li></ul><div class="code-wrapper"><pre><code class="hljs python">driver.switch_to_previous_tab()</code></pre></div><ul><li><strong>new_tab</strong>：airtest-selenium封装的切换到新打开标签页的操作</li></ul><div class="code-wrapper"><pre><code class="hljs python">driver.switch_to_new_tab()</code></pre></div><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><div class="code-wrapper"><pre><code class="hljs routeros">python -m airtest <span class="hljs-builtin-name">run</span></code></pre></div><p>或者与selenium相同，在main方法中运行</p><h2 id="Ubuntu运行selenium"><a href="#Ubuntu运行selenium" class="headerlink" title="Ubuntu运行selenium"></a>Ubuntu运行selenium</h2><p>selenium不仅仅能在windows上运行，也能在linux上运行，这里用Ubuntu去运行。</p><blockquote><p>源自：<a href="https://www.jerrycoding.com/article/linux-selenium/">Linux Ubuntu 下安装使用selenium 环境搭建-学习笔记-JerryCoding个人博客</a></p></blockquote><h3 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h3><div class="code-wrapper"><pre><code class="hljs shell">sudo apt-get install libxss1 libappindicator1 libindicator7 # 安装依赖库wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb # 获取chrome安装包sudo dpkg -i google-chrome*.deb # 开始安装google-chrome --version # 查看版本</code></pre></div><h3 id="下载chromedriver"><a href="#下载chromedriver" class="headerlink" title="下载chromedriver"></a>下载chromedriver</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">执行如下命令（第一条用于获取最新版本号，第二条用于下载）：</span>LATEST=$(wget -q -O - http://chromedriver.storage.googleapis.com/LATEST_RELEASE)wget http://chromedriver.storage.googleapis.com/$LATEST/chromedriver_linux64.zip<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 解压</span>unzip chromedriver_linux64.zip<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 修改权限</span>chmod +x chromedriver<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 可以移动driver 省的指定位置</span>sudo mv chromedriver /usr/bin/<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看版本</span>./chromedriver --version</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-comment"># 如果没有将driver移动到 sudo mv chromedriver /usr/bin/ 要指定 driverpath</span>driverpath = <span class="hljs-string">&#x27;&#x27;</span>       driver = webdriver.Chrome(executable_path=driverpath)driver.get(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>)<span class="hljs-built_in">print</span>(driver.title)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>airtest</tag>
      
      <tag>poco</tag>
      
      <tag>selectium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式快速入门</title>
    <link href="/my_world/content/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/my_world/content/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>正则表达式</strong>，又称规则表达式<strong>。</strong>（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p><p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。</p><blockquote><p>引用文章<a href="https://baike.baidu.com/item/正则表达式/1700215">正则表达式_百度百科 (baidu.com)</a></p></blockquote><p>这里就从浅入深一步一个脚印开始探索正则表达式</p><h1 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h1><p>限定符是指限定一个字符，通过限定符可以匹配字符出现的数量，这里列举出限定符</p><ol><li><code>?</code><ul><li>指出现0次或者一次</li><li>列举：<code>ad?</code>  意思为d出现0次或者1次，可有可无</li></ul></li><li><code>*</code><ul><li>匹配出现0个或【多】个字符</li><li>列举：<code>ad*c</code>  意思为b可以没有，也可以出现多次</li></ul></li><li><code>+</code><ul><li>匹配出现1次以上的字符</li></ul></li><li><code>&#123;&#125;</code><ul><li>匹配出现字符次数</li><li>列举：<code>ad&#123;2&#125;c</code>  意思为出现2次b；<code>ab&#123;2,6&#125;c</code>  意思为出现2到6次b；<code>ab&#123;2,&#125;c</code>  意思为出现2次以上b</li></ul></li></ol><h1 id="“或”运算器"><a href="#“或”运算器" class="headerlink" title="“或”运算器"></a>“或”运算器</h1><p><code>a (cat|dog)</code>  匹配：a cat,a dog。<code>|</code>表示或</p><h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><ol><li><code>[a-z]</code><ul><li>匹配所有小写英语字符</li></ul></li><li><code>[a-zA-Z]</code><ul><li>匹配所有英语字符</li></ul></li><li><code>[a-zA-Z0-9]</code><ul><li>匹配所有英语字符和数字</li></ul></li><li><code>^</code><ul><li>匹配除<code>^</code>以后的字符</li><li>列举：<code>\[^0-9]</code>  匹配所有的非数字字符（包括换行符）</li></ul></li></ol><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><ol><li><code>\d</code>  代表数字字符</li><li><code>\w</code>  代表单词字符（英文，数字以及下划线）</li><li><code>\s</code>  代表空白符（包括Tab和换行符）</li><li><code>\D</code>  代表非数字字符</li><li><code>\W</code>  代表非单词字符</li><li><code>\S</code>  代表非空白符</li><li><code>\b</code>  代表单词的开始或结束</li><li><code>^</code>  代表行首</li><li><code>$</code>  代表行尾</li><li><code>.</code>  任意字符（不包含Tab）</li></ol><h1 id="贪婪与懒惰匹配"><a href="#贪婪与懒惰匹配" class="headerlink" title="贪婪与懒惰匹配"></a>贪婪与懒惰匹配</h1><ol><li><p><code>&lt;.+&gt;</code>匹配<code>&lt;</code>后<code>&gt;</code>前尽可能多的字符，为贪婪匹配</p></li><li><p><code>&lt;.+?&gt;</code> 加上<code>？</code>后将贪婪匹配转换为懒惰匹配</p></li></ol><h1 id="先、后行断言"><a href="#先、后行断言" class="headerlink" title="先、后行断言"></a>先、后行断言</h1><p>这里先引入笔者一个叫”丢弃匹配”的概念。</p><p><strong>丢弃匹配</strong>，指的是匹配到了，但是会被丢弃，不被引用。比如说匹配<code>1pt</code>，当只需要<code>1</code>时，<code>pt</code>就是被丢弃的部分，但是也需要被匹配到，所以<code>pt</code>就是<strong>丢弃匹配字符串</strong></p><p>先行断言，指的是<strong>匹配字符串在前</strong>，<strong>丢弃匹配字符串在后</strong>的匹配方法。比如说匹配<code>1px</code>，当只需要<code>1</code>时，<code>px</code>作为丢弃匹配字符串在<code>1</code>的<strong>后面</strong>。先行断言匹配有两种形式：</p><ul><li>正向先行断言：匹配<strong>对应丢弃匹配字符串</strong>的部分，匹配表达式为：<code>(?=)</code>，例子：<code>\d(?=px)</code></li></ul><p><img src="../../image/image-20220620104607815.png" alt="正向先行断言案例"></p><ul><li>负向先行断言：匹配对应丢弃匹配字符串<strong>以外</strong>的部分，匹配表达式为：<code>(?!)</code>，例子：<code>\d(?!px)</code></li></ul><p><img src="../../image/image-20220620104727221.png" alt="负向先行断言案例"></p><p>后行断言，指的是<strong>匹配字符串在后</strong>，<strong>丢弃匹配字符串在前</strong>的匹配方法。比如说匹配<code>px1</code>，当只需要<code>1</code>时，<code>px</code>作为丢弃匹配字符串在<code>1</code>的<strong>前面</strong>。后行断言匹配有两种形式</p><ul><li>正向后行断言：匹配<strong>对应丢弃匹配字符串</strong>的部分，匹配表达式为：<code>(?&lt;=)</code>，例子：<code>(?&lt;=px)\d</code></li></ul><p><img src="../../image/image-20220620105229435.png" alt="正向后行断言案例"></p><ul><li>负向后行断言：匹配对应丢弃匹配字符串<strong>以外</strong>的部分，匹配表达式为：<code>(?&lt;!)</code>，例子：<code>(?&lt;!px)\d</code></li></ul><p><img src="../../image/image-20220620105329590.png" alt="负向后行断言案例"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法基础</title>
    <link href="/my_world/content/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/my_world/content/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>所谓排序，即将原本无序的序列重新排列成有序序列的过程。这个序列中的每一项可能是单独的数据元素，也可能是一条记录（多个数据元素组成，如学号、姓名等）。如果是记录，可按照记录的主关键字排序（唯一标识符，主键）。</p><p>所谓稳定性，是指当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的</p><blockquote><p>以下文章、代码大量在<a href="https://www.runoob.com/w3cnote_genre/algorithm">算法 | 菜鸟分类 | 菜鸟教程 (runoob.com)</a>中取，其中有一些笔者的补充</p></blockquote><h2 id="排序算法的分类"><a href="#排序算法的分类" class="headerlink" title="排序算法的分类"></a>排序算法的分类</h2><ol><li>插入类的排序：在一个有序的序列中，插入一个新的关键字。属于这类排序的有【直接插入排序】、【折半插入排序】、【希尔排序】</li><li>交换类排序：每一趟排序，都通过一些列的”交换“动作，让一个关键字拍到它最终的位置上。属于这类排序的有【冒泡排序】、【快速排序】</li><li>选择类排序：每一趟排序都选出一个最小（或者最大）的关键字，把它和序列中的第一个（或最后一个）关键字交换，这样最小（或最大）的关键字到位。属于这类排序算法的有【简单选择排序】、【堆排序】</li><li>归并类排序：将两个或两个以上的有序序列合并成一个新的有序序列。</li><li>基数类排序：基于多关键字排序，把一个关键字拆分成多个关键字。最特别的一类。</li></ol><h2 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h2><h3 id="直接插入排序（Insertion-Sort）"><a href="#直接插入排序（Insertion-Sort）" class="headerlink" title="直接插入排序（Insertion Sort）"></a>直接插入排序（Insertion Sort）</h3><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><p>其过程相当于打纸牌，按照牌序算法从小到大排序</p><p><strong>算法步骤</strong></p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="算法动图展示"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span></span>&#123;    <span class="hljs-comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;        <span class="hljs-comment">// 记录要插入的数据</span>        <span class="hljs-keyword">int</span> tmp = array[i];        <span class="hljs-comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span>        <span class="hljs-keyword">int</span> j = i;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &lt; array[j - <span class="hljs-number">1</span>]) &#123;            array[j] = array[j - <span class="hljs-number">1</span>];            j--;        &#125;        <span class="hljs-comment">// 存在比其小的数，插入</span>        <span class="hljs-keyword">if</span> (j != i) &#123;            array[j] = tmp;        &#125;    &#125;&#125;</code></pre></div><h3 id="折半插入排序（Binary-Insertion-Sort）"><a href="#折半插入排序（Binary-Insertion-Sort）" class="headerlink" title="折半插入排序（Binary Insertion Sort）"></a>折半插入排序（Binary Insertion Sort）</h3><p>折半插入排序的基本思想和直接插入排序类似，区别是查找插入位置的方法不同，折半插入排序是采用折半查找法来查找插入位置的</p><p>折半插入排序适合关键字较多的场景。</p><h3 id="希尔排序（Shell’s-Sort）"><a href="#希尔排序（Shell’s-Sort）" class="headerlink" title="希尔排序（Shell’s Sort）"></a>希尔排序（Shell’s Sort）</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><p><strong>算法步骤</strong></p><ol><li>取数组长度，除于2得增量</li><li>将数组中每一个增量的数据当做一组，进行插入排序。例如：增量为5，则取数组为x_0，x_5；增量为n，则取数组为x_i，x_i+n)</li><li>取上一次的增量，除于2得下一个增量，重复步骤2，3，直到增量为1为止</li><li>当增量为1，将整个数组用直接插入排序排序即可。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="算法动图展示"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> length = arr.length;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = length / <span class="hljs-number">2</span>; step &gt;= <span class="hljs-number">1</span>; step /= <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = step; i &lt; length; i++) &#123;            temp = arr[i];            <span class="hljs-keyword">int</span> j = i - step;            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;                arr[j + step] = arr[j];                j -= step;            &#125;            arr[j + step] = temp;        &#125;    &#125;&#125;</code></pre></div><ol><li>时间复杂度分析<ol><li>O(n^2)</li><li>O(n^1.5)</li><li>平均情况：O(nlog_2n)</li></ol></li><li>空间复杂度分析：O(1)</li></ol><h2 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h2><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p>作为最简单的排序算法之一，冒泡排序给人的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="算法动图演示"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span>            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">int</span> tmp = arr[j];                    arr[j] = arr[j + <span class="hljs-number">1</span>];                    arr[j + <span class="hljs-number">1</span>] = tmp;                    flag = <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><ol><li>时间复杂度分析<ol><li>最坏情况：O(n^2)</li><li>最好情况：O(n)</li><li>平均情况：O(n^2)</li></ol></li><li>空间复杂度分析：O(1)</li></ol><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。其具体思路是：</p><ol><li>先从数列中取出一个元素作为基准数。</li><li>扫描数列，将比基准数小的元素全部放到它的左边，大于或等于基准数的元素全部放到它的右边，得到左右两个区间</li><li>再对左右区间重复第二步，直到各区间少于两个元素</li></ol><p>快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想——分治法也确实实用</p><p>分治法是一种很重要的算法，也就是“分而治之”的意思，就是把一个复杂的问题分解成两个或者多个相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="算法动图演示"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] finalarrays;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] quickSort(<span class="hljs-keyword">int</span>[] array)&#123;       sort(array, <span class="hljs-number">0</span>, array.length-<span class="hljs-number">1</span>);<span class="hljs-comment">//记得减一否则数组下标越界</span>       <span class="hljs-keyword">return</span> finalarrays;   &#125;   <span class="hljs-comment">//left和right代表下标值</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;       <span class="hljs-keyword">if</span>(left &gt;= right)&#123; <span class="hljs-comment">//递归出口，遍历的终点</span>           finalarrays = Arrays.copyOf(array ,array.length);<span class="hljs-comment">//将结果拷贝在属性上，会有多次更替</span>           <span class="hljs-keyword">return</span>;       &#125;       <span class="hljs-keyword">int</span> pivot = array[(left + right) / <span class="hljs-number">2</span>];<span class="hljs-comment">//找出基准位</span>       <span class="hljs-keyword">int</span> index = partition(array, left, right, pivot);<span class="hljs-comment">//获取基准数下标的后一位，更换位置</span>       sort(array, left, index-<span class="hljs-number">1</span>);<span class="hljs-comment">//递归算法排序左边的数组</span>       sort(array, index, right);<span class="hljs-comment">//递归算法排序右边的数组</span>   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 核心，最能体现分治法的部分</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array ,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> pivot)</span></span>&#123;       <span class="hljs-keyword">while</span> (left &lt;= right)&#123; <span class="hljs-comment">//左右下标遍历</span>           <span class="hljs-keyword">while</span> (array[left] &lt; pivot)&#123; <span class="hljs-comment">//从左边遍历查找是否有大于基准位的数字</span>               left++;           &#125;           <span class="hljs-keyword">while</span> (array[right] &gt; pivot)&#123; <span class="hljs-comment">//从右边遍历查找是否有小于基准位的数字</span>               right--;           &#125;           <span class="hljs-comment">/**</span><span class="hljs-comment">            * 排除以上情况后</span><span class="hljs-comment">            * 将大于基准位数字的放在右边，将小于基准位数字的放在左边</span><span class="hljs-comment">            * 也就是左右互换</span><span class="hljs-comment">            */</span>           <span class="hljs-keyword">if</span>(left &lt;= right)&#123;               swap(array, left, right);               <span class="hljs-comment">//互换完成后下标继续走</span>               left++;               right--;           &#125;       &#125;       <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回基准位下标的后一位</span>   &#125;   <span class="hljs-comment">//左右数值交换</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;       <span class="hljs-keyword">int</span> number;       number = array[left];       array[left] = array[right];       array[right] = number;   &#125;</code></pre></div><ol><li>时间复杂度分析<ol><li>最坏情况：O(n^2)</li><li>最好情况：O(nlog_2n)，待排序列越接近无序，效率越高效</li><li>平均情况：O(nlog_2n)</li></ol></li><li>空间复杂度分析：O(log_2n)，快速排序是递归进行的，递归需要栈的辅助，因此它需要的辅助空间比前面几类排序算法大</li></ol><h2 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h2><h3 id="简单选择排序（Insertion-Sort）"><a href="#简单选择排序（Insertion-Sort）" class="headerlink" title="简单选择排序（Insertion Sort）"></a>简单选择排序（Insertion Sort）</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。</p><p><strong>算法步骤</strong></p><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="算法动图演示"></p><p>代码实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-comment">// 总共要经过 N-1 轮比较</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">int</span> min = i;            <span class="hljs-comment">// 每轮需要比较的次数 N-i</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;                    <span class="hljs-comment">// 记录目前能找到的最小值元素的下标</span>                    min = j;                &#125;            &#125;            <span class="hljs-comment">// 将找到的最小值和i位置所在的值进行交换</span>            <span class="hljs-keyword">if</span> (i != min) &#123;                <span class="hljs-keyword">int</span> tmp = arr[i];                arr[i] = arr[min];                arr[min] = tmp;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;</code></pre></div><ol><li>时间复杂度分析<ol><li>平均情况：O(n^2)</li></ol></li><li>空间复杂度分析：O(1)</li></ol><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；（父亲大，孩子小）</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；（父亲小，孩子大）</li></ol><p><strong>算法步骤</strong></p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="算法动图演示"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt="算法动图演示2"></p><p>代码实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">int</span> len = arr.length;        buildMaxHeap(arr, len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;            swap(arr, <span class="hljs-number">0</span>, i);            len--;            heapify(arr, <span class="hljs-number">0</span>, len);        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>) Math.floor(len / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;            heapify(arr, i, len);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> largest = i;        <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;            largest = left;        &#125;        <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;            largest = right;        &#125;        <span class="hljs-keyword">if</span> (largest != i) &#123;            swap(arr, i, largest);            heapify(arr, largest, len);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;&#125;</code></pre></div><p>自己总结的交换过程：</p><ol><li>从倒数第二层开始，对比父节点和子节点，若子节点的值大于父节点的值，交换父子节点，这里有两种情况：<ul><li>子节点只有一个值大于父节点，直接交换即可</li><li>子节点全部大于父节点，选出最大的那个，和父节点交换</li></ul></li><li>倒数第二层交换完毕后，重复以上交换步骤，直到交换的焦点为根节点（即交换到根节点），此时根节点为最大的数</li><li>将根节点和树的最后一个叶子节点交换（从右往左数），交换后，删除最后一个叶子节点（拿出来存到容器中）。</li><li><p>重复1-3步骤，直到该二叉树为空树，此时排序结束。</p></li><li><p>时间复杂度分析</p><ol><li>平均情况：O(nlog_2n)</li></ol></li><li>空间复杂度分析：O(1)</li></ol><h2 id="归并类排序"><a href="#归并类排序" class="headerlink" title="归并类排序"></a>归并类排序</h2><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p><strong>算法步骤</strong></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="算法动图演示"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        sort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(L == R) &#123;            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 递归出口</span>        &#125;        <span class="hljs-keyword">int</span> mid = L + ((R - L) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 找出中间值</span>        sort(arr, L, mid);<span class="hljs-comment">// 左子序列递归</span>        sort(arr, mid + <span class="hljs-number">1</span>, R);<span class="hljs-comment">// 右子序列递归</span>        merge(arr, L, mid, R);<span class="hljs-comment">// 出口后归并序列</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R - L + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> p1 = L;        <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;        <span class="hljs-comment">// 比较左右两部分的元素，哪个小，把那个元素填入temp中</span>        <span class="hljs-keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;            temp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];        &#125;        <span class="hljs-comment">// 上面的循环退出后，把剩余的元素依次填入到temp中</span>        <span class="hljs-comment">// 以下两个while只有一个会执行</span>        <span class="hljs-keyword">while</span>(p1 &lt;= mid) &#123;            temp[i++] = arr[p1++];        &#125;        <span class="hljs-keyword">while</span>(p2 &lt;= R) &#123;            temp[i++] = arr[p2++];        &#125;        <span class="hljs-comment">// 把最终的排序的结果复制给原数组</span>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; temp.length; i++) &#123;            arr[L + i] = temp[i];        &#125;    &#125;&#125;</code></pre></div><ol><li>时间复杂度分析<ol><li>O(nlog_2n)</li></ol></li><li>空间复杂度分析：O(n)</li></ol><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>所谓外部排序，即对外存中的记录进行排序（相对于内部排序而言）。外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p><p>外部排序常用的算法是<strong>归并排序</strong>，之所以归并排序常用，是因为它不需要将全部记录都读入内存即可完成排序。因此可以解决由于由于内存空间不足导致的无法对大规模记录排序的问题。</p><h2 id="基数类"><a href="#基数类" class="headerlink" title="基数类"></a>基数类</h2><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ol><li><p>什么时候最快：</p><p>当输入的数据可以均匀的分配到每一个桶中。</p></li><li><p>什么时候最慢：</p><p>当输入的数据被分配到了同一个桶中。</p></li></ol><p>示意图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="元素分布在桶中"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="每个桶排序"></p><p>代码实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BucketSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InsertSort insertSort = <span class="hljs-keyword">new</span> InsertSort();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">return</span> bucketSort(arr, <span class="hljs-number">5</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] bucketSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> bucketSize) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> arr;        &#125;        <span class="hljs-keyword">int</span> minValue = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;            <span class="hljs-keyword">if</span> (value &lt; minValue) &#123;                minValue = value;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; maxValue) &#123;                maxValue = value;            &#125;        &#125;        <span class="hljs-keyword">int</span> bucketCount = (<span class="hljs-keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount][<span class="hljs-number">0</span>];        <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-keyword">int</span> index = (<span class="hljs-keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);            buckets[index] = arrAppend(buckets[index], arr[i]);        &#125;        <span class="hljs-keyword">int</span> arrIndex = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : buckets) &#123;            <span class="hljs-keyword">if</span> (bucket.length &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 对每个桶进行排序，这里使用了插入排序</span>            bucket = insertSort.sort(bucket);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;                arr[arrIndex++] = value;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自动扩容，并保存数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);        arr[arr.length - <span class="hljs-number">1</span>] = value;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>基数排序有两种实现方式：</p><ol><li>最高位优先。即先按最高位排成若干子序列，再对每个子序列按次高位排序</li><li>最低位优先。这种方式不必分成子序列，每次排序全体关键字都参与。最低位可以不通过比较，而是通过分配和收集进行排序。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="算法动图演示"></p><p>代码实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基数排序</span><span class="hljs-comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        <span class="hljs-keyword">int</span> maxDigit = getMaxDigit(arr);        <span class="hljs-keyword">return</span> radixSort(arr, maxDigit);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取最高位数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxValue = getMaxValue(arr);        <span class="hljs-keyword">return</span> getNumLenght(maxValue);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;                maxValue = value;            &#125;        &#125;        <span class="hljs-keyword">return</span> maxValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumLenght</span><span class="hljs-params">(<span class="hljs-keyword">long</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> lenght = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> temp = num; temp != <span class="hljs-number">0</span>; temp /= <span class="hljs-number">10</span>) &#123;            lenght++;        &#125;        <span class="hljs-keyword">return</span> lenght;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] radixSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxDigit) &#123;        <span class="hljs-keyword">int</span> mod = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> dev = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;            <span class="hljs-comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span>            <span class="hljs-keyword">int</span>[][] counter = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mod * <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;                <span class="hljs-keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;                counter[bucket] = arrayAppend(counter[bucket], arr[j]);            &#125;            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : counter) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;                    arr[pos++] = value;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自动扩容，并保存数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrayAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);        arr[arr.length - <span class="hljs-number">1</span>] = value;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre></div><h2 id="各大排序算法时间空间复杂度总结"><a href="#各大排序算法时间空间复杂度总结" class="headerlink" title="各大排序算法时间空间复杂度总结"></a>各大排序算法时间空间复杂度总结</h2><p><img src="../../image/image-20210802150414124.png" alt="图原自于[各种排序算法的时间空间复杂度_方同学的博客-CSDN博客_几种排序的空间复杂度](https://blog.csdn.net/weixin_43824059/article/details/88238177)"></p><p>速记：</p><p>时间复杂度：</p><ul><li>平均情况：<strong>快些</strong>以$nlog_2n$的速度<strong>归队</strong>。“快”指快速排序，“些”指希尔排序（谐音），“归”指归并排序，“队”指堆排序（谐音），平均情况下，快速排序、希尔排序、归并排序和堆排序的时间复杂度均为$O(nlog_2n)$，其他的都是$O(n^2)$。一个特殊的是基数排序，其时间复杂度为$O(d(n+r_d))$</li><li>最坏情况，快速排序的时间复杂度为$O(n^2)$，其他都和平均情况相同</li></ul><p>空间复杂度：</p><ul><li>快速排序为$O(log_2n)$</li><li>归并排序为$O(n)$</li><li>基数排序为$O(r_d)$</li><li>其他都是$O(1)$</li></ul><p>算法稳定性</p><ul><li>快些选堆。“快”指快速排序，“些”指希尔排序（谐音），“选”指简单选择排序，“堆”指堆排序，这4种是不稳定的，其他自然都是稳定的。</li></ul><p>算法使用场景：</p><blockquote><p>引用<a href="https://blog.csdn.net/derbi123123/article/details/104318134">十大排序算法的实现以及各自的优缺点、适用情况<em>derbi123123的博客-CSDN博客</em>排序算法的优缺点</a></p></blockquote><p>不存在最好的排序算法，我们需要根据上面这些性能选择合适的方法，甚至是结合使用。</p><ol><li>当数据规模较小时候，可以使用简单的<strong>直接插入排序</strong>、<strong>直接选择排序</strong>或者<strong>冒泡排序</strong>。</li><li>当文件的初态已经基本有序或者存在大量重复数据，可以用<strong>希尔排序</strong>。</li><li>当文件的初态已经基本有序，可以用<strong>直接插入排序</strong>和<strong>冒泡排序</strong>。</li><li>当数据规模较大时，应用速度最快的排序算法，可以考虑使用<strong>快速排序</strong>。当记录随机分布的时候，快速排序平均时间最短，但是会出现最坏的情况，这个时候的时间复杂度是O(n^2)，且递归深度为n,所需的占空间为O(n)。</li><li><strong>堆排序</strong>不会出现快排那样最坏情况，且堆排序所需的辅助空间比快排要少，但是这两种算法都不是稳定的，要求排序时是稳定的，可以考虑用<strong>归并排序</strong>。</li><li><strong>归并排序</strong>可以用于内部排序，也可以使用于外部排序。在外部排序时，通常采用多路归并，并且通过解决长顺串的合并，加上长的初始串，提高主机与外设并行能力等，以减少访问外存额外次数，提高外排的效率。</li><li>特殊的<strong>桶排序</strong>、<strong>基数排序</strong>都是稳定且高效的排序算法，但有一定的局限性：<ul><li>关键字可分解。</li><li>记录的关键字位数较少，如果密集更好</li><li>如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</li></ul></li></ol><p>常用时间复杂度大小比较</p><script type="math/tex; mode=display">O(1) \leq O(log_2n) \leq O(n) \leq O(nlog_2n) \leq O(n^2) \leq O(n^3) \leq \cdots \leq O(n^k) \leq O(2^n)</script><p><img src="../../image/image-202108111628499919.png" alt="笔者思考总结算法使用场景"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
      <tag>更新未完成</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找算法基础</title>
    <link href="/my_world/content/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/my_world/content/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查找的定义：给定一个值K，在含有N个记录的表中找出关键字等于K的记录。若找到，则查找成功，返回该记录的信息或者该记录在表中的位置；否则查找失败。重要信息：记录和关键字。由于查找算法的基本操作是关键字的比较，并且关键字比较次数与<strong>待查找关键字</strong>有关（对于一个查找表来说，对其中不同的关键字进行查找，关键字比较次数一般不同），因此通常把查找过程中对关键字的<strong>平均比较次数</strong>（也称为<strong>平均查找长度</strong>）作为衡量一个查找算法效率优劣的标准。平均查找长度用<strong>ASL</strong>来表示。</p><h2 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h2><p>顺序查找法是一种最简单的查找方法。基本思路为：顺序遍历线性表，依次将表中数据与给定值K比较。若当前扫描的关键字与K相等，则查找成功；若扫描结束后，仍未发现关键字等于K的记录，则查找失败。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">simpleSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> target)</span></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;        <span class="hljs-keyword">if</span>(array[i] == target)&#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="折半查找法（half-interval-search）"><a href="#折半查找法（half-interval-search）" class="headerlink" title="折半查找法（half-interval search）"></a>折半查找法（half-interval search）</h2><p>也称二分搜索（英语：binary search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。</p><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；</p><p>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</p><p>如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半</p><p>折半查找法的优点是比较次数少，查找速度快，平均性能好；</p><p>其缺点是要求待查表为<strong>有序</strong>表，且插入删除困难。</p><p>因此，折半查找方法适用于不经常变动而查找频繁的有序列表。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> target)</span></span>&#123;    <span class="hljs-comment">//把左右下标独立出来</span>    <span class="hljs-keyword">int</span> mid, left, right;    left = <span class="hljs-number">0</span>;    right = array.length - <span class="hljs-number">1</span>;    mid = (left + right) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (array[mid] != target) &#123;        <span class="hljs-comment">//查询断口</span>        <span class="hljs-keyword">if</span>(right - left &lt; <span class="hljs-number">4</span>)&#123;            <span class="hljs-keyword">int</span> length = right - left;<span class="hljs-comment">//返回查询数据量的长度</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;                <span class="hljs-keyword">if</span>(array[left] == target)&#123;                    <span class="hljs-keyword">return</span> left;                &#125;                left++;            &#125;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//查询失败返回-1</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[mid]) &#123;            <span class="hljs-comment">//如果目标搜索的数字大于中间的数字，左下标转移到中间下标的下一位</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[mid]) &#123;            <span class="hljs-comment">//如果目标搜索的数字小于中间的数字，右下标转移到中间下标的前一位</span>            right = mid - <span class="hljs-number">1</span>;        &#125;        mid = (left + right) / <span class="hljs-number">2</span>;<span class="hljs-comment">//左右下标运算得到新的中间下标</span>    &#125;    <span class="hljs-keyword">return</span> mid;&#125;</code></pre></div><p>折半查找的过程可以用二叉树来表示，得到的二叉树称为<strong>描述折半查找的判定树</strong></p><p><img src="../../image/image-202107281628499919.png" alt="折半查找的判定树"></p><p>图e中折半查找判定树的查找成功（ASL1）和不成功（ASL2）的平均查找长度为：</p><p>ASL1 = (每层的结点个数<em>层数后相加)/总结点数 = (1\</em>1+2*2+4*3+3*4)/10</p><p>ASL2 = (空结点<em>层数-1后相加)/总空结点数 = (5\</em>3+6*4)/11</p><ol><li><p>查找判定树的中序遍历序列与查找表相同</p></li><li><p>如果mid=(low+high)/2判定树中任何子树的右子树结点数-左子树结点数必为0或1</p></li><li><p>判定树是一棵平衡的二叉排序树</p></li><li><p>除了最后一层，判定树其它层的结点一定是满的，查找表为n的判定树高h= [log_2(n+1)]</p></li><li><p>查找表为n的判定树有n-1个失败叶结点</p></li><li><p>查找成功和失败的ASL&lt;=树高</p></li><li><p>算法时间复杂度为o(log_2n)</p></li></ol><h2 id="插值查找（额外）"><a href="#插值查找（额外）" class="headerlink" title="插值查找（额外）"></a>插值查找（额外）</h2><p>插值查找，有序表的一种查找方式。</p><p>插值查找是根据查找关键字与查找表中最大最小记录关键字比较后的查找方法。</p><p>插值查找基于二分查找，将查找点的选择改进为自适应选择，提高查找效率。</p><p>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快。<br>关键字分布不均匀的情况下，该方法不一定比折半查找要好</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertSeatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (array.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = array.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> mid = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;        mid = left + (target - array[left]) / (array[right] - array[left]) * (right - left);        <span class="hljs-keyword">if</span> (target &gt; array[mid])            left = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[mid])            right = mid - <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="分块查找（索引顺序查找）"><a href="#分块查找（索引顺序查找）" class="headerlink" title="分块查找（索引顺序查找）"></a>分块查找（索引顺序查找）</h2><p>分块查找把线性表分成若干块，每一块中的元素存储循序是任意的，但是块与块之间必须按照关键字大小有序排序，即前一块中的最大关键字要小于后一块中的最小关键字。对顺序表进行分块查询需要额外建立一个索引表，表中的每一项对应线性表中的一块。</p><p>方法为：首先确定待查找的元素属于哪一块（索引表比较），然后在块内精确查找该元素。</p><p>分块查找实际上进行两次查找，整个算法的平均查找长度是两次查找的平均查找长度之和，即二分查找平均查找长度+顺序查找平均查找长度</p><h2 id="二叉排序树（Binary-Sort-Tree，缩写为BST）"><a href="#二叉排序树（Binary-Sort-Tree，缩写为BST）" class="headerlink" title="二叉排序树（Binary Sort Tree，缩写为BST）"></a>二叉排序树（Binary Sort Tree，缩写为BST）</h2><p>一棵空树，或者是具有下列性质的二叉树：</p><p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3）左、右子树也分别为二叉排序树；</p><p>（4）没有键值相等的结点。</p><p>输出二叉排序树的中序遍历序列，则这个序列是非递减（非递增）有序的，若不做说明，排序二叉树节点关键字按左小右大分布。<strong>折半查找法的判定树是一个二叉排序树</strong>，以下为插入二叉排序树的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node root;<span class="hljs-comment">//根节点</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">this</span>.root = root;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 二叉排序树</span><span class="hljs-comment">     * 排序式添加结点，比根大的放右边，比根小的放左边</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortAdd</span><span class="hljs-params">(Node node)</span> </span>&#123;        isBST = <span class="hljs-keyword">true</span>;        Map parent = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//            System.out.println(node.getValue()+&quot; set root&quot;);</span>            setRoot(node);            parent = <span class="hljs-keyword">null</span>;            node.setParent(parent);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(node.getValue().hashCode() &lt; root.getValue().hashCode())&#123;                <span class="hljs-comment">//该节点的值比根小，搜索左子树</span>                <span class="hljs-keyword">if</span>(root.getLeft()!=<span class="hljs-keyword">null</span>)&#123;                    Node root = <span class="hljs-keyword">this</span>.root;                    setRoot(root.getLeft());<span class="hljs-comment">//                    System.out.println(this.root.getValue()+&quot; go left&quot;);</span>                    sortAdd(node);                    setRoot(root);                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//                    System.out.println(node.getValue()+&quot; set left&quot;);</span>                    root.setLeft(node);                    parent.put(<span class="hljs-number">0</span>,root);                    node.setParent(parent);                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node.getValue().hashCode() &gt; root.getValue().hashCode())&#123;                <span class="hljs-comment">//该节点的值比根大，搜索右子树</span>                <span class="hljs-keyword">if</span>(root.getRight()!=<span class="hljs-keyword">null</span>)&#123;                    Node root = <span class="hljs-keyword">this</span>.root;                    setRoot(root.getRight());<span class="hljs-comment">//                    System.out.println(this.root.getValue()+&quot; go right&quot;);</span>                    sortAdd(node);                    setRoot(root);                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//                    System.out.println(node.getValue()+&quot; set right&quot;);</span>                    root.setRight(node);                    parent.put(<span class="hljs-number">1</span>,root);                    node.setParent(parent);                &#125;            &#125;        &#125;    &#125;</code></pre></div><p>关于如何删除二叉排序树的结点：</p><ol><li>如果树只有根结点，并且待删除的结点就是根结点</li><li>如果待删除的结点是叶结点，直接删除，不会破坏二又排序树的性质。</li><li>如果待删除的结点只有左子树或右子树，则让子树代替自己。</li><li>如果待除的结点有左子树和右子树，让左子树最右侧的结点代替自己，然后删除左子树最右侧的结点。（也可以让石子树最左侧的结点代替自己，然后除石子树最左侧的结点。）</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 二叉排序树</span><span class="hljs-comment"> * 删除节点，并且删除节点后保持二叉排序树的性质</span><span class="hljs-comment"> * 若不是二叉排序树，不会删除任何节点</span><span class="hljs-comment"> * 若不存在结点，不删除任何节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortDel</span><span class="hljs-params">(Node node)</span></span>&#123;    Node current = search(node);    <span class="hljs-keyword">if</span>(isBST == <span class="hljs-keyword">false</span>)&#123;        System.out.println(<span class="hljs-string">&quot;This tree is not BST(Binary Sort Tree)&quot;</span>);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current != <span class="hljs-keyword">null</span> &amp;&amp; isBST == <span class="hljs-keyword">true</span>)&#123;        <span class="hljs-comment">/* 如果树只有根结点，并且待删除的结点就是根结点 */</span>        <span class="hljs-keyword">if</span>(root.getValue().hashCode() == current.getValue().hashCode() &amp;&amp; root.getRight() == <span class="hljs-keyword">null</span> &amp;&amp; root.getLeft() == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This tree only has a root node,this node is root,so delete it&quot;</span>);            root = <span class="hljs-keyword">null</span>;            current = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">/* 如果待删除的结点是叶结点，直接删除，不会破坏二又排序树的性质 */</span>        <span class="hljs-keyword">if</span>(root.getValue().hashCode() != current.getValue().hashCode() &amp;&amp; root.getRight() == <span class="hljs-keyword">null</span> &amp;&amp; root.getLeft() == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node is leaf node,delete it&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(<span class="hljs-keyword">null</span>);            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(<span class="hljs-keyword">null</span>);            &#125;        &#125;        <span class="hljs-comment">/* 如果待删除的结点只有左子树或右子树，则让子树代替自己。 */</span>        <span class="hljs-keyword">if</span>(current.getLeft()!= <span class="hljs-keyword">null</span> &amp;&amp; current.getRight() == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node only have left tree,delete this node and replace with left tree&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(current.getLeft());            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(current.getLeft());            &#125;        &#125;        <span class="hljs-keyword">if</span>(current.getLeft()== <span class="hljs-keyword">null</span> &amp;&amp; current.getRight() != <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node only have right tree,delete this node and replace with right tree&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(current.getRight());            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(current.getRight());            &#125;        &#125;        <span class="hljs-comment">/* 如果待除的结点有左子树和右子树，让左子树最右侧的结点代替自己，然后删除左子树最右侧的结点。</span><span class="hljs-comment">        （也可以让石子树最左侧的结点代替自己，然后除石子树最左侧的结点。）*/</span>        <span class="hljs-keyword">if</span>(current.getLeft()!= <span class="hljs-keyword">null</span> &amp;&amp; current.getRight() != <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node both have left and right tree,delete this node and replace with right tree&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(current.getRight());                current.getRight().setLeft(current.getLeft());            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(current.getRight());                current.getRight().setLeft(current.getLeft());            &#125;        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        System.out.println(<span class="hljs-string">&quot;Can not find this node in the tree,cant delete this node&quot;</span>);    &#125;&#125;</code></pre></div><p>如果二又排序树高为h,最下层结点的查找长度为h,查找操作的时间复杂度为O(h)</p><p>具有n个(n&gt;0)结点的二叉树的最小高度为log_2(n+1)或log_2n+1。最大高度为n</p><p>最好的情况：平均查找长度=O(log_2n)</p><p>最坏的情况：平均查找长度=O(n)</p><h2 id="平衡二叉树-Balanced-Binary-Tree"><a href="#平衡二叉树-Balanced-Binary-Tree" class="headerlink" title="平衡二叉树(Balanced Binary Tree)"></a>平衡二叉树(Balanced Binary Tree)</h2><p>简称平衡树(AVLG. MAdelson-velsky、E.M. Landis),是一种特殊的二叉排序树。它实现了较高的查找效率，发现树越矮查找效率越高，进而发明了平衡二叉树。树上任意结点的左子树和右子树的深度之差不超过1</p><p><strong>结点的平衡因子=左子树的高度-右子树的高度</strong></p><p>在二叉排序树中插入和删除结点后，只需要调整<strong>最小不平衡子树</strong>，整棵树将恢复平衡。</p><p>最小平衡子树有四种情况（LL，RR，LR，RL）：</p><ol><li>LL：左左更高，整棵树向右旋转（右单旋转调整）</li><li>RR：右右更高，整棵树向左旋转（左单旋转调整）</li><li>LR：左右更高，左子树先向左旋转，后将整棵树向右旋转（先左后右双旋转调整）</li><li>RL：右左更高，右子树先向右旋转，后将整棵树向左旋转（先右后左双旋转调整）</li></ol><p><img src="../../image/image-20210729.png" alt="最小不平衡数四种情况举例，1234分别代表LL、RR、LR、RL"></p><h2 id="散列（Hash，也叫哈希）表"><a href="#散列（Hash，也叫哈希）表" class="headerlink" title="散列（Hash，也叫哈希）表"></a>散列（Hash，也叫哈希）表</h2><p>散列表，又叫哈希表（Hash Table），是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。也就是说，<strong>把关键字映射到一个表中的位置（地址）来直接访问记录</strong>，以加快访问速度。</p><p>在哈希查找过程中，要解决两方面的问题，分别是<strong>构造哈希函数</strong>和<strong>处理冲突</strong>。评判一个散列函数优劣的两个主要条件是<strong>值均匀分布与表空间以减少冲突</strong>和<strong>函数尽可能简单以方便计算</strong></p><p>评价哈希表的标准是：<strong>哈希表内数值分部是否均匀</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node[] hash_table;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> remain;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tableLength)</span></span>&#123;    initTable(tableLength);    remain = tableLength;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tableLength)</span></span>&#123;    hash_table = <span class="hljs-keyword">new</span> Node[tableLength];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hash_table_toString</span><span class="hljs-params">()</span></span>&#123;    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();    sb.append(<span class="hljs-string">&quot;HashTable:[&quot;</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; hash_table.length; i++) &#123;        <span class="hljs-keyword">if</span>(hash_table[i] == <span class="hljs-keyword">null</span>)&#123;            sb.append(<span class="hljs-string">&quot;index: &quot;</span>+i+<span class="hljs-string">&quot; value: &quot;</span>+<span class="hljs-string">&quot;null&quot;</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hash_table[i]!=<span class="hljs-keyword">null</span> &amp;&amp; hash_table[i].getNext() == <span class="hljs-keyword">null</span>)&#123;            sb.append(<span class="hljs-string">&quot;index: &quot;</span>+i+<span class="hljs-string">&quot; value: &quot;</span>+hash_table[i].getValue());        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hash_table[i]!=<span class="hljs-keyword">null</span> &amp;&amp; hash_table[i].getNext() != <span class="hljs-keyword">null</span>)&#123;            LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();            queue.offer(hash_table[i]);            <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;                Node pollNode = queue.poll();                sb.append(<span class="hljs-string">&quot;index: &quot;</span>+i+<span class="hljs-string">&quot; value: &quot;</span>+pollNode.getValue());                sb.append(<span class="hljs-string">&quot;--&gt;&quot;</span>);                <span class="hljs-keyword">if</span>(pollNode.getNext()!=<span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">//出队队头元素并访问，若不为空指针，则将下一个结点拿出来，放到队列里面</span>                    queue.offer(pollNode.getNext());                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pollNode.getNext()==<span class="hljs-keyword">null</span>)&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        sb.append(<span class="hljs-string">&quot;,&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    sb.delete(sb.length()-<span class="hljs-number">1</span>,sb.length());    sb.append(<span class="hljs-string">&quot;]&quot;</span>);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre></div><p>下面简单介绍几种哈希函数。</p><ul><li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</li><li>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li><li>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li><li>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li><li><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 除留余数法构造Hash(hash为哈希表的下标/地址)</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bulidHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;       <span class="hljs-keyword">return</span> key%remain;   &#125;</code></pre></div><h3 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h3><p>散列表有两种用法：一种是 Key 的值与 Value 的值一样，一般我们称这种情况的结构为 Set（集合）；而如果 Key 和 Value 所对应的内容不一样时，那么我们称这种情况为 Map，也就是人们俗称的键值对集合。</p><p>根据散列表的存储结构，我们可以得出散列表的以下特点。</p><p>1) 访问速度很快</p><p>由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</p><p>2) 需要额外的空间</p><p>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。</p><p>这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</p><p>3) 无序</p><p>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</p><p>4) 可能会产生碰撞</p><p>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</p><h3 id="常用Hash解决冲突的办法"><a href="#常用Hash解决冲突的办法" class="headerlink" title="常用Hash解决冲突的办法"></a>常用Hash解决冲突的办法</h3><ol><li>拉链法/链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 拉链法存储Hash</span><span class="hljs-comment">  * 将Hash映射到表中</span><span class="hljs-comment">  */</span> <span class="hljs-keyword">public</span> Node[] zipperSave(T key)&#123;     Node node = <span class="hljs-keyword">new</span> Node();     node.setValue(key);     <span class="hljs-keyword">int</span> hash = bulidHash(Integer.parseInt(String.valueOf(node.getValue())));<span class="hljs-comment">//构建hash</span>     <span class="hljs-keyword">if</span>(hash_table[hash]!=<span class="hljs-keyword">null</span>)&#123;         LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();         queue.offer(hash_table[hash]);<span class="hljs-comment">//将</span>         <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;             Node pollNode = queue.poll();             <span class="hljs-keyword">if</span>(pollNode.getNext()!=<span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">//出队队头元素并访问，若不为空指针，则将下一个结点拿出来，放到队列里面</span>                 queue.offer(pollNode.getNext());             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pollNode.getNext()==<span class="hljs-keyword">null</span>)&#123;                 pollNode.setNext(node);             &#125;         &#125;     &#125;<span class="hljs-keyword">else</span>&#123;         hash_table[hash] = node;     &#125;     <span class="hljs-keyword">return</span> hash_table; &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 使用拉链法后，快速搜索哈希表</span><span class="hljs-comment">  */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">zipperGetValue</span><span class="hljs-params">(T key)</span></span>&#123;     <span class="hljs-keyword">int</span> hash = bulidHash(Integer.parseInt(String.valueOf(key)));<span class="hljs-comment">//构建hash</span>     <span class="hljs-keyword">if</span>(hash_table[hash]!=<span class="hljs-keyword">null</span>)&#123;         LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();         queue.offer(hash_table[hash]);         <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;             Node pollNode = queue.poll();             <span class="hljs-keyword">if</span>(pollNode.getValue().hashCode() == key.hashCode())&#123;                 <span class="hljs-keyword">return</span> pollNode;             &#125;             <span class="hljs-keyword">if</span>(pollNode.getNext()!=<span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">//出队队头元素并访问，若不为空指针，则将下一个结点拿出来，放到队列里面</span>                 queue.offer(pollNode.getNext());             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pollNode.getNext()==<span class="hljs-keyword">null</span>)&#123;                 queue.poll();             &#125;         &#125;     &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; &#125;</code></pre></div><ol><li>线性探索法：在开放定址算法里，线性探测法是散列解决冲突的一种方法，当hash一个关键字时，发现没有冲突，就保存关键字， 如果出现冲突，则就探测冲突地址下一个地址，依次按照线性查找，直到发现有空地址为止，从而解决冲突，</li></ol><blockquote><p>引用文章<a href="https://www.cnblogs.com/longerQiu/p/11703441.html">线性探测法 - loserQiu - 博客园 (cnblogs.com)</a></p></blockquote><p>例如 关键字集合{7、8、30、11、18、9、14}，散列函数为：H(key) = (keyx3) MOD 7， 设装填因子（元素个数/散列表长度）为0.7，那么 散列表的长度为 10。</p><p>关键字（key）集合存放位置分别为：</p><div class="table-container"><table><thead><tr><th>7</th><th>8</th><th>30</th><th>11</th><th>18</th><th>9</th><th>14</th></tr></thead><tbody><tr><td>0</td><td>3</td><td>6</td><td>5</td><td>5</td><td>6</td><td>0</td></tr></tbody></table></div><p>由表格知道，这里的7和14、30和9、11和18出现了位置存放冲突。存放key=7时，散列表长度为10的表中其实没有冲突， 因为7是第一个存在到表中的key，所以一定不会有冲突的，所以7对应散列表的地址0。8、30、11存放的地址分别是3、 6 、5，但是到了key=18时候，发现存放的地址为5，而地址5已经存放了key=11,这时发生了地址冲突。根据线性探测法，算法会探测地址5的下一个地址，即地址6，而此时地址6已经存放了key=30，程序继续探测下一个地址，发现地址7位空，此时把key=18存放到地址7处。以此类推，最后得出的散列表为：</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>7</td><td>14</td><td></td><td>8</td><td></td><td>11</td><td>30</td><td>18</td><td>9</td></tr></tbody></table></div><p>成功查找率：（1+1+1++1+3+3+2）/ 7</p><p>不成功查找率</p><p>计算查找不成功的次数就直接找关键字到第一个地址上关键字为空的距离即可， 但根据哈希函数地址为MOD7，因此初始只可能在0~6的位置。等概率情况下，查找0~6位置查找失败的查找次数为：</p><p>　　 地址0，到第一个关键字为空的地址2的距离为3，因此查找不成功的次数为3.　　</p><p>　　 地址1， 到第一个关键为空的地址2的距离为2，因此查找不成功的次数为2.</p><p>​    地址2， 到第一个关键为空的地址2的距离为1，因此查找不成功的次数为1.</p><p>​    地址3，到第一个关键为空的地址4的距离为2，因此查找不成功的次数为2.</p><p>​    地址4，到第一个关键为空的地址4的距离为1，因此查找不成功的次数为1.</p><p>​    地址5，到第一个关键为空的地址2(注意不是地址9，因为初始只可能在0~6之间，因此循环回去)的距离为5，因此查找不成功的次数为5.</p><p>​    地址6，到第一个关键为空的地址2(注意不是地址9，因为初始只可能在0~6之间，因此循环回去)的距离为4，因此查找不成功的次数为4.</p><p>不成功查找率：（3+2+1+2+1+5+4）/7</p><ol><li>平方探测法</li></ol><h2 id="时间复杂度总结"><a href="#时间复杂度总结" class="headerlink" title="时间复杂度总结"></a>时间复杂度总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">查找找</th><th style="text-align:center">平均时间复杂度</th><th>查找条件</th><th>算法描述</th></tr></thead><tbody><tr><td style="text-align:center">顺序查找</td><td style="text-align:center">O(n)</td><td>无序或有序队列</td><td>按顺序比较每个元素，直到找到关键字为止</td></tr><tr><td style="text-align:center">二分查找（折半查找）</td><td style="text-align:center">O(logn)</td><td>有序数组</td><td>查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。</td></tr><tr><td style="text-align:center">二叉排序树查找</td><td style="text-align:center">O(logn)</td><td>二叉排序树</td><td>在二叉查找树b中查找x的过程为：1. 若b是空树，则搜索失败2. 若x等于b的根节点的数据域之值，则查找成功；3. 若x小于b的根节点的数据域之值，则搜索左子树4. 查找右子树。</td></tr><tr><td style="text-align:center">哈希表法（散列表）</td><td style="text-align:center">O(1)</td><td>先创建哈希表（散列表）</td><td>根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。</td></tr><tr><td style="text-align:center">分块查找</td><td style="text-align:center">O(logn)</td><td>无序或有序队列</td><td>将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。</td></tr></tbody></table></div><h2 id="ASL分析"><a href="#ASL分析" class="headerlink" title="ASL分析"></a>ASL分析</h2><p>第一个表达式为成功的ASL，第二个为失败的ASL</p><p>顺序查找法：(n+1)/2；n</p><p>折半查找法：转换为折半查找判定二叉树，将线性表的中间分别拆开，比根小的放左边，比根大的放右边；（第一层结点个数<em>1+第二层结点个数\</em>2+…+第n层结点个数*n）/结点总数；（第2层空结点总数*1+第3层空结点总数*2+第4层空结点总数*3+..+第n层空结点总数*n-1）/结点总数</p><p>分块查找法：ASL(折半查找法)+ASL(顺序查找法)</p><p>二叉排序树：ASL(折半查找法)</p><p>哈希表（散列表）查找法：线性探查法：每个元素被访问（查找）的次数<strong>相加</strong>/关键字个数，每个地址由开始到空位置位置所要发生比较操作的地址<strong>相加</strong>/地址总数（eg：0 -&gt; null 1；1 -&gt; null 1、2、3  3）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
      <tag>更新未完成</tag>
      
      <tag>查找算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树基础理论与运用</title>
    <link href="/my_world/content/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E4%B8%8E%E8%BF%90%E7%94%A8/"/>
    <url>/my_world/content/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E4%B8%8E%E8%BF%90%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p><p>二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点 。</p><h1 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h1><ol><li>结点：包含一个数据元素及若干指向子树分支的信息 。</li><li>结点的度：一个结点拥有子树的数目称为结点的度。</li><li>孩子结点：一个结点含有的子树的根结点称为该结点的子结点</li><li>兄弟结点：具有相同父结点的结点互称为兄弟结点</li><li>父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点</li><li>叔叔结点：父结点的兄弟结点</li><li>叶子结点：也称为终端结点，没有子树的结点或者度为零的结点 。</li><li>分支结点：也称为非终端结点，度不为零的结点称为非终端结点 。</li><li>树的度：树中所有结点的度的最大值 。</li><li>结点的层次：从根结点开始，假设根结点为第1层，根结点的子节点为第2层，依此类推，如果某一个结点位于第L层，则其子节点位于第L+1层 。</li><li>树的高度：从下而上，节点的高度是该节点到叶子节点的最长路径（边数），树的高度等于根节点的高度</li><li>节点的深度：从下而上，根节点到这个节点所经历的边的个数</li><li>有序树：如果树中各棵子树的次序是有先后次序，则称该树为有序树 。</li><li>无序树：如果树中各棵子树的次序没有先后次序，则称该树为无序树 。</li><li>森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根结点删除，则该树就变成了一片森林，森林中的树由原来根结点的各棵子树构成 。</li></ol><blockquote><p> 高度和深度的概念和以下图片原链接：<a href="https://www.cnblogs.com/jianglinliu/p/11197715.html">树的高度与深度 - jianglin_liu - 博客园 (cnblogs.com)</a></p></blockquote><p><img src="../../image/image-20211209180137966.png" alt="高度和深度演示图"></p><h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><p><strong>性质1：</strong>二叉树的第i层上至多有2i-1（i≥1）个节点  。</p><p><strong>性质2：</strong>深度为h的二叉树中至多含有2h-1个节点  。</p><p><strong>性质3：</strong>若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2+1  。</p><p><strong>性质4：</strong>具有n个节点的完全二叉树深为log2x+1（其中x表示不大于n的最大整数）  。</p><p><strong>性质5：</strong>若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），那么，对于编号为i（i≥1）的节点：  </p><p>当i=1时，该节点为根，它无双亲节点  。</p><p>当i&gt;1时，该节点的双亲节点的编号为i/2  。</p><p>若2i≤n，则有编号为2i的左节点，否则没有左节点  。</p><p>若2i+1≤n，则有编号为2i+1的右节点，否则没有右节点  。</p><h1 id="二叉树的基本形态"><a href="#二叉树的基本形态" class="headerlink" title="二叉树的基本形态"></a>二叉树的基本形态</h1><ol><li>空二叉树：没有节点</li><li>只有根节点</li><li>只有左子树</li><li>只有右子树</li><li>既有左子树，又有右子树</li></ol><h1 id="二叉树的特殊类型"><a href="#二叉树的特殊类型" class="headerlink" title="二叉树的特殊类型"></a>二叉树的特殊类型</h1><ol><li>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树 。</li></ol><p><img src="http://data.biancheng.net/uploads/allimg/181226/2-1Q226195949495.gif" alt="满二叉树示意图"></p><ol><li>完全二叉树：深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应时，称为完全二叉树 。完全二叉树的特点是叶子结点只可能出现在层序最大的两层上，并且某个结点的左分支下子孙的最大层序与右分支下子孙的最大层序相等或大1 。</li></ol><p><img src="http://data.biancheng.net/uploads/allimg/181226/2-1Q22620003J18.gif" alt="完全二叉树示意图"></p><h1 id="二叉树与森林、树的互相转换"><a href="#二叉树与森林、树的互相转换" class="headerlink" title="二叉树与森林、树的互相转换"></a>二叉树与森林、树的互相转换</h1><blockquote><p>原链接：<a href="https://zhuanlan.zhihu.com/p/134251528">#图解 数据结构：树和森林与二叉树的相互转换 - 知乎 (zhihu.com)</a></p></blockquote><h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><ol><li><p>顺序存储。二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。</p><p><img src="http://data.biancheng.net/uploads/allimg/170830/2-1FS0105529235.png" alt="完全二叉树存储状态示意图"></p></li><li><p>链式存储。二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用顺序表存储或多或多会存在空间浪费的现象。一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。</p></li></ol><p><img src="http://data.biancheng.net/uploads/allimg/181228/2-1Q22R035341H.gif" alt="二叉树链式存储示意图"></p><p>Node的代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 数结点</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> T value;    <span class="hljs-keyword">private</span> Node&lt;T&gt; left;<span class="hljs-comment">//左节点</span>    <span class="hljs-keyword">private</span> Node&lt;T&gt; right;<span class="hljs-comment">//右结点</span>    <span class="hljs-keyword">private</span> Map parent;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(Node&lt;T&gt; left)</span> </span>&#123;        <span class="hljs-keyword">this</span>.left = left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> right;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(Node&lt;T&gt; right)</span> </span>&#123;        <span class="hljs-keyword">this</span>.right = right;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getParent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> parent;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(Map parent)</span> </span>&#123;        <span class="hljs-keyword">this</span>.parent = parent;    &#125;&#125;</code></pre></div><p>C++版的</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @use: Node节点</span><span class="hljs-comment"> **/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> data)&#123;        <span class="hljs-keyword">this</span>-&gt;data = data;        leftNode = <span class="hljs-literal">NULL</span>;        rightNode = <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">int</span> data;    <span class="hljs-comment">// 左子树</span>    Node* leftNode;    <span class="hljs-comment">// 右子树</span>    Node* rightNode;&#125;;</code></pre></div><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><img src="https://upload-images.jianshu.io/upload_images/7043118-df454c0a574836de.png?imageMogr2/auto-orient/strip|imageView2/2/w/441/format/webp" alt="用于示例的二叉树"></p><p>先序遍历（也称为前序遍历）：（简洁：根左右，上面例子的先序遍历的结果为：<strong>A-&gt;B-&gt;D-&gt;H-&gt;I-&gt;E-&gt;J-&gt;C-&gt;F-&gt;G</strong>，简写为<strong>ABDHIEJCFG</strong>）</p><ol><li>访问根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 先序遍历，根左右</span><span class="hljs-comment"> * 以传入的数值为根开始进行先序遍历</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title">leftTraversal</span><span class="hljs-params">(Node node)</span></span>&#123;    binaryTreeList.clear();<span class="hljs-comment">//将数组清除</span>    <span class="hljs-keyword">return</span> leftTraversalM(node);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Node&gt; <span class="hljs-title">leftTraversalM</span><span class="hljs-params">(Node node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>)&#123;        binaryTreeList.add(node);        leftTraversalM(node.getLeft());        leftTraversalM(node.getRight());    &#125;    <span class="hljs-keyword">return</span> binaryTreeList;&#125;</code></pre></div><p>C++版</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @use: 先序遍历，根左右，以传入的数值为根开始进行先序遍历，使用递归法</span><span class="hljs-comment">  * @parameter: 结点</span><span class="hljs-comment">  **/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leftTraversalM</span><span class="hljs-params">(Node* node)</span></span>&#123;    cout &lt;&lt; node-&gt;data;    <span class="hljs-keyword">if</span>(node-&gt;leftNode)&#123;        <span class="hljs-built_in">leftTraversalM</span>(node-&gt;leftNode);    &#125;    <span class="hljs-keyword">if</span>(node-&gt;rightNode)&#123;        <span class="hljs-built_in">leftTraversalM</span>(node-&gt;rightNode);    &#125;&#125;</code></pre></div><p>中序遍历：（简洁：左根右，上面例子的中序遍历的结果为：<strong>H-&gt;D-&gt;I-&gt;B-&gt;J-&gt;E-&gt;A-&gt;F-&gt;C-&gt;G</strong>，简写为<strong>HDIBJEAFCG</strong>）</p><ol><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 中序遍历，左根右</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title">middleTraversal</span><span class="hljs-params">(Node node)</span></span>&#123;    binaryTreeList.clear();<span class="hljs-comment">//将数组清除</span>    <span class="hljs-keyword">return</span> middleTraversalM(node);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Node&gt; <span class="hljs-title">middleTraversalM</span><span class="hljs-params">(Node node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>)&#123;        middleTraversalM(node.getLeft());        binaryTreeList.add(node);        middleTraversalM(node.getRight());    &#125;    <span class="hljs-keyword">return</span> binaryTreeList;&#125;</code></pre></div><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @use: 中序遍历，左根右，以传入的数值为根开始进行中序遍历，使用递归法</span><span class="hljs-comment">  * @parameter: 结点</span><span class="hljs-comment">  **/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">middleTraversalM</span><span class="hljs-params">(Node* node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node-&gt;leftNode)&#123;        <span class="hljs-built_in">middleTraversalM</span>(node-&gt;leftNode);    &#125;    cout &lt;&lt; node-&gt;data;    <span class="hljs-keyword">if</span>(node-&gt;rightNode)&#123;        <span class="hljs-built_in">middleTraversalM</span>(node-&gt;rightNode);    &#125;&#125;</code></pre></div><p>后序遍历：（简洁：左右根，上面例子的后序遍历的结果为：<strong>H-&gt;I-&gt;D-&gt;J-&gt;E-&gt;B-&gt;F-&gt;G-&gt;C-&gt;A</strong>，简写为<strong>HIDJEBFGCA</strong>）</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 后序遍历 左右根</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title">afterTraversal</span><span class="hljs-params">(Node node)</span></span>&#123;    binaryTreeList.clear();<span class="hljs-comment">//将数组清除</span>    <span class="hljs-keyword">return</span> afterTraversalM(node);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Node&gt; <span class="hljs-title">afterTraversalM</span><span class="hljs-params">(Node node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>)&#123;        afterTraversalM(node.getLeft());        afterTraversalM(node.getRight());        binaryTreeList.add(node);    &#125;    <span class="hljs-keyword">return</span> binaryTreeList;&#125;</code></pre></div><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @use: 后序遍历，左右根，以传入的数值为根开始进行后序遍历，使用递归法</span><span class="hljs-comment">  * @parameter: 结点</span><span class="hljs-comment">  **/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterTraversalM</span><span class="hljs-params">(Node* node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node-&gt;leftNode)&#123;        <span class="hljs-built_in">afterTraversalM</span>(node-&gt;leftNode);    &#125;    <span class="hljs-keyword">if</span>(node-&gt;rightNode)&#123;        <span class="hljs-built_in">afterTraversalM</span>(node-&gt;rightNode);    &#125;    cout &lt;&lt; node-&gt;data;&#125;</code></pre></div><p>层次遍历：</p><p>按照树的层次自上而下的遍历二叉树。上面例子的层次遍历结果为：<strong>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;I-&gt;J</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 层次遍历 每层的根节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title">levelTraversal</span><span class="hljs-params">(Node node)</span></span>&#123;    binaryTreeList.clear();<span class="hljs-comment">//将数组清除</span>    <span class="hljs-keyword">return</span> levelTraversalM(node);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Node&gt; <span class="hljs-title">levelTraversalM</span><span class="hljs-params">(Node node)</span></span>&#123;    LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();<span class="hljs-comment">// 新建一个队列</span>    Node current = <span class="hljs-keyword">null</span>;    queue.offer(node);<span class="hljs-comment">//根节点入队</span>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;        current = queue.poll();<span class="hljs-comment">//出队队头元素并访问</span>        binaryTreeList.add(current);        <span class="hljs-keyword">if</span>(current.getLeft() != <span class="hljs-keyword">null</span>)<span class="hljs-comment">//如果当前节点的左节点不为空入队</span>        &#123;            queue.offer(current.getLeft());        &#125;        <span class="hljs-keyword">if</span>(current.getRight() != <span class="hljs-keyword">null</span>)<span class="hljs-comment">//如果当前节点的右节点不为空，把右节点入队</span>        &#123;            queue.offer(current.getRight());        &#125;    &#125;    <span class="hljs-keyword">return</span>  binaryTreeList;&#125;</code></pre></div><p>c++</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @use: 层次遍历，每层的根节点，以传入的数值为根开始进行后序遍历，使用队列辅助</span><span class="hljs-comment">  * @parameter: 结点</span><span class="hljs-comment">  **/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">levelTraversalM</span><span class="hljs-params">(Node* node)</span></span>&#123;    queue&lt;Node*&gt; queue;    Node* current = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// 根节点入队</span>    queue.<span class="hljs-built_in">push</span>(node);    <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-comment">// 队头元素并访问</span>        current = queue.<span class="hljs-built_in">front</span>();        <span class="hljs-comment">// 队头元素出队</span>        queue.<span class="hljs-built_in">pop</span>();        cout &lt;&lt; current-&gt;data;        <span class="hljs-comment">// 如果当前节点的左节点不为空入队</span>        <span class="hljs-keyword">if</span>(current-&gt;leftNode)&#123;            queue.<span class="hljs-built_in">push</span>(current-&gt;leftNode);        &#125;        <span class="hljs-comment">// 如果当前节点的右节点不为空，把右节点入队</span>        <span class="hljs-keyword">if</span>(current-&gt;rightNode)&#123;            queue.<span class="hljs-built_in">push</span>(current-&gt;rightNode);        &#125;    &#125;&#125;</code></pre></div><h1 id="二叉树遍历的优化"><a href="#二叉树遍历的优化" class="headerlink" title="二叉树遍历的优化"></a>二叉树遍历的优化</h1><p>使用栈取代递归函数</p><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>采用先序、中序和后序三种方法遍历二又树后都可以得到个线性序列，序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和后继。但是，这个线性序列只是逻辑的概念，不是物理结构。</p><p>二叉链表体现的是父子关系，<strong>不一定</strong>是结点在遍历序列中的前驱和后继。</p><p>在含有n个结点的二叉链表中，有n+1个空指针，能否利用这些空指针来存放前驱和后继结点的地址？然后像遍历链表一样方便的遍历二叉树的序列？</p><p>线索二又树可以部分解決上述问题，加快在序列中查找前驱和后继结点的速度，但<strong>增加了在树中插入和删除结点的难度</strong>。</p><p>二叉树线索化是将二叉链表中的空指针改为指向前驱或后继结点。而前驱或后继结点的信息只有遍历时才能得到，所以二叉树的线索化分为<strong>先序线索二叉树</strong>、<strong>中序线索二又树</strong>和<strong>后序线索二又树</strong>。</p><ul><li>如果该结点没有左子结点（左子树），则将左指针指向遍历序列中它的前驱结点。</li><li>如果该结点没有右子结点（右子树），则将右指针指向遍历序列中它的后继结点。</li></ul><p>后序线索二叉树对查找指定结点在该次序下的后序效率较差，对二叉树进行后序线索化后，寻找指定结点的后序下的后序结点比较麻烦。因为它首先要找到这个结点的父节点，再到其父节点的右子树中找后序下的第一个结点。</p><h1 id="二叉排序树（Binary-Sort-Tree，缩写为BST）"><a href="#二叉排序树（Binary-Sort-Tree，缩写为BST）" class="headerlink" title="二叉排序树（Binary Sort Tree，缩写为BST）"></a>二叉排序树（Binary Sort Tree，缩写为BST）</h1><p>一棵空树，或者是具有下列性质的二叉树：</p><p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3）左、右子树也分别为二叉排序树；</p><p>（4）没有键值相等的结点。</p><p>输出二叉排序树的中序遍历序列，则这个序列是非递减（非递增）有序的，若不做说明，排序二叉树节点关键字按左小右大分布。<strong>折半查找法的判定树是一个二叉排序树</strong>，以下为插入二叉排序树的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node root;<span class="hljs-comment">//根节点</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">this</span>.root = root;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 二叉排序树</span><span class="hljs-comment">     * 排序式添加结点，比根大的放右边，比根小的放左边</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortAdd</span><span class="hljs-params">(Node node)</span> </span>&#123;        isBST = <span class="hljs-keyword">true</span>;        Map parent = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//            System.out.println(node.getValue()+&quot; set root&quot;);</span>            setRoot(node);            parent = <span class="hljs-keyword">null</span>;            node.setParent(parent);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(node.getValue().hashCode() &lt; root.getValue().hashCode())&#123;                <span class="hljs-comment">//该节点的值比根小，搜索左子树</span>                <span class="hljs-keyword">if</span>(root.getLeft()!=<span class="hljs-keyword">null</span>)&#123;                    Node root = <span class="hljs-keyword">this</span>.root;                    setRoot(root.getLeft());<span class="hljs-comment">//                    System.out.println(this.root.getValue()+&quot; go left&quot;);</span>                    sortAdd(node);                    setRoot(root);                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//                    System.out.println(node.getValue()+&quot; set left&quot;);</span>                    root.setLeft(node);                    parent.put(<span class="hljs-number">0</span>,root);                    node.setParent(parent);                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node.getValue().hashCode() &gt; root.getValue().hashCode())&#123;                <span class="hljs-comment">//该节点的值比根大，搜索右子树</span>                <span class="hljs-keyword">if</span>(root.getRight()!=<span class="hljs-keyword">null</span>)&#123;                    Node root = <span class="hljs-keyword">this</span>.root;                    setRoot(root.getRight());<span class="hljs-comment">//                    System.out.println(this.root.getValue()+&quot; go right&quot;);</span>                    sortAdd(node);                    setRoot(root);                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//                    System.out.println(node.getValue()+&quot; set right&quot;);</span>                    root.setRight(node);                    parent.put(<span class="hljs-number">1</span>,root);                    node.setParent(parent);                &#125;            &#125;        &#125;    &#125;</code></pre></div><p>关于如何删除二叉排序树的结点：</p><ol><li>如果树只有根结点，并且待删除的结点就是根结点</li><li>如果待删除的结点是叶结点，直接删除，不会破坏二又排序树的性质。</li><li>如果待删除的结点只有左子树或右子树，则让子树代替自己。</li><li>如果待除的结点有左子树和右子树，让左子树最右侧的结点代替自己，然后删除左子树最右侧的结点。（也可以让石子树最左侧的结点代替自己，然后除石子树最左侧的结点。）</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 二叉排序树</span><span class="hljs-comment"> * 删除节点，并且删除节点后保持二叉排序树的性质</span><span class="hljs-comment"> * 若不是二叉排序树，不会删除任何节点</span><span class="hljs-comment"> * 若不存在结点，不删除任何节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortDel</span><span class="hljs-params">(Node node)</span></span>&#123;    Node current = search(node);    <span class="hljs-keyword">if</span>(isBST == <span class="hljs-keyword">false</span>)&#123;        System.out.println(<span class="hljs-string">&quot;This tree is not BST(Binary Sort Tree)&quot;</span>);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current != <span class="hljs-keyword">null</span> &amp;&amp; isBST == <span class="hljs-keyword">true</span>)&#123;        <span class="hljs-comment">/* 如果树只有根结点，并且待删除的结点就是根结点 */</span>        <span class="hljs-keyword">if</span>(root.getValue().hashCode() == current.getValue().hashCode() &amp;&amp; root.getRight() == <span class="hljs-keyword">null</span> &amp;&amp; root.getLeft() == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This tree only has a root node,this node is root,so delete it&quot;</span>);            root = <span class="hljs-keyword">null</span>;            current = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">/* 如果待删除的结点是叶结点，直接删除，不会破坏二又排序树的性质 */</span>        <span class="hljs-keyword">if</span>(root.getValue().hashCode() != current.getValue().hashCode() &amp;&amp; root.getRight() == <span class="hljs-keyword">null</span> &amp;&amp; root.getLeft() == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node is leaf node,delete it&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(<span class="hljs-keyword">null</span>);            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(<span class="hljs-keyword">null</span>);            &#125;        &#125;        <span class="hljs-comment">/* 如果待删除的结点只有左子树或右子树，则让子树代替自己。 */</span>        <span class="hljs-keyword">if</span>(current.getLeft()!= <span class="hljs-keyword">null</span> &amp;&amp; current.getRight() == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node only have left tree,delete this node and replace with left tree&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(current.getLeft());            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(current.getLeft());            &#125;        &#125;        <span class="hljs-keyword">if</span>(current.getLeft()== <span class="hljs-keyword">null</span> &amp;&amp; current.getRight() != <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node only have right tree,delete this node and replace with right tree&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(current.getRight());            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(current.getRight());            &#125;        &#125;        <span class="hljs-comment">/* 如果待除的结点有左子树和右子树，让左子树最右侧的结点代替自己，然后删除左子树最右侧的结点。</span><span class="hljs-comment">        （也可以让石子树最左侧的结点代替自己，然后除石子树最左侧的结点。）*/</span>        <span class="hljs-keyword">if</span>(current.getLeft()!= <span class="hljs-keyword">null</span> &amp;&amp; current.getRight() != <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;This node both have left and right tree,delete this node and replace with right tree&quot;</span>);            Map&lt;Integer,Node&gt; parentmap = getParentMap(current);            <span class="hljs-keyword">if</span>(parentmap.get(<span class="hljs-number">0</span>)!= <span class="hljs-keyword">null</span>)&#123;                parentmap.get(<span class="hljs-number">0</span>).setLeft(current.getRight());                current.getRight().setLeft(current.getLeft());            &#125;<span class="hljs-keyword">else</span>&#123;                parentmap.get(<span class="hljs-number">1</span>).setRight(current.getRight());                current.getRight().setLeft(current.getLeft());            &#125;        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        System.out.println(<span class="hljs-string">&quot;Can not find this node in the tree,cant delete this node&quot;</span>);    &#125;&#125;</code></pre></div><p>如果二又排序树高为h,最下层结点的查找长度为h,查找操作的时间复杂度为O(h)</p><p>具有n个(n&gt;0)结点的二叉树的最小高度为log_2(n+1)或log_2n+1。最大高度为n</p><p>最好的情况：平均查找长度=O(log_2n)</p><p>最坏的情况：平均查找长度=O(n)</p><h1 id="平衡二叉树-Balanced-Binary-Tree"><a href="#平衡二叉树-Balanced-Binary-Tree" class="headerlink" title="平衡二叉树(Balanced Binary Tree)"></a>平衡二叉树(Balanced Binary Tree)</h1><p>简称平衡树(AVLG. MAdelson-velsky、E.M. Landis),是一种特殊的二叉排序树。它实现了较高的查找效率，发现树越矮查找效率越高，进而发明了平衡二叉树。树上任意结点的左子树和右子树的深度之差不超过1</p><p><strong>结点的平衡因子=左子树的高度-右子树的高度</strong></p><p>在二叉排序树中插入和删除结点后，只需要调整<strong>最小不平衡子树</strong>，整棵树将恢复平衡。</p><p>最小平衡子树有四种情况（LL，RR，LR，RL）：</p><ol><li>LL：左左更高，整棵树向右旋转（右单旋转调整），左子树变为根，左子树的右子树放到右子树的左边。</li><li>RR：右右更高，整棵树向左旋转（左单旋转调整），右子树变为根，右子树的左子树放到左子树的右边。</li><li>LR：左右更高，左子树先向左旋转，后将整棵树向右旋转（先左后右双旋转调整）</li><li>RL：右左更高，右子树先向右旋转，后将整棵树向左旋转（先右后左双旋转调整）</li></ol><p><img src="../../image/image-20210729.png" alt="最小不平衡数四种情况举例，1234分别代表LL、RR、LR、RL"></p><h1 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h1><p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p><p>在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。</p><p><strong>赫夫曼树的几个相关名词：</strong></p><p>路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。</p><p>路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。</p><p>结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。</p><p>结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。</p><p>树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。</p><p><strong>构建哈夫曼树的过程：</strong></p><p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p><ol><li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li><li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li><li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li></ol><blockquote><p>原链接：<a href="http://c.biancheng.net/view/3398.html">哈夫曼树（赫夫曼树、最优树）详解 (biancheng.net)</a></p></blockquote><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>可变长度编码，任何个字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。利用哈夫曼树来设计前缀编码，用0和1表示左子树或右子树。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。</p><p>红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p><p>红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><p><img src="G:\Gotsomenews\project\blog2.0\source\_posts\image\image-20211109101410919.png" alt="红黑树图解"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>结点是红色或者黑色</li><li>根结点是黑色</li><li>叶结点是不存储数据的黑色空结点（NULL结点）</li><li>每个红色结点必须有两个黑色的子结点</li><li><strong>任意结点到其可到达的叶结点间包含相同数量的黑色结点</strong></li></ol><p>根黑叶黑，黑红相间，不能连续两个红，必须相同的黑</p><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><p>变色：节点的颜色由黑变红或者由红变黑</p><p>左旋右旋：参考平衡二叉树</p><h2 id="插入结点后平衡与变色的几种情况"><a href="#插入结点后平衡与变色的几种情况" class="headerlink" title="插入结点后平衡与变色的几种情况"></a>插入结点后平衡与变色的几种情况</h2><blockquote><p>原视频：<a href="https://www.bilibili.com/video/BV17J411P7aJ?p=3&amp;spm_id_from=pageDriver">red black trees 红黑树 超棒讲解_哔哩哔哩_bilibili</a></p></blockquote><p>插入结点时，该结点默认为红色</p><h3 id="根结点为空"><a href="#根结点为空" class="headerlink" title="根结点为空"></a>根结点为空</h3><p>插入到根结点后，颜色变成黑色</p><h3 id="父亲与叔叔结点皆为红色"><a href="#父亲与叔叔结点皆为红色" class="headerlink" title="父亲与叔叔结点皆为红色"></a>父亲与叔叔结点皆为红色</h3><p>将父亲与叔叔结点变成黑色，父亲与叔叔结点的父结点变为红色</p><h3 id="叔叔结点为黑色，插入的结点在左子树且祖先结点为黑色"><a href="#叔叔结点为黑色，插入的结点在左子树且祖先结点为黑色" class="headerlink" title="叔叔结点为黑色，插入的结点在左子树且祖先结点为黑色"></a>叔叔结点为黑色，插入的结点在左子树且祖先结点为黑色</h3><p>结点与父亲结点交换，祖先结点插入在结点的左子树，颜色变成红色，结点变成黑色</p><h3 id="叔叔结点为黑色，插入的结点在右子树且祖先结点为黑色"><a href="#叔叔结点为黑色，插入的结点在右子树且祖先结点为黑色" class="headerlink" title="叔叔结点为黑色，插入的结点在右子树且祖先结点为黑色"></a>叔叔结点为黑色，插入的结点在右子树且祖先结点为黑色</h3><p>祖先结点左旋/右旋，旋转后的根结点变黑色，旋转后的左/右结点变成红色</p><h3 id="红黑树与平衡二叉树的区别"><a href="#红黑树与平衡二叉树的区别" class="headerlink" title="红黑树与平衡二叉树的区别"></a>红黑树与平衡二叉树的区别</h3><blockquote><p>原链接：<a href="https://www.cnblogs.com/EmilZs/p/10477973.html">二叉树的分类 - EmilZs丶 - 博客园 (cnblogs.com)</a></p></blockquote><ol><li>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多<strong>只需要三次旋转</strong>就能达到平衡，实现起来也更为简单。</li><li>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</li><li>红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。</li><li>红黑树是牺牲了严格的高度平衡的优越条件为代价让红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。</li><li>红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.</li></ol><p>若增删操作频繁用红黑树（统计性能高），增删操作少用平衡二叉树（查询效率高）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研究生考试</tag>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学公式大全（一）</title>
    <link href="/my_world/content/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/my_world/content/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h1><h2 id="章节概括"><a href="#章节概括" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>定义</li><li>性质<ul><li>唯一性</li><li>有界性</li><li>保号性</li></ul></li><li>运算规则</li><li>夹逼准则</li><li>单调有界准则</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设${x_n}$为一个数列，若存在常数a，对于任意的$\xi &gt; 0$（不论它多小），总存在正整数N，使得当$n &gt; N$时，$|x_n - a| &lt; \xi$恒成立，则称数a是${x_n}$的极限，或者称数列${x_n}$收敛于$a$，记为</p><script type="math/tex; mode=display">\lim_{n \rightarrow \infty} x_n = a</script><p>若不存在这样的常数a，就说数列${x_n}$是发散的</p><p>常用的语言：$\lim<em>{n \rightarrow \infty} x_n = a \Leftrightarrow \forall \xi &gt; 0$,$\exist N \in N</em>+$,当$n &gt;N$时，恒有$|x_n - a| &lt; \xi$</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li><strong>唯一性</strong>：给出数列${x<em>n}$，若$ \lim</em>{n \rightarrow \infty} x_n = a$（存在），则a是唯一的</li><li><strong>有界性</strong>：若数列${x_n}$极限存在，则数列${x_n}$有界</li><li><strong>保号性</strong>：设数列${a_n}$存在极限a，且$a &gt; 0$（或$a &lt; 0$），则存在正整数N，当$n &gt; N$时，有$a_n &gt; 0$（或$a_n &lt; 0$）</li><li>推论：如果数列${a<em>n}$从某项起有$a_n\ge 0$，且$ \lim</em>{n \rightarrow \infty}a_n = a$则$a \ge 0$</li></ol><h2 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h2><p>设$\lim<em>{n \rightarrow \infty} x_n = a$，$\lim</em>{n \rightarrow \infty} y_n = b$，则</p><ol><li>$\lim_{n \rightarrow \infty}(x_n \pm y_n) = a \pm b$</li><li>$\lim_{n \rightarrow \infty}x_ny_n = ab$</li><li>若$b \neq 0 , y<em>n \neq 0$，则$\lim</em>{n \rightarrow \infty} \frac{x_n}{y_n} = \frac{a}{b}$</li></ol><h2 id="夹逼准则"><a href="#夹逼准则" class="headerlink" title="夹逼准则"></a>夹逼准则</h2><p>如果数列${x_n}$，${y_n}$及${z_n}$满足下列条件</p><ol><li>$y_n \le x_n \le z_n(n = 1,2,3,\cdots)$</li><li>$\lim<em>{n \rightarrow \infty} y_n = a$，$\lim</em>{n \rightarrow \infty} z_n = a$</li></ol><p>则数列${x<em>n}$的极限存在，且$\lim</em>{n \rightarrow \infty} x_n = a$</p><h2 id="海涅定理"><a href="#海涅定理" class="headerlink" title="海涅定理"></a>海涅定理</h2><p>设函数$f(x)$在$x_0$的某去心领域内有定义</p><p>则$\lim_{x \rightarrow x_0}f(x) = A$存在的充要条件是</p><p>对任一极限为$x<em>0$的数列${x_n}(x_n \ne x_0)$，极限$\lim</em>{n \rightarrow \infty}f(x_n) = A$存在</p><h2 id="单调有界准则"><a href="#单调有界准则" class="headerlink" title="单调有界准则"></a>单调有界准则</h2><script type="math/tex; mode=display">如果数列\{x_n\}单调，并且有界，那么\{x_n\}必收敛，即\lim_{n\rightarrow \infty}x_n存在</script><script type="math/tex; mode=display">如果数列\{x_n\}单调增有上界，那么\{x_n\}收敛，即\lim_{n\rightarrow \infty}x_n存在</script><script type="math/tex; mode=display">如果数列\{x_n\}单调减有下界，那么\{x_n\}收敛，即\lim_{n\rightarrow \infty}x_n存在</script><h2 id="证明单调常用方法"><a href="#证明单调常用方法" class="headerlink" title="证明单调常用方法"></a>证明单调常用方法</h2><script type="math/tex; mode=display">作差与0比较，即计算x_{n+1} - x_n，与0比较</script><script type="math/tex; mode=display">如果x_n > 0，也可以做商与1比较，即计算\frac{x_{n+1}}{x_n}与1比较</script><script type="math/tex; mode=display">{x_n}的通项已知，为f(n)，则可设为f(x)，x>0。如果f'(x)\ge 0,则数列单调递增；如果f'(x) \le 0，则数列单调递减</script><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><blockquote><p>原视频：<a href="https://www.bilibili.com/video/BV1t741187id?from=search&amp;seid=7839709392386725484&amp;spm_id_from=333.337.0.0">2021考研数学，秒懂数学归纳法_哔哩哔哩_bilibili</a></p></blockquote><ol><li>验证结论成立，取n的首项带入f(n)</li><li>假设$n=k$结论成立</li><li>证明$n = k+1$结论成立</li></ol><h1 id="函数极限"><a href="#函数极限" class="headerlink" title="函数极限"></a>函数极限</h1><h2 id="章节概括-1"><a href="#章节概括-1" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>领域</li><li>定义</li><li>性质<ul><li>唯一性</li><li>局部有界性</li><li>局部保号性</li></ul></li><li>运算规则</li><li>夹逼准则</li><li>洛必达法则</li><li>泰勒公式<ul><li>公式</li><li>展开原则</li></ul></li><li>归结原则</li><li>无穷小比阶</li><li>连续与间断<ul><li>连续点的定义</li><li>间断点的定义与分类</li></ul></li></ul><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>设函数$f(x)$在点$x_0$的某一去心领域内有定义。</p><p>若存在常数A，对于任意给定的$\epsilon &gt; 0$（不论它多小），总存在正数$\delta$，使得当$0 &lt; |x - x_0| &lt; \delta$时，对应的函数值$f(x)$都满足不等式$|f(x) - A| &lt; \epsilon$</p><p>则A就叫作函数$f(x)$当$x \rightarrow x_0$时的极限，记为</p><script type="math/tex; mode=display">\lim_{x \rightarrow x_0}f(x) = A 或 f(x) \rightarrow A(x \rightarrow x_0)</script><p>写成”$\epsilon - \delta$”语言</p><script type="math/tex; mode=display">\forall \epsilon > 0,\exists \delta > 0,当0< |x-x_0| < \delta时,有|f(x) - A| < \epsilon</script><h2 id="函数连续性"><a href="#函数连续性" class="headerlink" title="函数连续性"></a>函数连续性</h2><p>设函数$y = f(x)$在点$x_0$的某一领域内有定义，如果</p><script type="math/tex; mode=display">\lim_{x\rightarrow x_0}f(x) = f(x_0)</script><p>那么称函数$f(x)$在点$x_0$连续。</p><p>若$\lim_{x \rightarrow x_0^+} f(x) = f(x_0)$，则称$f(x)$在$x_0$右连续</p><p>若$\lim_{x \rightarrow x_0^-} f(x) = f(x_0)$,则称$f(x)$在$x_0$左连续</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><ol><li><strong>唯一性</strong>：若极限存在，那么极限唯一</li><li><strong>局部有界性</strong>：如果$\lim_{x \rightarrow x_0}f(x) = A$，则存在正常数M和$\delta$，使得当$0&lt; |x-x_0| &lt; \delta$时，有$|f(x)| \le M$</li><li><strong>局部保号性</strong>：如果$f(x) \rightarrow A(x \rightarrow x_0)$，且$A &gt; 0$(或$A &lt; 0$)，那么存在常数$\delta &gt;0$，使得当$0&lt; |x-x_0| &lt; \delta$时，有$f(x) &gt;0$（或$f(x) &lt; 0$）</li></ol><h2 id="极限运算法则"><a href="#极限运算法则" class="headerlink" title="极限运算法则"></a>极限运算法则</h2><p>若$\lim f(x) = A$,$\lim g(x) = B$</p><script type="math/tex; mode=display">\lim[f(x)\pm g(x)] = \lim f(x) \pm \lim g(x)</script><script type="math/tex; mode=display">lim[f(x) \cdot g(x)] = \lim f(x) \cdot \lim g(x)</script><script type="math/tex; mode=display">\lim Cf(x) = C\lim f(x),C为常数</script><script type="math/tex; mode=display">lim[f(x)]^n = [\lim f(x)]^n</script><script type="math/tex; mode=display">lim\frac{f(x)}{g(x)} = \frac{\lim f(x)}{\lim g(x)},\lim g(x)\neq 0</script><h2 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h2><p>法则一：</p><ol><li>当$ x \rightarrow a $（或$ x \rightarrow \infty $）时，函数$f(x)$及$F(x)$都趋于零</li><li>$ f^\prime(x) $及$ F^\prime(x) $在点a的某去心领域内（或当|x| &gt; X，此时X为充分大的正数）存在，且$ F^\prime(x) \neq 0 $</li><li>$ \lim<em>{x \rightarrow a} \frac{f^\prime(x)}{F^\prime(x)} $或$ \lim</em>{x \rightarrow \infty} \frac{f^\prime(x)}{F^\prime(x)} $存在或无穷大</li></ol><p>则：</p><script type="math/tex; mode=display">\lim_{x \rightarrow a} \frac{f(x)}{F(x)} = \lim_{x \rightarrow a} \frac{f^\prime(x)}{F^\prime(x)} 或 \lim_{x \rightarrow \infty} \frac{f(x)}{F(x)} = \lim_{x \rightarrow \infty} \frac{f^\prime(x)}{F^\prime(x)}</script><p>法则二：</p><ol><li>当$ x \rightarrow a $（或$ x \rightarrow \infty $）时，函数$f(x)$及$F(x)$都趋于无穷大</li><li>$ f^\prime(x) $及$ F^\prime(x) $在点a的某去心领域内（或当|x| &gt; X，此时X为充分大的正数）存在，且$ F^\prime(x) \neq 0 $</li><li>$ \lim<em>{x \rightarrow a} \frac{f^\prime(x)}{F^\prime(x)} $或$ \lim</em>{x \rightarrow \infty} \frac{f^\prime(x)}{F^\prime(x)} $存在或无穷大</li></ol><p>则：</p><script type="math/tex; mode=display">\lim_{x \rightarrow a} \frac{f(x)}{F(x)} = \lim_{x \rightarrow a} \frac{f^\prime(x)}{F^\prime(x)} 或 \lim_{x \rightarrow \infty} \frac{f(x)}{F(x)} = \lim_{x \rightarrow \infty} \frac{f^\prime(x)}{F^\prime(x)}</script><h2 id="夹逼准则-1"><a href="#夹逼准则-1" class="headerlink" title="夹逼准则"></a>夹逼准则</h2><p>如果函数$f(x)$，$g(x)$及$h(x)$满足下列条件</p><ol><li>$g(x) \le f(x) \le h(x)$</li><li>$\lim<em>{n \rightarrow \infty} g(x) = a$，$\lim</em>{n \rightarrow \infty} h(x) = a$</li></ol><p>则函数$f(x)$的极限存在，且$\lim_{n \rightarrow \infty} f(x) = a$</p><h2 id="函数间断点"><a href="#函数间断点" class="headerlink" title="函数间断点"></a>函数间断点</h2><ul><li><p>第一类间断点（左右极限都存在，设$x_0$是$f$的间断点）</p><ul><li><p>可去间断点（左极限 = 右极限）</p></li><li><script type="math/tex; mode=display">\lim_{x→x_0^−}f(x)=lim_{x→x_0^+}f(x)≠f(x0)\lim_{x\rightarrow x^-_0} f(x) = \lim_{x\rightarrow x^+_0} f(x) \neq f(x_0)</script></li><li><p>跳跃间断点（左极限 != 右极限）</p></li><li><script type="math/tex; mode=display">\lim_{x\rightarrow x^-_0} f(x) \neq \lim_{x\rightarrow x^+_0} f(x)</script></li></ul></li><li>第二类间断点：左极限或者右极限不存在，除第一类间断点之外的间断点</li></ul><p>由于初等函数在其定义区间上连续，故间断点只可能出现在：</p><ol><li>分段函数的分段点处</li><li>初等函数无定义的点（分母=0处）</li></ol><p>所以有以下判断间断点步骤：</p><ol><li>找出所有可能的间断点</li><li>逐个点计算其左极限、右极限，再判断其类型。</li></ol><h2 id="无穷小比阶"><a href="#无穷小比阶" class="headerlink" title="无穷小比阶"></a>无穷小比阶</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>如果当$x \rightarrow x_o$（或$x \rightarrow \infty$）时，函数$f(x)$的极限为零</p><p>那么称函数$f(x)$为当$x \rightarrow x_0$（或$x \rightarrow \infty$）时的<strong>无穷小</strong>，记为</p><script type="math/tex; mode=display">\lim_{x\rightarrow x_0} f(x) = 0或\lim_{x\rightarrow \infty} f(x) = 0</script><p>特别地，以零为极限的数列${x_n}$称为$n \rightarrow \infty$时的<strong>无穷小</strong></p><p>当$\lim<em>{x\rightarrow x_0} f(x) = \infty$或$\lim</em>{x\rightarrow \infty} f(x) = \infty$时，称函数$f(x)$为当$x \rightarrow x_0$（或$x \rightarrow \infty$）时的<strong>无穷大</strong></p><h3 id="高阶无穷小"><a href="#高阶无穷小" class="headerlink" title="高阶无穷小"></a>高阶无穷小</h3><script type="math/tex; mode=display">\lim_{x\rightarrow x_0} \frac{f(x)}{g(x)} = 0</script><p>称当$x \rightarrow x_0$时,$f(x)$是$g(x)$的<strong>高阶无穷小量</strong>，记作：$f(x) = o(g(x))(x \rightarrow x_0)$</p><h3 id="低阶无穷小"><a href="#低阶无穷小" class="headerlink" title="低阶无穷小"></a>低阶无穷小</h3><script type="math/tex; mode=display">\lim_{x\rightarrow x_0} \frac{f(x)}{g(x)} = \infty</script><p>称$f(x)$是$g(x)$的<strong>低阶无穷小量</strong></p><h3 id="同阶无穷小量"><a href="#同阶无穷小量" class="headerlink" title="同阶无穷小量"></a>同阶无穷小量</h3><script type="math/tex; mode=display">\lim_{x\rightarrow x_0} \frac{f(x)}{g(x)} = c (c \neq 0)</script><p>称$f(x)$与$g(x)$为$x \rightarrow x_0$时的<strong>同阶无穷小</strong></p><p>当$x \rightarrow 0$时的同阶无穷小量：</p><ul><li>$1 - cosx$ 与 $\frac{1}{2}x^2$</li><li>$tanx - x$ 与 $\frac{x^3}{3}$</li></ul><h3 id="等价无穷小"><a href="#等价无穷小" class="headerlink" title="等价无穷小"></a>等价无穷小</h3><script type="math/tex; mode=display">\lim_{x\rightarrow x_0} \frac{f(x)}{g(x)} = 1</script><p>称$f(x)$与$g(x)$为$x \rightarrow x_0$时的<strong>等阶无穷小</strong></p><p>当$x \rightarrow 0$时，常用的等价无穷小：</p><ul><li>$sin\sim x$</li><li>$tanx\sim x$</li><li>$arcsinx \sim x$</li><li>$arctanx \sim x$</li><li>$arctanx \sim x$</li><li>$\ln(x+1) \sim x$</li><li>$e^x-1\sim x$</li><li>$1-cosx\sim \frac{x^2}{2}$</li><li>$sinx^2\sim x^2$</li><li>$x\rightarrow1,sin(x-1) \sim x-1$</li><li>$x\rightarrow \pm3:sin(x^2-9) \sim x^2-9$</li><li>$sin(sinx) \sim sinx$</li></ul><p>整体乘除可换，加减有的凑巧可以，有的不行</p><p>等价无穷小后最低次项不能完全抵消，eg：$x - sinx \neq x - x$</p><h2 id="两个重要极限"><a href="#两个重要极限" class="headerlink" title="两个重要极限"></a>两个重要极限</h2><script type="math/tex; mode=display">\lim_{x\rightarrow0}\frac{sinx}{x} = 1</script><script type="math/tex; mode=display">\lim_{x\rightarrow\infty}(1+\frac{1}{x})^x=e，\lim_{x\rightarrow0}(1+x)^\frac{1}{x}=e</script><h2 id="拉格朗日求极限"><a href="#拉格朗日求极限" class="headerlink" title="拉格朗日求极限"></a>拉格朗日求极限</h2><script type="math/tex; mode=display">利用f(b) - f(a) = f'(\xi)(b-a)</script><script type="math/tex; mode=display">sin(x+1) - sinx = cos\xi \cdot (x+1-x)</script><h1 id="一元函数微分学"><a href="#一元函数微分学" class="headerlink" title="一元函数微分学"></a>一元函数微分学</h1><h2 id="章节概括-2"><a href="#章节概括-2" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>概念<ul><li>导数的概念</li><li>微分的概念</li></ul></li><li>导数与微分的计算<ul><li>四则运算</li><li>分段函数的导数</li><li>复合函数的导数与微分形式不变性</li><li>反函数的导数</li><li>参数方程所确定的函数的导数</li><li>隐函数求导法</li><li>对数求导法</li><li>幂指函数求导法</li><li>高阶导数<ul><li>归纳法</li><li>莱布尼茨公式</li><li>泰勒公式</li></ul></li><li>变限积分求导公式</li><li>基本求导公式</li></ul></li></ul><h2 id="导数的概念"><a href="#导数的概念" class="headerlink" title="导数的概念"></a>导数的概念</h2><script type="math/tex; mode=display">\begin{align}& f^\prime(x_0) = \lim_{\Delta x\rightarrow 0}\frac{\Delta y}{\Delta x} = \lim_{\Delta x\rightarrow 0}\frac{f(x_0 + \Delta x)-f(x_0)}{\Delta x}\end{align}</script><script type="math/tex; mode=display">可记作 y^\prime |_{x = x_0}或\frac{dy}{dx} |_{x = x_0}或\frac{d[f(x)]}{dx} |_{x = x_0}</script><script type="math/tex; mode=display">\lim_{x \rightarrow x_0} \frac{f(x) - f(x_0)}{x - x_0} = f^\prime(x)</script><h2 id="单侧导数"><a href="#单侧导数" class="headerlink" title="单侧导数"></a>单侧导数</h2><p>左导数</p><script type="math/tex; mode=display">\lim_{\Delta x\rightarrow 0^-}\frac{f(x_0 + \Delta x)-f(x_0)}{\Delta x}，记为f^\prime_{-}(x_0)</script><p>右导数</p><script type="math/tex; mode=display">\lim_{\Delta x\rightarrow 0^+}\frac{f(x_0 + \Delta x)-f(x_0)}{\Delta x}，记为f^\prime_{+}(x_0)</script><p>函数在点$x_0$可导的<strong>充分必要条件</strong>是左导数与右导数<strong>均存在并相等</strong></p><h2 id="微分的概念"><a href="#微分的概念" class="headerlink" title="微分的概念"></a>微分的概念</h2><p>设函数$y = f(x)$在点$x<em>{0}$的某领域内有定义，且$x</em>{0} + \Delta x$在该领域内，对于函数增量</p><script type="math/tex; mode=display">\Delta y = f(x_0 + \Delta x) - f(x_0)</script><p>若存在与$\Delta x$无关的常数$A$，使得$\Delta y = A\Delta x + o(\Delta x)$</p><p>其中$o(\Delta x)$是在$\Delta x \rightarrow 0$时比$\Delta x$更高阶的无穷小，则称$f(x)$在点$x<em>{0}$处<strong>可微</strong>，并称$A\Delta x$为$f(x)$在点$x</em>{0}$处的<strong>微分</strong>，记作$dy|<em>{x = x_0} = A \Delta x$或者$d[f(x)]|</em>{x = x_0} = A \Delta x$</p><p>又由于$\Delta x = 1 \cdot \Delta x + 0$，于是一元函数微分学中规定$\Delta x = dx$，故</p><script type="math/tex; mode=display">dy|_{x = x_0} = Adx</script><p>可微的判别：</p><ol><li>写增量$\Delta y = f(x_0 + \Delta x) - f(x_0)$</li><li>写线性增量$A \Delta x = f^\prime(x)\Delta x$</li><li>作极限$\lim_{\Delta x \rightarrow 0} \frac{\Delta y - A\Delta x}{\Delta x}$</li></ol><h2 id="导数公式"><a href="#导数公式" class="headerlink" title="导数公式"></a>导数公式</h2><script type="math/tex; mode=display">C^{\prime} = 0</script><script type="math/tex; mode=display">(x)^{\prime} = 1</script><script type="math/tex; mode=display">(x^n)^{\prime} = nx^{n-1}</script><script type="math/tex; mode=display">(sinx)^{\prime} = cosx</script><script type="math/tex; mode=display">(cosx)^{\prime} = - sinx</script><script type="math/tex; mode=display">(tanx)^{\prime} = sec^2x</script><script type="math/tex; mode=display">(cotx)^{\prime} = -csc^2x</script><script type="math/tex; mode=display">(secx)^{\prime} = secxtanx</script><script type="math/tex; mode=display">(cscx)^{\prime} = -cscxcotx</script><script type="math/tex; mode=display">(\sqrt{x})^{\prime} = \frac{1}{2\sqrt{x}}</script><script type="math/tex; mode=display">(a^x) = a^xIna</script><script type="math/tex; mode=display">(e^x)^{\prime} = e^x</script><script type="math/tex; mode=display">(log_ax)^{\prime} = \frac{1}{xIna}</script><script type="math/tex; mode=display">(Inx)^{\prime} = \frac{1}{x}</script><script type="math/tex; mode=display">(acrsinx)^{\prime} = \frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">(arccosx)^{\prime} = -\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">(arctanx)^{\prime} = \frac{1}{1+x^2}</script><script type="math/tex; mode=display">(arccotx)^{\prime} = -\frac{1}{1+x^2}</script><h2 id="导数运算"><a href="#导数运算" class="headerlink" title="导数运算"></a>导数运算</h2><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><p>$u = u(x)，v = v(x)$</p><script type="math/tex; mode=display">(Cu)^{\prime} = Cu\prime(C是常数)</script><p>和、差的导数（微分）</p><script type="math/tex; mode=display">(u\pm v)^{\prime} = u^\prime \pm v^\prime,d(u \pm v) = du \pm dv</script><p>积的导数（微分）</p><script type="math/tex; mode=display">(uv)^{\prime} = u^\prime v + uv^\prime,d(uv) = vdu + udv</script><p>商的导数（微分）</p><script type="math/tex; mode=display">(\frac{u}{v})^{\prime} = \frac{u^{\prime} v - uv^{\prime}}{v^2}(v\neq0, d(\frac{u}{v})= \frac{vdu - udv}{v^2}(v\neq0)</script><h3 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h3><script type="math/tex; mode=display">设f(x) = \begin{cases}f_1(x) & x \ge x_0\\f_2(x) & x < x_0\end{cases}，其中f_1(x)与f_2(x)可导</script><ol><li>在分段点处用导数定义求导，判断<strong>左导数是否等于右导数</strong>可判定<strong>是否可导</strong>，若可导得出导数结果</li><li>在非分段点用导数公式求导，即$x &gt; x_0$时，$f^\prime(x) = f_1^\prime(x)$；$x &lt; x_0$时，$f^\prime(x) = f_2^\prime(x)$</li></ol><h3 id="反函数的导数"><a href="#反函数的导数" class="headerlink" title="反函数的导数"></a>反函数的导数</h3><p>设$y = f(x)$可导，且$f^\prime(x) \neq 0$，则存在反函数$x = \varphi(y)$，且$\frac{dx}{dy} = \frac{1}{\frac{dy}{dx}}$，即$\varphi(y) = \frac{1}{f^\prime(x)}$</p><h1 id="一元函数微分学的几何应用"><a href="#一元函数微分学的几何应用" class="headerlink" title="一元函数微分学的几何应用"></a>一元函数微分学的几何应用</h1><h2 id="章节概括-3"><a href="#章节概括-3" class="headerlink" title="章节概括"></a>章节概括</h2><ul><li>极值与最值的概念<ul><li>极值的概念</li><li>最值的概念</li></ul></li><li>单调性与极值的判别<ul><li>单调性判别</li><li>判极值的必要条件</li><li>判极值的第一充分条件</li><li>判极值的第二充分条件</li><li>判极值的第三充分条件</li></ul></li><li>凹凸性与拐点的概念<ul><li>凹凸性</li><li>拐点</li></ul></li><li>凹凸性与拐点的判别<ul><li>凹凸性判别</li><li>判拐点的必要条件</li><li>判拐点的第一充分条件</li><li>判拐点的第二充分条件</li><li>判拐点的第三充分条件</li></ul></li><li>渐近线<ul><li>铅垂渐近线</li><li>水平渐近线</li><li>斜渐近线</li></ul></li><li>最值或取值范围<ul><li>在闭区间[a,b]上求</li><li>在开区间(a,b)上求</li></ul></li><li>做函数图形</li></ul><h2 id="极值和最值"><a href="#极值和最值" class="headerlink" title="极值和最值"></a>极值和最值</h2><p>若存在$x_0$的某个<strong>领域</strong>，使得在该领域内任意一点$x$，均有</p><script type="math/tex; mode=display">f(x) \le f(x_0)(或f(x) \ge f(x_0))</script><p>成立，则称$x_0$为$f(x)$的<strong>广义的极大值点</strong>（或<strong>极小值点</strong>），$f(x_0)$为$f(x)$的<strong>广义的极大值</strong>（或<strong>极小值</strong>）</p><p>若存在$x_0$的某个<strong>去心领域</strong>，使得在该领域内任一异于$x_0$的点$x$，均有</p><script type="math/tex; mode=display">f(x) < f(x_0)(或f(x) > f(x_0))</script><p>成立，则称$x_0$为$f(x)$的<strong>真正的极大值点</strong>（或<strong>极小值点</strong>），$f(x_0)$为$f(x)$的<strong>真正的极大值</strong>（或<strong>极小值</strong>）</p><p>设$x_0$为$f(x)$定义域内一点，若对于$f(x)$的定义域内任意一点$x$，均有</p><script type="math/tex; mode=display">f(x) \le f(x_0)(或f(x) \ge f(x_0))</script><p>成立，则称$f(x_0)$为$f(x)$的<strong>广义的最大值</strong>（或<strong>最小值</strong>）</p><p>设$x_0$为$f(x)$定义域内一点，若对于$f(x)$的定义域内任一异于$x_0$的点$x$，均有</p><script type="math/tex; mode=display">f(x) < f(x_0)(或f(x) > f(x_0))</script><p>成立，则称$f(x_0)$为$f(x)$的<strong>真正的最大值</strong>（或<strong>最小值</strong>）</p><h2 id="单调性与极值的判别"><a href="#单调性与极值的判别" class="headerlink" title="单调性与极值的判别"></a>单调性与极值的判别</h2><h3 id="单调性的判别"><a href="#单调性的判别" class="headerlink" title="单调性的判别"></a>单调性的判别</h3><p>若$y = f(x)$在区间$I$上有$f^\prime(x) &gt; 0$，则$y = f(x)$在$I$上严格<strong>单调增加</strong></p><p>若$y = f(x)$在区间$I$上有$f^\prime(x) &lt; 0$，则$y = f(x)$在$I$上严格<strong>单调减少</strong></p><h3 id="一阶可导点是极值点的必要条件"><a href="#一阶可导点是极值点的必要条件" class="headerlink" title="一阶可导点是极值点的必要条件"></a>一阶可导点是极值点的必要条件</h3><p>设$f(x)$在$x = x_0$处可导，且在点$x_0$处取得极值，则必有$f^\prime(x_0) = 0$</p><h3 id="判别极值的第一充分条件"><a href="#判别极值的第一充分条件" class="headerlink" title="判别极值的第一充分条件"></a>判别极值的第一充分条件</h3><p>设$f(x)$在$x = x_0$处连续，且在点$x_0$的某去心领域$U(x_0+\delta)(\delta &gt; 0)$内可导</p><p>若$x \in (x_0-\delta , x_0)$时，$f^\prime(x) &lt; 0$，而$x \in (x_0 , x_0+\delta)$时，$f^\prime(x) &gt; 0$，则$f(x)$在$x = x_0$处取得<strong>极小值</strong></p><p>若$x \in (x_0-\delta , x_0)$时，$f^\prime(x) &gt; 0$，而$x \in (x_0 , x_0+\delta)$时，$f^\prime(x) &lt; 0$，则$f(x)$在$x = x_0$处取得<strong>极大值</strong></p><p>若$f^\prime(x)$在$(x_0-\delta , x_0)$和$(x_0 , x_0+\delta)$内不变号，则点$x_0$不是极值点</p><h3 id="判别极值的第二充分条件"><a href="#判别极值的第二充分条件" class="headerlink" title="判别极值的第二充分条件"></a>判别极值的第二充分条件</h3><h3 id="判别极值的第三充分条件"><a href="#判别极值的第三充分条件" class="headerlink" title="判别极值的第三充分条件"></a>判别极值的第三充分条件</h3><h2 id="凹凸性与拐点"><a href="#凹凸性与拐点" class="headerlink" title="凹凸性与拐点"></a>凹凸性与拐点</h2><p>设函数$f(x)$在区间$I$上连续，如果对$I$上任意不同两点$x_1,x_2$，恒有</p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2}) < \frac{f(x_1) + f(x_2)}{2}</script><p>则称$y = f(x)$在$I$上的<strong>图形是凹的</strong>（或<strong>凹弧</strong>）</p><p>设函数$f(x)$在区间$I$上连续，如果对$I$上任意不同两点$x_1,x_2$，恒有</p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2}) > \frac{f(x_1) + f(x_2)}{2}</script><p>则称$y = f(x)$在$I$上的<strong>图形是凸的</strong>（或<strong>凸弧</strong>）</p><p><img src="../../image/image-20220513173036581.png" alt="凹凸弧"></p><p>连续曲线的凹弧与凸弧的分界点成为该曲线的<strong>拐点</strong></p><h2 id="曲线曲率"><a href="#曲线曲率" class="headerlink" title="曲线曲率"></a>曲线曲率</h2><script type="math/tex; mode=display">设曲线y = f(x)</script><script type="math/tex; mode=display">K = \frac{|y''|}{(1+y'^2)^{\frac{3}{2}}}</script><script type="math/tex; mode=display">设曲线是由参数方程\begin{cases}x = \alpha(t)\\y = \beta(t)\end{cases}</script><script type="math/tex; mode=display">K = \frac{|\alpha'(t)\beta''(t) - \alpha''(t)\beta'(t)|}{[\alpha'^2(t)\beta'^2(t)]^{\frac{3}{2}}}</script><h2 id="莱布尼茨公式"><a href="#莱布尼茨公式" class="headerlink" title="莱布尼茨公式"></a>莱布尼茨公式</h2><script type="math/tex; mode=display">若函数是两个函数的乘积，即f = uv,则</script><script type="math/tex; mode=display">f^{(n)} = (uv)^{(n)} = \sum_{k = 0}^n \C_n^k u^{(n-k)}v^{(k)}</script><h1 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h1><h2 id="有界与最值定理"><a href="#有界与最值定理" class="headerlink" title="有界与最值定理"></a>有界与最值定理</h2><p>设$f(x)$在$[a,b]$上连续</p><script type="math/tex; mode=display">m \le f(x) \le M</script><p><strong>m</strong>、<strong>M</strong>分别为$f(x)$在$[a,b]$上的<strong>最小值</strong>与<strong>最大值</strong></p><h2 id="介值定理"><a href="#介值定理" class="headerlink" title="介值定理"></a>介值定理</h2><p>设$f(x)$在$[a,b]$上连续，当$m \le \mu \le M$，存在$\xi \in [a,b]$，使得$f(\xi) = \mu$</p><h2 id="平均值定理"><a href="#平均值定理" class="headerlink" title="平均值定理"></a>平均值定理</h2><p>设$f(x)$在$[a,b]$上连续，当$a &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_n &lt; b$时，在$[x_1,x_n]$内至少存在一点$\xi$，使得</p><script type="math/tex; mode=display">f(\xi) = \frac{f(x_1) + f(x_2) + \cdots + f(x_n)}{n}</script><h2 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h2><p>设$f(x)$在$[a,b]$上连续，存在$\xi \in [a,b]$，使得</p><script type="math/tex; mode=display">\int^b_af(x)dx = f(\xi)(b-a)</script><p>函数$f(x)$在区间$[a,b]$上的平均值为</p><script type="math/tex; mode=display">A = \frac{\int_a^b f(x)dx}{b-a}</script><h2 id="达步定理（导函数介值定理）"><a href="#达步定理（导函数介值定理）" class="headerlink" title="达步定理（导函数介值定理）"></a>达步定理（导函数介值定理）</h2><script type="math/tex; mode=display">设f(x)在[a,b]内可导，若f^{\prime}_+(a) \neq f^{\prime}_-(b)，则对\forall k介于f^{\prime}_+(a)与f^{\prime}_-(b)之间，总\exists \xi \in (a,b)，使得f^{\prime}(\xi ) = k</script><h2 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h2><p>设$f(x)$满足在点$x_0$处<strong>可导</strong>并<strong>取极值</strong>，则$f^\prime(x_0) = 0$</p><h2 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h2><p>设$f(x)$满足在$[a,b]$处<strong>连续</strong>、在$(a,b)$<strong>可导</strong>，并且$f(a) = f(b)$，则存在$\xi \in (a,b)$，使得$f^\prime(\xi) = 0$</p><h2 id="罗尔定理常用辅助函数构造方法"><a href="#罗尔定理常用辅助函数构造方法" class="headerlink" title="罗尔定理常用辅助函数构造方法"></a>罗尔定理常用辅助函数构造方法</h2><script type="math/tex; mode=display">x f'(x) + nf(x) = 0 \rightarrow F(x) = x^nf(x)</script><script type="math/tex; mode=display">\alpha f'(x) + \beta f(x) = 0 \rightarrow F(x) = e^{\frac{\beta}{\alpha}x}f(x)</script><script type="math/tex; mode=display">f'(x) + g'(x)f(x) = 0 \rightarrow F(x) = e^{g(x)}f(x)</script><script type="math/tex; mode=display">f'(x) + g(x)f(x) = 0 \rightarrow F(x) = e^{\int^x_{\alpha}g(t)dt}f(x)</script><script type="math/tex; mode=display">f''(x) + f'(x) = c \rightarrow F(x) = e^x[f'(x) - c]</script><h2 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h2><p>设$f(x)$满足在$[a,b]$处<strong>连续</strong>、在$(a,b)$<strong>可导</strong>，则存在$\xi \in (a,b)$，使得</p><script type="math/tex; mode=display">f(b) - f(a) = f^\prime(\xi)(b-a)</script><p>或者</p><script type="math/tex; mode=display">f^\prime(\xi) = \frac{f(b) - f(a)}{b-a}</script><h2 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h2><p>设$f(x)$满足在$[a,b]$处<strong>连续</strong>、在$(a,b)$<strong>可导</strong>，则存在$\xi \in (a,b)$，使得</p><script type="math/tex; mode=display">\frac{f^\prime(\xi)}{g^\prime(\xi)} = \frac{f(b) - f(a)}{g(b) - g(a)}</script><p>其中$g^\prime(\xi) \neq 0$</p><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><script type="math/tex; mode=display">f(x) = f(x_0)+\frac{f'(x)}{1!}(x-x_0)+\frac{f''(x)}{2!}(x-x_0)^2 + \cdots + \frac{f^{(n)}(x)}{n!}(x - x_0)^n+R_n(x)</script><script type="math/tex; mode=display">拉格朗日型余项:R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x - x_0)^{n+1}</script><script type="math/tex; mode=display">佩亚诺型余项:R_n(x) = o[(x-x_o)^n]</script><h2 id="常见的麦克劳林公式"><a href="#常见的麦克劳林公式" class="headerlink" title="常见的麦克劳林公式"></a>常见的麦克劳林公式</h2><script type="math/tex; mode=display">\frac{1}{1-x} = 1 + x + \cdots +x^{n} + o(x^{n})</script><script type="math/tex; mode=display">- In(1+x) = x + \frac{x^2}{2} + \cdots +\frac{x^{n}}{n} + o(x^{n})</script><script type="math/tex; mode=display">In(1-x) = - \sum_{n = 1}^\infty \frac{x^n}{n}</script><script type="math/tex; mode=display">In(1+x) = x - \frac{x^2}{2} + \cdots +\frac{(-1)^{n-1}}{n}x^{n} + o(x^{n})</script><script type="math/tex; mode=display">\frac{1}{1+x} = 1 - x + x^2 - \cdots +(-1)^nx^{n} + o(x^{n})</script><script type="math/tex; mode=display">e^x = 1 + x + \cdots +\frac{x^n}{n!} + o(x^n)</script><script type="math/tex; mode=display">cosx = 1 - \frac{x^2}{2!} + \cdots +\frac{(-1)^n}{(2n)!}x^{2n} + o(x^{2n})</script><script type="math/tex; mode=display">sinx = x - \frac{x^3}{3!} + \cdots +\frac{(-1)^n}{(2n + 1)!}x^{2n+1} + o(x^{2n+1})</script><script type="math/tex; mode=display">arctanx = x - \frac{x^3}{3} + \frac{x^5}{5} - \cdots + \frac{(-1)^n}{2n+1}x^{2n+1} + o(x^{2n+1})</script><script type="math/tex; mode=display">(1+x)^a = 1 + ax + \frac{a(a-1)}{2!}x^2 + \cdots +\frac{a(a-1)\cdots (a-n+1)}{n!}x^n + o(x^{n})</script><h1 id="零点问题与微分不等式"><a href="#零点问题与微分不等式" class="headerlink" title="零点问题与微分不等式"></a>零点问题与微分不等式</h1><h2 id="零点定理"><a href="#零点定理" class="headerlink" title="零点定理"></a>零点定理</h2><p>$f(x)$在$[a,b]$连续，且$f(a)f(b)&lt;0$，则至少有一点$\xi \in (a,b)$，使$f(\xi) = 0$</p><p>零点定义：如果$x_0$使得$f(x_0) = 0$，就称$x_0$为函数$f(x)$的零点（或称$x_0$为方程$f(x) = 0$的根）</p><h2 id="零点问题"><a href="#零点问题" class="headerlink" title="零点问题"></a>零点问题</h2><p>主要证明根的存在性</p><p>若$f(x)$在$[a,b]$连续，且$f(a)f(b)&lt;0$，则$f(x) = 0$在$(a,b)$内至少有一个根</p><h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>主要证明根的唯一性</p><p>若$f(x)$在$(a,b)$内单调，则$f(x) = 0$在$(a,b)$内至多有一个根，这里a，b可以是有限数，也可以是无穷大</p><h2 id="罗尔定理的推论"><a href="#罗尔定理的推论" class="headerlink" title="罗尔定理的推论"></a>罗尔定理的推论</h2><p>若$f^{(n)}(x) = 0$至多有k个根，则$f(x) = 0$至多有$k + n$个根</p><p>实系数奇次方程$x^{2n+1} + a<em>1x^{2n}+ \cdots + a</em>{2n}x + a_{2n+1} = 0$至少有一个实根</p><h2 id="微分不等式"><a href="#微分不等式" class="headerlink" title="微分不等式"></a>微分不等式</h2><h3 id="用函数性态（包括单调性、凹凸性和最值等）证明不等式"><a href="#用函数性态（包括单调性、凹凸性和最值等）证明不等式" class="headerlink" title="用函数性态（包括单调性、凹凸性和最值等）证明不等式"></a>用函数性态（包括单调性、凹凸性和最值等）证明不等式</h3><p>一般地，使用如下依据</p><ol><li>若有$f^\prime(x) \ge 0,a&lt;x&lt;b$，则有$f(a) \le f(x) \le f(b)$</li><li>若有$f^”(x) \ge 0,a &lt; x &lt; b$，则有$f^\prime(a) \le f^\prime(x) \le f^\prime(b)$<ol><li>当$f^\prime(a) &gt; 0$时，$f^\prime(x) &gt; 0 \rightarrow f(x)$单调增加</li><li>当$f^\prime(a) &lt; 0$时，$f^\prime(x) &lt; 0 \rightarrow f(x)$单调减少</li></ol></li><li>设$f(x)$在$I$内连续，且有唯一的极值点$x_0$，则<ol><li>当$x_0$为极大值点时，$f(x_0) \ge f(x)$</li><li>当$x_0$为极小值点时，$f(x_0) \le f(x)$</li><li>$\forall x \in I$</li></ol></li><li>若有$f^”(x) &gt; 0,a&lt;x&lt;b,f(a) = f(b) = 0$，则有$f(x) &lt; 0$</li></ol><h3 id="常数变量化证明不等式"><a href="#常数变量化证明不等式" class="headerlink" title="常数变量化证明不等式"></a>常数变量化证明不等式</h3><p>不等式中都是常数，则可以将其中一个或者几个常数变量化，再使用上述导数工具证明</p><h3 id="中值定理证明不等式"><a href="#中值定理证明不等式" class="headerlink" title="中值定理证明不等式"></a>中值定理证明不等式</h3><p>主要使用拉格朗日中值定理或者泰勒公式</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连接mysql的多种玩法（java-python）</title>
    <link href="/my_world/content/%E8%BF%9E%E6%8E%A5mysql%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%8E%A9%E6%B3%95%EF%BC%88java-python%EF%BC%89/"/>
    <url>/my_world/content/%E8%BF%9E%E6%8E%A5mysql%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%8E%A9%E6%B3%95%EF%BC%88java-python%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据库几乎是所有程序必备的，而每一种语言都有相应的连接数据库的手段。无论是在线的，还是本地，都需要通过一定的手段去连接数据库。今天就谈谈连接数据库的多种玩法，使用java和python两种语言，连接mysql数据库。</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>java有多种框架支撑，但是基本套路都是【驱动+连接+事务】，这里用mysql-connector-java（5.1.40）作为驱动，mybatis作为事务框架。何为事务，网上有各种教材，但笔者认为，事务用最简单的概括即是增删查改。</p><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>作为最原始的JDBC，没有用事务框架，用ResultSet处理数据库的数据（查），PreparedStatement进行事务操作（增删改），使用mysql-connector-java作为mysql驱动，引入jar包或者依赖即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQLDemo</span> </span>&#123;     <span class="hljs-comment">// MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JDBC_DRIVER = <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>;      <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DB_URL = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/RUNOOB&quot;</span>;     <span class="hljs-comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span>    <span class="hljs-comment">//static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;  </span>    <span class="hljs-comment">//static final String DB_URL = &quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;;</span>      <span class="hljs-comment">// 数据库的用户名与密码，需要根据自己的设置</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USER = <span class="hljs-string">&quot;root&quot;</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PASS = <span class="hljs-string">&quot;123456&quot;</span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        Statement stmt = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span>&#123;            <span class="hljs-comment">// 注册 JDBC 驱动</span>            Class.forName(JDBC_DRIVER);                    <span class="hljs-comment">// 打开链接</span>            System.out.println(<span class="hljs-string">&quot;连接数据库...&quot;</span>);            conn = DriverManager.getConnection(DB_URL,USER,PASS);                    <span class="hljs-comment">// 执行查询</span>            System.out.println(<span class="hljs-string">&quot;实例化Statement对象...&quot;</span>);            stmt = conn.createStatement();            String sql;            sql = <span class="hljs-string">&quot;SELECT id, name, url FROM websites&quot;</span>;            ResultSet rs = stmt.executeQuery(sql);                    <span class="hljs-comment">// 展开结果集数据库</span>            <span class="hljs-keyword">while</span>(rs.next())&#123;                <span class="hljs-comment">// 通过字段检索</span>                <span class="hljs-keyword">int</span> id  = rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);                String name = rs.getString(<span class="hljs-string">&quot;name&quot;</span>);                String url = rs.getString(<span class="hljs-string">&quot;url&quot;</span>);                    <span class="hljs-comment">// 输出数据</span>                System.out.print(<span class="hljs-string">&quot;ID: &quot;</span> + id);                System.out.print(<span class="hljs-string">&quot;, 站点名称: &quot;</span> + name);                System.out.print(<span class="hljs-string">&quot;, 站点 URL: &quot;</span> + url);                System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);            &#125;            <span class="hljs-comment">// 完成后关闭</span>            rs.close();            stmt.close();            conn.close();        &#125;<span class="hljs-keyword">catch</span>(SQLException se)&#123;            <span class="hljs-comment">// 处理 JDBC 错误</span>            se.printStackTrace();        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;            <span class="hljs-comment">// 处理 Class.forName 错误</span>            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span>&#123;            <span class="hljs-comment">// 关闭资源</span>            <span class="hljs-keyword">try</span>&#123;                <span class="hljs-keyword">if</span>(stmt!=<span class="hljs-keyword">null</span>) stmt.close();            &#125;<span class="hljs-keyword">catch</span>(SQLException se2)&#123;            &#125;<span class="hljs-comment">// 什么都不做</span>            <span class="hljs-keyword">try</span>&#123;                <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>) conn.close();            &#125;<span class="hljs-keyword">catch</span>(SQLException se)&#123;                se.printStackTrace();            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;Goodbye!&quot;</span>);    &#125;&#125;</code></pre></div><p>其中ps的操作为：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//3.获得预处理对象</span>String sql = <span class="hljs-string">&quot;update sort set sname=? where sid=?&quot;</span>;PreparedStatement stat = con.prepareStatement(sql);<span class="hljs-comment">//4.SQL语句占位符设置实际参数</span>stat.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>);<span class="hljs-comment">//索引参数1代表着sql中的第一个？号，也就是我需要将条件sid所对应的sname数据更新为“儿童玩具测试”</span>stat.setInt(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//索引参数2代表着sql中的第二个？号，也就是条件是sid为3</span><span class="hljs-comment">//5.执行SQL语句</span><span class="hljs-keyword">int</span> line = stat.executeUpdate();System.out.println(<span class="hljs-string">&quot;更新记录数&quot;</span>+ line);<span class="hljs-comment">//6.释放资源</span>stat.close();</code></pre></div><h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><p><strong>orm工具的基本思想</strong></p><p>无论是用过的hibernate,mybatis,你都可以观察到他们有一些共同点：</p><ul><li>从配置文件(通常是XML配置文件中)得到 sessionfactory.</li><li>由sessionfactory 产生 session</li><li>在session 中完成对数据的增删改查和事务提交等.</li><li>在用完之后关闭session 。</li><li>在java 对象和 数据库之间有做mapping 的配置文件，也通常是xml 文件。</li></ul><p>Mybatis的功能架构分为三层：</p><ol><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。  </li></ol><p>首先引入依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!--mysqlq驱动--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!--mybatis--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p>编写mybatis的核心配置文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--configuration核心配置文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?userSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>编写mybatis工具类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//sqlSessionFactory --&gt; sqlSession</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtils</span> </span>&#123;    <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//使用Mybatis第一步 ：获取sqlSessionFactory对象</span>            String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例.</span>    <span class="hljs-comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();    &#125;&#125;</code></pre></div><p>Dao</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>Mapper映射文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace=绑定一个指定的Dao/Mapper接口--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.dao.UserDao&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.pojo.User&quot;</span>&gt;</span>    select * from USER  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.获取SqlSession对象</span>SqlSession sqlSession = MybatisUtils.getSqlSession();<span class="hljs-comment">//2.执行SQL</span><span class="hljs-comment">// 方式一：getMapper</span>UserDao userDao = sqlSession.getMapper(UserDao.class);List&lt;User&gt; userList = userDao.getUserList();<span class="hljs-keyword">for</span> (User user : userList) &#123;    System.out.println(user);&#125;<span class="hljs-comment">//关闭sqlSession</span>sqlSession.close();</code></pre></div><h3 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h3><p>大概思路为：引入依赖【驱动，事务框架】—&gt; 修改连接参数【application.yml】—&gt; 添加映射xml，并添加sql语句 —&gt; 添加pojo对象，存储数据 —&gt; 添加映射类映射sql语句【CURD操作】</p><p>首先引入依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- mybatis starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- mybatis starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>修改application.yml，为数据库的连接提供参数</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-comment"># UTC： Coordinated Universal Time, 国际协调时间，也称世界标准时间。</span>    <span class="hljs-comment"># 设置国际标准时间能够保证mysql连接不会出现时区错误，并且保证编号为UTF-8</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&amp;serverTimezone=UTC</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:/mapper/*Mapper.xml</span> <span class="hljs-comment"># mapper文件存放位置</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.test.dao</span> <span class="hljs-comment"># mapper配置类存放包</span></code></pre></div><p>在resources文件夹下添加mapper文件夹，并添加Test01Mapper.xml</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 命名空间映射到Mapper的该config类 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.Mapper.Test01MapperDao&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.pojo.test01&quot;</span>&gt;</span>        SELECT * FROM test01;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.pojo.test01&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span>        SELECT * FROM test01 WHERE id = #&#123;id&#125;;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.test.pojo.test01&quot;</span>&gt;</span>        INSERT INTO test01 (&#x27;username&#x27;, &#x27;password&#x27;, &#x27;type&#x27;, &#x27;number&#x27;) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;type&#125;, #&#123;number&#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.test.pojo.test01&quot;</span>&gt;</span>        UPDATE test01 SET username = #&#123;username&#125;,password = #&#123;password&#125;,type = #&#123;type&#125;,number = #&#123;number&#125;WHERE id = #&#123;id&#125;;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span>        DELETE FROM test01 WHERE id = #&#123;id&#125;;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>添加pojo【test01】，包名为com.test.pojo</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.pojo;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-comment">/*</span><span class="hljs-comment"> * @Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，</span><span class="hljs-comment"> * 如为final属性，则不会为该属性生成setter方法。</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * 无参构造器、部分参数构造器、全参构造器。Lombok没法实现多种参数构造器的重载。</span><span class="hljs-comment"> */</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test01</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;&#125;</code></pre></div><p>以上的属性（id，username，password等）可以用lombok的工具类来添加，一般是用getter和setter来解决。如何生成getter和setter请自行百度。</p><p>生成映射类，用于映射.xml文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.Mapper;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="hljs-keyword">import</span> com.test.pojo.test01;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test01MapperDao</span> </span>&#123;    <span class="hljs-function">List&lt;test01&gt; <span class="hljs-title">queryList</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">test01 <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(test01 info)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(test01 info)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;&#125;</code></pre></div><p>之后在controller中直接使用该映射类即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTestController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Test01MapperDao test01MapperDao;    <span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;test01&gt; <span class="hljs-title">query</span><span class="hljs-params">()</span></span>&#123;        List&lt;test01&gt; test01 = test01MapperDao.queryList();        <span class="hljs-keyword">return</span> test01;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/queryByid&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> test01 <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span>Integer id)</span></span>&#123;        test01 test01;        <span class="hljs-keyword">if</span>(id != <span class="hljs-keyword">null</span>)&#123;            test01 = test01MapperDao.queryById(id);        &#125;<span class="hljs-keyword">else</span>&#123;            test01 = test01MapperDao.queryById(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> test01;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/deleteById&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deleteById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span>Integer id)</span></span>&#123;        test01MapperDao.deleteById(id);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/index&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre></div><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>使用pymysql连接mysql，注意，这里用的是<strong>python3</strong>，python2是<strong>mysqldb</strong>，由于python3逐渐成熟，所以python2的mysqldb不再阐述</p><blockquote><p>安装</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">pip install PyMySQL</code></pre></div><blockquote><p>引用</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql</code></pre></div><blockquote><p>连接数据库</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">db = pymysql.connect(host=<span class="hljs-string">&quot;localhost&quot;</span>,user=<span class="hljs-string">&quot;username&quot;</span>,password=<span class="hljs-string">&quot;password&quot;</span>,database=<span class="hljs-string">&quot;database&quot;</span>) <span class="hljs-comment"># 打开链接</span></code></pre></div><p>注意，一定要加上“host=”等字样，否则会出现<code>takes 1 positional argument but 5 were given</code>错误</p><blockquote><p>创建游标对象</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">cursor = db.cursor()</code></pre></div><blockquote><p>查询</p></blockquote><p>传输sql语句 —&gt; 查找对象 —&gt; 返回元组（类似list，但是内容不可修改）</p><div class="code-wrapper"><pre><code class="hljs python">cursor.execute(<span class="hljs-string">&quot;SELECT * FROM table1&quot;</span>)<span class="hljs-comment"># 输入sql语句</span>results = cursor.fetchall()<span class="hljs-comment"># 查找所有对象</span>输出：((<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;testing&#x27;</span>, <span class="hljs-string">&#x27;testing&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>),)results = cursor.fetchone()<span class="hljs-comment"># 查询一条数据</span>输出：(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;testing&#x27;</span>, <span class="hljs-string">&#x27;testing&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>)</code></pre></div><blockquote><p>增加一条数据</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">sql = <span class="hljs-string">&quot;&quot;&quot;INSERT INTO answertable1(name,name2, name3, name4) VALUES (&#x27;test01&#x27;, &#x27;test01&#x27;, &#x27;test01&#x27;, &#x27;test01&#x27;)&quot;&quot;&quot;</span><span class="hljs-comment"># SQL 插入语句，&quot;&quot;&quot;为三引号</span>cursor.execute(sql)<span class="hljs-comment"># 执行sql语句</span>db.commit()<span class="hljs-comment"># 提交到数据库执行</span></code></pre></div><blockquote><p>更新操作</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">sql = <span class="hljs-string">&quot;UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = &#x27;%c&#x27;&quot;</span> % (<span class="hljs-string">&#x27;M&#x27;</span>)<span class="hljs-comment"># SQL 插入语句</span>cursor.execute(sql)<span class="hljs-comment"># 执行sql语句</span>db.commit()<span class="hljs-comment"># 提交到数据库执行</span></code></pre></div><blockquote><p>删除</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">sql = <span class="hljs-string">&quot;DELETE FROM EMPLOYEE WHERE AGE &gt; %s&quot;</span> % (<span class="hljs-number">20</span>)<span class="hljs-comment"># SQL 插入语句</span>cursor.execute(sql)<span class="hljs-comment"># 执行sql语句</span>db.commit()<span class="hljs-comment"># 提交到数据库执行</span></code></pre></div><blockquote><p>回滚</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">db.rollback() <span class="hljs-comment"># 如果发生错误则回滚</span></code></pre></div><blockquote><p>关闭数据库</p></blockquote><div class="code-wrapper"><pre><code class="hljs python">db.close()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>python</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摘录--乔布斯于2005年在斯坦福大学的演讲</title>
    <link href="/my_world/content/%E6%91%98%E5%BD%95-%E4%B9%94%E5%B8%83%E6%96%AF%E4%BA%8E2005%E5%B9%B4%E5%9C%A8%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%BC%94%E8%AE%B2/"/>
    <url>/my_world/content/%E6%91%98%E5%BD%95-%E4%B9%94%E5%B8%83%E6%96%AF%E4%BA%8E2005%E5%B9%B4%E5%9C%A8%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%BC%94%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天闲来无事，看到了乔布斯的毕业典礼的演讲稿。在这个特殊的时期，2020-2021，我们都是极度特殊的大学毕业生。但是危机带来的是机遇，乔布斯在大学期间决定退学，也直接促使他走向了另外一个不同的道路。下面是毕业典礼的演讲稿原文：</p><p>=================================== 原文分割线 ========================================</p><p>I am honored to be with you today for your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. And this is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.</p><p><strong>The first story is about connecting the dots.</strong></p><p>I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?</p><p>It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.” My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college. This was the start in my life.</p><p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition. After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked far more interesting.</p><p>It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5￠ deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p><p>Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.</p><p>None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, it’s likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.</p><p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something — your gut, destiny, life, karma, whatever. Because believing in the dots will connect down the road will give you the confidence to follow your heart even when they leave you off the well-worn path. And it has made all the difference in my life.</p><p><strong>My second story is about love and loss.</strong></p><p>I was lucky — I found what I loved to do early in life. Woz and I started Apple in my parents’ garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees. We had just released our finest creation — the Macintosh — a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.</p><p>I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me — I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.</p><p>I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.</p><p>During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the world’s first computer animated feature film, Toy Story, and is now the most successful animation studio in the world. In a remarkable turn of events, Apple bought NeXT, I returned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.</p><p>I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking. Don’t settle.</p><p><strong>My third story is about death.</strong></p><p>When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.</p><p>Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.</p><p>About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.</p><p>I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and thankfully I’m fine now.</p><p>This was the closest I’ve been to facing death, and I hope it’s the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.</p><p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p><p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and Polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.</p><p>Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.</p><p><strong>Stay Hungry. Stay Foolish.</strong></p><p>=================================== 译文分割线 ========================================</p><p>今天很荣幸能和你们一起参加毕业典礼，斯坦福大学是世界上最好的大学之一。我从来没有从大学中毕业。说实话,今天也许是我生命中离大学毕业最近的一天了。今天我想向你们讲述我生命中的三个故事。不是什么大不了的事情，只是三个故事而已。</p><p><strong>第一个故事是关于如何把生命中的点点滴滴串连起来。</strong></p><p>我在里德学院读了六个月之后就退学了，但之后作为旁听生又混了十八个月以后才真正离开。我为什么要退学呢？</p><p>故事要从我出生时讲起。我的生母是一个年轻的、没有结婚的大学毕业生。她决定让别人收养我，但她信念强烈得认为我一定要被受过高等教育的人收养。所以她安排好了我出生时将被一个律师和他的妻子所收养。不过她没有料到，当我出生之后，律师夫妇表示他们实际上想要一个女孩。所以我的生养父母（他们在待选名单上）突然在半夜接到了一个电话：”我们现在这儿有一个不小心生出来的男婴，你们想要他吗？”他们回答道: “当然！”但是我亲生母亲随后发现，我的养母从来没有上过大学，我的养父甚至从没有读过高中。她拒绝签署收养合同。不过在几个月以后，我的父母答应她一定要让我上大学，那个时候她才软化同意。</p><p>在十七岁那年，我真的上了大学。但是我很愚蠢的选择了一所几乎和斯坦福大学一样贵的学校, 我父母是蓝领阶层，他们几乎把所有积蓄都花在了我的学费上面。在六个月后, 我已经看不到其中的价值所在。我不知道我真正想要做什么，我也不知道大学能教会我什么。在这里我几乎花光了父母这一辈子的全部积蓄。所以我决定要退学，我觉得这是个正确的决定。不能否认,我当时确实非常的害怕，但是现在回头看看，那的确是我这一生中最棒的一个决定。在我做出退学决定的那一刻，我终于可以不必去读那些令我提不起丝毫兴趣的课，并可以开始去修那些看起来有点意思的课程。</p><p>但是这并不美妙。我失去了宿舍，所以只能在朋友房间的地板上睡觉，我去捡可以换5美分的可乐罐，仅仅为了填饱肚子, 在星期天的晚上，我需要走七英里的路程，穿过城市到Hare Krishna神庙，只是为了能吃上好饭——那是一个星期种唯一一顿好一点的饭，我喜欢那里的饭菜。我跟着我的直觉和好奇心走, 遇到的很多东西，此后被证明是无价之宝。让我给你们举一个例子吧：</p><p>里德学院在那时提供了也许是全美最好的美术字课程。在这个大学里面的每个海报, 每个抽屉的标签上面全都是漂亮的美术字。因为我退学了, 不必去上正规的课程, 所以我决定去参加这个课程，去学学怎样写出漂亮的美术字。我学到了san serif 和serif字体, 我学会了怎么样在不同的字母组合之中改变空白间距, 还有怎么样才能作出最棒的印刷式样。那种漂亮、充满历史气息和巧妙艺术的字体，是科学永远不能捕捉到的, 我发现那实在是太迷人了。</p><p>当时看起来这些东西在我的生命中好像都没有什么实际应用的可能。但是十年之后，当我们在设计第一台Macintosh电脑的时候，就不是那样了。我把当时我学的那些东西全都设计进Mac。那是第一台使用了漂亮印刷字体的电脑。如果我当时没有退学, 就不会有机会去参加这个我感兴趣的美术字课程, Mac就不会有这么多丰富的字体以及赏心悦目的字体间距。如果不是因为Windows抄袭了Mac，个人电脑就不会有现在这么美妙的字型了。当然我在大学的时候，还不可能把从前的点点滴滴串连起来，但是当我十年后回顾这一切的时候，真的豁然开朗了。</p><p>我要再次强调的是，当你展望未来时，你不可能将这些片断串连起来，你只能在回顾过去时将他们串在一起。所以你必须相信这些片断会在你未来的某一天串连起来，你必须要相信某些东西：勇气、命运、生命、因缘……这个过程从来没有令我失望，只是让我的生命更加地与众不同。</p><p><strong>我的第二个故事，有关爱与失去。</strong></p><p>我非常幸运, 因为在很早的时候就找到了我钟爱的东西。Woz和我在二十岁的时候就在父母的车库里面开创了苹果公司。我们工作得很努力， 十年之后, 这个公司从那两个车库中的穷小子发展到了雇员超过四千名、市值超过二十亿的大公司。在公司成立的第九年，我们发布了最好的产品Macintosh。也在那一年, 我被炒了鱿鱼。你很难想象我会被亲手创办的公司扫地出门? 嗯,在苹果快速成长的时候，我们雇用了一个很有天分的家伙和我一起管理公司, 在最初的几年,公司运转的很好。但是后来我们对未来的看法发生了分歧, 最终我们吵了起来。当争吵得不可开交的时候, 董事会站在了他的那一边。所以在三十岁的时候, 我被解雇了。而立之年，我生命的全部支柱离自己远去, 这真是毁灭性的打击。</p><p>在最初的几个月里，我真是不知道该做些什么。我觉得我令上一代的创业家们很失望，我把他们交给我的接力棒弄丢了。我和创办惠普的David Pack、创办Intel的Bob Noyce见面，并试图向他们道歉。我把事情弄得糟糕透顶，一度想离开硅谷。但是渐渐地，我发现了曙光，我仍然热爱我所从事的这些东西。在苹果公司发生的这些事情丝毫没有改变这些, 一点也没有。我被驱逐了,但是我仍然钟爱我所做的事情。所以我决定从头来过。</p><p>当时我没有觉察, 但是事后证明, 被苹果公司解雇是我这辈子发生过的最棒的事情。作为一个成功者的负重感被作为一个创业者的轻松感所重新代替, 没有比这更确定的事情了。这让我觉得如此自由，进入了我生命中最有创造力的一个阶段。</p><p>在接下来的五年里, 我创立了一个名叫NeXT的公司, 还有一个叫Pixar的公司, 和一个优雅的女人恋爱，她成为了我的妻子。Pixar 制作了世界上第一个电脑动画电影——“玩具总动员”，Pixar现在也是世界上最成功的动画制作公司。后来，Apple收购了NeXT, 我又回到了苹果公司。我们在NeXT发展的技术成了苹果电脑后来复兴的核心。而且，我还和Laurence 一起建立了一个幸福完美的家庭。</p><p>我可以非常肯定，如果我不被Apple开除的话, 这其中一件事情也不会发生。这个药的味道实在是很苦。但是我想病人需要这个药。有些时候, 生活会拿起一块砖头向你的脑袋上猛拍一下，不要失去信仰。我很清楚唯一使我继续走下去的，就是我做的事情令我无比钟爱。你需要去找到你所热爱的东西，对于工作是如此，对于你的爱人也是如此。你的工作将会占据生活中很大的一部分，只有相信自己所做的是伟大的工作, 你才能怡然自得。如果你现在还没有找到，那么继续找，不要停下来，只要全心全意的去找，在你找到的时候，你的内心会告诉你的。就像任何真诚的关系, 随着岁月的流逝只会越来越紧密。所以继续找，直到你找到它，不要停下来！</p><p><strong>我的第三个故事，是关于死亡的。</strong></p><p>当我十七岁的时候，我读到了一句话，内容大概是：“如果你把每一天都当作生命中最后一天去生活的话，那么有一天你会发现这无比正确。”这句话对我影响深远。从那时开始，在过去的33年里，我每天早晨都会对着镜子问自己：”如果今天是我生命中的最后一天, 你还会不会做今天要做的事情呢？”当答案连续多天是”No”的时候，我知道自己是时候要做出改变了。</p><p>“记住你即将死去”是我一生中遇到的最重要的箴言。它帮助我做出了生命中最重要的选择。因为几乎所有的事情，包括所有外界的期待、所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧，这些东西在死亡面前都微不足道。留下的是那些真正重要的东西。你有时候会思考你将失去某些东西，”记住你即将死去”是我知道的避免这些想法的最好办法。如果你清空一切, 你没有理由不去跟随自己内心的声音。</p><p>大概一年前, 我被诊断出癌症。我在早晨七点半做了一个检查，检查清楚的显示在我的胰腺有一个肿瘤，我当时都不知道胰腺是什么东西。医生告诉我那很可能是一种无法治愈的癌症，我至多还能活三到六个月的时间。医生建议我回家, 料理好自己的事情，那是医生对临终病人的标准建议。那意味着你要把未来十年对小孩说的话在几个月里面说完。那意味着你要把每件事情都安排好, 让你的家人尽可能轻松的生活；那意味着你要说“再见了”。</p><p>我整天想着那个诊断结果，那天晚上我作了一个活切片检查，医生将一个内窥镜从我的喉咙伸进去，通过我的胃，然后进入肠子, 用一根针在我胰腺的肿瘤上取了几个细胞。我当时是被麻醉的，但是我的妻子在那里，后来她告诉我，当医生在显微镜下观察这些细胞的时候他们哭了, 因为这些是一种非常罕见的、可以用手术治愈的胰腺癌细胞。我做了这个手术, 现在我痊愈了。</p><p>这是我最接近死亡的一次，我希望这也是以后几十年中最接近的一次。从死亡线上又活了过来,相比于以前只把死亡当成一种想象中的概念，我现在可以更肯定一点地对你们说：没有人想死, 即使那些想上天堂的人，也想活着上去。然而死亡是我们每个人共同的终点，概莫能外，亦理应如此。死亡是生命中最好的发明，它去陈让新，它送走耄耋老者给新生代让路。现在你们是新生代，但是不久的将来，你们也会逐渐变老，被送出人生的舞台。抱歉讲得这么戏剧化，但是这是真的。</p><p>你们的时间有限，所以不要浪费时间在重复别人的生活上。不要被教条所束缚，那意味着你活在别人的世界里。不要让其他人的想法淹没你内心的声音。还有最重要的是，你要有勇气去听从内心的声音，跟着感觉走——它们在某种程度上知道你想要成为什么样子，所有其他的事情都是次要的。</p><p>当我年轻的时候, 有一本令人惊叹的、叫做”全球概览”的杂志，它被我们那一代人奉为圭臬。它是一个叫Stewart Brand的家伙在离这里不远的Menlo Park编辑的，他把杂志办得很有诗意。那是六十年代后期, 个人电脑还没有出现，这本杂志的所有内容全部是用打字机,、剪刀还有拍立得照相机编辑的。有点像印在纸上的Google，它比谷歌早出现了三十五年：这是梦幻般的，其中有许多灵巧的工具和伟大的想法。</p><p>Stewart和他的团队出版了几期”全球概览”，当它完成自己使命的时候, 他们出版了最后一期。那是在七十年代的中期，我正是你们的年纪。在最后一期的封底上是一张清晨乡间小路的照片（如果你足够有冒险精神的话，你会看到这种小路），在照片下有这样一行字：”求知若饥，虚心若愚。”这是他们的告别箴言。”求知若饥，虚心若愚。”我总是希望自己能够那样。现在, 在你们即将毕业，开始新的旅程的时候，我也以此期许你们：</p><p><strong>Stay Hungry. Stay Foolish.</strong></p><p>求知若饥，虚心若愚。</p><p>=================================== 译文分割线 ========================================</p><p>这是从<a href="https://zhuanlan.zhihu.com/p/272831486">乔布斯在斯坦福大学的演讲 - 知乎 (zhihu.com)</a>中摘录的，如果说想看每一段的翻译，可以在这个url上看看。</p><p>一篇文章，一句话，足以能够改变一个人的人生。</p>]]></content>
    
    
    <categories>
      
      <category>摘录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乔布斯</tag>
      
      <tag>演讲稿</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超简单shiro的springboot整合，一看就懂</title>
    <link href="/my_world/content/%E8%B6%85%E7%AE%80%E5%8D%95shiro%E7%9A%84springboot%E6%95%B4%E5%90%88%EF%BC%8C%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82/"/>
    <url>/my_world/content/%E8%B6%85%E7%AE%80%E5%8D%95shiro%E7%9A%84springboot%E6%95%B4%E5%90%88%EF%BC%8C%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API可以快速、轻松地获得任何应用程序，不论是从最小的移动应用程序到最大的网络和企业应用程序。shiro有三个核心的组件，分别是：Subject, SecurityManager 和 Realms.</p><p>该文章已经整合到springboot框架大全里面了</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文章只是作为一个框架供参考，在项目中需要灵活运用</p><h2 id="什么是shiro"><a href="#什么是shiro" class="headerlink" title="什么是shiro"></a>什么是shiro</h2><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API可以快速、轻松地获得任何应用程序，不论是从最小的移动应用程序到最大的网络和企业应用程序。</p><p><img src="http://upload-images.jianshu.io/upload_images/426671-4f553a3555dcf438.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="简略图"></p><p>shiro有三个核心的组件，分别是：Subject, SecurityManager 和 Realms.</p><ul><li><p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着”当前跟软件交互的东西”。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。</p></li><li><p>SecurityManager：它是Shiro框架的核心，典型的<a href="https://baike.baidu.com/item/Facade模式/7557140">Facade模式</a>，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。</p></li><li><p>Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/426671-5458508e59ae958a.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="顺序图"></p><blockquote><p>以上摘自百度百科<a href="https://baike.baidu.com/item/shiro/17753571">shiro</a>，有少许修改</p></blockquote><p>shiro的大体框架为：</p><p><img src="http://upload-images.jianshu.io/upload_images/426671-d2c043d97b735c9e.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="框架图"></p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p><strong>springboot</strong>整合shiro</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>这里不得不提一嘴官网的QuickStart，下面是shiro的QuickStart：</p><blockquote><p><a href="http://shiro.apache.org/10-minute-tutorial.html">10分钟入门shiro</a></p></blockquote><p>以下是QuickStart的全部代码，这里笔者自己注释了一下，分解可以看到有6个部分，大致是SecurityManagerFactory（安全管理的工厂，属于工厂模式）、SecurityManager（安全管理，三大核心之一）、Subject（对象，三大核心之一）、Authenticated（认证）、Role（角色）、Permitted（授权）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.quickstart;<span class="hljs-keyword">import</span> org.apache.log4j.Logger;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;<span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<span class="hljs-keyword">import</span> org.apache.shiro.session.Session;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.apache.shiro.util.Factory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickStart</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger log = Logger.getLogger(QuickStart.class);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1.创建shiro工厂</span>        Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>);        <span class="hljs-comment">//2.创建SecurityManager</span>        SecurityManager securityManager = factory.getInstance();        <span class="hljs-comment">//3.SecurityUtils设置SecurityManager</span>        SecurityUtils.setSecurityManager(securityManager);        <span class="hljs-comment">//4.获取Subject对象 *</span>        Subject currentUser = SecurityUtils.getSubject();        <span class="hljs-comment">//5.创建shiro的session</span>        Session session = currentUser.getSession();        session.setAttribute(<span class="hljs-string">&quot;someKey&quot;</span>, <span class="hljs-string">&quot;aValue&quot;</span>);<span class="hljs-comment">//设置session属性</span>        String value = (String) session.getAttribute(<span class="hljs-string">&quot;someKey&quot;</span>);        <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;aValue&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;Retrieved the correct value! [&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>);        &#125;        <span class="hljs-comment">//判断该用户是否被认证</span>        <span class="hljs-keyword">if</span> (!currentUser.isAuthenticated()) &#123;            UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;lonestarr&quot;</span>, <span class="hljs-string">&quot;vespa&quot;</span>);            token.setRememberMe(<span class="hljs-keyword">true</span>);            <span class="hljs-keyword">try</span> &#123;                currentUser.login(token);            &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;                log.info(<span class="hljs-string">&quot;There is no user with username of &quot;</span> + token.getPrincipal());            &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;                log.info(<span class="hljs-string">&quot;Password for account &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; was incorrect!&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;                log.info(<span class="hljs-string">&quot;The account for username &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; is locked.  &quot;</span> +                        <span class="hljs-string">&quot;Please contact your administrator to unlock it.&quot;</span>);            &#125;            <span class="hljs-comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span>            <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;                <span class="hljs-comment">//unexpected condition?  error?</span>            &#125;        &#125;        <span class="hljs-comment">//say who they are:</span>        <span class="hljs-comment">//print their identifying principal (in this case, a username):</span>        log.info(<span class="hljs-string">&quot;User [&quot;</span> + currentUser.getPrincipal() + <span class="hljs-string">&quot;] logged in successfully.&quot;</span>);        <span class="hljs-comment">//test a role:角色</span>        <span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">&quot;schwartz&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;May the Schwartz be with you!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">&quot;Hello, mere mortal.&quot;</span>);        &#125;        <span class="hljs-comment">//test a typed permission (not instance-level)粗粒度</span>        <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;lightsaber:wield&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;You may use a lightsaber ring.  Use it wisely.&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;</span>);        &#125;        <span class="hljs-comment">//a (very powerful) Instance Level permission:细粒度</span>        <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;winnebago:drive:eagle5&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot;</span> +                    <span class="hljs-string">&quot;Here are the keys - have fun!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;</span>);        &#125;        <span class="hljs-comment">//all done - log out!</span>        currentUser.logout();    &#125;&#125;</code></pre></div><p>配置文件shiro.ini为：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># =============================================================================</span><span class="hljs-comment"># Tutorial INI configuration</span><span class="hljs-comment">#</span><span class="hljs-comment"># Usernames/passwords are based on the classic Mel Brooks&#x27; film &quot;Spaceballs&quot; :)</span><span class="hljs-comment"># =============================================================================</span><span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-comment"># Users and their (optional) assigned roles</span><span class="hljs-comment"># username = password, role1, role2, ..., roleN</span><span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-section">[users]</span><span class="hljs-attr">root</span> = secret, admin<span class="hljs-attr">guest</span> = guest, guest<span class="hljs-attr">presidentskroob</span> = <span class="hljs-number">12345</span>, president<span class="hljs-attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz<span class="hljs-attr">lonestarr</span> = vespa, goodguy, schwartz<span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-comment"># Roles with assigned permissions</span><span class="hljs-comment"># roleName = perm1, perm2, ..., permN</span><span class="hljs-comment"># -----------------------------------------------------------------------------</span><span class="hljs-section">[roles]</span><span class="hljs-attr">admin</span> = *<span class="hljs-attr">schwartz</span> = lightsaber:*<span class="hljs-attr">goodguy</span> = winnebago:drive:eagle5</code></pre></div><p>log4j.properties几乎是固定的：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">### 设置###</span><span class="hljs-meta">log4j.rootLogger</span> = <span class="hljs-string">debug,stdout,D,E</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出信息到控制抬 ###</span><span class="hljs-meta">log4j.appender.stdout</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.stdout.Target</span> = <span class="hljs-string">System.out</span><span class="hljs-meta">log4j.appender.stdout.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span> = <span class="hljs-string">[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><span class="hljs-meta">log4j.appender.D</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-comment">#log4j.appender.D.File = E://logs/log.log</span><span class="hljs-meta">log4j.appender.D.Append</span> = <span class="hljs-string">true</span><span class="hljs-meta">log4j.appender.D.Threshold</span> = <span class="hljs-string">DEBUG </span><span class="hljs-meta">log4j.appender.D.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.D.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><span class="hljs-comment"></span><span class="hljs-comment">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><span class="hljs-meta">log4j.appender.E</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><span class="hljs-comment">#log4j.appender.E.File =E://logs/error.log</span><span class="hljs-meta">log4j.appender.E.Append</span> = <span class="hljs-string">true</span><span class="hljs-meta">log4j.appender.E.Threshold</span> = <span class="hljs-string">ERROR </span><span class="hljs-meta">log4j.appender.E.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.E.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span></code></pre></div><p>pom.xml</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- shiro的核心包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="整合springboot"><a href="#整合springboot" class="headerlink" title="整合springboot"></a>整合springboot</h2><h3 id="配置类和realm"><a href="#配置类和realm" class="headerlink" title="配置类和realm"></a>配置类和realm</h3><p>在springboot中自定义shiro的配置类ShiroConfig，并在方法前添加@Configuration（标准的springboot配置类注解），<strong>config类中所有的方法前都应该加上@Bean，让spring托管方法</strong></p><p>首先引入realm，这里的自定义realm命名为UserRealm，创建一个UserRealm类，并继承AuthorizingRealm类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;    <span class="hljs-comment">//授权</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 授权方法doGetAuthorizationInfo&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//认证</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 认证方法doGetAuthenticationInfo&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>在ShiroConfig类添加方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建realm对象，需要自定义</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserRealm <span class="hljs-title">getUserRealm</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRealm();&#125;</code></pre></div><p>其次引入SecurityManager，这里使用DefaultWebSecurityManager，形参中用@Qualifier指定realm方法引入UserRealm：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//DefaultWebSecurityManager--&gt;获取UserRealm</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getUserRealm&quot;)</span> UserRealm userRealm)</span></span>&#123;    DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();    securityManager.setRealm(userRealm);<span class="hljs-comment">//关联realm</span>    <span class="hljs-keyword">return</span> securityManager;&#125;</code></pre></div><p>最后加入Factory，这里用ShiroFilterFactoryBean，获取DefaultWebSecurityManager的方法同上：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ShiroFilterFactoryBean--&gt;获取DefaultWebSecurityManager</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getDefaultWebSecurityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;    ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();    <span class="hljs-comment">// 设置安全管理器</span>    bean.setSecurityManager(defaultWebSecurityManager);    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div><p>三个方法在config类中是串起来的，顺序是UserRealm—&gt;DefaultWebSecurityManager—&gt;ShiroFilterFactoryBean</p><h3 id="添加测试页面"><a href="#添加测试页面" class="headerlink" title="添加测试页面"></a>添加测试页面</h3><p>引入thymeleaf</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- springboot thymeleaf starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>添加主页index，两个页面add，update和登录页面login.html</p><p>index.html</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Index<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/user/add&#125;&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> | <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/user/update&#125;&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>login.html</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/loginCheck&quot;</span>&gt;</span>    请输入账号: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>    请输入密码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>add.html和update.html添加1级标题即可</p><h3 id="添加controller"><a href="#添加controller" class="headerlink" title="添加controller"></a>添加controller</h3><p>用一个controller测试即可，命名为exampleController，并为页面添加链接</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span></span>&#123;    model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello shiro&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(&quot;/user/update&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(&quot;/user/add&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add&quot;</span>;&#125;<span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;&#125;</code></pre></div><p>至此所有工作准备完毕</p><h2 id="登录拦截"><a href="#登录拦截" class="headerlink" title="登录拦截"></a>登录拦截</h2><p>由shiro的内置过滤器完成，有5大选项：</p><ul><li>anon:无需认证可以访问</li><li>authc: 必须认证了才能访问</li><li>user:必须拥有 记住我 功能才能用</li><li>perms: 拥有对某个资源的权限才能访问</li><li>role: 拥有某个角色权限才能访问</li></ul><p>在ShiroConfig类的ShiroFilterFactoryBean操作方法中引入过滤器，完整的方法如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ShiroFilterFactoryBean--&gt;获取DefaultWebSecurityManager</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getDefaultWebSecurityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;    ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();    <span class="hljs-comment">// 设置安全管理器</span>    bean.setSecurityManager(defaultWebSecurityManager);    <span class="hljs-comment">// 添加shiro的内置过滤器</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">        anon:无需认证可以访问</span><span class="hljs-comment">        authc: 必须认证了才能访问</span><span class="hljs-comment">        user:必须拥有 记住我 功能才能用</span><span class="hljs-comment">        perms: 拥有对某个资源的权限才能访问</span><span class="hljs-comment">        role: 拥有某个角色权限才能访问</span><span class="hljs-comment">     */</span>    Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();    filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>);    bean.setFilterChainDefinitionMap(filterChainDefinitionMap);    <span class="hljs-comment">//设置登录请求</span>    bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div><p>可以看到，/user/下面的请求全部被拦截，必须认证了才能访问。在没有认证的时候，会跳转至/login。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>登录其实就是一个认证的过程，在controller中添加/loginCheck的操作逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/loginCheck&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loginCheck</span><span class="hljs-params">(String username,String password)</span></span>&#123;    System.out.println(<span class="hljs-string">&quot;获取账号密码:username: &quot;</span>+username+<span class="hljs-string">&quot;,password: &quot;</span>+password);    Subject subject = SecurityUtils.getSubject();<span class="hljs-comment">//获取当前用户</span>    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username,password);<span class="hljs-comment">//封装登录数据</span>    System.out.println(<span class="hljs-string">&quot;验证登录&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        subject.login(token);<span class="hljs-comment">//验证登录</span>    &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;        System.out.println(<span class="hljs-string">&quot;用户名错误&quot;</span>);    &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;        System.out.println(<span class="hljs-string">&quot;密码错误&quot;</span>);    &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;        System.out.println(<span class="hljs-string">&quot;账号被锁定&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;&#125;</code></pre></div><p>在执行subject.login(token);方法时，会将token输送到UserRealm中的doGetAuthenticationInfo()方法，验证是否正确即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//认证</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;     System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 认证方法doGetAuthenticationInfo&quot;</span>);     <span class="hljs-comment">//从数据库获取账号密码</span>     User user = <span class="hljs-keyword">new</span> User();     String username = <span class="hljs-string">&quot;root&quot;</span>;     user.setUsername(username);     String password = <span class="hljs-string">&quot;1234&quot;</span>;     user.setPassword(password);     String perms = <span class="hljs-string">&quot;user:add&quot;</span>;     user.setPerms(perms);     UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;     <span class="hljs-keyword">if</span>(!token.getUsername().equals(username))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//返回错误 UnknownAccountException</span>     &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user,user.getPassword(),<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//principal放存放着账户对象:USER</span> &#125;</code></pre></div><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>每个账户都有相应的权限，某些功能不能给某些没有该权限的人使用。首先限制url的权限，在过滤器中添加即可</p><div class="code-wrapper"><pre><code class="hljs java">ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();<span class="hljs-comment">// 设置安全管理器</span>bean.setSecurityManager(defaultWebSecurityManager);<span class="hljs-comment">// 添加shiro的内置过滤器</span><span class="hljs-comment">/*</span><span class="hljs-comment">    anon:无需认证可以访问</span><span class="hljs-comment">    authc: 必须认证了才能访问</span><span class="hljs-comment">    user:必须拥有 记住我 功能才能用</span><span class="hljs-comment">    perms: 拥有对某个资源的权限才能访问</span><span class="hljs-comment">    role: 拥有某个角色权限才能访问</span><span class="hljs-comment"> */</span>Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<span class="hljs-comment">/* 先检测授权后检测拦截，越在上面的优先度越大,未经授权跳转到指定页面 */</span>filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;perms[user:add]&quot;</span>);filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/update&quot;</span>,<span class="hljs-string">&quot;perms[user:update]&quot;</span>);filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>);bean.setFilterChainDefinitionMap(filterChainDefinitionMap);<span class="hljs-comment">//设置登录请求</span>bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);<span class="hljs-comment">//未授权页面</span>bean.setUnauthorizedUrl(<span class="hljs-string">&quot;/unau&quot;</span>);<span class="hljs-keyword">return</span> bean;</code></pre></div><p>一定要注意授权和拦截的顺序，并且授权是有优先度的。可以看到未授权也会跳转到相应的url，在controller添加即可：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/unau&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unauthorized</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;未经授权无法访问&quot;</span>;&#125;</code></pre></div><p>最后在UserRealm中添加授权逻辑</p><div class="code-wrapper"><pre><code class="hljs java">    <span class="hljs-comment">//授权</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 授权方法doGetAuthorizationInfo&quot;</span>);        SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<span class="hljs-comment">//        info.addStringPermission(&quot;user:add&quot;);//为账户添加user:add权限</span>        System.out.println(<span class="hljs-string">&quot;开始授权&quot;</span>);        <span class="hljs-comment">//拿到登录对象</span>        Subject subject = SecurityUtils.getSubject();        User currentUser = (User) subject.getPrincipal();<span class="hljs-comment">//拿到User对象</span>        <span class="hljs-comment">//设置当前用户的权限</span>        info.addStringPermission(currentUser.getPerms());        <span class="hljs-keyword">return</span> info;    &#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将所有的代码统一，QuickStart和user对象在上面已经总结完成，这是springboot中各类的所有代码：</p><p>ShiroConfig.java</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<span class="hljs-keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;<span class="hljs-keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        三大核心</span><span class="hljs-comment">        realm</span><span class="hljs-comment">        subject</span><span class="hljs-comment">        SecurityManager</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">//创建realm对象，需要自定义</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserRealm <span class="hljs-title">getUserRealm</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRealm();    &#125;    <span class="hljs-comment">//DefaultWebSecurityManager--&gt;获取UserRealm</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getUserRealm&quot;)</span> UserRealm userRealm)</span></span>&#123;        DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();        securityManager.setRealm(userRealm);<span class="hljs-comment">//关联realm</span>        <span class="hljs-keyword">return</span> securityManager;    &#125;    <span class="hljs-comment">//ShiroFilterFactoryBean--&gt;获取DefaultWebSecurityManager</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;getDefaultWebSecurityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;        ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();        <span class="hljs-comment">// 设置安全管理器</span>        bean.setSecurityManager(defaultWebSecurityManager);        <span class="hljs-comment">// 添加shiro的内置过滤器</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">            anon:无需认证可以访问</span><span class="hljs-comment">            authc: 必须认证了才能访问</span><span class="hljs-comment">            user:必须拥有 记住我 功能才能用</span><span class="hljs-comment">            perms: 拥有对某个资源的权限才能访问</span><span class="hljs-comment">            role: 拥有某个角色权限才能访问</span><span class="hljs-comment">         */</span>        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-comment">/* 先检测授权后检测拦截，越在上面的优先度越大,未经授权跳转到指定页面 */</span>        filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;perms[user:add]&quot;</span>);        filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/update&quot;</span>,<span class="hljs-string">&quot;perms[user:update]&quot;</span>);        filterChainDefinitionMap.put(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>);        bean.setFilterChainDefinitionMap(filterChainDefinitionMap);        <span class="hljs-comment">//设置登录请求</span>        bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);        <span class="hljs-comment">//未授权页面</span>        bean.setUnauthorizedUrl(<span class="hljs-string">&quot;/unau&quot;</span>);        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><p>UserRealm.java</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.config;<span class="hljs-keyword">import</span> com.example.pojo.User;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;<span class="hljs-keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;<span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;<span class="hljs-keyword">import</span> org.apache.shiro.subject.PrincipalCollection;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;    <span class="hljs-comment">//授权</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 授权方法doGetAuthorizationInfo&quot;</span>);        SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<span class="hljs-comment">//        info.addStringPermission(&quot;user:add&quot;);//为账户添加user:add权限</span>        System.out.println(<span class="hljs-string">&quot;开始授权&quot;</span>);        <span class="hljs-comment">//拿到登录对象</span>        Subject subject = SecurityUtils.getSubject();        User currentUser = (User) subject.getPrincipal();<span class="hljs-comment">//拿到User对象</span>        <span class="hljs-comment">//设置当前用户的权限</span>        info.addStringPermission(currentUser.getPerms());        <span class="hljs-keyword">return</span> info;    &#125;    <span class="hljs-comment">//认证</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了 =&gt; 认证方法doGetAuthenticationInfo&quot;</span>);        <span class="hljs-comment">//从数据库获取账号密码</span>        User user = <span class="hljs-keyword">new</span> User();        String username = <span class="hljs-string">&quot;root&quot;</span>;        user.setUsername(username);        String password = <span class="hljs-string">&quot;1234&quot;</span>;        user.setPassword(password);        String perms = <span class="hljs-string">&quot;user:add&quot;</span>;        user.setPerms(perms);        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;        <span class="hljs-keyword">if</span>(!token.getUsername().equals(username))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//返回错误 UnknownAccountException</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user,user.getPassword(),<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//principal放存放着账户对象:USER</span>    &#125;&#125;</code></pre></div><p>exampleController.java</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.controller;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.ui.Model;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exampleController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span></span>&#123;        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello shiro&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/user/update&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/user/add&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shiro</tag>
      
      <tag>安全框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>poco的超简单用法</title>
    <link href="/my_world/content/poco%E7%9A%84%E8%B6%85%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"/>
    <url>/my_world/content/poco%E7%9A%84%E8%B6%85%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>poco是一种基于UI控件搜索的自动化框架，与airtest不同，它的操作方式与appium相似。airtest是基于图像识别的框架，这就意味着，若页面是动态的（比如说系统的蓝牙，在开启的时候是一个样子，关闭的时候是另外一个样子），图像可能会无法识别，降低自动化测试的效率。poco的使用非常简单，在短短1天的时间就能学好并且开始制作项目，而且运行的错误率非常低.</p><p>本文章已废弃，请移步至该文章查看自动化测试框架的大总结<a href="http://vsoapmac.cn/content/更新未完成--自动化测试框架大总结/#Selenium">更新未完成—自动化测试框架大总结</a></p><h2 id="一句话概述什么是poco"><a href="#一句话概述什么是poco" class="headerlink" title="一句话概述什么是poco"></a>一句话概述什么是poco</h2><p>poco是一种基于UI控件搜索的自动化框架，与airtest不同，它的操作方式与appium相似。</p><h2 id="为什么在使用airtest时，推荐使用poco"><a href="#为什么在使用airtest时，推荐使用poco" class="headerlink" title="为什么在使用airtest时，推荐使用poco"></a>为什么在使用airtest时，推荐使用poco</h2><p>airtest是基于图像识别的框架，这就意味着，若页面是动态的（比如说系统的蓝牙，在开启的时候是一个样子，关闭的时候是另外一个样子），图像可能会无法识别，降低自动化测试的效率。poco的使用非常简单，在短短1天的时间就能学好并且开始制作项目，而且运行的错误率非常低（编写逻辑的错误不算）。</p><h2 id="poco的基本用法"><a href="#poco的基本用法" class="headerlink" title="poco的基本用法"></a>poco的基本用法</h2><p>这里列举了一些poco的入门且简单的常用用法（在笔者看来常用的用法），笔者是在<strong>airtest自带的ide</strong>上进行的代码编写</p><blockquote><p>常用的点击</p></blockquote><ol><li>通过元素name</li></ol><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;com.android.systemui:id/nubia_settings_button&quot;</span>).click()<span class="hljs-comment">#.click()为点击，后面会讲到</span></code></pre></div><ol><li>通过元素text</li></ol><div class="code-wrapper"><pre><code class="hljs python">poco(text=<span class="hljs-string">&quot;电话&quot;</span>).click()</code></pre></div><ol><li>通过坐标</li></ol><div class="code-wrapper"><pre><code class="hljs python">poco().click([<span class="hljs-number">0.507</span>,<span class="hljs-number">0.013</span>])</code></pre></div><blockquote><p>滑动页面</p></blockquote><p>滑动页面是通过坐标完成的，在airtest中所有的坐标使用相对坐标，查看坐标的方法为：选项—&gt;设置—&gt;勾选【实时坐标显示】和【相对坐标】。鼠标移动到设备窗口即可查看相对坐标</p><div class="code-wrapper"><pre><code class="hljs python">poco.swipe([<span class="hljs-number">0.507</span>,<span class="hljs-number">0.013</span>],[<span class="hljs-number">0.507</span>,<span class="hljs-number">0.575</span>])</code></pre></div><blockquote><p>判断元素是否存在</p></blockquote><p>有些元素是变化的，可能在某个时间段存在，某个时间段又消失了，这个时候我们可以判断元素是否存在</p><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).exists</code></pre></div><p>可以配合if，如果元素存在，则执行动作</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span>(poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).exists):    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入框存在，点击&quot;</span>);    poco(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>).click()</code></pre></div><blockquote><p>常用的事件</p></blockquote><ol><li>点击</li></ol><div class="code-wrapper"><pre><code class="hljs python">poco().click([<span class="hljs-number">0.507</span>,<span class="hljs-number">0.013</span>])</code></pre></div><ol><li>长按</li></ol><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;蓝牙。&quot;</span>).long_click()<span class="hljs-comment"># 默认的长按点击，笔者比较喜欢用这个（因为不用动脑而且不会出现很奇葩的错误）</span></code></pre></div><ol><li>发送文本</li></ol><div class="code-wrapper"><pre><code class="hljs python">poco(<span class="hljs-string">&quot;cn.nubia.mms:id/embedded_text_editor&quot;</span>).set_text(<span class="hljs-string">&quot;0000&quot;</span>)</code></pre></div><p>以上就是poco的最简单的用法</p><h2 id="如何提高效率"><a href="#如何提高效率" class="headerlink" title="如何提高效率"></a>如何提高效率</h2><p>笔者使用airtest自带的ide中的poco的脚本录制，所谓脚本录制，就是可视化操作，由IDE自动输入代码。这也是为什么推荐poco的原因。</p><p>打开Poco Assistant窗口，在Poco辅助窗下面的选项中（有Stop、Android等等）右边的第三个图标（鼠标悬停会出现Poco Auto Recording字样），点击后点击设备窗口即可进行脚本录制。</p>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>airtest</tag>
      
      <tag>pocoui</tag>
      
      <tag>自动化测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单了解Thymeleaf在springboot中的应用</title>
    <link href="/my_world/content/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3Thymeleaf%E5%9C%A8springboot%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/my_world/content/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3Thymeleaf%E5%9C%A8springboot%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎。它主要目标是为您的开发工作流程带来优雅的模板，HTML可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作。Thymeleaf拥有用于Spring Framework的模块，与您喜欢的工具（例如springboot）的大量集成以及嵌入自己的功能的能力，对于现代HTML5 JVM Web开发而言，Thymeleaf是理想的选择-尽管它还有很多工作要做。</p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>该文只是对于想初步了解thymeleaf，并且用thymeleaf能做出来一点简单的东西。视作读者使用<strong>springboot</strong>框架使用thymeleaf，仅供参考</p><h2 id="什么是thymeleaf"><a href="#什么是thymeleaf" class="headerlink" title="什么是thymeleaf"></a>什么是thymeleaf</h2><p>稍微摘自官网的内容</p><ul><li><em>Thymeleaf is a modern server-side Java template engine for both web and standalone environments.</em></li><li><em>Thymeleaf’s main goal is to bring elegant natural templates to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams.</em></li><li><em>With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do.</em></li></ul><p>机翻后，就是（作者稍作修改）：</p><ol><li>Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎。</li><li>Thymeleaf的主要目标是为您的开发工作流程带来优雅的模板，HTML可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作。 </li><li>Thymeleaf拥有用于Spring Framework的模块，与您喜欢的工具（例如springboot）的大量集成以及嵌入您自己的功能的能力，对于现代HTML5 JVM Web开发而言，Thymeleaf是理想的选择-尽管它还有很多工作要做。</li></ol><p>不得不说Thymeleaf和JSP十分得像，但是他们之间的区别在于，不运行项目之前，Thymeleaf也是纯HTML（<strong>不需要服务端的支持</strong>）而JSP需要进行一定的转换，这样就方便前端人员进行独立的设计、调试。它有如下三个吸引人的特点：</p><ol><li><p>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p></li><li><p>Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p></li><li><p>Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</p></li></ol><blockquote><p>摘自：<a href="https://www.cnblogs.com/ityouknow/p/5833560.html">spring boot(四):thymeleaf使用详解-纯洁的微笑</a></p></blockquote><h2 id="为什么使用thymeleaf"><a href="#为什么使用thymeleaf" class="headerlink" title="为什么使用thymeleaf"></a>为什么使用thymeleaf</h2><p>前后端分离确实很方便，无可厚非。某些时候，我们也需要用到单机，thymeleaf无疑是最好的选择。</p><h2 id="pom-xml引入"><a href="#pom-xml引入" class="headerlink" title="pom.xml引入"></a>pom.xml引入</h2><p>依赖如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- springboot thymeleaf starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h2><p>无需配置，保持默认即可，遵从springboot中<strong>约定大于配置</strong></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>所有的html、css、js等文件存放到resources文件夹下</p><p>新建static、templates文件夹（若存在忽略），将css、js等文件存放到static文件夹，html存放到templates文件夹</p><p>在html引入css、js文件夹时，只需要按照同级目录的方式引入即可，以bootstrap为例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span>/&gt;</span></code></pre></div><h2 id="html引入"><a href="#html引入" class="headerlink" title="html引入"></a>html引入</h2><p>在html页面中引入：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">“http://www.thymeleaf.org”</span>&gt;</span>    ...<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>准备工作基本完毕，注意：<strong>xmlns:th中th，个人认为是一个命名空间，在使用时需要引用，强烈建议不改，笔者查阅了大量的资料，几乎都是用的th</strong></p><h2 id="thymeleaf使用"><a href="#thymeleaf使用" class="headerlink" title="thymeleaf使用"></a>thymeleaf使用</h2><p>这里列举最常用的，若有不足以后会慢慢添加</p><h3 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h3><p>后端首先发送一个对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-meta">@RequestMapping(&quot;/pageAction&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pageAction</span><span class="hljs-params">(Model model)</span></span>&#123;    List&lt;user&gt; list = Service.queryList();    model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;page&quot;</span>;&#125;</code></pre></div><p>对象是这样的，getter and setter不是代码，是属性的get和set方法，若有不懂请自行百度【属性的get和set方法】，Serializable是将对象序列化，建议搞上去。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">user</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    getter and setter&#125;</code></pre></div><p>前端循环遍历对象：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;list : $&#123;list&#125;&quot;</span>&gt;</span></code></pre></div><p>展示，注意要在遍历对象的盒子里边：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;list : $&#123;list&#125;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;list.name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- 展示在页面上使用text --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;list.name&#125;&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 嵌套在input或其他用value --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>可以使用#numbers.sequence()限制展示的数量</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;index:$&#123;#numbers.sequence(1,10)&#125;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;index&#125;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 这里会展示1-&gt;10 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre></div><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/pageAction(id = $&#123;list.id&#125;,name = $&#123;list.name&#125;)&#125;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>若点击1,url上会显示</p><div class="code-wrapper"><pre><code class="hljs applescript">localhost:<span class="hljs-number">8080</span>/pageAction?<span class="hljs-built_in">id</span>=xxx&amp;<span class="hljs-built_in">name</span>=xxx</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些就是thymeleaf中的某些部分，若有需要后续添加</p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thymeleaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解File类中绝对路径和相对路径的操作</title>
    <link href="/my_world/content/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3File%E7%B1%BB%E4%B8%AD%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/my_world/content/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3File%E7%B1%BB%E4%B8%AD%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。</p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本文视作读者对于<code>java.io.File</code>类有一定的了解,该文用于加深了解文件路径，仅供参考。</p><h1 id="什么是File类"><a href="#什么是File类" class="headerlink" title="什么是File类"></a>什么是File类</h1><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p><p>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。</p><p>通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。</p><h1 id="什么是绝对路径和相对路径"><a href="#什么是绝对路径和相对路径" class="headerlink" title="什么是绝对路径和相对路径"></a>什么是绝对路径和相对路径</h1><blockquote><p> 绝对路径</p></blockquote><p>是一个完整的路径，以盘符开始（c： d：）c:\a.txt</p><blockquote><p>相对路径</p></blockquote><p>相对指的是相对于当前项目的根目录（可以省略项目的根目录），例如：/user/xxx/a.txt</p><p>注意：<br>1、路径不区分大小写，文件名区分大小写（）<br>2、路径中的文件名称分隔符windows使用反斜杠，反斜杠是转义字符，两个反斜杠代表一个普通的反斜杠（c:\\a.txt等价于c:\a.txt）</p><h1 id="为什么推荐使用相对路径"><a href="#为什么推荐使用相对路径" class="headerlink" title="为什么推荐使用相对路径"></a>为什么推荐使用相对路径</h1><p>在生产环境中，项目的位置会实时变更。我们不可能每一次变更都手动获取绝对路径。当使用相对路径后，我们只需要将项目随意放到任意的文件夹即可运行，提高不少的效率（说白了就是懒，懒人科技.jpg）。</p><h1 id="获取路径的主要方法"><a href="#获取路径的主要方法" class="headerlink" title="获取路径的主要方法"></a>获取路径的主要方法</h1><ul><li><strong>public String getName()</strong> 返回由此相对路径名表示的文件或目录的名称。</li><li><strong>public String getParent()</strong> 返回此相对路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 null。</li><li><strong>public File getParentFile()</strong> 返回此相对路径名的父路径名的相对路径名，如果此路径名没有指定父目录，则返回 null。</li><li><strong>public String getPath()</strong> 将此相对路径名转换为一个路径名字符串。</li><li><strong>public String getAbsolutePath()</strong> 返回绝对路径名字符串。</li></ul><h1 id="如何动态获取绝对路径"><a href="#如何动态获取绝对路径" class="headerlink" title="如何动态获取绝对路径"></a>如何动态获取绝对路径</h1><p>在了解获取相对路径前，我们来聊聊如何动态获取绝对路径。这是在生产环境中比较便利的一种方法，可以达到相对路径的效果。</p><ul><li>获取某文件的绝对路径</li></ul><div class="code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;pom.xml&quot;</span>);String file_absolute_path = file.getAbsolutePath();</code></pre></div><ul><li>获得项目根目录的绝对路径<div class="code-wrapper"><pre><code class="hljs java">String project_absolute_path = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);</code></pre></div></li></ul><p>最后得出的结果，用字符串拼接即可进行下一步处理</p><h1 id="如何使用相对路径"><a href="#如何使用相对路径" class="headerlink" title="如何使用相对路径"></a>如何使用相对路径</h1><p>对于文件，我们是进行读（Read，获取文件、读取文件中的信息）和写（Write，创建文件）两个操作</p><p>我们在D：project文件夹下面创建类来测试我们的结果。</p><blockquote><p>创建文件</p></blockquote><p>在创建文件的时候，是相对于项目的同级目录进行的，创建类，编写下面方法后编译运行。</p><div class="code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);<span class="hljs-keyword">if</span>(!file.exists())&#123;    <span class="hljs-keyword">try</span> &#123;        file.createNewFile();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;String filepath = file.getAbsolutePath();System.out.println(filepath);</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs tex">D:<span class="hljs-keyword">\project</span><span class="hljs-keyword">\test</span>.txt</code></pre></div><blockquote><p>创建文件，存放到项目同级文件夹</p></blockquote><p>若想将文件存放到同级某特定文件夹中，原理和上面相似，编写项目，创建好特定的文件夹后编译运行。</p><div class="code-wrapper"><pre><code class="hljs java">String path = <span class="hljs-string">&quot;txt&quot;</span>;String filename = <span class="hljs-string">&quot;test.txt&quot;</span>File filepath = <span class="hljs-keyword">new</span> File(path);<span class="hljs-keyword">if</span>(!filepath.exists())&#123;  <span class="hljs-comment">//若不想手动创建文件夹加上该代码块即可</span>    filepath.mkdir(); &#125;File file = <span class="hljs-keyword">new</span> File(path + <span class="hljs-string">&quot;/&quot;</span> + filename);<span class="hljs-keyword">if</span>(!file.exists())&#123;    <span class="hljs-keyword">try</span> &#123;        file.createNewFile();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;System.out.println(file.getAbsolutePath());</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs tex">D:<span class="hljs-keyword">\project</span><span class="hljs-keyword">\txt</span><span class="hljs-keyword">\test</span>.txt</code></pre></div><blockquote><p>读取文件</p></blockquote><p>原理和创建文件类似，直接用file获取即可。</p><div class="code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);<span class="hljs-comment">//获取同级目录下的test.txt文件</span>File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;txt/test.txt&quot;</span>);<span class="hljs-comment">//获取同级目录下的txt文件夹中的test.txt文件</span></code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>相对路径是相对于项目所在的文件夹而言的</li><li>相对路径虽然好用，但是不能无脑使用，视情况而定（例如需要在某特定文件夹下创建或者读取文件）</li><li>可以通过动态获取绝对路径来便利我们的生产</li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件设计的行为型模式（二）</title>
    <link href="/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><blockquote><p>图片原链接：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 | 菜鸟教程 (runoob.com)</a></p><p>文字原链接：<a href="http://c.biancheng.net/view/1317.html">软件设计模式概述 (biancheng.net)</a></p></blockquote><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p><ol><li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li><strong>命令（Command）模式</strong>：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li><strong>观察者（Observer）模式</strong>：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><p>中介者模式是一种对象行为型模式，其主要优点如下。</p><ol><li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li><li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li></ol><p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p><h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>中介者模式实现的关键是找出“中介者”，下面对它的结构和实现进行分析。</p><p><strong>模式的结构</strong></p><p>中介者模式包含以下主要角色。</p><ol><li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/mediator_pattern_uml_diagram.jpg" alt="中介者模式"></p><p><strong>模式的实现</strong></p><p>中介者模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mediator;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediatorPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Mediator md=<span class="hljs-keyword">new</span> ConcreteMediator();        Colleague c1,c2;        c1=<span class="hljs-keyword">new</span> ConcreteColleague1();        c2=<span class="hljs-keyword">new</span> ConcreteColleague2();        md.register(c1);        md.register(c2);        c1.send();        System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);        c2.send();    &#125;&#125;<span class="hljs-comment">//抽象中介者</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Colleague colleague)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relay</span><span class="hljs-params">(Colleague cl)</span></span>; <span class="hljs-comment">//转发</span>&#125;<span class="hljs-comment">//具体中介者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mediator</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> List&lt;Colleague&gt; colleagues=<span class="hljs-keyword">new</span> ArrayList&lt;Colleague&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Colleague colleague)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(!colleagues.contains(colleague))        &#123;            colleagues.add(colleague);            colleague.setMedium(<span class="hljs-keyword">this</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relay</span><span class="hljs-params">(Colleague cl)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(Colleague ob:colleagues)        &#123;            <span class="hljs-keyword">if</span>(!ob.equals(cl))            &#123;                ((Colleague)ob).receive();            &#125;           &#125;    &#125;&#125;<span class="hljs-comment">//抽象同事类</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">protected</span> Mediator mediator;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMedium</span><span class="hljs-params">(Mediator mediator)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.mediator=mediator;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体同事类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Colleague</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体同事类1收到请求。&quot;</span>);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体同事类1发出请求。&quot;</span>);        mediator.relay(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//请中介者转发</span>    &#125;&#125;<span class="hljs-comment">//具体同事类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Colleague</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体同事类2收到请求。&quot;</span>);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体同事类2发出请求。&quot;</span>);        mediator.relay(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//请中介者转发</span>    &#125;&#125;</code></pre></div><h2 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用中介者模式编写一个“韶关房地产交流平台”程序。</p><p>说明：韶关房地产交流平台是“房地产中介公司”提供给“卖方客户”与“买方客户”进行信息交流的平台，比较适合用中介者模式来实现。</p><p>首先，定义一个中介公司（Medium）接口，它是抽象中介者，它包含了客户注册方法 register(Customer member) 和信息转发方法 relay(String from,String ad)；再定义一个韶关房地产中介（EstateMedium）公司，它是具体中介者类，它包含了保存客户信息的 List 对象，并实现了中介公司中的抽象方法。</p><p>然后，定义一个客户（Qistomer）类，它是抽象同事类，其中包含了中介者的对象，和发送信息的 send(String ad) 方法与接收信息的 receive(String from，Stringad) 方法的接口，由于本程序是窗体程序，所以本类继承 JPmme 类，并实现动作事件的处理方法 actionPerformed(ActionEvent e)。</p><p>最后，定义卖方（Seller）类和买方（Buyer）类，它们是具体同事类，是客户（Customer）类的子类，它们实现了父类中的抽象方法，通过中介者类进行信息交流</p><h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>前面分析了中介者模式的结构与特点，下面分析其以下应用场景。</p><ul><li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。</p><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li></ol><p>其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。</p><h2 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。</p><p><strong>模式的结构</strong></p><p>迭代器模式主要包含以下角色。</p><ol><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/202107-23-iterator-pattern.png" alt="迭代器模式"></p><p><strong>模式的实现</strong></p><p>迭代器模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> iterator;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Aggregate ag=<span class="hljs-keyword">new</span> ConcreteAggregate();         ag.add(<span class="hljs-string">&quot;中山大学&quot;</span>);         ag.add(<span class="hljs-string">&quot;华南理工&quot;</span>);         ag.add(<span class="hljs-string">&quot;韶关学院&quot;</span>);        System.out.print(<span class="hljs-string">&quot;聚合的内容有：&quot;</span>);        Iterator it=ag.getIterator();         <span class="hljs-keyword">while</span>(it.hasNext())        &#123;             Object ob=it.next();             System.out.print(ob.toString()+<span class="hljs-string">&quot;\t&quot;</span>);         &#125;        Object ob=it.first();        System.out.println(<span class="hljs-string">&quot;\nFirst：&quot;</span>+ob.toString());    &#125;&#125;<span class="hljs-comment">//抽象聚合</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Aggregate</span></span><span class="hljs-class"></span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object obj)</span></span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object obj)</span></span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">//具体聚合</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Aggregate</span></span><span class="hljs-class"></span>&#123;     <span class="hljs-keyword">private</span> List&lt;Object&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object obj)</span></span><span class="hljs-function">    </span>&#123;         list.add(obj);     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object obj)</span></span><span class="hljs-function">    </span>&#123;         list.remove(obj);     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span>(<span class="hljs-keyword">new</span> ConcreteIterator(list));     &#125;     &#125;<span class="hljs-comment">//抽象迭代器</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function">Object <span class="hljs-title">first</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体迭代器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span></span><span class="hljs-class"></span>&#123;     <span class="hljs-keyword">private</span> List&lt;Object&gt; list=<span class="hljs-keyword">null</span>;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index=-<span class="hljs-number">1</span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span><span class="hljs-params">(List&lt;Object&gt; list)</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">this</span>.list=list;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">if</span>(index&lt;list.size()-<span class="hljs-number">1</span>)        &#123;             <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">first</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        index=<span class="hljs-number">0</span>;        Object obj=list.get(index);;        <span class="hljs-keyword">return</span> obj;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         Object obj=<span class="hljs-keyword">null</span>;         <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.hasNext())        &#123;             obj=list.get(++index);         &#125;         <span class="hljs-keyword">return</span> obj;     &#125;   &#125;</code></pre></div><h2 id="模式的应用实例-1"><a href="#模式的应用实例-1" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用迭代器模式编写一个浏览婺源旅游风景图的程序。</p><p>分析：婺源的名胜古迹较多，要设计一个查看相关景点图片（点此下载本实例所要显示的景点图片）和简介的程序，用“迭代器模式”设计比较合适。</p><p>首先，设计一个婺源景点（WyViewSpot）类来保存每张图片的名称与简介；再设计一个景点集（ViewSpotSet）接口，它是抽象聚合类，提供了增加和删除婺源景点的方法，以及获取迭代器的方法。</p><p>然后，定义一个婺源景点集（WyViewSpotSet）类，它是具体聚合类，用 ArrayList 来保存所有景点信息，并实现父类中的抽象方法；再定义婺源景点的抽象迭代器（ViewSpotltemtor）接口，其中包含了查看景点信息的相关方法。</p><p>最后，定义婺源景点的具体迭代器（WyViewSpotlterator）类，它实现了父类的抽象方法；客户端程序设计成窗口程序，它初始化婺源景点集（ViewSpotSet）中的数据，并实现 ActionListener 接口，它通过婺源景点迭代器（ViewSpotlterator）来査看婺源景点（WyViewSpot）的信息</p><h2 id="模式的应用场景-1"><a href="#模式的应用场景-1" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>前面介绍了关于迭代器模式的结构与特点，下面介绍其应用场景，迭代器模式通常在以下几种情况使用。</p><ol><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li></ol><h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p><p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p><ol><li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li><li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li><li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li></ol><p>访问者（Visitor）模式的主要缺点如下。</p><ol><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li><li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li><li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li></ol><h2 id="模式的结构与实现-2"><a href="#模式的结构与实现-2" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类，其基本结构与实现方法如下。</p><p><strong>模式的结构</strong></p><p>访问者模式包含以下主要角色。</p><ol><li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li><li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li><li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li><li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li><li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/visitor_pattern_uml_diagram.jpg" alt="访问者模式实现"></p><p><strong>模式的实现</strong></p><p>访问者模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> visitor;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitorPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        ObjectStructure os=<span class="hljs-keyword">new</span> ObjectStructure();        os.add(<span class="hljs-keyword">new</span> ConcreteElementA());        os.add(<span class="hljs-keyword">new</span> ConcreteElementB());        Visitor visitor=<span class="hljs-keyword">new</span> ConcreteVisitorA();        os.accept(visitor);        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);        visitor=<span class="hljs-keyword">new</span> ConcreteVisitorB();        os.accept(visitor);    &#125;&#125;<span class="hljs-comment">//抽象访问者</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementA element)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementB element)</span></span>;&#125;<span class="hljs-comment">//具体访问者A类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteVisitorA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementA element)</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体访问者A访问--&gt;&quot;</span>+element.operationA());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementB element)</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体访问者A访问--&gt;&quot;</span>+element.operationB());    &#125;&#125;<span class="hljs-comment">//具体访问者B类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteVisitorB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementA element)</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体访问者B访问--&gt;&quot;</span>+element.operationA());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementB element)</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体访问者B访问--&gt;&quot;</span>+element.operationB());    &#125;&#125;<span class="hljs-comment">//抽象元素类</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;&#125;<span class="hljs-comment">//具体元素A类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Element</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span><span class="hljs-function">    </span>&#123;        visitor.visit(<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">operationA</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;具体元素A的操作。&quot;</span>;    &#125;&#125;<span class="hljs-comment">//具体元素B类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Element</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span><span class="hljs-function">    </span>&#123;        visitor.visit(<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">operationB</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;具体元素B的操作。&quot;</span>;    &#125;&#125;<span class="hljs-comment">//对象结构角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectStructure</span></span><span class="hljs-class"></span>&#123;       <span class="hljs-keyword">private</span> List&lt;Element&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;Element&gt;();       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span><span class="hljs-function">    </span>&#123;        Iterator&lt;Element&gt; i=list.iterator();        <span class="hljs-keyword">while</span>(i.hasNext())        &#123;            ((Element) i.next()).accept(visitor);        &#125;          &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Element element)</span></span><span class="hljs-function">    </span>&#123;        list.add(element);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Element element)</span></span><span class="hljs-function">    </span>&#123;        list.remove(element);    &#125;&#125;</code></pre></div><h2 id="模式的应用实例-2"><a href="#模式的应用实例-2" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>利用“访问者（Visitor）模式”模拟艺术公司与造币公司的功能。</p><p>分析：艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币（点此下载运行该程序后所要显示的图片）。对“铜”和“纸”这两种元素，两个公司的处理方法不同，所以该实例用访问者模式来实现比较适合。</p><p>首先，定义一个公司（Company）接口，它是抽象访问者，提供了两个根据纸（Paper）或铜（Cuprum）这两种元素创建作品的方法；再定义艺术公司（ArtCompany）类和造币公司（Mint）类，它们是具体访问者，实现了父接口的方法；然后，定义一个材料（Material）接口，它是抽象元素，提供了 accept（Company visitor）方法来接受访问者（Company）对象访问；再定义纸（Paper）类和铜（Cuprum）类，它们是具体元素类，实现了父接口中的方法；最后，定义一个材料集（SetMaterial）类，它是对象结构角色，拥有保存所有元素的容器 List，并提供让访问者对象遍历容器中的所有元素的 accept（Company visitor）方法；客户类设计成窗体程序，它提供材料集（SetMaterial）对象供访问者（Company）对象访问，实现了 ItemListener 接口，处理用户的事件请求。图 2 所示是其结构图。</p><h2 id="模式的应用场景-2"><a href="#模式的应用场景-2" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>通常在以下情况可以考虑使用访问者（Visitor）模式。</p><ol><li>对象结构相对稳定，但其操作算法经常变化的程序。</li><li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li><li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li></ol><h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><p>备忘录模式是一种对象行为型模式，其主要优点如下。</p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p><h2 id="模式的结构与实现-3"><a href="#模式的结构与实现-3" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类，现在我们来学习其结构与实现。</p><p><strong>模式的结构</strong></p><p>备忘录模式的主要角色如下。</p><ol><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/memento_pattern_uml_diagram.jpg" alt="备忘录模式实现"></p><p><strong>模式的实现</strong></p><p>备忘录模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> memento;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MementoPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Originator or=<span class="hljs-keyword">new</span> Originator();        Caretaker cr=<span class="hljs-keyword">new</span> Caretaker();               or.setState(<span class="hljs-string">&quot;S0&quot;</span>);         System.out.println(<span class="hljs-string">&quot;初始状态:&quot;</span>+or.getState());                   cr.setMemento(or.createMemento()); <span class="hljs-comment">//保存状态      </span>        or.setState(<span class="hljs-string">&quot;S1&quot;</span>);         System.out.println(<span class="hljs-string">&quot;新的状态:&quot;</span>+or.getState());                or.restoreMemento(cr.getMemento()); <span class="hljs-comment">//恢复状态</span>        System.out.println(<span class="hljs-string">&quot;恢复状态:&quot;</span>+or.getState());    &#125;&#125;<span class="hljs-comment">//备忘录</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span></span><span class="hljs-class"></span>&#123;     <span class="hljs-keyword">private</span> String state;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span><span class="hljs-params">(String state)</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">this</span>.state=state;     &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">this</span>.state=state;     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span> state;     &#125;&#125;<span class="hljs-comment">//发起人</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span></span><span class="hljs-class"></span>&#123;     <span class="hljs-keyword">private</span> String state;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">this</span>.state=state;     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span> state;     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">createMemento</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(state);     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreMemento</span><span class="hljs-params">(Memento m)</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">this</span>.setState(m.getState());     &#125; &#125;<span class="hljs-comment">//管理者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Caretaker</span></span><span class="hljs-class"></span>&#123;     <span class="hljs-keyword">private</span> Memento memento;           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemento</span><span class="hljs-params">(Memento m)</span></span><span class="hljs-function">    </span>&#123;         memento=m;     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">getMemento</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span> memento;     &#125;&#125;</code></pre></div><h2 id="模式的应用实例-3"><a href="#模式的应用实例-3" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>利用备忘录模式设计相亲游戏。</p><p>分析：假如有西施、王昭君、貂蝉、杨玉环四大美女同你相亲，你可以选择其中一位作为你的爱人；当然，如果你对前面的选择不满意，还可以重新选择，但希望你不要太花心；这个游戏提供后悔功能，用“备忘录模式”设计比较合适。</p><p>首先，先设计一个美女（Girl）类，它是备忘录角色，提供了获取和存储美女信息的功能；然后，设计一个相亲者（You）类，它是发起人角色，它记录当 前时刻的内部状态信息（临时妻子的姓名），并提供创建备忘录和恢复备忘录数据的功能；最后，定义一个美女栈（GirlStack）类，它是管理者角色，负责对备忘录进行管理，用于保存相亲者（You）前面选过的美女信息，不过最多只能保存 4 个，提供后悔功能。</p><p>客户类设计成窗体程序，它包含美女栈（GirlStack）对象和相亲者（You）对象，它实现了 ActionListener 接口的事件处理方法 actionPerformed(ActionEvent e)，并将 4 大美女图像和相亲者（You）选择的美女图像在窗体中显示出来</p><h2 id="模式的应用场景-3"><a href="#模式的应用场景-3" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>前面学习了备忘录模式的定义与特点、结构与实现，现在来看该模式的以下应用场景。</p><ol><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li><li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li></ol><h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p><p>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。</p><p>解释器模式是一种类行为型模式，其主要优点如下。</p><ol><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ol><p>解释器模式的主要缺点如下。</p><ol><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ol><h2 id="模式的结构与实现-4"><a href="#模式的结构与实现-4" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。</p><p>1) 文法</p><p>文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。</p><div class="code-wrapper"><pre><code>〈句子〉::=〈主语〉〈谓语〉〈宾语〉〈主语〉::=〈代词〉|〈名词〉〈谓语〉::=〈动词〉〈宾语〉::=〈代词〉|〈名词〉〈代词〉你|我|他〈名词〉7大学生I筱霞I英语〈动词〉::=是|学习</code></pre></div><p><em>注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。</em></p><p>2) 句子</p><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。</p><p>3) 语法树</p><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。图 1 所示是“我是大学生”的语法树。</p><p>有了以上基础知识，现在来介绍解释器模式的结构就简单了。解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg" alt="解释器模式实现"></p><p><strong>模式的结构</strong></p><p>解释器模式包含以下主要角色。</p><ol><li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式（Terminal    Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ol><p><strong>模式的实现</strong></p><p>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//抽象表达式类</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractExpression</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">interpret</span><span class="hljs-params">(String info)</span></span>;    <span class="hljs-comment">//解释方法</span>&#125;<span class="hljs-comment">//终结符表达式类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TerminalExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractExpression</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">interpret</span><span class="hljs-params">(String info)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//对终结符表达式的处理</span>    &#125;&#125;<span class="hljs-comment">//非终结符表达式类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonterminalExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractExpression</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> AbstractExpression exp1;    <span class="hljs-keyword">private</span> AbstractExpression exp2;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">interpret</span><span class="hljs-params">(String info)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//非对终结符表达式的处理</span>    &#125;&#125;<span class="hljs-comment">//环境类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> AbstractExpression exp;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//数据初始化</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String info)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//调用相关表达式类的解释方法</span>    &#125;&#125;</code></pre></div><h2 id="模式的应用实例-4"><a href="#模式的应用实例-4" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用解释器模式设计一个“韶粵通”公交车卡的读卡器程序。</p><p>说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。</p><p>分析：本实例用“解释器模式”设计比较适合，首先设计其文法规则如下。</p><div class="code-wrapper"><pre><code>&lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;&lt;city&gt; ::= 韶关|广州&lt;person&gt; ::= 老人|妇女|儿童</code></pre></div><p>然后，根据文法规则按以下步骤设计公交车卡的读卡器程序的类图。</p><ul><li>定义一个抽象表达式（Expression）接口，它包含了解释方法 interpret(String    info)。</li><li>定义一个终结符表达式（Terminal Expression）类，它用集合（Set）类来保存满足条件的城市或人，并实现抽象表达式接口中的解释方法 interpret(Stringinfo)，用来判断被分析的字符串是否是集合中的终结符。</li><li>定义一个非终结符表达式（AndExpressicm）类，它也是抽象表达式的子类，它包含满足条件的城市的终结符表达式对象和满足条件的人员的终结符表达式对象，并实现 interpret(String info) 方法，用来判断被分析的字符串是否是满足条件的城市中的满足条件的人员。</li><li>最后，定义一个环境（Context）类，它包含解释器需要的数据，完成对终结符表达式的初始化，并定义一个方法 freeRide(String info) 调用表达式对象的解释方法来对被分析的字符串进行解释。</li></ul><h2 id="模式的应用场景-4"><a href="#模式的应用场景-4" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>前面介绍了解释器模式的结构与特点，下面分析它的应用场景。</p><ul><li>当语言的文法较为简单，且执行效率不是关键问题时。</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li></ul><p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计的结构型模式</title>
    <link href="/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><blockquote><p>图片原链接：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 | 菜鸟教程 (runoob.com)</a></p><p>文字原链接：<a href="http://c.biancheng.net/view/1317.html">软件设计模式概述 (biancheng.net)</a></p></blockquote><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ol><li><strong>代理（Proxy）模式</strong>：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li><strong>适配器（Adapter）模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li><li><strong>装饰（Decorator）模式</strong>：动态地给对象增加一些职责，即增加其额外的功能。</li><li><strong>外观（Facade）模式</strong>：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ol><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>代理模式的主要优点有：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p>其主要缺点是：</p><ul><li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li><li>增加了系统的复杂度；</li></ul><h2 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h2><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>代理模式的主要角色如下。</p><ol><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20211025-proxy.svg" alt="代理模式实现"></p><p><strong>模式的实现</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> proxy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Proxy proxy=<span class="hljs-keyword">new</span> Proxy();        proxy.Request();    &#125;&#125;<span class="hljs-comment">//抽象主题</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//真实主题</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;访问真实主题方法...&quot;</span>);    &#125;&#125;<span class="hljs-comment">//代理</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> RealSubject realSubject;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> (realSubject==<span class="hljs-keyword">null</span>)        &#123;            realSubject=<span class="hljs-keyword">new</span> RealSubject();        &#125;        preRequest();        realSubject.Request();        postRequest();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preRequest</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;访问真实主题之前的预处理。&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postRequest</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;访问真实主题之后的后续处理。&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="代理模式的应用实例"><a href="#代理模式的应用实例" class="headerlink" title="代理模式的应用实例"></a>代理模式的应用实例</h2><p>韶关“天街e角”公司是一家婺源特产公司的代理公司，用代理模式实现。</p><p>分析：本实例中的“婺源特产公司”经营许多婺源特产，它是真实主题，提供了显示特产的 display() 方法，可以用窗体程序实现。而韶关“天街e角”公司是婺源特产公司特产的代理，通过调用婺源特产公司的 display() 方法显示代理产品，当然它可以增加一些额外的处理，如包裝或加价等。客户可通过“天街e角”代理公司间接访问“婺源特产公司”的产品</p><h2 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h2><p>前面分析了代理模式的结构与特点，现在来分析以下的应用场景。</p><ul><li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li><li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li><li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li><li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li><li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li></ul><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>该模式的主要优点如下。</p><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p><h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</p><p><strong>模式的结构</strong></p><p>适配器模式（Adapter）包含以下主要角色。</p><ol><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210223-adapter.png" alt="适配器模式实现"></p><p><strong>模式的实现</strong></p><p>(1) 类适配器模式的代码如下。</p><div class="code-wrapper"><pre><code>package adapter;//目标接口interface Target&#123;    public void request();&#125;//适配者接口class Adaptee&#123;    public void specificRequest()    &#123;               System.out.println(&quot;适配者中的业务代码被调用！&quot;);    &#125;&#125;//类适配器类class ClassAdapter extends Adaptee implements Target&#123;    public void request()    &#123;        specificRequest();    &#125;&#125;//客户端代码public class ClassAdapterTest&#123;    public static void main(String[] args)    &#123;        System.out.println(&quot;类适配器模式测试：&quot;);        Target target = new ClassAdapter();        target.request();    &#125;&#125;</code></pre></div><p>(2)对象适配器模式的代码如下。</p><div class="code-wrapper"><pre><code>package adapter;//对象适配器类class ObjectAdapter implements Target&#123;    private Adaptee adaptee;    public ObjectAdapter(Adaptee adaptee)    &#123;        this.adaptee=adaptee;    &#125;    public void request()    &#123;        adaptee.specificRequest();    &#125;&#125;//客户端代码public class ObjectAdapterTest&#123;    public static void main(String[] args)    &#123;        System.out.println(&quot;对象适配器模式测试：&quot;);        Adaptee adaptee = new Adaptee();        Target target = new ObjectAdapter(adaptee);        target.request();    &#125;&#125;</code></pre></div><h2 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>【例1】用适配器模式（Adapter）模拟新能源汽车的发动机。</p><p>分析：新能源汽车的发动机有电能发动机（Electric Motor）和光能发动机（Optical Motor）等，各种发动机的驱动方法不同，例如，电能发动机的驱动方法 electricDrive() 是用电能驱动，而光能发动机的驱动方法 opticalDrive() 是用光能驱动，它们是适配器模式中被访问的适配者。</p><p>客户端希望用统一的发动机驱动方法 drive() 访问这两种发动机，所以必须定义一个统一的目标接口 Motor，然后再定义电能适配器（Electric Adapter）和光能适配器（Optical Adapter）去适配这两种发动机。</p><h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>适配器模式（Adapter）通常适用于以下场景。</p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>桥接（Bridge）模式的优点是：</p><ul><li>由于抽象与实现分离，所以扩展能力强；</li><li>其实现细节对客户透明。</li></ul><p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p><h2 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h2><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p><p><strong>模式的结构</strong></p><p>桥接（Bridge）模式包含以下主要角色。</p><ol><li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20201015-bridge.svg" alt="桥接模式实现"></p><p><strong>模式的实现</strong></p><p>桥接模式的代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bridge;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Implementor imple=<span class="hljs-keyword">new</span> ConcreteImplementorA();        Abstraction abs=<span class="hljs-keyword">new</span> RefinedAbstraction(imple);        abs.Operation();    &#125;&#125;<span class="hljs-comment">//实现化角色</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Implementor</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OperationImpl</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体实现化角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementorA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Implementor</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OperationImpl</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span> );    &#125;&#125;<span class="hljs-comment">//抽象化角色</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abstraction</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">protected</span> Implementor imple;   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Abstraction</span><span class="hljs-params">(Implementor imple)</span></span><span class="hljs-function">   </span>&#123;       <span class="hljs-keyword">this</span>.imple=imple;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span><span class="hljs-params">()</span></span>;   &#125;<span class="hljs-comment">//扩展抽象化角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Abstraction</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">RefinedAbstraction</span><span class="hljs-params">(Implementor imple)</span></span><span class="hljs-function">   </span>&#123;       <span class="hljs-keyword">super</span>(imple);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;       System.out.println(<span class="hljs-string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span> );       imple.OperationImpl();   &#125;&#125;</code></pre></div><h2 id="桥接模式的应用实例"><a href="#桥接模式的应用实例" class="headerlink" title="桥接模式的应用实例"></a>桥接模式的应用实例</h2><p>【例1】用桥接（Bridge）模式模拟女士皮包的选购。</p><p>分析：女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。</p><p>本实例按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）。可以按两个维度定义为颜色类和包类。</p><p>颜色类（Color）是一个维度，定义为实现化角色，它有两个具体实现化角色：黄色和红色，通过 getColor() 方法可以选择颜色；包类（Bag）是另一个维度，定义为抽象化角色，它有两个扩展抽象化角色：挎包和钱包，它包含了颜色类对象，通过 getName() 方法可以选择相关颜色的挎包和钱包。</p><h2 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h2><p>桥接模式通常适用于以下场景。</p><ol><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li></ol><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p><p>装饰（Decorator）模式的主要优点有：</p><ul><li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li><li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li></ul><p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p><h2 id="装饰模式的结构与实现"><a href="#装饰模式的结构与实现" class="headerlink" title="装饰模式的结构与实现"></a>装饰模式的结构与实现</h2><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>装饰模式主要包含以下角色。</p><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210420-decorator-1-decorator-decorator.svg" alt="装饰器模式实现"></p><p><strong>模式的实现</strong></p><p>装饰模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> decorator;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Component p=<span class="hljs-keyword">new</span> ConcreteComponent();        p.operation();        System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);        Component d=<span class="hljs-keyword">new</span> ConcreteDecorator(p);        d.operation();    &#125;&#125;<span class="hljs-comment">//抽象构件角色</span><span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">Component</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体构件角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteComponent</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;创建具体构件角色&quot;</span>);           &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;调用具体构件角色的方法operation()&quot;</span>);               &#125;&#125;<span class="hljs-comment">//抽象装饰角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Component component;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Component component)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.component=component;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        component.operation();    &#125;&#125;<span class="hljs-comment">//具体装饰角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteDecorator</span><span class="hljs-params">(Component component)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">super</span>(component);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">super</span>.operation();        addedFunction();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addedFunction</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);               &#125;&#125;</code></pre></div><h2 id="装饰模式的应用实例"><a href="#装饰模式的应用实例" class="headerlink" title="装饰模式的应用实例"></a>装饰模式的应用实例</h2><p>用装饰模式实现游戏角色“莫莉卡·安斯兰”的变身。</p><p>分析：在《恶魔战士》中，游戏角色“莫莉卡·安斯兰”的原身是一个可爱少女，但当她变身时，会变成头顶及背部延伸出蝙蝠状飞翼的女妖，当然她还可以变为穿着漂亮外衣的少女。这些都可用装饰模式来实现，在本实例中的“莫莉卡”原身有 setImage(String t) 方法决定其显示方式，而其 变身“蝙蝠状女妖”和“着装少女”可以用 setChanger() 方法来改变其外观，原身与变身后的效果用 display() 方法来显示</p><h2 id="装饰模式的应用场景"><a href="#装饰模式的应用场景" class="headerlink" title="装饰模式的应用场景"></a>装饰模式的应用场景</h2><p>前面讲解了关于装饰模式的结构与特点，下面介绍其适用的应用场景，装饰模式通常在以下几种情况使用。</p><ul><li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li><li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。</li><li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li></ul><p>装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p><p>下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：</p><div class="code-wrapper"><pre><code class="hljs java">BufferedReader in=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;filename.txtn));</span><span class="hljs-string">String s=in.readLine();</span></code></pre></div><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p><ol><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ol><p>外观（Facade）模式的主要缺点如下。</p><ol><li>不能很好地限制客户使用子系统类。</li><li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ol><h2 id="外观模式的结构与实现"><a href="#外观模式的结构与实现" class="headerlink" title="外观模式的结构与实现"></a>外观模式的结构与实现</h2><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>外观（Facade）模式包含以下主要角色。</p><ol><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li><li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20201015-facade.svg" alt="外观模式实现"></p><p><strong>模式的实现</strong></p><p>外观模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> facade;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FacadePattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Facade f=<span class="hljs-keyword">new</span> Facade();        f.method();    &#125;&#125;<span class="hljs-comment">//外观角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> SubSystem01 obj1=<span class="hljs-keyword">new</span> SubSystem01();    <span class="hljs-keyword">private</span> SubSystem02 obj2=<span class="hljs-keyword">new</span> SubSystem02();    <span class="hljs-keyword">private</span> SubSystem03 obj3=<span class="hljs-keyword">new</span> SubSystem03();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        obj1.method1();        obj2.method2();        obj3.method3();    &#125;&#125;<span class="hljs-comment">//子系统角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem01</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;子系统01的method1()被调用！&quot;</span>);    &#125;   &#125;<span class="hljs-comment">//子系统角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem02</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;子系统02的method2()被调用！&quot;</span>);    &#125;   &#125;<span class="hljs-comment">//子系统角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem03</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;子系统03的method3()被调用！&quot;</span>);    &#125;   &#125;</code></pre></div><h2 id="外观模式的应用实例"><a href="#外观模式的应用实例" class="headerlink" title="外观模式的应用实例"></a>外观模式的应用实例</h2><p>用“外观模式”设计一个婺源特产的选购界面。</p><p>分析：本实例的外观角色 WySpecialty 是 JPanel 的子类，它拥有 8 个子系统角色 Specialty1~Specialty8，它们是图标类（ImageIcon）的子类对象，用来保存该婺源特产的图标（点此下载要显示的婺源特产的图片）。</p><p>外观类（WySpecialty）用 JTree 组件来管理婺源特产的名称，并定义一个事件处理方法 valueClianged(TreeSelectionEvent e)，当用户从树中选择特产时，该特产的图标对象保存在标签（JLabd）对象中。</p><h2 id="外观模式的应用场景"><a href="#外观模式的应用场景" class="headerlink" title="外观模式的应用场景"></a>外观模式的应用场景</h2><p>通常在以下情况下可以考虑使用外观模式。</p><ol><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ol><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p><p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><p>其主要缺点是：</p><ol><li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li><li>读取享元模式的外部状态会使得运行时间稍微变长。</li></ol><h2 id="享元模式的结构与实现"><a href="#享元模式的结构与实现" class="headerlink" title="享元模式的结构与实现"></a>享元模式的结构与实现</h2><p>享元模式中存在以下两种状态：</p><ol><li>内部状态，即不会随着环境的改变而改变的可共享部分；</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</li></ol><p><strong>模式的结构</strong></p><p>享元模式的主要角色有如下。</p><ol><li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li><li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li><li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li><li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20201015-fiyweight.svg" alt="享元模式实现"></p><p><strong>模式的实现</strong></p><p>享元模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> flyweight;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        FlyweightFactory factory=<span class="hljs-keyword">new</span> FlyweightFactory();        Flyweight f01=factory.getFlyweight(<span class="hljs-string">&quot;a&quot;</span>);        Flyweight f02=factory.getFlyweight(<span class="hljs-string">&quot;a&quot;</span>);        Flyweight f03=factory.getFlyweight(<span class="hljs-string">&quot;a&quot;</span>);        Flyweight f11=factory.getFlyweight(<span class="hljs-string">&quot;b&quot;</span>);        Flyweight f12=factory.getFlyweight(<span class="hljs-string">&quot;b&quot;</span>);               f01.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第1次调用a。&quot;</span>));               f02.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第2次调用a。&quot;</span>));               f03.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第3次调用a。&quot;</span>));               f11.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第1次调用b。&quot;</span>));               f12.operation(<span class="hljs-keyword">new</span> UnsharedConcreteFlyweight(<span class="hljs-string">&quot;第2次调用b。&quot;</span>));    &#125;&#125;<span class="hljs-comment">//非享元角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharedConcreteFlyweight</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> String info;    UnsharedConcreteFlyweight(String info)    &#123;        <span class="hljs-keyword">this</span>.info=info;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> info;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(String info)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.info=info;    &#125;&#125;<span class="hljs-comment">//抽象享元角色</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyweight</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(UnsharedConcreteFlyweight state)</span></span>;&#125;<span class="hljs-comment">//具体享元角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyweight</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> String key;    ConcreteFlyweight(String key)    &#123;        <span class="hljs-keyword">this</span>.key=key;        System.out.println(<span class="hljs-string">&quot;具体享元&quot;</span>+key+<span class="hljs-string">&quot;被创建！&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(UnsharedConcreteFlyweight outState)</span></span><span class="hljs-function">    </span>&#123;        System.out.print(<span class="hljs-string">&quot;具体享元&quot;</span>+key+<span class="hljs-string">&quot;被调用，&quot;</span>);        System.out.println(<span class="hljs-string">&quot;非享元信息是:&quot;</span>+outState.getInfo());    &#125;&#125;<span class="hljs-comment">//享元工厂角色</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights=<span class="hljs-keyword">new</span> HashMap&lt;String, Flyweight&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">getFlyweight</span><span class="hljs-params">(String key)</span></span><span class="hljs-function">    </span>&#123;        Flyweight flyweight=(Flyweight)flyweights.get(key);        <span class="hljs-keyword">if</span>(flyweight!=<span class="hljs-keyword">null</span>)        &#123;            System.out.println(<span class="hljs-string">&quot;具体享元&quot;</span>+key+<span class="hljs-string">&quot;已经存在，被成功获取！&quot;</span>);        &#125;        <span class="hljs-keyword">else</span>        &#123;            flyweight=<span class="hljs-keyword">new</span> ConcreteFlyweight(key);            flyweights.put(key, flyweight);        &#125;        <span class="hljs-keyword">return</span> flyweight;    &#125;&#125;</code></pre></div><h2 id="享元模式的应用实例"><a href="#享元模式的应用实例" class="headerlink" title="享元模式的应用实例"></a>享元模式的应用实例</h2><p>享元模式在五子棋游戏中的应用。</p><p>分析：五子棋同围棋一样，包含多个“黑”或“白”颜色的棋子，所以用享元模式比较好。</p><p>本实例中的棋子（ChessPieces）类是抽象享元角色，它包含了一个落子的 DownPieces(Graphics g,Point pt) 方法；白子（WhitePieces）和黑子（BlackPieces）类是具体享元角色，它实现了落子方法；Point 是非享元角色，它指定了落子的位置；WeiqiFactory 是享元工厂角色，它通过 ArrayList 来管理棋子，并且提供了获取白子或者黑子的 getChessPieces(String type) 方法；客户类（Chessboard）利用 Graphics 组件在框架窗体中绘制一个棋盘，并实现 mouseClicked(MouseEvent e) 事件处理方法，该方法根据用户的选择从享元工厂中获取白子或者黑子并落在棋盘上。</p><h2 id="享元模式的应用场景"><a href="#享元模式的应用场景" class="headerlink" title="享元模式的应用场景"></a>享元模式的应用场景</h2><p>前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。</p><ol><li>系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</li><li>大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</li><li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</li></ol><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p><p>组合模式的主要优点有：</p><ol><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li></ol><p>其主要缺点是：</p><ol><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li><li>不容易限制容器中的构件；</li><li>不容易用继承的方法来增加构件的新功能；</li></ol><h2 id="组合模式的结构与实现"><a href="#组合模式的结构与实现" class="headerlink" title="组合模式的结构与实现"></a>组合模式的结构与实现</h2><p>组合模式的结构不是很复杂，下面对它的结构和实现进行分析。</p><p><strong>模式的结构</strong></p><p>组合模式包含以下主要角色。</p><ol><li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li><li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li><li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li></ol><p>组合模式分为透明式的组合模式和安全式的组合模式。</p><p>(1) 透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</p><p>(2) 安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210817-composite-composite.svg" alt="组合模式实现"></p><p><strong>模式的实现</strong></p><p>假如要访问集合 c0={leaf1,{leaf2,leaf3}} 中的元素</p><p>下面给出透明式的组合模式的实现代码，与安全式的组合模式的实现代码类似，只要对其做简单修改就可以了。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> composite;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositePattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Component c0=<span class="hljs-keyword">new</span> Composite();         Component c1=<span class="hljs-keyword">new</span> Composite();         Component leaf1=<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;1&quot;</span>);         Component leaf2=<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;2&quot;</span>);         Component leaf3=<span class="hljs-keyword">new</span> Leaf(<span class="hljs-string">&quot;3&quot;</span>);                  c0.add(leaf1);         c0.add(c1);        c1.add(leaf2);         c1.add(leaf3);                  c0.operation();     &#125;&#125;<span class="hljs-comment">//抽象构件</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Component</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//树叶构件</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Leaf</span><span class="hljs-params">(String name)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.name=name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span></span>&#123; &#125;               <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span></span>&#123; &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;树叶&quot;</span>+name+<span class="hljs-string">&quot;：被访问！&quot;</span>);     &#125;&#125;<span class="hljs-comment">//树枝构件</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; children=<span class="hljs-keyword">new</span> ArrayList&lt;Component&gt;();       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span></span><span class="hljs-function">    </span>&#123;        children.add(c);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span></span><span class="hljs-function">    </span>&#123;        children.remove(c);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> children.get(i);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(Object obj:children)        &#123;            ((Component)obj).operation();        &#125;    &#125;    &#125;</code></pre></div><h2 id="组合模式的应用实例"><a href="#组合模式的应用实例" class="headerlink" title="组合模式的应用实例"></a>组合模式的应用实例</h2><p>用组合模式实现当用户在商店购物后，显示其所选商品信息，并计算所选商品总价的功能。</p><p>说明：假如李先生到韶关“天街e角”生活用品店购物，用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。</p><p>最后“大袋子”中的内容有：{1 双李宁牌运动鞋（单价 198 元）、白色小袋子{2 包韶关香菇（单价 68 元）、3 包韶关红茶（单价 180 元）}、中袋子{1 个景德镇瓷器（单价 380 元）、红色小袋子{2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）}}}，现在要求编程显示李先生放在大袋子中的所有商品信息并计算要支付的总价。</p><h2 id="组合模式的应用场景"><a href="#组合模式的应用场景" class="headerlink" title="组合模式的应用场景"></a>组合模式的应用场景</h2><p>前面分析了组合模式的结构与特点，下面分析它适用的以下应用场景。</p><ol><li>在需要表示一个对象整体与部分的层次结构的场合。</li><li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计的SOLID原则</title>
    <link href="/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84SOLID%E5%8E%9F%E5%88%99/"/>
    <url>/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84SOLID%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><blockquote><p>源自：<a href="https://zhuanlan.zhihu.com/p/320494053">SOLID设计原则 - 知乎 (zhihu.com)</a></p></blockquote><p><strong>SOLID</strong> 是面向对象设计五大重要原则的首字母缩写，当我们设计类和模块时，遵守 SOLID 原则就如同它的名字一样：(solid，<strong>可靠的</strong>)，可以让软件更加稳定、灵活和健壮。</p><p>分别为：</p><p>S：SRP（Single Responsibility Principle）单一职责原则</p><p>O：OCP（Open Closed Principle）开闭原则</p><p>L：LSP（Liskov Substitution Principle）里氏替换原则</p><p>I：ISP（Interface Segregation Principle）接口隔离原则</p><p>D：DIP（Dependence Inversion Principle）依赖倒置原则</p><h1 id="SRP（单一职责原则）"><a href="#SRP（单一职责原则）" class="headerlink" title="SRP（单一职责原则）"></a>SRP（单一职责原则）</h1><p><strong>一个类或者一个模块只做一件事</strong>。让一个类或者一个模块专注于单一的功能，减少功能之间的耦合程度。这样做在需要修改某个功能时，就不会影响到其他的功能。</p><p><img src="../../image/image-20220613162414168.png" alt=""></p><h1 id="OCP（开闭原则）"><a href="#OCP（开闭原则）" class="headerlink" title="OCP（开闭原则）"></a>OCP（开闭原则）</h1><p><strong>对扩展开放，对修改关闭</strong>。一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。</p><p><img src="../../image/image-20220613162506844.png" alt=""></p><h1 id="LSP（里氏替换原则）"><a href="#LSP（里氏替换原则）" class="headerlink" title="LSP（里氏替换原则）"></a>LSP（里氏替换原则）</h1><p>所有基类出现的地方都可以用派生类替换而不会让程序产生错误，派生类可以<strong>扩展基类的功能</strong>，但<strong>不能改变基类原有的功能</strong></p><p><img src="../../image/image-20220613162555791.png" alt=""></p><h1 id="ISP（接口隔离原则）"><a href="#ISP（接口隔离原则）" class="headerlink" title="ISP（接口隔离原则）"></a>ISP（接口隔离原则）</h1><p><strong>一个接口应该拥有尽可能少的行为</strong>，使其精简单一。对于<strong>不同的功能的模块分别使用不同接口</strong>，而不是使用同一个通用的接口。</p><p><img src="../../image/image-20220613162647744.png" alt=""></p><h1 id="DIP（依赖倒置原则）"><a href="#DIP（依赖倒置原则）" class="headerlink" title="DIP（依赖倒置原则）"></a>DIP（依赖倒置原则）</h1><p>高级模块不应该依赖低级模块，而是<strong>依赖抽象接口</strong>，通过抽象接口使用对应的低级模块。</p><p><img src="../../image/image-20220613162726208.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oracle数据库的基本应用</title>
    <link href="/my_world/content/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <url>/my_world/content/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小微机环境。它是一种高效率的、可靠性好的、适应高吞吐量的数据库方案。</p><h2 id="表空间概念"><a href="#表空间概念" class="headerlink" title="表空间概念"></a>表空间概念</h2><p>永久表空间</p><p>存储数据库中需要永久化存储的对象，比如二维表、视图、存储过程、索引。</p><p>临时表空间</p><p>存储数据库的中间执行过程，如：保存order by数据库排序，分组时产生的临时数据。操作完成后存储的内容会被自动释放。临时表空间是通用的，所的用户都使用TEMP作为临时表空间。一般只有tmp一个临时表空间，如果还需要别的临时表空间时，可以自己创建。</p><p>undo表空间</p><p>保存数据修改前的副本。存储事务所修改的旧址，即被修改之前的数据。当我们对一张表中的数据进行修改的同时会对修改之前的信息进行保存，为了对数据执行回滚、恢复、撤销的操作。</p><h3 id="Oracle在创建数据库与mysql创建数据库的区别"><a href="#Oracle在创建数据库与mysql创建数据库的区别" class="headerlink" title="Oracle在创建数据库与mysql创建数据库的区别"></a>Oracle在创建数据库与mysql创建数据库的区别</h3><p>Mysql存在数据库的概念，一个项目对应一个单独的database，为数据库创建独立的用户。</p><p>Oracle一个数据库就是一个服务，存在table space概念（表空间），一个项目对应一个单独的表空间，创建一个用户，具有表空间使用的权限。</p><h2 id="登录oracle"><a href="#登录oracle" class="headerlink" title="登录oracle"></a>登录oracle</h2><h3 id="1、运行SQLPLUS工具"><a href="#1、运行SQLPLUS工具" class="headerlink" title="1、运行SQLPLUS工具"></a>1、运行SQLPLUS工具</h3><div class="code-wrapper"><pre><code>C:\Users\wd-pc&gt;sqlplus</code></pre></div><h3 id="2、直接进入SQLPLUS命令提示符"><a href="#2、直接进入SQLPLUS命令提示符" class="headerlink" title="2、直接进入SQLPLUS命令提示符"></a>2、直接进入SQLPLUS命令提示符</h3><div class="code-wrapper"><pre><code>C:\Users\wd-pc&gt;sqlplus /nolog</code></pre></div><h3 id="3、以admin身份连接"><a href="#3、以admin身份连接" class="headerlink" title="3、以admin身份连接"></a>3、以admin身份连接</h3><div class="code-wrapper"><pre><code>C:\Users\wd-pc&gt;sqlplus / as sysdba 或SQL&gt;connect / as sysdba</code></pre></div><h3 id="4、普通用户登录"><a href="#4、普通用户登录" class="headerlink" title="4、普通用户登录"></a>4、普通用户登录</h3><div class="code-wrapper"><pre><code>C:\Users\wd-pc&gt;sqlplus scott/123456　或SQL&gt;connect scott/123456 或SQL&gt;connect scott/123456@servername</code></pre></div><h3 id="5、以管理员登录"><a href="#5、以管理员登录" class="headerlink" title="5、以管理员登录"></a>5、以管理员登录</h3><div class="code-wrapper"><pre><code>C:\Users\wd-pc&gt;sqlplus sys/123456 as sysdbaSQL&gt;connect sys/123456 as sysdba</code></pre></div><h3 id="6、切换用户"><a href="#6、切换用户" class="headerlink" title="6、切换用户"></a>6、切换用户</h3><div class="code-wrapper"><pre><code>SQL&gt;conn hr/123456注：conn同connect</code></pre></div><h3 id="7、退出"><a href="#7、退出" class="headerlink" title="7、退出"></a>7、退出</h3><div class="code-wrapper"><pre><code>exit</code></pre></div><h2 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h2><h3 id="1-创建表空间"><a href="#1-创建表空间" class="headerlink" title="1. 创建表空间"></a>1. 创建表空间</h3><p>语法：</p><div class="code-wrapper"><pre><code>CREATE TABLESPACE 表空间名DATAFILE &#39;数据文件路径&#39; SIZE 大小[AUTOEXTEND ON] [NEXT 大小][MAXSIZE 大小];</code></pre></div><p>说明：</p><div class="code-wrapper"><pre><code>[ ]里面内容可选项，数据文件路径中若包含目录需先创建SIZE 为初始表空间大小，单位为K或者MAUTOEXTEND 是否自动扩展，值为ON或OFFNEXT 为文件满了后扩展大小MAXSIZE 为文件最大大小，值为数值或UNLIMITED(表示不限大小)</code></pre></div><p>示例：</p><div class="code-wrapper"><pre><code>CREATE TABLESPACE ts_testDATAFILE &#39;D:\oracle_tablespace\ts_test.dbf&#39; SIZE 20MAUTOEXTEND ON;</code></pre></div><h3 id="2-查询表空间"><a href="#2-查询表空间" class="headerlink" title="2. 查询表空间"></a>2. 查询表空间</h3><p>示例：</p><div class="code-wrapper"><pre><code>--管理员角色查看表空间SELECT file_name, tablespace_name, bytes, autoextensibleFROM dba_data_filesWHERE tablespace_name = &#39;ts_test&#39;;</code></pre></div><h3 id="3-修改表空间"><a href="#3-修改表空间" class="headerlink" title="3. 修改表空间"></a>3. 修改表空间</h3><p>语法：</p><div class="code-wrapper"><pre><code>ALTER TABLESPACE 表空间名ADD DATAFILE &#39;文件路径&#39; SIZE 大小[AUTOEXTEND ON] [NEXT大小][MAXSIZE 大小];</code></pre></div><p>示例：</p><div class="code-wrapper"><pre><code>ALTER TABLESPACE ts_testADD DATAFILE &#39;D:\oracle_tablespace\ts_test2.dbf &#39;SIZE 5MAUTOEXTEND ON;</code></pre></div><h3 id="4-删除表空间"><a href="#4-删除表空间" class="headerlink" title="4. 删除表空间"></a>4. 删除表空间</h3><p>语法：</p><div class="code-wrapper"><pre><code>--仅删除表空间DROP TABLESPACE 表空间名;--删除表空间及数据文件DROP TABLESPACE 表空间名 INCLUDING CONTENTS AND DATAFILES;</code></pre></div><p>示例：</p><div class="code-wrapper"><pre><code>--仅删除表空间DROP TABLESPACE ts_test;--删除表空间及数据文件DROP TABLESPACE ts_test INCLUDING CONTENTS AND DATAFILES;</code></pre></div><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>用户是一个用于连接表空间的账号，oracle数据库里面的各个表需要指定的账号密码进入才能保证其身份的正确，每个用户都有它自己所属的权限，它们要被oracle管理员授予它们充当的角色才能继续使用，这些角色是oracle提供的三种标准角色（role），分为:connect/resource和dba.</p><ol><li>connect role(连接角色)</li></ol><p>临时用户，特指不需要建表的用户，通常只赋予他们connect role.</p><p>connect是使用oracle简单权限，这种权限只对其他用户的表有访问权限，包括select/insert/update和delete等。<br>拥有connect role 的用户还能够创建表、视图、序列（sequence）、簇（cluster）、同义词(synonym)、回话（session）和其他 数据的链（link)。</p><ol><li>resource role(资源角色)</li></ol><p>更可靠和正式的数据库用户可以授予resource role。</p><p>resource提供给用户另外的权限以创建他们自己的表、序列、过程(procedure)、触发器(trigger)、索引(index)和簇(cluster)。</p><ol><li>dba role(数据库管理员角色)</li></ol><p>dba role拥有所有的系统权限,包括无限制的空间限额和给其他用户授予各种权限的能力。</p><p>下面操作都在sys空间里面实现</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><div class="code-wrapper"><pre><code>create user homework identified by jiaqi123456 default tablespace homework;</code></pre></div><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><div class="code-wrapper"><pre><code>alter user user1 identified by 234556;</code></pre></div><h3 id="撤销用户"><a href="#撤销用户" class="headerlink" title="撤销用户"></a>撤销用户</h3><div class="code-wrapper"><pre><code>alter user user1;</code></pre></div><h3 id="为用户授权"><a href="#为用户授权" class="headerlink" title="为用户授权"></a>为用户授权</h3><div class="code-wrapper"><pre><code>grant connect, resource to homework;</code></pre></div><h3 id="撤销对用户赋予的权限："><a href="#撤销对用户赋予的权限：" class="headerlink" title="撤销对用户赋予的权限："></a>撤销对用户赋予的权限：</h3><div class="code-wrapper"><pre><code>revoke connect, resource from user;</code></pre></div><h2 id="表空间总结"><a href="#表空间总结" class="headerlink" title="表空间总结"></a>表空间总结</h2><p>oracle与mysql的思维模式完全不同，mysql的数据库是一个对象，而oracle的数据库是一个集合，一个容器。mysql的数据库只需要在mysql的空间里面创建一个数据库即可，而oracle需要首先创建数据库实例(集装箱),在这个实例里面由管理员创建表空间(纸箱子),添加用户(锁)和密码(钥匙)并赋予权限，完毕后便可以使用表空间进行表的操作和使用了。整个结构很复杂工整，所以oracle是大型数据库。</p><p>整个创建表空间的实例：</p><div class="code-wrapper"><pre><code>create tablespace homework datafile &#39;D:\oracle\oradata\oracle\homework.dbf&#39; size 10m;create user homework identified by jiaqi123456 default tablespace homework;grant connect, resource to homework;</code></pre></div><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h3 id="新增表"><a href="#新增表" class="headerlink" title="新增表"></a>新增表</h3><p>注意:Oracle没有这个”auto_increment”属性，所以它没法像MySQL般在表内定义自增主键。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> (　　id number(<span class="hljs-number">6</span>) <span class="hljs-keyword">primary</span> key,  <span class="hljs-comment">---主键</span>　　name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,  <span class="hljs-comment">---姓名 不为null</span>　　sex varchar2(<span class="hljs-number">6</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">check</span> ( sex <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>))  <span class="hljs-comment">---性别 默认&#x27;男&#x27;</span>);</code></pre></div><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><ol><li>修改字段名   </li></ol><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">rename</span> <span class="hljs-keyword">column</span> course <span class="hljs-keyword">to</span> newcourse;</code></pre></div><ol><li>修改字段</li></ol><div class="code-wrapper"><pre><code class="hljs crmsh">alter table <span class="hljs-keyword">user</span> <span class="hljs-title">modify</span>((age <span class="hljs-keyword">number</span>(<span class="hljs-number">8</span>));</code></pre></div><ol><li>删除字段</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> course;</code></pre></div><ol><li>添加新字段</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span>(age number(<span class="hljs-number">6</span>));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> (course varchar2(<span class="hljs-number">30</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;空&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);</code></pre></div><ol><li>修改表名</li></ol><div class="code-wrapper"><pre><code class="hljs crmsh">rename <span class="hljs-keyword">user</span> <span class="hljs-title">to</span> newuser;</code></pre></div><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> 表名；<span class="hljs-keyword">drop</span>删除所有数据，会删除表结构。</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名；<span class="hljs-keyword">truncate</span>是一次性删掉所有数据，不删除表结构。注意：如果表中有<span class="hljs-keyword">identity</span>产生的自增id列，<span class="hljs-keyword">truncate</span>后，会恢复初始值。</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名；<span class="hljs-keyword">delete</span>删除数据是一条一条的删除数据，后面可以添加<span class="hljs-keyword">where</span>条件，不删除表结构。注意：如果表中有<span class="hljs-keyword">identity</span>产生的自增id列，<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span>后仍然从上次的数开始增加。</code></pre></div><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> user_tables;       //查看当前用户拥有的表<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> all_tables;          //查看所有用户的表<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> dba_tables;       //查看所有用户的表包括系统表，此命令应该在sys系统表上运行直接输入,不需要做任何修改说明：user_tables： <span class="hljs-built_in">table_name</span>,tablespace_name,last_analyzed等 dba_tables： ower,<span class="hljs-built_in">table_name</span>,tablespace_name,last_analyzed等 all_tables： ower,<span class="hljs-built_in">table_name</span>,tablespace_name,last_analyzed等 all_objects： ower,object_name,subobject_name,object_id,created,last_ddl_time,<span class="hljs-type">timestamp</span>,status等</code></pre></div><h3 id="获取表字段"><a href="#获取表字段" class="headerlink" title="获取表字段"></a>获取表字段</h3><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> user_tab_columns <span class="hljs-keyword">where</span> <span class="hljs-built_in">Table_Name</span>=<span class="hljs-string">&#x27;TEST&#x27;</span>; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> all_tab_columns <span class="hljs-keyword">where</span> <span class="hljs-built_in">Table_Name</span>=<span class="hljs-string">&#x27;TEST&#x27;</span>; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> dba_tab_columns <span class="hljs-keyword">where</span> <span class="hljs-built_in">Table_Name</span>=<span class="hljs-string">&#x27;TEST&#x27;</span>; 此处的数据表名称应该大写</code></pre></div><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 <span class="hljs-keyword">values</span>(所有列的值);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> TEST <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">20</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名(列) <span class="hljs-keyword">values</span>(对应的值);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> TEST(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>);</code></pre></div><h3 id="删除一行数据"><a href="#删除一行数据" class="headerlink" title="删除一行数据"></a>删除一行数据</h3><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> TEST <span class="hljs-keyword">where</span> ID = <span class="hljs-string">&#x27;1&#x27;</span>;列名大写</code></pre></div><h3 id="更改一行数据"><a href="#更改一行数据" class="headerlink" title="更改一行数据"></a>更改一行数据</h3><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> TEST <span class="hljs-keyword">set</span> <span class="hljs-type">NAME</span> = <span class="hljs-string">&#x27;李四&#x27;</span> <span class="hljs-keyword">where</span> ID = <span class="hljs-string">&#x27;1&#x27;</span>;</code></pre></div><h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> TEST;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> TEST <span class="hljs-keyword">where</span> ID = <span class="hljs-string">&#x27;1&#x27;</span>;</code></pre></div><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图(view)，也称虚表, 不占用物理空间，这个也是相对概念，因为视图本身的定义语句还是要存储在数据字典里的。视图只有逻辑定义。每次使用的时候,只是重新执行SQL。</p><p>视图是从一个或多个实际表中获得的，这些表的数据存放在数据库中。那些用于产生视图的表叫做该视图的基表。一个视图也可以从另一个视图中产生。</p><h3 id="授予用户创建视图的权限"><a href="#授予用户创建视图的权限" class="headerlink" title="授予用户创建视图的权限"></a>授予用户创建视图的权限</h3><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 创建视图权限，只授权第一个是无法创建 视图的，需要三个权限都授予</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">to</span> breakfast;<span class="hljs-comment">-- 授予查询权限</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">to</span> breakfast;<span class="hljs-comment">-- 授予查询任何字典</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">dictionary</span> <span class="hljs-keyword">to</span> breakfast;此代码需要在sys中运行</code></pre></div><h3 id="创建简单视图"><a href="#创建简单视图" class="headerlink" title="创建简单视图"></a>创建简单视图</h3><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> vw_menu <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> product_id,product_name,product_price,product_num <span class="hljs-keyword">from</span> menu;</code></pre></div><h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> vw_menu <span class="hljs-keyword">where</span> product_id = <span class="hljs-string">&#x27;1&#x27;</span>;</code></pre></div><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来调用存储过程。</p><p>简单的说就是专门干一件事一段sql语句。</p><p>可以由数据库自己去调用，也可以由java程序去调用。</p><p>在oracle数据库中存储过程是procedure。</p><h3 id="为什么要写存储过程"><a href="#为什么要写存储过程" class="headerlink" title="为什么要写存储过程"></a>为什么要写存储过程</h3><ol><li>效率高</li></ol><p>存储过程编译一次后，就会存到数据库，每次调用时都直接执行。而普通的sql语句我们要保存到其他地方（例如：记事本上），都要先分析编译才会执行。所以想对而言存储过程效率更高。</p><ol><li>降低网络流量</li></ol><p>存储过程编译好会放在数据库，我们在远程调用时，不会传输大量的字符串类型的sql语句。</p><ol><li>复用性高</li></ol><p>存储过程往往是针对一个特定的功能编写的，当再需要完成这个特定的功能时，可以再次调用该存储过程。</p><ol><li>可维护性高</li></ol><p>当功能要求发生小的变化时，修改之前的存储过程比较容易，花费精力少。</p><ol><li>安全性高</li></ol><p>完成某个特定功能的存储过程一般只有特定的用户可以使用，具有使用身份限制，更安全。</p><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><div class="code-wrapper"><pre><code class="hljs cal">drop <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">Proc_menu</span>;</span></code></pre></div><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>存储过程类似一个方法,procedure 后面的是方法名，括号里面是形参，begin-end里面执行方法</p><div class="code-wrapper"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">Proc_menu</span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">--定义输入、输出参数--</span></span><span class="hljs-params"><span class="hljs-function">prod_name <span class="hljs-keyword">in</span> varchar,</span></span><span class="hljs-params"><span class="hljs-function">prod_num <span class="hljs-keyword">in</span> integer</span></span><span class="hljs-params"><span class="hljs-function">)</span></span><span class="hljs-function"><span class="hljs-title">begin</span>   </span><span class="hljs-function">    <span class="hljs-title">update</span> <span class="hljs-title">menu</span> <span class="hljs-title">set</span> <span class="hljs-title">product_name</span> = <span class="hljs-title">prod_name</span> <span class="hljs-title">where</span> <span class="hljs-title">product_id</span> = <span class="hljs-title">prod_num</span>;</span><span class="hljs-keyword">end</span>;</code></pre></div><h3 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h3><p>无形参<br><div class="code-wrapper"><pre><code class="hljs abnf">exec Proc_menu<span class="hljs-comment">;</span>begin  Proc_menu<span class="hljs-comment">;</span>end<span class="hljs-comment">;</span></code></pre></div></p><p>有形参<br><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">exec</span> Proc_menu(<span class="hljs-string">&#x27;番茄炒蛋&#x27;</span>);<span class="hljs-keyword">begin</span>  Proc_menu(<span class="hljs-string">&#x27;番茄炒蛋&#x27;</span>);<span class="hljs-keyword">end</span>;</code></pre></div></p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器的定义就是说某个条件成立的时候，触发器里面所定义的语句就会被自动的执行。因此触发器不需要人为的去调用，也不能调用。</p><p>在触发器中有一个触发事件，触发器是通过这个“触发事件”来执行的（而存储过程的调用或执行是由用户或应用程序进行的）。能够引起触发器运行的操作被称为“触发事件”，如执行DML语句（使用INSERT、UPDATE、DELETE语句对表或视图执行数据处理操作）；执行DDL语句（CREATE、ALTER、DROP语句在数据库中创建、修改、删除模式对象）；引发数据库系统事件（如系统启动或退出、产生异常错误等）；引发用户事件（如登录或退出数据库操作）。</p><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>此代码仅供参考<br><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or replace</span> <span class="hljs-keyword">trigger</span> auth_goods_money <span class="hljs-keyword">after</span> <span class="hljs-keyword">insert</span><span class="hljs-keyword">on</span> goods<span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-comment">--行级触发器</span><span class="hljs-keyword">begin</span>    <span class="hljs-keyword">update</span> goods <span class="hljs-keyword">set</span> goods.sum_money =     (<span class="hljs-keyword">select</span> menu.product_price <span class="hljs-keyword">from</span> menu <span class="hljs-keyword">where</span> menu.product_id = goods.product_id) <span class="hljs-keyword">where</span> goods.product_id = :<span class="hljs-built_in">new</span>.product_id;<span class="hljs-keyword">END</span>;</code></pre></div></p><p>行级触发器：执行(after)之后的触发器，带有for each row,加for each row是为了使用 :old 对象或者 :new 对象（一行记录），其含义如下表。</p><div class="table-container"><table><thead><tr><th>触发语句</th><th>:old</th><th>:new</th></tr></thead><tbody><tr><td>insert</td><td>所有字段都是空（null）</td><td>将要插入的数据</td></tr><tr><td>update</td><td>更新以前该行的值</td><td>更新后的值</td></tr><tr><td>delete</td><td>删除以前该行的值</td><td>所有字段都为空（null）</td></tr></tbody></table></div><p>语句级触发器：不包含有for each row的触发器</p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> auth_goods_money;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongoDB的简单应用</title>
    <link href="/my_world/content/mongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <url>/my_world/content/mongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>该文章大量文字摘自：<a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 教程 | 菜鸟教程 (runoob.com)</a></p><h1 id="mongodb中的概念"><a href="#mongodb中的概念" class="headerlink" title="mongodb中的概念"></a>mongodb中的概念</h1><ul><li>database：数据库</li><li>collection：集合，对应sql中的数据库表（table）</li><li>document：文档，对应sql中的数据（data）</li><li>field：域，对应sql中的数据列（column）</li><li>index：索引</li><li>primary key：主键,MongoDB自动将_id字段设置为主键</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>下载地址：<a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community</a></p><p>下载.msi版本，点击选择安装路径点击下一步即可</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>标准 URI 连接语法：</p><div class="code-wrapper"><pre><code class="hljs shell">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</code></pre></div><p>比如：</p><div class="code-wrapper"><pre><code class="hljs shell">mongodb://localhost:27017 # 连接到本机的27017端口的Mongodb数据库mongodb://root:1234@localhost/test # 使用用户名(root)和密码(1234)连接登录到指定数据库(test)mongodb://localhost/?safe=true # 以安全模式连接到数据库，端口不写默认27017</code></pre></div><p>问号后面的选项为：</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>replicaSet=name</td><td>验证replica set的名称。 Impliesconnect=replicaSet.</td></tr><tr><td>slaveOk=true\</td><td>false</td><td>true:在connect=direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect=replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。false: 在 connect=direct模式下，驱动会自动找寻主服务器. 在connect=replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。</td></tr><tr><td>safe=true\</td><td>false</td><td>true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).false: 在每次更新之后，驱动不会发送getLastError来确保更新成功。</td></tr><tr><td>w=n</td><td>驱动添加 { w : n } 到getLastError命令. 应用于safe=true。</td></tr><tr><td>wtimeoutMS=ms</td><td>驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe=true.</td></tr><tr><td>fsync=true\</td><td>false</td><td>true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于 safe=true.false: 驱动不会添加到getLastError命令中。</td></tr><tr><td>journal=true\</td><td>false</td><td>如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中). 应用于 safe=true</td></tr><tr><td>connectTimeoutMS=ms</td><td>可以打开连接的时间。</td></tr><tr><td>socketTimeoutMS=ms</td><td>发送和接受sockets的时间。</td></tr></tbody></table></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre><code class="hljs sql">use test</code></pre></div><p>注意：NoSQL不能像mysql一样，使用use 数据库 之后添加新的集合之后才会出现名字</p><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre><code class="hljs sql">db.dropDatabase()</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases</code></pre></div><h1 id="数据表-集合"><a href="#数据表-集合" class="headerlink" title="数据表/集合"></a>数据表/集合</h1><h2 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre><code class="hljs sql">db.createCollection(&quot;test&quot;)</code></pre></div><h2 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.drop()</code></pre></div><h2 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> tables</code></pre></div><h1 id="数据记录行-文档"><a href="#数据记录行-文档" class="headerlink" title="数据记录行/文档"></a>数据记录行/文档</h1><h2 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.insert(&#123;title: <span class="hljs-string">&#x27;MongoDB&#x27;</span>&#125;)</code></pre></div><h2 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h2><p>删除所有数据</p><div class="code-wrapper"><pre><code class="hljs sql">db.test.remove(&#123;&#125;)</code></pre></div><p>删除指定数据</p><div class="code-wrapper"><pre><code class="hljs sql">db.test.remove(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB&#x27;</span>&#125;)</code></pre></div><h2 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h2><p>查找全部</p><div class="code-wrapper"><pre><code class="hljs sql">db.test.find().pretty()</code></pre></div><p>查找指定数据<br><div class="code-wrapper"><pre><code class="hljs sql">db.test.find(&#123;&quot;by&quot;:&quot;test&quot;, &quot;title&quot;:&quot;MongoDB&quot;&#125;).pretty()</code></pre></div></p><p>等于:db.col.find({“by”:”test”}).pretty()</p><p>小于:db.col.find({“likes”:{$lt:50}}).pretty()</p><p>小于或等于:db.col.find({“likes”:{$lte:50}}).pretty()</p><p>大于:db.col.find({“likes”:{$gt:50}}).pretty()</p><p>大于或等于:db.col.find({“likes”:{$gte:50}}).pretty()</p><p>不等于:db.col.find({“likes”:{$ne:50}}).pretty()</p><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.update(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB&#x27;</span>&#125;,&#123;$<span class="hljs-keyword">set</span>:&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB&#x27;</span>&#125;&#125;)</code></pre></div><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>$type:检索集合中匹配的数据类型</p><div class="code-wrapper"><pre><code class="hljs sql">db.col.find(&#123;&quot;title&quot; : &#123;$type : <span class="hljs-string">&#x27;string&#x27;</span>&#125;&#125;)</code></pre></div><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><p>limit：读取指定数量的数据记录</p><div class="code-wrapper"><pre><code class="hljs sql">db.col.find(&#123;&#125;,&#123;&quot;title&quot;:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>&#125;).limit(<span class="hljs-number">2</span>)</code></pre></div><p>skip：跳过指定数量的数据</p><div class="code-wrapper"><pre><code class="hljs sql">db.col.find(&#123;&#125;,&#123;&quot;title&quot;:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>&#125;).limit(<span class="hljs-number">1</span>).<span class="hljs-keyword">skip</span>(<span class="hljs-number">1</span>)</code></pre></div><p>sort：数据进行排序</p><div class="code-wrapper"><pre><code class="hljs sql">db.col.find(&#123;&#125;,&#123;&quot;title&quot;:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>&#125;).sort(&#123;&quot;likes&quot;:<span class="hljs-number">-1</span>&#125;)</code></pre></div><p>“likes”是字段;1是升序，-1是降序</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.createIndex(&#123;&quot;title&quot;:<span class="hljs-number">1</span>&#125;)</code></pre></div><p>语法中”title”值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</p><h2 id="查看集合索引"><a href="#查看集合索引" class="headerlink" title="查看集合索引"></a>查看集合索引</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.getIndexes()</code></pre></div><h2 id="查看集合索引大小"><a href="#查看集合索引大小" class="headerlink" title="查看集合索引大小"></a>查看集合索引大小</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.totalIndexSize()</code></pre></div><h2 id="删除集合所有索引"><a href="#删除集合所有索引" class="headerlink" title="删除集合所有索引"></a>删除集合所有索引</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.dropIndexes()</code></pre></div><h2 id="删除集合指定索引"><a href="#删除集合指定索引" class="headerlink" title="删除集合指定索引"></a>删除集合指定索引</h2><div class="code-wrapper"><pre><code class="hljs sql">db.test.dropIndex(&quot;索引名称&quot;)</code></pre></div><h1 id="SQL转换Nosql"><a href="#SQL转换Nosql" class="headerlink" title="SQL转换Nosql"></a>SQL转换Nosql</h1><p>该章节是为了直观感受MongoDB中，调用的命令与sql对应关系。以test表为例：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<span class="hljs-keyword">DROP</span> DATABASE test;db.dropDatabase()<span class="hljs-keyword">CREATE</span> DATABASE test;use test;<span class="hljs-keyword">SHOW</span> TABLES;<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> test;db.test.drop()<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test(&#123;id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,name string&#125;);db.createCollection(&quot;test&quot;)<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test;db.test.find().pretty()<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> test;db.test.<span class="hljs-built_in">count</span>();<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;db.test.find(&#123;&quot;id&quot; : <span class="hljs-number">1</span>&#125;).pretty()<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span>;db.col.find(&#123;&quot;id&quot;:&#123;$lt:<span class="hljs-number">1</span>&#125;&#125;).pretty()<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1</span>;db.col.find(&#123;&quot;id&quot;:&#123;$lte:<span class="hljs-number">50</span>&#125;&#125;).pretty()<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;db.col.find(&#123;&quot;id&quot;:&#123;$gt:<span class="hljs-number">50</span>&#125;&#125;).pretty()<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span>;db.col.find(&#123;&quot;id&quot;:&#123;$gte:<span class="hljs-number">50</span>&#125;&#125;).pretty()<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">!=</span> <span class="hljs-number">1</span>;db.col.find(&#123;&quot;id&quot;:&#123;$ne:<span class="hljs-number">1</span>&#125;&#125;).pretty()<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test  <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%l%&#x27;</span>;db.users.find(&#123;&quot;name&quot;:<span class="hljs-operator">/</span>l<span class="hljs-operator">/</span>&#125;); <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test  <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;l%&#x27;</span>;db.users.find(&#123;&quot;name&quot;:<span class="hljs-operator">/</span><span class="hljs-operator">^</span>l<span class="hljs-operator">/</span>&#125;); <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">DESC</span><span class="hljs-operator">/</span><span class="hljs-keyword">ASC</span>;db.col.find().sort(&#123;&quot;id&quot;:<span class="hljs-number">-1</span><span class="hljs-operator">/</span><span class="hljs-number">1</span>&#125;)<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> LIMIT <span class="hljs-number">2</span>;db.test.find(&#123;&quot;id&quot; : <span class="hljs-number">1</span>&#125;).limit(<span class="hljs-number">2</span>)<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> type <span class="hljs-operator">=</span> &quot;book&quot;var map1 <span class="hljs-operator">=</span> <span class="hljs-keyword">function</span> () &#123;emit(this.type, <span class="hljs-number">1</span>)&#125;;var reduce <span class="hljs-operator">=</span> <span class="hljs-keyword">function</span>(type , count)&#123;<span class="hljs-keyword">return</span> Array.<span class="hljs-built_in">sum</span>(count)&#125;db.test.mapReduce(map1 , reduce , &#123;query:&#123;type : &quot;book&quot;&#125; , <span class="hljs-keyword">out</span>:&quot;test&quot;&#125;).find()<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test (id , name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span> , li);db.test.insert(&#123;&quot;id&quot; : <span class="hljs-number">1</span>,&quot;name&quot;: <span class="hljs-string">&#x27;li&#x27;</span>&#125;)UPDATE test <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;li&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;db.test.update(&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;li&#x27;</span>&#125;,&#123;$<span class="hljs-keyword">set</span>:&#123;<span class="hljs-string">&#x27;id&#x27;</span>:<span class="hljs-number">1</span>&#125;&#125;)<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;db.test.remove(&#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">1</span> &#125;)</code></pre></div><h1 id="链接java"><a href="#链接java" class="headerlink" title="链接java"></a>链接java</h1><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mongodb-driver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>链接到数据库</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.MongoClient;<span class="hljs-keyword">import</span> com.mongodb.client.MongoDatabase;MongoDBJDBC &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main（String args[]）&#123;      <span class="hljs-keyword">try</span>&#123;            MongoClient mongoClient =<span class="hljs-keyword">new</span> MongoClient（“ localhost”，<span class="hljs-number">27017</span>）;                <span class="hljs-comment">//连接到数据库</span>         MongoDatabase mongoDatabase = mongoClient.getDatabase（<span class="hljs-string">&quot;mysql&quot;</span>）;          System.out.println（“成功连接到数据库”）;         mongoDatabase.createCollection（<span class="hljs-string">&quot;test&quot;</span>）; System.out.println（<span class="hljs-string">&quot;集合创建成功&quot;</span>）; MongoCollection &lt;Document&gt; collection = mongoDatabase.getCollection（<span class="hljs-string">&quot;test&quot;</span>）; FindIterable&lt;Document&gt; list = collection.find();<span class="hljs-comment">//获取文档集合</span> <span class="hljs-keyword">for</span>(Document doc: list)&#123;<span class="hljs-comment">//遍历集合中的文档输出数据</span>    System.out.println(<span class="hljs-string">&quot;name:&quot;</span>+ doc.getString(<span class="hljs-string">&quot;name&quot;</span>) );    System.out.println(<span class="hljs-string">&quot;sex:&quot;</span>+ doc.getString(<span class="hljs-string">&quot;sex&quot;</span>) );    System.out.println(<span class="hljs-string">&quot;age:&quot;</span>+ doc.getDouble(<span class="hljs-string">&quot;age&quot;</span>) );<span class="hljs-comment">//默认为浮点型</span>    System.out.println(<span class="hljs-string">&quot;address:&quot;</span>+ doc.getString(<span class="hljs-string">&quot;address&quot;</span>) );    System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);&#125;Map&lt;String, Object&gt; map=<span class="hljs-keyword">new</span> HashMap();map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;铁扇公主&quot;</span>);map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>);map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">35.0</span>);map.put(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;芭蕉洞&quot;</span>);     Document doc=<span class="hljs-keyword">new</span> Document(map);       collection.insertOne(doc);<span class="hljs-comment">//插入一条记录</span>BasicDBObject bson=<span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;铁扇公主&quot;</span>);collection.deleteOne(bson);<span class="hljs-comment">//删除记录（符合条件的第一条记录）</span><span class="hljs-comment">//修改的条件</span>BasicDBObject bson= <span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;红孩儿&quot;</span>);<span class="hljs-comment">//修改后的值</span>BasicDBObject bson2 = <span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">&quot;$set&quot;</span>,<span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;南海&quot;</span>));<span class="hljs-comment">//参数1：修改条件  参数2：修改后的值</span>collection.updateOne(bson, bson2);      &#125; <span class="hljs-keyword">catch</span>（Exception e）&#123;        System.err.println（e.getClass（）。getName（）+“：” + e.getMessage（））;     &#125;   &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
      <tag>非关系型数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql的基本应用</title>
    <link href="/my_world/content/mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <url>/my_world/content/mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p><h1 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p><p>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</p><p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p><p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><p>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p><ol><li>数据以表格的形式出现</li><li>每行为各种记录名称</li><li>每列为记录名称所对应的数据域</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database</li></ol><p>数据库语言分为四大类</p><ul><li>数据定义语言(DDL)，例如：CREATE、DROP、ALTER等语句。</li><li>数据操作语言(DML)，例如：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。</li><li>数据查询语言(DQL)，例如：SELECT语句。（一般不会单独归于一类，因为只有一个语句）。</li><li>数据控制语言(DCL)，例如：GRANT、REVOKE等语句。</li></ul><p>PS：事务控制语言（TCL），例如：COMMIT、ROLLBACK等语句。</p><h1 id="Mysql简介"><a href="#Mysql简介" class="headerlink" title="Mysql简介"></a>Mysql简介</h1><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p><p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p><p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p><p>事务用来管理 insert,update,delete 语句</p><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><ul><li>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://downloads.mysql.com/archives/community/">MySQL :: Download MySQL Community Server (Archived Versions)</a></p><p>在输入栏中搜索<code>5.5.49</code>的版本下载即可（当然不限制其他版本）</p><h1 id="Mysql命令"><a href="#Mysql命令" class="headerlink" title="Mysql命令"></a>Mysql命令</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE world</code></pre></div><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE db_librarysys</code></pre></div><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><div class="code-wrapper"><pre><code class="hljs sql">use world</code></pre></div><h2 id="查找所有数据库"><a href="#查找所有数据库" class="headerlink" title="查找所有数据库"></a>查找所有数据库</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;</code></pre></div><h1 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h1><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span>(    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),    PASSWORD <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),    <span class="hljs-keyword">PRIMARY</span> KEY (`id`))</code></pre></div><h2 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span></code></pre></div><h2 id="查找所有数据表"><a href="#查找所有数据表" class="headerlink" title="查找所有数据表"></a>查找所有数据表</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;</code></pre></div><h2 id="查看当前表结构"><a href="#查看当前表结构" class="headerlink" title="查看当前表结构"></a>查看当前表结构</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> COLUMNS <span class="hljs-keyword">FROM</span> tb;</code></pre></div><p>tb为表格名字</p><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (username, password) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;1234&#x27;</span>, <span class="hljs-string">&#x27;1234&#x27;</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>单条数据<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (username, password) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;1234&#x27;</span>, <span class="hljs-string">&#x27;1234&#x27;</span>),(<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;134&#x27;</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>批量数据</code></pre></div><h2 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h2><div class="code-wrapper"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1234&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1234&#x27;</span>;</code></pre></div><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1234&#x27;</span></code></pre></div><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>where：数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。</p><p>group by:对select查询出来的结果集按照某个字段或者表达式进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。</p><p>having：用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。</p><p>执行顺序</p><p>select –&gt;where –&gt; group by–&gt; having–&gt;order by</p><h3 id="全部查询"><a href="#全部查询" class="headerlink" title="全部查询"></a>全部查询</h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span></code></pre></div><h3 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1234&#x27;</span>;</code></pre></div><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>在 where like 的条件查询中，SQL 提供了四种匹配方式。</p><ol><li>%：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</li><li>_：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</li><li>[]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</li><li><sup><a href="#fn_" id="reffn_"></a></sup> ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。<br>查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%4&#x27;</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>以<span class="hljs-number">4</span>结尾的匹配</code></pre></div><p>like 匹配/模糊匹配，会与 % 和 _ 结合使用。</p><ul><li>‘%a’：以a结尾的数据</li><li>‘a%’：以a开头的数据</li><li>‘%a%’：含有a的数据</li><li>‘_a_‘：三位且中间字母是a的</li><li>‘_a’：两位且结尾字母是a的</li><li>‘a_’：两位且开头字母是a的</li></ul><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>作用为：</p><ol><li>集合两个表中相同的元素</li><li>单个表执行多个查询</li><li>拼接多条select语句</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> city <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> usertable</code></pre></div><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> city <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">ASC</span></code></pre></div><ul><li>ASC 升序(默认)</li><li>DESC 降序</li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> city <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> name;</code></pre></div><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</p><p>JOIN 按照功能大致分为如下三类：</p><ul><li>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</li><li>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</li><li>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li></ul><p>内连接：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.name, a.age, b.username <span class="hljs-keyword">FROM</span> a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">ON</span> a.id <span class="hljs-operator">=</span> b.id</code></pre></div><p>等价于</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.name, a.age, b.username <span class="hljs-keyword">FROM</span> a, b <span class="hljs-keyword">WHERE</span> a.id <span class="hljs-operator">=</span> b.id</code></pre></div><p>外连接（左连接）：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.name, a.age, b.username <span class="hljs-keyword">FROM</span> a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">ON</span> a.id <span class="hljs-operator">=</span> b.id</code></pre></div><p>外连接（右连接）：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.name, a.age, b.username <span class="hljs-keyword">FROM</span> a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">ON</span> a.id <span class="hljs-operator">=</span> b.id</code></pre></div><h1 id="Mysql内置函数"><a href="#Mysql内置函数" class="headerlink" title="Mysql内置函数"></a>Mysql内置函数</h1><blockquote><p>源自：<a href="http://c.biancheng.net/mysql/function/">MySQL函数大全，MySQL常用函数汇总 (biancheng.net)</a></p></blockquote><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><div class="table-container"><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="http://c.biancheng.net/mysql/max.html">MAX</a></td><td>查询指定列的最大值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/min.html">MIN</a></td><td>查询指定列的最小值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/count.html">COUNT</a></td><td>统计查询结果的行数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/sum.html">SUM</a></td><td>求和，返回指定列的总和</td></tr><tr><td><a href="http://c.biancheng.net/mysql/avg.html">AVG</a></td><td>求平均值，返回指定列数据的平均值</td></tr></tbody></table></div><h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><div class="table-container"><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td><a href="http://c.biancheng.net/mysql/curdate_current_date.html">CURDATE 和 CURRENT_DATE</a></td><td>两个函数作用相同，返回当前系统的日期值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/curtime_current_time.html">CURTIME 和 CURRENT_TIME</a></td><td>两个函数作用相同，返回当前系统的时间值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/now_sysdate.html">NOW 和 SYSDATE</a></td><td>两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/unix_timestamp.html">UNIX_TIMESTAMP</a></td><td>获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/from_unixtime.html">FROM_UNIXTIME</a></td><td>将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/month.html">MONTH</a></td><td>获取指定日期中的月份</td></tr><tr><td><a href="http://c.biancheng.net/mysql/monthname.html">MONTHNAME</a></td><td>获取指定日期中的月份英文名称</td></tr><tr><td><a href="http://c.biancheng.net/mysql/dayname.html">DAYNAME</a></td><td>获取指定曰期对应的星期几的英文名称</td></tr><tr><td><a href="http://c.biancheng.net/mysql/dayofweek.html">DAYOFWEEK</a></td><td>获取指定日期对应的一周的索引位置值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/week.html">WEEK</a></td><td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td><a href="http://c.biancheng.net/mysql/dayofyear.html">DAYOFYEAR</a></td><td>获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td><a href="http://c.biancheng.net/mysql/dayofmonth.html">DAYOFMONTH</a></td><td>获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td><a href="http://c.biancheng.net/mysql/year.html">YEAR</a></td><td>获取年份，返回值范围是 1970〜2069</td></tr><tr><td><a href="http://c.biancheng.net/mysql/time_to_sec.html">TIME_TO_SEC</a></td><td>将时间参数转换为秒数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/sec_to_time.html">SEC_TO_TIME</a></td><td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/date_add_adddate.html">DATE_ADD 和 ADDDATE</a></td><td>两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td><a href="http://c.biancheng.net/mysql/date_sub_subdate.html">DATE_SUB 和 SUBDATE</a></td><td>两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td><a href="http://c.biancheng.net/mysql/addtime.html">ADDTIME</a></td><td>时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td><a href="http://c.biancheng.net/mysql/subtime.html">SUBTIME</a></td><td>时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td><a href="http://c.biancheng.net/mysql/datediff.html">DATEDIFF</a></td><td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/date_format.html">DATE_FORMAT</a></td><td>格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/weekday.html">WEEKDAY</a></td><td>获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table></div><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><div class="table-container"><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td><a href="http://c.biancheng.net/mysql/length.html">LENGTH</a></td><td>计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td><a href="http://c.biancheng.net/mysql/concat.html">CONCAT</a></td><td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td><a href="http://c.biancheng.net/mysql/insert.html">INSERT</a></td><td>替换字符串函数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/lower.html">LOWER</a></td><td>将字符串中的字母转换为小写</td></tr><tr><td><a href="http://c.biancheng.net/mysql/upper.html">UPPER</a></td><td>将字符串中的字母转换为大写</td></tr><tr><td><a href="http://c.biancheng.net/mysql/left.html">LEFT</a></td><td>从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td><a href="http://c.biancheng.net/mysql/right.html">RIGHT</a></td><td>从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td><a href="http://c.biancheng.net/mysql/trim.html">TRIM</a></td><td>删除字符串左右两侧的空格</td></tr><tr><td><a href="http://c.biancheng.net/mysql/replace.html">REPLACE</a></td><td>字符串替换函数，返回替换后的新字符串</td></tr><tr><td><a href="http://c.biancheng.net/mysql/substring.html">SUBSTRING</a></td><td>截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td><a href="http://c.biancheng.net/mysql/reverse.html">REVERSE</a></td><td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table></div><h2 id="数值型函数"><a href="#数值型函数" class="headerlink" title="数值型函数"></a>数值型函数</h2><div class="table-container"><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td><a href="http://c.biancheng.net/mysql/abc.html">ABS</a></td><td>求绝对值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/sqrt.html">SQRT</a></td><td>求二次方根</td></tr><tr><td><a href="http://c.biancheng.net/mysql/mod.html">MOD</a></td><td>求余数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/ceil_celing.html">CEIL 和 CEILING</a></td><td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td><a href="http://c.biancheng.net/mysql/floor.html">FLOOR</a></td><td>向下取整，返回值转化为一个BIGINT</td></tr><tr><td><a href="http://c.biancheng.net/mysql/rand.html">RAND</a></td><td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td><a href="http://c.biancheng.net/mysql/round.html">ROUND</a></td><td>对所传参数进行四舍五入</td></tr><tr><td><a href="http://c.biancheng.net/mysql/sign.html">SIGN</a></td><td>返回参数的符号</td></tr><tr><td><a href="http://c.biancheng.net/mysql/pow_power.html">POW 和 POWER</a></td><td>两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/sin.html">SIN</a></td><td>求正弦值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/asin.html">ASIN</a></td><td>求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/cos.html">COS</a></td><td>求余弦值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/acos.html">ACOS</a></td><td>求反余弦值，与函数 COS 互为反函数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/tan.html">TAN</a></td><td>求正切值</td></tr><tr><td><a href="http://c.biancheng.net/mysql/atan.html">ATAN</a></td><td>求反正切值，与函数 TAN 互为反函数</td></tr><tr><td><a href="http://c.biancheng.net/mysql/cot.html">COT</a></td><td>求余切值</td></tr></tbody></table></div><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><div class="table-container"><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="http://c.biancheng.net/mysql/if.html">IF</a></td><td>判断，流程控制</td></tr><tr><td><a href="http://c.biancheng.net/mysql/ifnull.html">IFNULL</a></td><td>判断是否为空</td></tr><tr><td><a href="http://c.biancheng.net/mysql/case.html">CASE</a></td><td>搜索语句</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程的微妙理解</title>
    <link href="/my_world/content/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BE%AE%E5%A6%99%E7%90%86%E8%A7%A3/"/>
    <url>/my_world/content/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BE%AE%E5%A6%99%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。</p><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。</p><p>在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。</p><p>使用多线程的理由之一是和进程相比，它是一种非常花销小，切换快，更”节俭”的多任务操作方式。</p><h2 id="线程与同步异步的关系"><a href="#线程与同步异步的关系" class="headerlink" title="线程与同步异步的关系"></a>线程与同步异步的关系</h2><ol><li>同步（sync）：</li></ol><p>发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p><ol><li>异步（async）：</li></ol><p>与同步相对，调用在发出之后，这个调用就直接返回了，所以没有返回结果。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p><p>对于通知调用者的三种方式，具体如下：</p><p>状态：即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。</p><p>通知：当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</p><p>回调：与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</p><div class="code-wrapper"><pre><code class="hljs markdown">打比方:<span class="hljs-bullet">1.</span> 单线程同步：甲先搬了一块砖，回头又搬了另一块砖<span class="hljs-bullet">2.</span> 多线程同步：甲先搬了一块砖，乙又搬了一块砖（要用到线程间的同步机制）<span class="hljs-bullet">3.</span> 多线程异步：甲乙同时各搬了一块砖</code></pre></div><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p><strong>进程</strong></p><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p><strong>线程</strong></p><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p><strong>根本区别：</strong> 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p><strong>资源开销：</strong> 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p><strong>包含关系：</strong> 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p><strong>内存分配：</strong> 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p><strong>影响关系：</strong> 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p><strong>执行过程：</strong> 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p><h2 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a><span id="线程的生命周期">线程的状态转换</span></h2><blockquote><p>生命周期图</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt="image"></p><ol><li>新建状态（New）：新创建了一个线程对象。</li><li>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li><li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</li></ol><ul><li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li></ul><ol><li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ol><blockquote><p>状态装换图</p></blockquote><p><img src="https://img-blog.csdn.net/20150309140927553" alt="image"></p><h2 id="守护线程和用户线程之间的区别"><a href="#守护线程和用户线程之间的区别" class="headerlink" title="守护线程和用户线程之间的区别"></a>守护线程和用户线程之间的区别</h2><p>java提供了俩类的线程：用户线程和守护线程(user thread and Daemon thread)。用户线程是高优先级的线程。JVM虚拟机在结束一个用户线程之前，会先等待该用户线程完成它的task。</p><p>在另一方面，守护线程是低优先级的线程，它的作用仅仅是为用户线程提供服务。正是由于守护线程是为用户线程提供服务的，仅仅在用户线程处于运行状态时才需要守护线程。另外，一旦所有的用户线程都运行完毕，那么守护线程是无法阻止JVM退出的。</p><p>这也是存在于守护线程中的无限循环不会产生问题的原因，因为包括finally 块的任何代码都不会被执行，一旦所有的用户线程结束运行之后。出于这个原因，我们不推荐使用守护线程处理I/O任务。</p><p>然而，这个规则也有例外。守护线程中那些设计糟糕的代码也能阻止JVM虚拟机退出。例如，在一个运行中的守护线程上调用Thread.join()方法会阻塞应用程序的关闭。</p><h2 id="java实现线程的方式"><a href="#java实现线程的方式" class="headerlink" title="java实现线程的方式"></a><span id="java实现线程的方式">java实现线程的方式</span></h2><ol><li><p>继承 Thread 类本身</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> ThreadDemo extends Thread &#123;   private Thread t;   private String threadName;      ThreadDemo( String <span class="hljs-type">name</span>) &#123;      threadName = <span class="hljs-type">name</span>;      <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Creating &quot; +  threadName );   &#125;      <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> run() &#123;      <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Running &quot; +  threadName );      try &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &gt; <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);            // 让线程睡眠一会            Thread.sleep(<span class="hljs-number">50</span>);         &#125;      &#125;catch (InterruptedException e) &#123;         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);      &#125;      <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);   &#125;      <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">start</span> () &#123;      <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Starting &quot; +  threadName );      <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;         t = <span class="hljs-built_in">new</span> Thread (this, threadName);         t.<span class="hljs-keyword">start</span> ();      &#125;   &#125;&#125;</code></pre></div></li><li><p>实现runnable接口</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment">* 实现Runnable接口的类</span><span class="hljs-comment">*</span><span class="hljs-comment">* @author leizhimin 2008-9-13 18:12:10</span><span class="hljs-comment">*/</span>publicclass DoSomethingimplements Runnable &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function">publicvoid <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100000000</span>; k++) ;            System.out.<span class="hljs-built_in">println</span>(name + <span class="hljs-string">&quot;: &quot;</span> + i);        &#125;    &#125;&#125;</code></pre></div></li><li><p>Callable 和 Future 创建线程</p></li></ol><h2 id="什么是线程同步"><a href="#什么是线程同步" class="headerlink" title="什么是线程同步"></a>什么是线程同步</h2><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态。java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h2 id="java实现线程同步的方式"><a href="#java实现线程同步的方式" class="headerlink" title="java实现线程同步的方式"></a>java实现线程同步的方式</h2><ol><li>同步方法</li></ol><p>即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。<br><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>&#123;&#125;注： <span class="hljs-keyword">synchronized</span>关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</code></pre></div></p><ol><li>同步代码块</li></ol><p>即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步<br><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(object)</span></span>&#123;&#125;注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</code></pre></div></p><ol><li>使用特殊域变量(volatile)实现线程同步<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span> </span>&#123;    <span class="hljs-comment">//需要同步的变量加上volatile</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> account = <span class="hljs-number">100</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAccount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> account;    &#125;    <span class="hljs-comment">//这里不再需要synchronized </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;        account += money;    &#125;&#125;a.<span class="hljs-keyword">volatile</span>关键字为域变量的访问提供了一种免锁机制，b.使用<span class="hljs-keyword">volatile</span>修饰域相当于告诉虚拟机该域可能会被其他线程更新，c.因此每次使用该域就要重新计算，而不是使用寄存器中的值d.<span class="hljs-keyword">volatile</span>不会提供任何原子操作，它也不能用来修饰<span class="hljs-keyword">final</span>类型的变量多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用<span class="hljs-keyword">final</span>域，有锁保护的域和<span class="hljs-keyword">volatile</span>域可以避免非同步的问题。</code></pre></div></li><li>使用重入锁实现线程同步<div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> account = <span class="hljs-number">100</span>;    <span class="hljs-comment">//需要声明这个锁</span>    <span class="hljs-keyword">private</span> Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getAccount</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> account;    &#125;    <span class="hljs-comment">//这里不再需要synchronized </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> money</span>)</span> &#123;        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();        <span class="hljs-keyword">try</span>&#123;            account += money;        &#125;<span class="hljs-keyword">finally</span>&#123;            <span class="hljs-keyword">lock</span>.unlock();        &#125;    &#125;｝注：关于Lock对象和synchronized关键字的选择：a.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在<span class="hljs-keyword">finally</span>代码释放锁</code></pre></div></li></ol><h2 id="什么是线程锁"><a href="#什么是线程锁" class="headerlink" title="什么是线程锁"></a>什么是线程锁</h2><p>多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。</p><h2 id="多线程锁机制的实现方式"><a href="#多线程锁机制的实现方式" class="headerlink" title="多线程锁机制的实现方式"></a>多线程锁机制的实现方式</h2><p>Java提供了多种多线程锁机制的实现方式，常见的有：</p><ul><li>synchronized</li><li>ReentrantLock</li><li>Semaphore</li><li>AtomicInteger</li></ul><p><strong>1. synchronized</strong></p><p>在Java中synchronized关键字被常用于维护数据一致性。</p><p>synchronized机制是给共享资源上锁，只有拿到锁的线程才可以访问共享资源，这样就可以强制使得对共享资源的访问都是顺序的。</p><p>Java开发人员都认识synchronized，使用它来实现多线程的同步操作是非常简单的，只要在需要同步的对方的方法、类或代码块中加入该关键字，它能够保证在同一个时刻最多只有一个线程执行同一个对象的同步代码，可保证修饰的代码在执行过程中不会被其他线程干扰。使用synchronized修饰的代码具有原子性和可见性，在需要进程同步的程序中使用的频率非常高，可以满足一般的进程同步要求。<br><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">synchronized</span> (obj) &#123;&#125;</code></pre></div></p><p><strong>2. ReentrantLock</strong></p><p>可重入锁，顾名思义，这个锁可以被线程多次重复进入进行获取操作。</p><p>ReentantLock继承接口Lock并实现了接口中定义的方法，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p><p>Lock实现的机理依赖于特殊的CPU指定，可以认为不受JVM的约束，并可以通过其他语言平台来完成底层的实现。在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准。</p><p>因此建议在高并发量情况下使用ReentrantLock。</p><p>ReentrantLock引入两个概念：公平锁与非公平锁。</p><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁。反之，JVM按随机、就近原则分配锁的机制则称为不公平锁。</p><p>ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。这是因为，非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><p>ReentrantLock通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock必须在finally控制块中进行解锁操作。<br><div class="code-wrapper"><pre><code class="hljs cos"><span class="hljs-keyword">Lock</span> <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock()<span class="hljs-comment">;</span><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>()<span class="hljs-comment">;</span>    <span class="hljs-comment">//…进行任务操作5 </span>&#125;finally &#123;    <span class="hljs-keyword">lock</span>.unlock()<span class="hljs-comment">;</span>&#125;</code></pre></div><br><strong>3. Semaphore</strong></p><p>上述两种锁机制类型都是“互斥锁”，互斥是进程同步关系的一种特殊情况，相当于只存在一个临界资源，因此同时最多只能给一个线程提供服务。但是，在实际复杂的多线程应用程序中，可能存在多个临界资源，这时候我们可以借助Semaphore信号量来完成多个临界资源的访问。</p><p>Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。</p><p>经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在finally代码块中完成。</p><p><strong>4.AtomicInteger</strong></p><p>首先说明，此处AtomicInteger是一系列相同类的代表之一，常见的还有AtomicLong、AtomicLong等，他们的实现原理相同，区别在与运算对象类型的不同。</p><p>我们知道，在多线程程序中，诸如++i或i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock的好几倍。</p><blockquote><p>总结</p></blockquote><p><strong>1.synchronized：</strong></p><p>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好。</p><p><strong>2.ReentrantLock:</strong></p><p>在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍，而ReentrantLock确还能维持常态。</p><p><strong>高并发量情况下使用ReentrantLock。</strong></p><p><strong>3.Atomic:</strong></p><p>和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p><p>所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。</p><h2 id="什么是死锁-产生条件"><a href="#什么是死锁-产生条件" class="headerlink" title="什么是死锁/产生条件"></a>什么是死锁/产生条件</h2><p>线程死锁是指两个或两个以上的线程互相持有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其它线程是获取不到这个锁的，而且会一直死等下去，因此这便造成了死锁。</p><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><ul><li>互斥条件：一个资源，或者说一个锁只能被一个线程所占用，当一个线程首先获取到这个锁之后，在该线程释放这个锁之前，其它线程均是无法获取到这个锁的。</li><li>占有且等待：一个线程已经获取到一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁。</li><li>不可剥夺条件：任何一个线程都无法强制获取别的线程已经占有的锁</li><li>循环等待条件：线程A拿着线程B的锁，线程B拿着线程A的锁。</li></ul><h2 id="死锁演示-避免方法"><a href="#死锁演示-避免方法" class="headerlink" title="死锁演示/避免方法"></a><span id="死锁演示/避免方法">死锁演示/避免方法</span></h2><div class="code-wrapper"><pre><code class="hljs reasonml">package com.github.excellent01;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @auther plg</span><span class="hljs-comment"> * @date 2019/5/18 12:12</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> DeadLock &#123;    <span class="hljs-keyword">private</span>  Object lock1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;    <span class="hljs-keyword">private</span>  Object lock2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;    public  void method1<span class="hljs-literal">()</span> throws InterruptedException &#123;        synchronized(lock1)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;获取到lock1,请求获取lock2....&quot;</span>);            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);            synchronized (lock2)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;获取到lock2....&quot;</span>);            &#125;        &#125;    &#125;    public  void method2<span class="hljs-literal">()</span> throws InterruptedException &#123;        synchronized(lock2)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;获取到lock2,请求获取lock1....&quot;</span>);            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);            synchronized (lock1)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;获取到lock1....&quot;</span>);            &#125;        &#125;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        DeadLock deadLock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DeadLock()</span>;        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                deadLock.method1<span class="hljs-literal">()</span>;            &#125; catch (InterruptedException e) &#123;                e.print<span class="hljs-constructor">StackTrace()</span>;            &#125;        &#125;).start<span class="hljs-literal">()</span>;        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                deadLock.method2<span class="hljs-literal">()</span>;            &#125; catch (InterruptedException e) &#123;                e.print<span class="hljs-constructor">StackTrace()</span>;            &#125;        &#125;).start<span class="hljs-literal">()</span>;    &#125;&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200610100524322.png" alt="image"></p><p>这样便造成了死锁，Thread1拿着lock1，想要lock2，Thread2拿着lock2，想要lock1.</p><h3 id="避免方法"><a href="#避免方法" class="headerlink" title="避免方法"></a>避免方法</h3><ul><li>加锁顺序：线程按照相同的顺序加锁。</li><li>加锁时限，线程获取锁的过程中限制一定的时间，如果给定时间内获取不到，就算了，别勉强自己。这需要用到Lock的一些API。</li></ul><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流的简要介绍</title>
    <link href="/my_world/content/IO%E6%B5%81%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
    <url>/my_world/content/IO%E6%B5%81%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式进行输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出</p><h2 id="什么是IO流"><a href="#什么是IO流" class="headerlink" title="什么是IO流"></a>什么是IO流</h2><p>流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式进行输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出</p><p>JAVA IO流就是JAVA程序和操作系统之间通信用的方法。</p><p><img src="https://images2015.cnblogs.com/blog/999727/201611/999727-20161109130405092-2025696523.png" alt="image"></p><h2 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a><span id="字节流和字符流的区别">字节流和字符流的区别</span></h2><p>字节流和字符流操作的本质区别只有一个：字节流是原生的操作，字符流是经过处理后的操作。</p><p>字节流在操作时不会用到缓冲区，也就是不会用到内存，文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件</p><p><img src="https://pic2.zhimg.com/v2-2fc170fd0824454a9db56b7a6070efed_r.jpg" alt="image"></p><ol><li><p>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p></li><li><p>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p></li><li><p>字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。</p></li></ol><p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p><h2 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h2><p>输入就是将数据从各种输入设备（包括文件、键盘等）中读取到内存中，输出则正好相反，是将数据写入到各种输出设备（比如文件、显示器、磁盘等）。例如键盘就是一个标准的输入设备，而显示器就是一个标准的输出设备，但是文件既可以作为输入设备，又可以作为输出设备。</p><p>数据流是 Java 进行 I/O 操作的对象，它按照不同的标准可以分为不同的类别。</p><ul><li>按照流的方向主要分为输入流和输出流两大类。</li><li>数据流按照数据单位的不同分为字节流和字符流。</li><li>按照功能可以划分为节点流和处理流。</li></ul><blockquote><p>输入流模式</p></blockquote><p><img src="http://c.biancheng.net/uploads/allimg/200115/5-200115142HWK.png" alt="image"></p><blockquote><p>输出流模式</p></blockquote><p><img src="http://c.biancheng.net/uploads/allimg/200115/5-200115142K1644.png" alt="image"></p><h3 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h3><p>Java 流相关的类都封装在 java.io 包中，而且每个数据流都是一个对象。所有输入流类都是 InputStream 抽象类（字节输入流）和 Reader 抽象类（字符输入流）的子类。其中 InputStream 类是字节输入流的抽象类，是所有字节输入流的父类</p><p><img src="http://c.biancheng.net/uploads/allimg/200115/5-200115145253550.png" alt="image"></p><p>InputStream 类中所有方法遇到错误时都会引发 IOException 异常。如下是该类中包含的常用方法。</p><div class="table-container"><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>int read()</td><td>从输入流读入一个 8 字节的数据，将它转换成一个0~ 255的整数,返回一个整数，如果遇到输入流的结尾返回 -1</td></tr><tr><td>int read(byte[] b)</td><td>从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，返回的字节数表示读取的字节数，如果遇到输入流的结尾返回 -1</td></tr><tr><td>int read(byte[] b,int off,int len)</td><td>从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，其中 off 是指在数组中开始保存数据位置的起始下标，len 是指读取字节的位数。返回的是实际读取的字节数，如果遇到输入流的结尾则返回 -1</td></tr><tr><td>void close()</td><td>关闭数据流，当完成对数据流的操作之后需要关闭数据流</td></tr><tr><td>int available()</td><td>返回可以从数据源读取的数据流的位数。</td></tr><tr><td>skip(long n)</td><td>从输入流跳过参数 n 指定的字节数目</td></tr><tr><td>boolean markSupported()</td><td>判断输入流是否可以重复读取，如果可以就返回 true</td></tr><tr><td>void mark(int readLimit)</td><td>如果输入流可以被重复读取，从流的当前位置开始设置标记，readLimit 指定可以设置标记的字节数</td></tr><tr><td>void reset()</td><td>使输入流重新定位到刚才被标记的位置，这样可以重新读取标记过的数据</td></tr></tbody></table></div><p>上述最后 3 个方法一般会结合在一起使用，首先使用 markSupported() 判断，如果可以重复读取，则使用 mark(int readLimit) 方法进行标记，标记完成之后可以使用 read() 方法读取标记范围内的字节数，最后使用 reset() 方法使输入流重新定位到标记的位置，继而完成重复读取操作。</p><p>Java 中的字符是 Unicode 编码，即双字节的，而 InputerStream 是用来处理单字节的，在处理字符文本时不是很方便。这时可以使用 Java 的文本输入流 Reader 类，该类是字符输入流的抽象类，即所有字符输入流的实现都是它的子类，该类的方法与 InputerSteam 类的方法类似</p><h3 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h3><p>在 Java 中所有输出流类都是 OutputStream 抽象类（字节输出流）和 Writer 抽象类（字符输出流）的子类。其中 OutputStream 类是字节输出流的抽象类，是所有字节输出流的父类</p><p><img src="http://c.biancheng.net/uploads/allimg/200115/5-200115151G3J0.png" alt="image"></p><p>OutputStream 类是所有字节输出流的超类，用于以二进制的形式将数据写入目标设备，该类是抽象类，不能被实例化。OutputStream 类提供了一系列跟数据输出有关的方法</p><div class="table-container"><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>int write(b)</td><td>将指定字节的数据写入到输出流</td></tr><tr><td>int write (byte[] b)</td><td>将指定字节数组的内容写入输出流</td></tr><tr><td>int write (byte[] b,int off,int len)</td><td>将指定字节数组从 off 位置开始的 len 字节的内容写入输出流</td></tr><tr><td>close()</td><td>关闭数据流，当完成对数据流的操作之后需要关闭数据流</td></tr><tr><td>flush()</td><td>刷新输出流，强行将缓冲区的内容写入输出流</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea使用小贴士</title>
    <link href="/my_world/content/idea%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    <url>/my_world/content/idea%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>idea是一款非常好用的工具，但是需要许许多多的设置，该记录用于在使用idea的时候，作为指路使用</p><h2 id="修改运行的虚拟内存加快运行速度"><a href="#修改运行的虚拟内存加快运行速度" class="headerlink" title="修改运行的虚拟内存加快运行速度"></a>修改运行的虚拟内存加快运行速度</h2><p>该方法用于修改idea的运行内存以便加快运行速度，代价是电脑运行变慢<br><div class="code-wrapper"><pre><code class="hljs taggerscript">配置文件路径：D:<span class="hljs-symbol">\s</span>oftware<span class="hljs-symbol">\i</span>deaIU-2020.1.3.win<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\i</span>dea.exe.vmoptions和idea64.exe.vmoptions用记事本打开，修改-Xms2048m-Xmx2048m</code></pre></div></p><h2 id="加快maven搭建速度-安装Maven-Helper插件"><a href="#加快maven搭建速度-安装Maven-Helper插件" class="headerlink" title="加快maven搭建速度/安装Maven Helper插件"></a>加快maven搭建速度/安装Maven Helper插件</h2><p>搜索栏搜索Maven，编辑Maven home directory和User settings file改成自己的<br>Maven —&gt; Runner —&gt;VM options 添加 -DarchetypeCatalog=local<br><div class="code-wrapper"><pre><code class="hljs xl">F<span class="hljs-function"><span class="hljs-title">ile</span> --&gt;</span> S<span class="hljs-function"><span class="hljs-title">ettings</span> --&gt;</span> P<span class="hljs-function"><span class="hljs-title">lugins</span> --&gt;</span> 搜索Helper安装Maven Helper</code></pre></div></p><h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><div class="code-wrapper"><pre><code class="hljs xl">F<span class="hljs-function"><span class="hljs-title">ile</span> --&gt;</span> S<span class="hljs-function"><span class="hljs-title">ettings</span> --&gt;</span> E<span class="hljs-function"><span class="hljs-title">ditor</span> --&gt;</span> File Encodings全部修改为UTF-<span class="hljs-number">8</span></code></pre></div><h2 id="log文件识别"><a href="#log文件识别" class="headerlink" title="log文件识别"></a>log文件识别</h2><p>在输出log文件时，idea无法打开idea查看Log文件，这一步是可以让idea识别.log文件<br><div class="code-wrapper"><pre><code class="hljs coq"><span class="hljs-keyword">File</span> --&gt; Settings --&gt; Editor --&gt; <span class="hljs-keyword">File</span> <span class="hljs-keyword">Types</span>点击Recognized <span class="hljs-keyword">File</span> <span class="hljs-keyword">Types</span>的 “+” ，在name上输入*.log，Description输入日志文件Apply即可</code></pre></div></p><h2 id="关闭自动更新"><a href="#关闭自动更新" class="headerlink" title="关闭自动更新"></a>关闭自动更新</h2><div class="code-wrapper"><pre><code class="hljs smali">Settings --&gt; Appearance &amp; Behavior --&gt; System Settings --&gt; Updates取消勾选Automatically<span class="hljs-built_in"> check </span>updates</code></pre></div><h2 id="使用eclipse快捷键插件"><a href="#使用eclipse快捷键插件" class="headerlink" title="使用eclipse快捷键插件"></a>使用eclipse快捷键插件</h2><p>idea自带eclipse的快捷键，但似乎并不好用。Eclipse KeyMap Plugins是最接近eclipse的快捷键的一个非常好用的插件<br><div class="code-wrapper"><pre><code class="hljs xl">F<span class="hljs-function"><span class="hljs-title">ile</span> --&gt;</span> S<span class="hljs-function"><span class="hljs-title">ettings</span> --&gt;</span> P<span class="hljs-function"><span class="hljs-title">lugins</span> --&gt;</span> 搜索<span class="hljs-function"><span class="hljs-title">eclipse</span> --&gt;</span> Eclipse keymap installF<span class="hljs-function"><span class="hljs-title">ile</span> --&gt;</span> S<span class="hljs-function"><span class="hljs-title">ettings</span> --&gt;</span> K<span class="hljs-function"><span class="hljs-title">eyMap</span> --&gt;</span> eclipse</code></pre></div></p><h2 id="使用Vue插件-步骤和eclipse差不多，插件名字为Vue-js"><a href="#使用Vue插件-步骤和eclipse差不多，插件名字为Vue-js" class="headerlink" title="使用Vue插件(步骤和eclipse差不多，插件名字为Vue.js)"></a>使用Vue插件(步骤和eclipse差不多，插件名字为Vue.js)</h2><h2 id="使用热部署插件-JREbel"><a href="#使用热部署插件-JREbel" class="headerlink" title="使用热部署插件(JREbel)"></a>使用热部署插件(JREbel)</h2><p>在插件里安装Jrebel</p><p>在网站上生成GUID<br><div class="code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.guidgen.com/</code></pre></div></p><p>在TeamURL上添加<br><div class="code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>jrebel.qekang.com/&#123;GUID&#125; GUID为刚刚在网站上生成的GUID</code></pre></div><br>邮件名字填写后点击激活，在设置栏里修改为work offline</p><h2 id="设置自动导包"><a href="#设置自动导包" class="headerlink" title="设置自动导包"></a>设置自动导包</h2><p>可以在编辑类时自动导入包名或者消除包<br><div class="code-wrapper"><pre><code class="hljs coq"><span class="hljs-keyword">File</span> --&gt; Settings --&gt; Editor --&gt; General --&gt; Auto <span class="hljs-keyword">Import</span>勾选 <span class="hljs-keyword">Add</span> unambiguous imports on the fly和<span class="hljs-keyword">Optimize</span> imports on the fly(<span class="hljs-keyword">for</span> current project)</code></pre></div></p><h2 id="忽略大小写提示"><a href="#忽略大小写提示" class="headerlink" title="忽略大小写提示"></a>忽略大小写提示</h2><p>无论大小写都会有相应的提示<br><div class="code-wrapper"><pre><code class="hljs xl">F<span class="hljs-function"><span class="hljs-title">ile</span> --&gt;</span> S<span class="hljs-function"><span class="hljs-title">ettings</span> --&gt;</span> E<span class="hljs-function"><span class="hljs-title">ditor</span> --&gt;</span> G<span class="hljs-function"><span class="hljs-title">eneral</span> --&gt;</span> Code Completion取消Match case的勾选，取消Show the parameter info popup <span class="hljs-built_in">in</span> xxx ms的勾选(加快提示速度)</code></pre></div></p><h2 id="提示快捷键修改"><a href="#提示快捷键修改" class="headerlink" title="提示快捷键修改"></a>提示快捷键修改</h2><p>修改为eclipse常用的alt+/<br><div class="code-wrapper"><pre><code class="hljs xl">F<span class="hljs-function"><span class="hljs-title">ile</span> --&gt;</span> S<span class="hljs-function"><span class="hljs-title">ettings</span> --&gt;</span> K<span class="hljs-function"><span class="hljs-title">eymap</span> --&gt;</span> C<span class="hljs-function"><span class="hljs-title">ode</span> --&gt;</span> Code Completion移除Cyclic Expand Word的快捷键,修改Basic的快捷键为ALT+/</code></pre></div></p><h2 id="设置syso-—-gt-system-out-println"><a href="#设置syso-—-gt-system-out-println" class="headerlink" title="设置syso —&gt; system.out.println()"></a>设置syso —&gt; system.out.println()</h2><p>idea默认是sout,使用eclipse的习惯<br><div class="code-wrapper"><pre><code class="hljs xl">F<span class="hljs-function"><span class="hljs-title">ile</span> --&gt;</span> S<span class="hljs-function"><span class="hljs-title">ettings</span> 搜索live并找到Live Templates --&gt;</span> <span class="hljs-function"><span class="hljs-title">output</span> --&gt;</span>sout改为syso</code></pre></div></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件设计的行为型模式（一）</title>
    <link href="/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><blockquote><p>图片原链接：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 | 菜鸟教程 (runoob.com)</a></p><p>文字原链接：<a href="http://c.biancheng.net/view/1317.html">软件设计模式概述 (biancheng.net)</a></p></blockquote><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p><ol><li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li><strong>命令（Command）模式</strong>：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li><strong>观察者（Observer）模式</strong>：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p><p>该模式的主要优点如下。</p><ol><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li><li>它在父类中提取了公共的部分代码，便于代码复用。</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ol><p>该模式的主要缺点如下。</p><ol><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ol><h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。现在来介绍它们的基本结构。</p><p><strong>模式的结构</strong></p><p>模板方法模式包含以下主要角色。</p><p>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p><p>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p><p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。<br>抽象方法：在抽象类中申明，由具体子类实现。<br>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。<br>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg" alt="模板模式实现"></p><p><strong>模式的实现</strong></p><p>模板方法模式的代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> templateMethod;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateMethodPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        AbstractClass tm=<span class="hljs-keyword">new</span> ConcreteClass();        tm.TemplateMethod();    &#125;&#125;<span class="hljs-comment">//抽象类</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span><span class="hljs-params">()</span> <span class="hljs-comment">//模板方法</span></span><span class="hljs-function">    </span>&#123;        SpecificMethod();        abstractMethod1();                   abstractMethod2();    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpecificMethod</span><span class="hljs-params">()</span> <span class="hljs-comment">//具体方法</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;抽象类中的具体方法被调用...&quot;</span>);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法2</span>&#125;<span class="hljs-comment">//具体子类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;抽象方法1的实现被调用...&quot;</span>);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;抽象方法2的实现被调用...&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用模板方法模式实现出国留学手续设计程序。</p><p>分析：出国留学手续一般经过以下流程：索取学校资料，提出入学申请，办理因私出国护照、出境卡和公证，申请签证，体检、订机票、准备行装，抵达目标学校等，其中有些业务对各个学校是一样的，但有些业务因学校不同而不同，所以比较适合用模板方法模式来实现。</p><p>在本实例中，我们先定义一个出国留学的抽象类 StudyAbroad，里面包含了一个模板方法 TemplateMethod()，该方法中包含了办理出国留学手续流程中的各个基本方法，其中有些方法的处理由于各国都一样，所以在抽象类中就可以实现，但有些方法的处理各国是不同的，必须在其具体子类（如美国留学类 StudyInAmerica）中实现。如果再增加一个国家，只要增加一个子类就可以了</p><h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>模板方法模式通常适用于以下场景。</p><ol><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li></ol><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><p>策略模式的主要优点如下。</p><ol><li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li><li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li><li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li><li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li></ol><p>其主要缺点如下。</p><ol><li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li><li>策略模式造成很多的策略类。</li></ol><h2 id="策略模式的结构与实现"><a href="#策略模式的结构与实现" class="headerlink" title="策略模式的结构与实现"></a>策略模式的结构与实现</h2><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>策略模式的主要角色如下。</p><ol><li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt="策略模式实现"></p><p><strong>模式的实现</strong></p><p>策略模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> strategy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Context c=<span class="hljs-keyword">new</span> Context();        Strategy s=<span class="hljs-keyword">new</span> ConcreteStrategyA();        c.setStrategy(s);        c.strategyMethod();        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);        s=<span class="hljs-keyword">new</span> ConcreteStrategyB();        c.setStrategy(s);        c.strategyMethod();    &#125;&#125;<span class="hljs-comment">//抽象策略类</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span></span><span class="hljs-class"></span>&#123;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//策略方法</span>&#125;<span class="hljs-comment">//具体策略类A</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体策略A的策略方法被访问！&quot;</span>);    &#125;&#125;<span class="hljs-comment">//具体策略类B</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span></span><span class="hljs-class"></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;      System.out.println(<span class="hljs-string">&quot;具体策略B的策略方法被访问！&quot;</span>);  &#125;&#125;<span class="hljs-comment">//环境类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Strategy strategy;    <span class="hljs-function"><span class="hljs-keyword">public</span> Strategy <span class="hljs-title">getStrategy</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> strategy;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStrategy</span><span class="hljs-params">(Strategy strategy)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.strategy=strategy;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        strategy.strategyMethod();    &#125;&#125;</code></pre></div><h2 id="策略模式的应用实例"><a href="#策略模式的应用实例" class="headerlink" title="策略模式的应用实例"></a>策略模式的应用实例</h2><p>策略模式在“大闸蟹”做菜中的应用。</p><p>分析：关于大闸蟹的做法有很多种，我们以清蒸大闸蟹和红烧大闸蟹两种方法为例，介绍策略模式的应用。</p><p>首先，定义一个大闸蟹加工的抽象策略类（CrabCooking），里面包含了一个做菜的抽象方法 CookingMethod()；然后，定义清蒸大闸蟹（SteamedCrabs）和红烧大闸蟹（BraisedCrabs）的具体策略类，它们实现了抽象策略类中的抽象方法；由于本程序要显示做好的结果图（点此下载要显示的结果图），所以将具体策略类定义成 JLabel 的子类；最后，定义一个厨房（Kitchen）环境类，它具有设置和选择做菜策略的方法；客户类通过厨房类获取做菜策略，并把做菜结果图在窗体中显示出来</p><h2 id="策略模式的应用场景"><a href="#策略模式的应用场景" class="headerlink" title="策略模式的应用场景"></a>策略模式的应用场景</h2><p>策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。</p><ol><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ol><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><p>命令模式的主要优点如下。</p><ol><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li></ol><p>其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p><h2 id="命令模式的结构与实现"><a href="#命令模式的结构与实现" class="headerlink" title="命令模式的结构与实现"></a>命令模式的结构与实现</h2><p>可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离，其结构如下。</p><p><strong>模式的结构</strong></p><p>命令模式包含以下主要角色。</p><ol><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令角色（Concrete    Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210830-command-1-command-1.svg" alt="命令模式实现"></p><p><strong>模式的实现</strong></p><p>命令模式的代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> command;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Command cmd=<span class="hljs-keyword">new</span> ConcreteCommand();        Invoker ir=<span class="hljs-keyword">new</span> Invoker(cmd);        System.out.println(<span class="hljs-string">&quot;客户访问调用者的call()方法...&quot;</span>);        ir.call();    &#125;&#125;<span class="hljs-comment">//调用者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Command command;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span><span class="hljs-params">(Command command)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.command=command;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.command=command;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;调用者执行命令command...&quot;</span>);        command.execute();    &#125;&#125;<span class="hljs-comment">//抽象命令</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体命令</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Receiver receiver;    ConcreteCommand()    &#123;        receiver=<span class="hljs-keyword">new</span> Receiver();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        receiver.action();    &#125;&#125;<span class="hljs-comment">//接收者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;接收者的action()方法被调用...&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="命令模式的应用实例"><a href="#命令模式的应用实例" class="headerlink" title="命令模式的应用实例"></a>命令模式的应用实例</h2><p>用命令模式实现客户去餐馆吃早餐的实例。</p><p>分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。</p><p>首先，定义一个早餐类（Breakfast），它是抽象命令类，有抽象方法 cooking()，说明要做什么；再定义其子类肠粉类（ChangFen）、馄饨类（HunTun）和河粉类（HeFen），它们是具体命令类，实现早餐类的 cooking() 方法，但它们不会具体做，而是交给具体的厨师去做；具体厨师类有肠粉厨师（ChangFenChef）、馄蚀厨师（HunTunChef）和河粉厨师（HeFenChef），他们是命令的接收者，由于本实例要显示厨师做菜的效果图（点此下载要显示的效果图），所以把每个厨师类定义为 JFrame 的子类；最后，定义服务员类（Waiter），它接收客户的做菜请求，并发出做菜的命令。客户类是通过服务员类来点菜的</p><h2 id="命令模式的应用场景"><a href="#命令模式的应用场景" class="headerlink" title="命令模式的应用场景"></a>命令模式的应用场景</h2><p>命令模式通常适用于以下场景。</p><ol><li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li><li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li><li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li><li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li></ol><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>注意：责任链模式也叫职责链模式。</p><p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p><p>责任链模式是一种对象行为型模式，其主要优点如下。</p><ol><li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li><li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ol><p>其主要缺点如下。</p><ol><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ol><h2 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p><p><strong>模式的结构</strong></p><p>职责链模式主要包含以下角色。</p><ol><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg" alt="责任链模式实现"></p><p><strong>模式的实现</strong></p><p>职责链模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chainOfResponsibility;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainOfResponsibilityPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//组装责任链 </span>        Handler handler1=<span class="hljs-keyword">new</span> ConcreteHandler1();         Handler handler2=<span class="hljs-keyword">new</span> ConcreteHandler2();         handler1.setNext(handler2);         <span class="hljs-comment">//提交请求 </span>        handler1.handleRequest(<span class="hljs-string">&quot;two&quot;</span>);    &#125;&#125;<span class="hljs-comment">//抽象处理者角色</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Handler next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler next)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.next=next;     &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         <span class="hljs-keyword">return</span> next;     &#125;       <span class="hljs-comment">//处理请求的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span>;       &#125;<span class="hljs-comment">//具体处理者角色1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(request.equals(<span class="hljs-string">&quot;one&quot;</span>))         &#123;            System.out.println(<span class="hljs-string">&quot;具体处理者1负责处理该请求！&quot;</span>);               &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(getNext()!=<span class="hljs-keyword">null</span>)             &#123;                getNext().handleRequest(request);                         &#125;            <span class="hljs-keyword">else</span>            &#123;                System.out.println(<span class="hljs-string">&quot;没有人处理该请求！&quot;</span>);            &#125;        &#125;     &#125; &#125;<span class="hljs-comment">//具体处理者角色2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(request.equals(<span class="hljs-string">&quot;two&quot;</span>))         &#123;            System.out.println(<span class="hljs-string">&quot;具体处理者2负责处理该请求！&quot;</span>);               &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(getNext()!=<span class="hljs-keyword">null</span>)             &#123;                getNext().handleRequest(request);                         &#125;            <span class="hljs-keyword">else</span>            &#123;                System.out.println(<span class="hljs-string">&quot;没有人处理该请求！&quot;</span>);            &#125;        &#125;     &#125;&#125;</code></pre></div><h2 id="模式的应用实例-1"><a href="#模式的应用实例-1" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用责任链模式设计一个请假条审批模块。</p><p>分析：假如规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；这个实例适合使用职责链模式实现。</p><p>首先，定义一个领导类（Leader），它是抽象处理者，包含了一个指向下一位领导的指针 next 和一个处理假条的抽象处理方法 handleRequest(int LeaveDays)；然后，定义班主任类（ClassAdviser）、系主任类（DepartmentHead）和院长类（Dean），它们是抽象处理者的子类，是具体处理者，必须根据自己的权力去实现父类的 handleRequest(int LeaveDays) 方法，如果无权处理就将假条交给下一位具体处理者，直到最后；客户类负责创建处理链，并将假条交给链头的具体处理者（班主任）。</p><h2 id="模式的应用场景-1"><a href="#模式的应用场景-1" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>前边已经讲述了关于责任链模式的结构与特点，下面介绍其应用场景，责任链模式通常在以下几种情况使用。</p><ol><li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li><li>可动态指定一组对象处理请求，或添加新的处理者。</li><li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li></ol><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><p>状态模式是一种对象行为型模式，其主要优点如下。</p><ol><li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ol><p>状态模式的主要缺点如下。</p><ol><li>状态模式的使用必然会增加系统的类与对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li></ol><h2 id="状态模式的结构与实现"><a href="#状态模式的结构与实现" class="headerlink" title="状态模式的结构与实现"></a>状态模式的结构与实现</h2><p>状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。现在我们来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>状态模式包含以下主要角色。</p><ol><li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete    State）角色：实现抽象状态所对应的行为。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png" alt="状态模式实现"></p><p><strong>模式的实现</strong></p><p>状态模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> state;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatePatternClient</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;               Context context=<span class="hljs-keyword">new</span> Context();    <span class="hljs-comment">//创建环境       </span>        context.Handle();    <span class="hljs-comment">//处理请求</span>        context.Handle();        context.Handle();        context.Handle();    &#125;&#125;<span class="hljs-comment">//环境类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> State state;    <span class="hljs-comment">//定义环境类的初始状态</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.state=<span class="hljs-keyword">new</span> ConcreteStateA();    &#125;    <span class="hljs-comment">//设置新状态</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.state=state;    &#125;    <span class="hljs-comment">//读取状态</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span>(state);    &#125;    <span class="hljs-comment">//对请求做处理</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        state.Handle(<span class="hljs-keyword">this</span>);    &#125;&#125;<span class="hljs-comment">//抽象状态类</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">(Context context)</span></span>;&#125;<span class="hljs-comment">//具体状态A类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">(Context context)</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;当前状态是 A.&quot;</span>);        context.setState(<span class="hljs-keyword">new</span> ConcreteStateB());    &#125;&#125;<span class="hljs-comment">//具体状态B类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">(Context context)</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;当前状态是 B.&quot;</span>);        context.setState(<span class="hljs-keyword">new</span> ConcreteStateA());    &#125;&#125;</code></pre></div><h2 id="状态模式的应用实例"><a href="#状态模式的应用实例" class="headerlink" title="状态模式的应用实例"></a>状态模式的应用实例</h2><p>用“状态模式”设计一个学生成绩的状态转换程序。</p><p>分析：本实例包含了“不及格”“中等”和“优秀” 3 种状态，当学生的分数小于 60 分时为“不及格”状态，当分数大于等于 60 分且小于 90 分时为“中等”状态，当分数大于等于 90 分时为“优秀”状态，我们用状态模式来实现这个程序。</p><p>首先，定义一个抽象状态类（AbstractState），其中包含了环境属性、状态名属性和当前分数属性，以及加减分方法 addScore(intx) 和检查当前状态的抽象方法 checkState()；然后，定义“不及格”状态类 LowState、“中等”状态类 MiddleState 和“优秀”状态类 HighState，它们是具体状态类，实现 checkState() 方法，负责检査自己的状态，并根据情况转换；最后，定义环境类（ScoreContext），其中包含了当前状态对象和加减分的方法 add(int score)，客户类通过该方法来改变成绩状态。</p><h2 id="状态模式的应用场景"><a href="#状态模式的应用场景" class="headerlink" title="状态模式的应用场景"></a>状态模式的应用场景</h2><p>通常在以下情况下可以考虑使用状态模式。</p><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><p>观察者模式是一种对象行为型模式，其主要优点如下。</p><ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ol><p>它的主要缺点如下。</p><ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ol><h2 id="模式的结构与实现-2"><a href="#模式的结构与实现-2" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。</p><p><strong>模式的结构</strong></p><p>观察者模式的主要角色如下。</p><ol><li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>具体主题（Concrete    Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg" alt="观察者模式实现"></p><p><strong>模式的实现</strong></p><p>观察者模式的实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> observer;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverPattern</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Subject subject=<span class="hljs-keyword">new</span> ConcreteSubject();        Observer obs1=<span class="hljs-keyword">new</span> ConcreteObserver1();        Observer obs2=<span class="hljs-keyword">new</span> ConcreteObserver2();        subject.add(obs1);        subject.add(obs2);        subject.notifyObserver();    &#125;&#125;<span class="hljs-comment">//抽象目标</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">protected</span> List&lt;Observer&gt; observers=<span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();       <span class="hljs-comment">//增加观察者方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer observer)</span></span><span class="hljs-function">    </span>&#123;        observers.add(observer);    &#125;        <span class="hljs-comment">//删除观察者方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Observer observer)</span></span><span class="hljs-function">    </span>&#123;        observers.remove(observer);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//通知观察者方法</span>&#125;<span class="hljs-comment">//具体目标</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体目标发生改变...&quot;</span>);        System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);                      <span class="hljs-keyword">for</span>(Object obs:observers)        &#123;            ((Observer)obs).response();        &#125;           &#125;          &#125;<span class="hljs-comment">//抽象观察者</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">response</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//反应</span>&#125;<span class="hljs-comment">//具体观察者1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteObserver1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">response</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体观察者1作出反应！&quot;</span>);    &#125;&#125;<span class="hljs-comment">//具体观察者1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteObserver2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">response</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体观察者2作出反应！&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="模式的应用实例-2"><a href="#模式的应用实例-2" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司的进口产品成本或出口公司的出口产品收入以及公司的利润率的影响。</p><p>分析：当“人民币汇率”升值时，进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降低且利润率降低；当“人民币汇率”贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。</p><p>这里的汇率（Rate）类是抽象目标类，它包含了保存观察者（Company）的 List 和增加/删除观察者的方法，以及有关汇率改变的抽象方法 change(int number)；而人民币汇率（RMBrate）类是具体目标， 它实现了父类的 change(int number) 方法，即当人民币汇率发生改变时通过相关公司；公司（Company）类是抽象观察者，它定义了一个有关汇率反应的抽象方法 response(int number)；进口公司（ImportCompany）类和出口公司（ExportCompany）类是具体观察者类，它们实现了父类的 response(int number) 方法，即当它们接收到汇率发生改变的通知时作为相应的反应。</p><h2 id="模式的应用场景-2"><a href="#模式的应用场景-2" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>通过前面的分析与应用实例可知观察者模式适合以下几种情形。</p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li></ul><p>策略模式—自助餐</p><p>命令模式—遥控器</p><p>责任链—院长&gt;&gt;系主任&gt;&gt;班主任</p><p>状态模式—成绩判断，A状态为优秀，B状态为中等</p><p>观察者模式—天气预报</p><p>中介者模式—房产中介</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计的创建型模式</title>
    <link href="/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/my_world/content/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\my_world\assets\css\APlayer.min.css"><script src="\my_world\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p><blockquote><p>图片原链接：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 | 菜鸟教程 (runoob.com)</a></p><p>文字原链接：<a href="http://c.biancheng.net/view/1317.html">软件设计模式概述 (biancheng.net)</a></p></blockquote><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p><p>创建型模式分为以下几种。</p><ol><li><strong>单例（Singleton）模式</strong>：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li><strong>工厂方法（FactoryMethod）模式</strong>：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li><strong>抽象工厂（AbstractFactory）模式</strong>：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ol><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>单例模式有 3 个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点；</li></ol><h2 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h2><p>单例模式的主要角色如下。</p><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg" alt="单例模式实现"></p><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>Singleton 模式通常有两种实现形式。<br>第 1 种：懒汉式单例<br>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> LazySingleton instance=<span class="hljs-keyword">null</span>;    <span class="hljs-comment">//保证 instance 在所有线程中同步</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">//private 避免类在外部被实例化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//getInstance 方法前加同步</span>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)        &#123;            instance=<span class="hljs-keyword">new</span> LazySingleton();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre></div><p>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</p><p>第 2 种：饿汉式单例<br>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HungrySingleton instance=<span class="hljs-keyword">new</span> HungrySingleton();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungrySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre></div><p>饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</p><h2 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h2><p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。</p><h2 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h2><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p><p><strong>模式的结构</strong></p><p>原型模式包含以下主要角色。</p><ol><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20201202-prototype-pattern.png" alt="原型模式实现"></p><p><strong>模式的实现</strong></p><p>原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。其代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//具体原型类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Realizetype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span><span class="hljs-class"></span>&#123;    Realizetype()    &#123;        System.out.println(<span class="hljs-string">&quot;具体原型创建成功！&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体原型复制成功！&quot;</span>);        <span class="hljs-keyword">return</span> (Realizetype)<span class="hljs-keyword">super</span>.clone();    &#125;&#125;<span class="hljs-comment">//原型模式的测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> CloneNotSupportedException</span><span class="hljs-function">    </span>&#123;        Realizetype obj1=<span class="hljs-keyword">new</span> Realizetype();        Realizetype obj2=(Realizetype)obj1.clone();        System.out.println(<span class="hljs-string">&quot;obj1==obj2?&quot;</span>+(obj1==obj2));    &#125;&#125;</code></pre></div><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。</p><p>本节介绍的“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p><p>工厂方法模式的主要优点有：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p>其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p><h2 id="工厂方法模式的结构与实现"><a href="#工厂方法模式的结构与实现" class="headerlink" title="工厂方法模式的结构与实现"></a>工厂方法模式的结构与实现</h2><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>工厂方法模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式实现"></p><p><strong>模式的实现</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> FactoryMethod;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">try</span>        &#123;            Product a;            AbstractFactory af;            af=(AbstractFactory) ReadXML1.getObject();            a=af.newProduct();            a.show();        &#125;        <span class="hljs-keyword">catch</span>(Exception e)        &#123;            System.out.println(e.getMessage());        &#125;    &#125;&#125;<span class="hljs-comment">//抽象产品：提供了产品的接口</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体产品1：实现抽象产品中的抽象方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体产品1显示...&quot;</span>);    &#125;&#125;<span class="hljs-comment">//具体产品2：实现抽象产品中的抽象方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体产品2显示...&quot;</span>);    &#125;&#125;<span class="hljs-comment">//抽象工厂：提供了厂品的生成方法</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">newProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体工厂1：实现了厂品的生成方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">newProduct</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct1();    &#125;&#125;<span class="hljs-comment">//具体工厂2：实现了厂品的生成方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">newProduct</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct2();    &#125;&#125;<span class="hljs-keyword">package</span> FactoryMethod;<span class="hljs-keyword">import</span> javax.xml.parsers.*;<span class="hljs-keyword">import</span> org.w3c.dom.*;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadXML1</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">try</span>        &#123;            <span class="hljs-comment">//创建文档对象</span>            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();            DocumentBuilder builder=dFactory.newDocumentBuilder();            Document doc;                                       doc=builder.parse(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/FactoryMethod/config1.xml&quot;</span>));                    <span class="hljs-comment">//获取包含类名的文本节点</span>            NodeList nl=doc.getElementsByTagName(<span class="hljs-string">&quot;className&quot;</span>);            Node classNode=nl.item(<span class="hljs-number">0</span>).getFirstChild();            String cName=<span class="hljs-string">&quot;FactoryMethod.&quot;</span>+classNode.getNodeValue();            <span class="hljs-comment">//System.out.println(&quot;新类名：&quot;+cName);</span>            <span class="hljs-comment">//通过类名生成实例对象并将其返回</span>            Class&lt;?&gt; c=Class.forName(cName);              Object obj=c.newInstance();            <span class="hljs-keyword">return</span> obj;         &#125;           <span class="hljs-keyword">catch</span>(Exception e)         &#123;                   e.printStackTrace();                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125;    &#125;&#125;</code></pre></div><h2 id="工厂方法模式的应用实例"><a href="#工厂方法模式的应用实例" class="headerlink" title="工厂方法模式的应用实例"></a>工厂方法模式的应用实例</h2><p>用工厂方法模式设计畜牧场。</p><p>分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。</p><p>对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可。由于要显示马类和牛类等具体产品类的图像，所以它们的构造函数中用到了 JPanel、JLabd 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。</p><h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>工厂方法模式通常适用于以下场景。</p><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌。</li></ul><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p>使用抽象工厂模式一般要满足以下条件。</p><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li></ul><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li></ul><p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>抽象工厂模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="抽象工厂模式实现"></p><p><strong>模式的结构</strong></p><p>抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。</p><p>(1) 抽象工厂：提供了产品的生成方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product1 <span class="hljs-title">newProduct1</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product2 <span class="hljs-title">newProduct2</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>(2) 具体工厂：实现了产品的生成方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product1 <span class="hljs-title">newProduct1</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct11();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product2 <span class="hljs-title">newProduct2</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(<span class="hljs-string">&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct21();    &#125;&#125;</code></pre></div><h2 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用抽象工厂模式设计农场类。</p><p>分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。</p><p>本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。</p><p>对马类、牛类、蔬菜类和水果类等具体产品类，由于要显示它们的图像（点此下载图片），所以它们的构造函数中用到了 JPanel、JLabel 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。</p><p>客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的数据来决定养什么动物和培养什么植物</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><p>该模式的主要优点如下：</p><ol><li>各个具体的建造者相互独立，有利于系统的扩展。</li><li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li></ol><p>其缺点如下：</p><ol><li>产品的组成部分必须相同，这限制了其使用范围。</li><li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li></ol><p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p><h2 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p><p><strong>模式的结构</strong></p><p>建造者（Builder）模式的主要角色如下。</p><ol><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。</li><li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210315-builder-pattern.svg" alt="建造者模式实现"></p><p><strong>模式的实现</strong></p><p>(1) 产品角色：包含多个组成部件的复杂对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> String partA;    <span class="hljs-keyword">private</span> String partB;    <span class="hljs-keyword">private</span> String partC;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPartA</span><span class="hljs-params">(String partA)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.partA=partA;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPartB</span><span class="hljs-params">(String partB)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.partB=partB;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPartC</span><span class="hljs-params">(String partC)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.partC=partC;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//显示产品的特性</span>    &#125;&#125;</code></pre></div><p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-comment">//创建产品对象</span>    <span class="hljs-keyword">protected</span> Product product=<span class="hljs-keyword">new</span> Product();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回产品对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> product;    &#125;&#125;</code></pre></div><p>(3) 具体建造者：实现了抽象建造者接口。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        product.setPartA(<span class="hljs-string">&quot;建造 PartA&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        product.setPartA(<span class="hljs-string">&quot;建造 PartB&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        product.setPartA(<span class="hljs-string">&quot;建造 PartC&quot;</span>);    &#125;&#125;</code></pre></div><p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Builder builder;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>.builder=builder;    &#125;    <span class="hljs-comment">//产品构建与组装方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">construct</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        builder.buildPartA();        builder.buildPartB();        builder.buildPartC();        <span class="hljs-keyword">return</span> builder.getResult();    &#125;&#125;</code></pre></div><p>(5) 客户类。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Builder builder=<span class="hljs-keyword">new</span> ConcreteBuilder();        Director director=<span class="hljs-keyword">new</span> Director(builder);        Product product=director.construct();        product.show();    &#125;&#125;</code></pre></div><h2 id="模式的应用实例-1"><a href="#模式的应用实例-1" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h2><p>用建造者（Builder）模式描述客厅装修。</p><p>分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。</p><p>这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。</p><p>另外，客厅类中提供了 show() 方法，可以将装修效果图显示出来（点此下载装修效果图的图片）。客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的装修方案数据（点此下载 XML 文件），调用项目经理进行装修。</p><h2 id="模式的应用场景-1"><a href="#模式的应用场景-1" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
